<!doctype html>
<html lang="en">
 <head> 
  <meta charset="utf-8"> 
  <title>Calculate distance and bearing between two Latitude/Longitude points using haversine formula in JavaScript</title> 
  <meta name="author" content="Chris Veness, www.movable-type.co.uk"> 
  <meta name="keywords" content="latitude longitude distance bearing points earth haversine great circle rhumb"> 
  <meta name="viewport" content="width=device-width, initial-scale=1"> 
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/normalize/5.0.0/normalize.min.css"> 
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.css"> 
  <link rel="stylesheet" href="../css/base.css"> 
  <link rel="stylesheet" href="../css/eb-garamond/stylesheet.css"> 
  <link rel="stylesheet" href="../css/mtl.css"> 
  <style>
        input               { text-align: right; width: 6em; }
        input[type="radio"] { width: auto; vertical-align: baseline; }
        output              { color: #000099; font-weight: bold; }
        a                   { cursor: pointer; } /* for 'show map' */
        figcaption          { font-size: 0.8em; font-style: italic; text-align: center; }
        form ul.list        { list-style: inherit; } /* an actual list to appear within a form! */
        fieldset            { padding: 0 2em; }
        .inputs             { float: left; margin: 1em 2em 0 0; }
        .outputs            { margin: 1em 2em 0 0; }
        .map                { height: 480px; width: 480px; }
        .radicand           { border-top: solid 1px #cccccc; }
        .label              { color: #666666; font-style: italic; }
        td.formula          { line-height: 1; padding: 0.4em 0.1em; }
        aside {
            width: 21em;
        }
        code.prettyprint {
            display: block;
            font-size: 0.8em;
            line-height: 1;;
            margin-left: 2.5em;
            padding-bottom: 0.4em;
            text-indent: -2.5em;
        }

        @media screen and (max-width: 800px) {
            .formula { font-size: 0.9em; /* Times a bit strange on Android? */ }
            figure img { width: 120px; }
        }
    </style> 
  <script defer src="//code.jquery.com/jquery-3.0.0.min.js"></script> 
  <script defer src="//cdnjs.cloudflare.com/ajax/libs/es6-promise/4.0.5/es6-promise.auto.min.js"></script> 
  <script defer src="//cdnjs.cloudflare.com/ajax/libs/fetch/0.11.1/fetch.min.js"></script> 
  <script defer src="//cdnjs.cloudflare.com/ajax/libs/prettify/188.0.0/prettify.js">/* r224/r298 don't work! */</script> 
  <script defer src="//cdnjs.cloudflare.com/ajax/libs/js-cookie/2.1.3/js.cookie.min.js">/* github.com/js-cookie/js-cookie */</script> 
  <script defer src="//cdnjs.cloudflare.com/ajax/libs/qs/6.3.0/qs.min.js">/* github.com/ljharb/qs */</script> 
  <script defer src="//maps.googleapis.com/maps/api/js"></script> 
  <!--[if lt IE 9]> <script src="//html5shim.googlecode.com/svn/trunk/html5.js"></script> <![endif]--> 
  <script defer src="../js/mtl.js">/* MTL utils */</script> 
  <script defer src="//cdn.rawgit.com/chrisveness/geodesy/v1.1.2/latlon-spherical.js">/* github.com/chrisveness/geodesy */</script> 
  <script defer src="//cdn.rawgit.com/chrisveness/geodesy/v1.1.2/dms.js">/* github.com/chrisveness/geodesy */</script> 
  <script>
        'use strict';
        var doc = document; doc.qrySel = doc.querySelector; doc.qrySelAll = doc.querySelectorAll; // shorthand

        var maps = { // note we have to track overlay items ourselves
            orthoDist: { map:null, geodesic:true,  overlay: { marker1:null, marker2:null, path:null } },
            orthoDest: { map:null, geodesic:true,  overlay: { marker1:null, marker2:null, path:null } },
            rhumbDist: { map:null, geodesic:false, overlay: { marker1:null, marker2:null, path:null } },
            rhumbDest: { map:null, geodesic:false, overlay: { marker1:null, marker2:null, path:null } }
        };

        document.addEventListener('DOMContentLoaded', function(event) {
            Dms.separator = '\u202f'; // narrow no-break space

            // has user made d/dms display preference?
            var degFmt = Cookies.get('latlon-degree-format') || 'dms';
            // show current preference
            doc.qrySel('#deg-format-'+degFmt).checked = true;

            // initialise maps
            var mapOptions = {
                zoom: 0,
                center: new google.maps.LatLng(0, 0),
                mapTypeId: google.maps.MapTypeId.HYBRID,
                mapTypeControlOptions: {
                    style: google.maps.MapTypeControlStyle.DROPDOWN_MENU,
                },
                navigationControlOptions: {
                    style: google.maps.NavigationControlStyle.SMALL,
                },
                streetViewControl: false,
                scaleControl: true,
            };
            maps.orthoDist.map = new google.maps.Map(doc.qrySel('#map-ortho-dist-canvas'), mapOptions);
            maps.orthoDest.map = new google.maps.Map(doc.qrySel('#map-ortho-dest-canvas'), mapOptions);
            maps.rhumbDist.map = new google.maps.Map(doc.qrySel('#map-rhumb-dist-canvas'), mapOptions);
            maps.rhumbDest.map = new google.maps.Map(doc.qrySel('#map-rhumb-dest-canvas'), mapOptions);

            // ---- listeners for orthodrome distance / bearings / midpoint between two points

            // listener for updated values
            $('#ortho-dist input').change( function() {
                var lat1 = Dms.parseDMS($('#ortho-dist .lat1').val());
                var lon1 = Dms.parseDMS($('#ortho-dist .lon1').val());
                var lat2 = Dms.parseDMS($('#ortho-dist .lat2').val());
                var lon2 = Dms.parseDMS($('#ortho-dist .lon2').val());

                // calculate distance, bearing, mid-point
                var p1 = LatLon(lat1, lon1);
                var p2 = LatLon(lat2, lon2);
                var dist = p1.distanceTo(p2);
                var brng1 = p1.bearingTo(p2);
                var brng2 = p1.finalBearingTo(p2);
                var pMid = p1.midpointTo(p2);

                // display results
                var d = (dist/1000).toPrecision(4); // in km rounded to 4 significant figures
                $('#ortho-dist .result-dist').html(d>1 ? Number(d) : d); // avoid exponential notation
                $('#ortho-dist .result-brng1').html(Dms.toBrng(brng1, degFmt));
                $('#ortho-dist .result-brng2').html(Dms.toBrng(brng2, degFmt));
                $('#ortho-dist .result-midpt').html(pMid.toString(degFmt));

                // show path on map
                if ($('#map-ortho-dist-canvas').is(':visible')) {
                    drawPath(p1.lat, p1.lon, p2.lat, p2.lon, maps.orthoDist);
                }
            });
            $('#ortho-dist .lat1').trigger('change'); // initial calculation

            // listener for map toggle
            $('#ortho-dist .toggle-map a').click( function() {
                $('#ortho-dist .toggle-map').toggle(); // 'see on map' text
                $('#ortho-dist .map').toggle();        // the map itself

                $('#ortho-dist .lat1').trigger('change'); // to invoke drawPath()
            });

            // ---- listeners for orthodrome destination point from start point / bearing / distance

            // listener for updated values
            $('#ortho-dest input').change( function() {
                var lat1 = Dms.parseDMS($('#ortho-dest .lat1').val());
                var lon1 = Dms.parseDMS($('#ortho-dest .lon1').val());
                var dist = $('#ortho-dest .dist').val() * 1000; // convert km to metres
                var brng = Dms.parseDMS($('#ortho-dest .brng').val());

                // calculate destination point, final bearing
                var p1 = LatLon(lat1, lon1);
                var p2 = p1.destinationPoint(dist, brng);
                var brngFinal = p1.finalBearingTo(p2);

                // display results
                $('#ortho-dest .result-point').html(p2.toString(degFmt));
                $('#ortho-dest .result-brng').html(Dms.toBrng(brngFinal,degFmt));

                // show path on map
                if ($('#map-ortho-dest-canvas').is(':visible')) {
                    drawPath(p1.lat, p1.lon, p2.lat, p2.lon, maps.orthoDest);
                }
            });
            $('#ortho-dest .lat1').trigger('change'); // initial calculation

            // listener for map toggle
            $('#ortho-dest .toggle-map a').click( function() {
                $('#ortho-dest .toggle-map').toggle();
                $('#ortho-dest .map').toggle();

                $('#ortho-dest .lat1').trigger('change'); // to invoke drawPath()
            });

            // ---- listeners for intersection of two paths

            // listener for updated values
            $('#intersect input').change( function() {
                var lat1 = Dms.parseDMS($('#intersect .lat1').val());
                var lon1 = Dms.parseDMS($('#intersect .lon1').val());
                var lat2 = Dms.parseDMS($('#intersect .lat2').val());
                var lon2 = Dms.parseDMS($('#intersect .lon2').val());

                // calculate intersection point
                var p1 = LatLon(lat1, lon1);
                var p2 = LatLon(lat2, lon2);
                var brng1 = Dms.parseDMS($('#intersect .brng1').val());
                var brng2 = Dms.parseDMS($('#intersect .brng2').val());
                var pInt = LatLon.intersection(p1, brng1, p2, brng2);

                // display result
                $('#intersect .result-point').html(pInt==null ? '[ambiguous]' : pInt.toString(degFmt));
            });
            $('#intersect .lat1').trigger('change'); // initial calculation

            // ---- listeners for rhumb lines distance

            // listener for updated values
            $('#rhumb-dist input').change( function() {
                var lat1 = Dms.parseDMS($('#rhumb-dist .lat1').val());
                var lon1 = Dms.parseDMS($('#rhumb-dist .lon1').val());
                var lat2 = Dms.parseDMS($('#rhumb-dist .lat2').val());
                var lon2 = Dms.parseDMS($('#rhumb-dist .lon2').val());

                // calculate distance, bearing, mid-point
                var p1 = LatLon(lat1, lon1);
                var p2 = LatLon(lat2, lon2);
                var dist = p1.rhumbDistanceTo(p2);
                var brng = p1.rhumbBearingTo(p2);
                var pMid = p1.rhumbMidpointTo(p2);

                // display results
                var d = (dist/1000).toPrecision(4); // in km rounded to 4 significant figures
                $('#rhumb-dist .result-dist').html(d>1 ? Number(d) : d); // avoid exponential notation
                $('#rhumb-dist .result-brng').html(Dms.toBrng(brng, degFmt));
                $('#rhumb-dist .result-midpt').html(pMid.toString(degFmt));

                // show path on map
                if ($('#map-rhumb-dist-canvas').is(':visible')) {
                    drawPath(p1.lat, p1.lon, p2.lat, p2.lon, maps.rhumbDist);
                }
            });
            $('#rhumb-dist .lat1').trigger('change'); // initial calculation

            // listener for map toggle
            $('#rhumb-dist .toggle-map a').click( function() {
                $('#rhumb-dist .toggle-map').toggle();
                $('#rhumb-dist .map').toggle();

                $('#rhumb-dist .lat1').trigger('change'); // to invoke drawPath()
            });

            // ---- listeners for rhumb lines destination

            // listener for updated values
            $('#rhumb-dest input').change( function() {
                var lat1 = Dms.parseDMS($('#rhumb-dest .lat1').val());
                var lon1 = Dms.parseDMS($('#rhumb-dest .lon1').val());
                var brng = Dms.parseDMS($('#rhumb-dest .brng').val());
                var dist = $('#rhumb-dest .dist').val() * 1000; // convert km to metres

                // calculate destination point
                var p1 = LatLon(lat1, lon1);
                var p2 = p1.rhumbDestinationPoint(dist, brng);

                // display results
                $('#rhumb-dest .result-point').html(p2.toString(degFmt));

                // show path on map
                if ($('#map-rhumb-dest-canvas').is(':visible')) {
                    drawPath(p1.lat, p1.lon, p2.lat, p2.lon, maps.rhumbDest);
                }
            });
            $('#rhumb-dest .lat1').trigger('change'); // initial calculation

            // listener for map toggle
            $('#rhumb-dest .toggle-map a').click( function() {
                $('#rhumb-dest .toggle-map').toggle();
                $('#rhumb-dest .map').toggle();

                $('#rhumb-dest .lat1').trigger('change'); // to invoke drawPath()
            });

            // deg-min-sec / decimal degrees conversion
            $('#latDMS').change( function() { var lat = Dms.parseDMS($('#latDMS').val()); $('#latDM').val(Dms.toLat(lat,'dm',3)); $('#latD').val(Dms.toLat(lat,'d',5)); });
            $('#lonDMS').change( function() { var lon = Dms.parseDMS($('#lonDMS').val()); $('#lonDM').val(Dms.toLon(lon,'dm',3)); $('#lonD').val(Dms.toLon(lon,'d',5)); });
            $('#latDM').change( function() { var lat = Dms.parseDMS($('#latDM').val()); $('#latDMS').val(Dms.toLat(lat,'dms',1)); $('#latD').val(Dms.toLat(lat,'d',5)); });
            $('#lonDM').change( function() { var lon = Dms.parseDMS($('#lonDM').val()); $('#lonDMS').val(Dms.toLon(lon,'dms',1)); $('#lonD').val(Dms.toLon(lon,'d',5)); });
            $('#latD').change( function() { var lat = Dms.parseDMS($('#latD').val()); $('#latDMS').val(Dms.toLat(lat,'dms',1)); $('#latDM').val(Dms.toLat(lat,'dm',3)); });
            $('#lonD').change( function() { var lon = Dms.parseDMS($('#lonD').val()); $('#lonDMS').val(Dms.toLon(lon,'dms',1)); $('#lonDM').val(Dms.toLon(lon,'dm',3)); });

            // listener for display of bearings to user's preference
            $('input[name="deg-format"]').change(function() {
                // record preference in cookie
                Cookies.set('latlon-degree-format', degFmt = $(this).val());

                // trigger recalculations with new format
                $('#ortho-dist .lat1').trigger('change');
                $('#ortho-dest .lat1').trigger('change');
                $('#intersect  .lat1').trigger('change');
                $('#rhumb-dist .lat1').trigger('change');
                $('#rhumb-dest .lat1').trigger('change');
            });

            // ---- url query arguments for distance calculation...

            var from = Qs.parse(location.search.slice(1)).from;
            var to = Qs.parse(location.search.slice(1)).to;
            if (from && to) {
                from = from.split(',');
                to = to.split(',');
                $('#ortho-dist .lat1').val(from[0]);
                $('#ortho-dist .lon1').val(from[1]);
                $('#ortho-dist .lat2').val(to[0]);
                $('#ortho-dist .lon2').val(to[1]);
                //$('#ortho-dist .toggle-map a').trigger('click'); why no work?
                $('#ortho-dist .toggle-map').toggle(); // 'see on map' text
                $('#ortho-dist .map').toggle();        // the map itself
                $('#ortho-dist .lat1').trigger('change'); // to invoke drawPath()
            }


            // ---- ... & destination calculation

            var dist = Qs.parse(location.search.slice(1)).dist;
            var brng = Qs.parse(location.search.slice(1)).brng;
            if (from && dist && brng) {
                from = from.split(',');
                $('#ortho-dest .lat1').val(from[0]);
                $('#ortho-dest .lon1').val(from[1]);
                $('#ortho-dest .brng').val(brng);
                $('#ortho-dest .dist').val(dist);
                //$('#ortho-dist .toggle-map a').trigger('click'); why no work?
                $('#ortho-dest .toggle-map').toggle(); // 'see on map' text
                $('#ortho-dest .map').toggle();        // the map itself
                $('#ortho-dest .lat1').trigger('change'); // to invoke drawPath()
            }

            // show source code
            fetch('//cdn.rawgit.com/chrisveness/geodesy/v1.1.2/latlon-spherical.js')
                .then(function(res) { return res.ok ? res.text() : res.status+' '+res.statusText; })
                .then(function(txt) { doc.qrySel('#latlon-src').textContent = txt; prettyPrint(); })
                .catch(function(err) { doc.qrySel('#error').textContent = err.message; });
            fetch('//cdn.rawgit.com/chrisveness/geodesy/v1.1.2/dms.js')
                .then(function(res) { return res.ok ? res.text() : res.status+' '+res.statusText; })
                .then(function(txt) { doc.qrySel('#dms-src').textContent = txt; prettyPrint(); })
                .catch(function(err) { doc.qrySel('#error').textContent = err.message; });
        });

        function drawPath(lat1, lon1, lat2, lon2, m) {
            google.maps.event.trigger(m.map, 'resize');  // Gaaaaaah!

            // clear current overlays
            if (m.overlay.marker1) { m.overlay.marker1.setMap(null); m.overlay.marker1 = null; }
            if (m.overlay.marker2) { m.overlay.marker2.setMap(null); m.overlay.marker1 = null; }
            if (m.overlay.path)    { m.overlay.path.setMap(null);    m.overlay.path = null; }

            // if supplied lat/long are all valid numbers, draw the path
            if (!isNaN(lat1+lon1+lat2+lon2)) {
                var p1 = new google.maps.LatLng(lat1, lon1);
                var p2 = new google.maps.LatLng(lat2, lon2);
                var sw = new google.maps.LatLng(Math.min(lat1, lat2), Math.min(lon1, lon2));
                var ne = new google.maps.LatLng(Math.max(lat1, lat2), Math.max(lon1, lon2));
                var bnds = new google.maps.LatLngBounds(sw, ne);
                m.map.fitBounds(bnds);
                m.overlay.marker1 = new google.maps.Marker({ map:m.map, position:p1, title:'Point 1', icon:'http://maps.google.com/mapfiles/ms/icons/red-dot.png' });
                m.overlay.marker2 = new google.maps.Marker({ map:m.map, position:p2, title:'Point 2', icon:'http://maps.google.com/mapfiles/ms/icons/red.png' });
                m.overlay.path = new google.maps.Polyline({ map:m.map, path:[p1, p2], strokeColor:'#990000', geodesic:m.geodesic});
            }
        }
    </script> 
 </head> 
 <body> 
  <header> 
   <a href="../"><img src="../images/mtl.gif" alt="MTL logo"></a> 
   <h1>Movable Type Scripts</h1> 
   <hr> 
   <h2>Calculate distance, bearing and more between Latitude/Longitude points</h2> 
  </header> 
  <!--[if lte IE 9]><p class="alert align-left">This page no longer works on Internet Explorer 9 and earlier, which are <em><a href="https://www.microsoft.com/en-gb/WindowsForBusiness/End-of-IE-support">no longer supported</a></em></p><![endif]--> 
  <p class="error"></p> 
  <main> 
   <p>This page presents a variety of calculations for lati­tude/longi­tude points, with the formulæ and code fragments for implementing them.</p> 
   <p>All these formulæ are for calculations on the basis of a spherical earth (ignoring ellipsoidal effects) – which is accurate enough<sup><a href="#ellipsoid" title="see notes">*</a></sup> for most purposes… [In fact, the earth is very slightly ellipsoidal; using a spherical model gives errors typically up to 0.3%<sup><a href="http://gis.stackexchange.com/questions/25494#25580">1</a></sup> – see notes for further details].</p> 
   <form name="ortho-dist" id="ortho-dist"> 
    <fieldset>
     <legend>Great-circle distance between two points</legend> 
     <p>Enter the co-ordinates into the text boxes to try out the calculations. A variety of formats are accepted, principally:</p> 
     <ul class="list"> 
      <li>deg-min-sec suffixed with N/S/E/W (e.g. 40°44?55?N, 73 59 11W), or</li> 
      <li>signed decimal degrees without compass direction, where negative indicates west/south (e.g. 40.7486, -73.9864): </li> 
     </ul> 
     <table class="inputs"> 
      <tbody>
       <tr> 
        <td>Point 1:</td> 
        <td> <input type="text" name="lat1" class="lat1" value="50 03 59N" placeholder="Lat 1 (°N/S)" title="Lat 1 (°N/S)" required> , <input type="text" name="lon1" class="lon1" value="005 42 53W" placeholder="Lon 1 (°E/W)" title="Lon 1 (°E/W)" required> </td> 
       </tr> 
       <tr> 
        <td>Point 2:</td> 
        <td> <input type="text" name="lat2" class="lat2" value="58 38 38N" placeholder="Lat 2 (°N/S)" title="Lat 2 (°N/S)" required> , <input type="text" name="lon2" class="lon2" value="003 04 12W" placeholder="Lon 2 (°E/W)" title="Lon 2 (°E/W)" required> </td> 
       </tr> 
      </tbody>
     </table> 
     <table class="outputs"> 
      <tbody>
       <tr> 
        <td>Distance:</td> 
        <td> <output class="result-dist" title="Distance (in km)"></output> km <span title="rounding to 4 significant figures reflects the approx. 0.3% accuracy of the spherical model" class="small grey">(to 4 SF<sup>*</sup>)</span> </td> 
       </tr> 
       <tr> 
        <td>Initial bearing:</td> 
        <td><output class="result-brng1" title="Initial bearing (azimuth) between points"></output></td> 
       </tr> 
       <tr> 
        <td>Final bearing:</td> 
        <td><output class="result-brng2" title="Final bearing (azimuth) between points"></output></td> 
       </tr> 
       <tr> 
        <td>Midpoint:</td> 
        <td><output class="result-midpt" title="Midpoint between points"></output></td> 
       </tr> 
      </tbody>
     </table> 
     <p class="toggle-map">And you can <a>see it on a map</a> (aren’t those Google guys wonderful!)</p> 
     <p class="toggle-map hide"><a>... hide map</a></p> 
     <div id="map-ortho-dist-canvas" class="map hide"></div> 
    </fieldset> 
   </form> 
   <h3>Distance</h3> 
   <p>This uses the ‘<b>haversine</b>’ formula to calculate the great-circle distance between two points – that is, the shortest distance over the earth’s surface – giving an ‘as-the-crow-flies’ distance between the points (ignoring any hills they fly over, of course!).</p> 
   <table> 
    <tbody>
     <tr id="haversine"> 
      <td class="label" rowspan="3">Haversine<br>formula:</td> 
      <td class="formula">a = sin²(??/2) + cos ?<sub>1</sub> ? cos ?<sub>2</sub> ? sin²(??/2)</td> 
     </tr> 
     <tr> 
      <td class="formula">c = 2 ? atan2( ?<span class="radicand">a</span>, ?<span class="radicand">(1?a)</span> )</td> 
     </tr> 
     <tr> 
      <td class="formula">d = R ? c</td> 
     </tr> 
     <tr> 
      <td class="label align-right">where</td> 
      <td><i></i>?<i> is latitude, </i>?<i> is longitude, </i>R<i> is earth’s radius (mean radius = 6,371km);<br> note that angles need to be in radians to pass to trig functions!</i></td> 
     </tr> 
     <tr> 
      <td class="label">JavaScript:</td> 
      <td><pre class="code prettyprint>">
var R = 6371e3; // metres
var ?1 = lat1.toRadians();
var ?2 = lat2.toRadians();
var ?? = (lat2-lat1).toRadians();
var ?? = (lon2-lon1).toRadians();

var a = Math.sin(??/2) * Math.sin(??/2) +
        Math.cos(?1) * Math.cos(?2) *
        Math.sin(??/2) * Math.sin(??/2);
var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

var d = R * c;</pre> </td> 
     </tr> 
    </tbody>
   </table> 
   <p><i>Note in these scripts, I generally use lat/lon for lati­tude/longi­tude in degrees, and ?/? for lati­tude/longi­tude in radians – having found that mixing degrees &amp; radians is often the easiest route to head-scratching bugs...</i></p> 
   <aside>
    <p><i>Historical aside</i>: The height of tech­nology for navigator’s calculations used to be log tables. As there is no (real) log of a negative number, the ‘versine’ enabled them to keep trig func­tions in positive numbers. Also, the sin²(?/2) form of the haversine avoided addition (which en­tailed an anti-log lookup, the addi­tion, and a log lookup). Printed <a href="http://haversine.files.wordpress.com/2012/08/haversines.jpg">tables</a> for the haver­sine/in­verse-haver­sine (and its log­arithm, to aid multip­lica­tions) saved navi­gators from squaring sines, com­puting square roots, etc – arduous and error-prone activ­ities.</p> 
   </aside> 
   <p>The <a href="http://en.wikipedia.org/wiki/Haversine_formula">haversine</a> formula<sup><a href="http://mathforum.org/library/drmath/view/51879.html">1</a></sup> ‘remains particularly well-conditioned for numerical computa­tion even at small distances’ – unlike calcula­tions based on the <span title="cos c = cos a cos b + sin a sin b cos C"><i>spherical law of cosines</i></span>. The ‘(re)versed sine’ is <span class="formula">1?cos?</span>, and the ‘half-versed-sine’ is <span class="formula">(1?cos?)/2</span> or <span class="formula">sin²(?/2)</span> as used above. Once widely used by navigators, it was described by Roger Sinnott in <a href="https://www.shopatsky.com/product/sky-and-telescope-august-1984-digital-issue/sky-and-telescope-digital-issues-1980-1989"><i>Sky &amp; Telescope</i></a> magazine in 1984 (“Virtues of the Haversine”): Sinnott explained that the angular separa­tion between Mizar and Alcor in Ursa Major – 0°11?49.69? – could be accurately calculated on a <a href="http://en.wikipedia.org/wiki/TRS-80#modeliii">TRS-80</a> using the haversine.</p> 
   <p>For the curious, <i>c</i> is the angular distance in radians, and <i>a</i> is the square of half the chord length between the points.</p> 
   <p>If <code>atan2</code> is not available, <i>c</i> could be calculated from <span class="formula">2 ? asin( min(1, ?<span class="radicand">a</span>) )</span> (including protec­tion against rounding errors).</p> 
   <p>Using Chrome on a middling Core i5 PC, a distance calcula­tion takes around <a href="performance/latlong-spherical.html">2 – 5 micro­seconds</a> (hence around 200,000 – 500,000 per second). Little to no benefit is obtained by factoring out common terms; probably the JIT compiler optimises them out.</p> 
   <h4 id="cosine-law">Spherical Law of Cosines</h4> 
   <p>In fact, JavaScript (and most modern computers &amp; languages) use ‘IEEE 754’ 64-bit floating-point numbers, which provide 15 significant figures of precision. By my estimate, with this precision, the simple <a href="http://mathworld.wolfram.com/SphericalTrigonometry.html">spherical law of cosines</a> formula (cos <i>c</i> = cos <i>a</i> cos <i>b</i> + sin <i>a</i> sin <i>b</i> cos <i>C</i>) gives well-condi­tioned results down to distances as small as a few metres on the earth’s surface. <span class="note">(<i>Note that the geodetic form of the law of cosines is rearranged from the canonical one so that the latitude can be used directly, rather than the <a href="http://mathworld.wolfram.com/Colatitude.html">colatitude</a></i>).</span></p> 
   <p>This makes the simpler law of cosines a reasonable 1-line alternative to the haversine formula for many geodesy purposes (if not for astronomy). The choice may be driven by programming language, processor, coding context, available trig func­tions (in different languages), etc – and, for very small distances an equirectangular approxima­tion may be more suitable.</p> 
   <table> 
    <tbody>
     <tr> 
      <td class="label">Law of cosines:</td> 
      <td class="formula">d = acos( sin ?<sub>1</sub> ? sin ?<sub>2</sub> + cos ?<sub>1</sub> ? cos ?<sub>2</sub> ? cos ?? ) ? R</td> 
     </tr> 
     <tr> 
      <td class="label">JavaScript:</td> 
      <td><pre class="code prettyprint>">
var ?1 = lat1.toRadians(), ?2 = lat2.toRadians(), ?? = (lon2-lon1).toRadians(), R = 6371e3; // gives d in metres
var d = Math.acos( Math.sin(?1)*Math.sin(?2) + Math.cos(?1)*Math.cos(?2) * Math.cos(??) ) * R;</pre> </td> 
     </tr> 
     <tr> 
      <td class="label">Excel:</td> 
      <td class="code">=ACOS( SIN(lat1)*SIN(lat2) + COS(lat1)*COS(lat2)*COS(lon2-lon1) ) * 6371000</td> 
     </tr> 
     <tr> 
      <td class="label">(or with lat/lon in degrees):</td> 
      <td class="code">=ACOS( SIN(lat1*PI()/180)*SIN(lat2*PI()/180) + COS(lat1*PI()/180)*COS(lat2*PI()/180)*COS(lon2*PI()/180-lon1*PI()/180) ) * 6371000</td> 
     </tr> 
    </tbody>
   </table> 
   <p>While simpler, the law of cosines is slightly slower than the haversine, in my tests.</p> 
   <h4 id="equirectangular">Equirectangular approximation</h4> 
   <p>If performance is an issue and accuracy less important, for small distances <a href="http://en.wikipedia.org/wiki/Pythagorean_theorem">Pythagoras’ theorem</a> can be used on an <a href="http://en.wikipedia.org/wiki/Equirectangular_projection">equi­rectangular projec­tion</a>:<sup title="merci à Laurent Grégoire">*</sup></p> 
   <table> 
    <tbody>
     <tr> 
      <td class="label">Formula</td> 
      <td class="formula">x = ?? ? cos ?<sub>m</sub></td> 
     </tr> 
     <tr> 
      <td></td> 
      <td class="formula">y = ??</td> 
     </tr> 
     <tr> 
      <td></td> 
      <td class="formula">d = R ? ?<span class="radicand">x² + y²</span></td> 
     </tr> 
     <tr> 
      <td class="label">JavaScript:</td> 
      <td><pre class="code prettyprint>">
var x = (?2-?1) * Math.cos((?1+?2)/2);
var y = (?2-?1);
var d = Math.sqrt(x*x + y*y) * R;</pre></td> 
     </tr> 
    </tbody>
   </table> 
   <p>This uses just one trig and one sqrt function – as against half-a-dozen trig func­tions for cos law, and 7 trigs + 2 sqrts for haversine. Accuracy is somewhat complex: along meridians there are no errors, otherwise they depend on distance, bearing, and latitude, but are small enough for many purposes<sup title="anyone care to quantify them?">*</sup> (and often trivial compared with the spherical approxima­tion itself).</p> 
   <p>Alternatively, the <i>polar coordinate flat-earth formula</i> can be used: using the co-latitudes ?<sub>1</sub> = ?/2??<sub>1</sub> and ?<sub>2</sub> = ?/2??<sub>2</sub>, then <span class="formula nowrap">d = R ? ?<span class="radicand">?<sub>1</sub>² + ?<sub>2</sub>² ? 2 ? ?<sub>1</sub> ? ?<sub>2</sub> ? cos ??</span></span>. I’ve not compared accuracy.</p> 
   <figure class="float-right">
    <img src="baghdad-to-osaka.jpg" alt="Baghdad to Osaka"> 
    <figcaption>
     Baghdad to Osaka – 
     <br> not a constant bearing!
    </figcaption> 
   </figure> 
   <h3 id="bearing">Bearing</h3> 
   <p>In general, your current heading will vary as you follow a great circle path (orthodrome); the final heading will differ from the initial heading by varying degrees according to distance and latitude (if you were to go from say 35°N,45°E (?&nbsp;Baghdad) to 35°N,135°E (?&nbsp;Osaka), you would start on a heading of 60° and end up on a heading of 120°!).</p> 
   <p>This formula is for the initial bearing (sometimes referred to as forward azimuth) which if followed in a straight line along a great-circle arc will take you from the start point to the end point:<sup><a href="http://mathforum.org/library/drmath/view/55417.html">1</a></sup></p> 
   <table> 
    <tbody>
     <tr> 
      <td class="label">Formula:</td> 
      <td class="formula">? = atan2( sin ?? ? cos ?<sub>2</sub> , cos ?<sub>1</sub> ? sin ?<sub>2</sub> ? sin ?<sub>1</sub> ? cos ?<sub>2</sub> ? cos ?? )</td> 
     </tr> 
     <tr> 
      <td class="label align-right">where</td> 
      <td><i></i>?<sub>1</sub><i>,</i>?<sub>1</sub><i> is the start point, </i>?<sub>2</sub><i>,</i>?<sub>2</sub><i> the end point (</i>??<i> is the difference in longitude)</i></td> 
     </tr> 
     <tr> 
      <td class="label">JavaScript:
       <div class="small grey">
        (all angles 
        <br>in radians)
       </div></td> 
      <td><pre class="code prettyprint>">
var y = Math.sin(?2-?1) * Math.cos(?2);
var x = Math.cos(?1)*Math.sin(?2) -
        Math.sin(?1)*Math.cos(?2)*Math.cos(?2-?1);
var brng = Math.atan2(y, x).toDegrees();</pre></td> 
     </tr> 
     <tr> 
      <td class="label">Excel:
       <div class="small grey">
        (all angles 
        <br>in radians)
       </div></td> 
      <td class="code nowrap">=ATAN2(COS(lat1)*SIN(lat2)-SIN(lat1)*COS(lat2)*COS(lon2-lon1), <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SIN(lon2-lon1)*COS(lat2)) <br><span class="note">*note that Excel reverses the arguments to ATAN2 – see notes below</span> </td> 
     </tr> 
    </tbody>
   </table> 
   <p class="note">Since atan2 returns values in the range -? ... +? (that is, -180° ... +180°), to normalise the result to a compass bearing (in the range 0° ... 360°, with ?ve values transformed into the range 180° ... 360°), convert to degrees and then use (?+360)&nbsp;%&nbsp;360, where % is (floating point) modulo.</p> 
   <p class="note">For final bearing, simply take the <i>initial</i> bearing from the <i>end</i> point to the <i>start</i> point and reverse it (using ? = (?+180) % 360).</p> 
   <h3 id="midpoint">Midpoint</h3> 
   <p>This is the half-way point along a great circle path between the two points.<sup><a href="http://mathforum.org/library/drmath/view/51822.html" title="Mathforum derivation">1</a></sup></p> 
   <table> 
    <tbody>
     <tr> 
      <td class="label">Formula:</td> 
      <td class="formula">B<sub>x</sub> = cos ?<sub>2</sub> ? cos ??</td> 
     </tr> 
     <tr> 
      <td></td> 
      <td class="formula">B<sub>y</sub> = cos ?<sub>2</sub> ? sin ??</td> 
     </tr> 
     <tr> 
      <td></td> 
      <td class="formula">?<sub>m</sub> = atan2( sin ?<sub>1</sub> + sin ?<sub>2</sub>, ?<span class="radicand">(cos ?<sub>1</sub> + B<sub>x</sub>)² + B<sub>y</sub>²</span> )</td> 
     </tr> 
     <tr> 
      <td></td> 
      <td class="formula">?<sub>m</sub> = ?<sub>1</sub> + atan2(B<sub>y</sub>, cos(?<sub>1</sub>)+B<sub>x</sub>)</td> 
     </tr> 
     <tr> 
      <td class="label">JavaScript:
       <div class="small grey">
        (all angles 
        <br>in radians)
       </div></td> 
      <td><pre class="code prettyprint>">
var Bx = Math.cos(?2) * Math.cos(?2-?1);
var By = Math.cos(?2) * Math.sin(?2-?1);
var ?3 = Math.atan2(Math.sin(?1) + Math.sin(?2),
                    Math.sqrt( (Math.cos(?1)+Bx)*(Math.cos(?1)+Bx) + By*By ) );
var ?3 = ?1 + Math.atan2(By, Math.cos(?1) + Bx);</pre></td> 
     </tr> 
     <tr> 
      <td></td> 
      <td class="note">The longitude can be normalised to ?180…+180 using <code>(lon+540)%360-180</code></td> 
     </tr> 
    </tbody>
   </table> 
   <p class="note">Just as the initial bearing may vary from the final bearing, the midpoint may not be located half-way between latitudes/longitudes; the midpoint between 35°N,45°E and 35°N,135°E is around 45°N,90°E.</p> 
   <h4 id="intermediate-point">Intermediate point</h4> 
   <p>An intermediate point at any fraction along the great circle path between two points can also be calculated.<sup><a href="http://www.edwilliams.org/avform.htm#Intermediate" title="from Ed William’s aviation formulary">1</a></sup></p> 
   <table> 
    <tbody>
     <tr> 
      <td class="label">Formula:</td> 
      <td class="formula">a = sin((1?f)??) / sin ?</td> 
     </tr> 
     <tr> 
      <td></td> 
      <td class="formula">b = sin(f??) / sin ?</td> 
     </tr> 
     <tr> 
      <td></td> 
      <td class="formula">x = a ? cos ?<sub>1</sub> ? cos ?<sub>1</sub> + b ? cos ?<sub>2</sub> ? cos ?<sub>2</sub></td> 
     </tr> 
     <tr> 
      <td></td> 
      <td class="formula">y = a ? cos ?<sub>1</sub> ? sin ?<sub>1</sub> + b ? cos ?<sub>2</sub> ? sin ?<sub>2</sub></td> 
     </tr> 
     <tr> 
      <td></td> 
      <td class="formula">z = a ? sin ?<sub>1</sub> + b ? sin ?<sub>2</sub></td> 
     </tr> 
     <tr> 
      <td></td> 
      <td class="formula">?<sub>i</sub> = atan2(z, ?<span class="radicand">x² + y²)</span></td> 
     </tr> 
     <tr> 
      <td></td> 
      <td class="formula">?<sub>i</sub> = atan2(y, x)</td> 
     </tr> 
     <tr> 
      <td class="label align-right">where</td> 
      <td><i></i>f<i> is fraction along great circle route (f=0 is point 1, f=1 is point 2), </i>?<i> is the angular distance </i>d/R<i> between the two points.</i></td> 
     </tr> 
    </tbody>
   </table> 
   <p>&nbsp;</p> 
   <hr> 
   <h3 id="destPoint"><b>Destination point given distance and bearing from start point</b></h3> 
   <p>Given a start point, initial bearing, and distance, this will calculate the destina­tion point and final bearing travelling along a (shortest distance) great circle arc.</p> 
   <form name="ortho-dest" id="ortho-dest"> 
    <fieldset>
     <legend>Destination point along great-circle given distance and bearing from start point</legend> 
     <table class="inputs"> 
      <tbody>
       <tr> 
        <td>Start point:</td> 
        <td> <input name="lat1" class="lat1" type="text" value="53°19?14?N">, <input name="lon1" class="lon1" type="text" value="001°43?47?W"></td> 
       </tr> 
       <tr> 
        <td>Bearing:</td> 
        <td><input type="text" name="brng" class="brng" value="096°01?18?"></td> 
       </tr> 
       <tr> 
        <td>Distance:</td> 
        <td><input name="dist" class="dist" type="number" step="any" value="124.8"> km</td> 
       </tr> 
      </tbody>
     </table> 
     <table class="outputs"> 
      <tbody>
       <tr> 
        <td>Destination point:</td> 
        <td><output class="result-point" title="Destination point"></output></td> 
       </tr> 
       <tr> 
        <td>Final bearing:</td> 
        <td><output class="result-brng" title="Final bearing (azimuth) arriving at point 2"></output></td> 
       </tr> 
       <tr> 
        <td> <p class="toggle-map"><a>view map</a></p> <p class="toggle-map hide"><a>hide map</a></p> </td> 
        <td></td> 
       </tr> 
      </tbody>
     </table> 
     <div id="map-ortho-dest-canvas" class="map hide"></div> 
    </fieldset> 
   </form> 
   <table> 
    <tbody>
     <tr> 
      <td class="label">Formula: </td> 
      <td class="formula">?<sub>2</sub> = asin( sin ?<sub>1</sub> ? cos ? + cos ?<sub>1</sub> ? sin ? ? cos ? )</td> 
     </tr> 
     <tr> 
      <td></td> 
      <td class="formula">?<sub>2</sub> = ?<sub>1</sub> + atan2( sin ? ? sin ? ? cos ?<sub>1</sub>, cos ? ? sin ?<sub>1</sub> ? sin ?<sub>2</sub> )</td> 
     </tr> 
     <tr> 
      <td class="label align-right">where</td> 
      <td><i></i>?<i> is latitude, </i>?<i> is longitude, </i>?<i> is the bearing (clockwise from north), ? is the angular distance </i>d/R<i>; </i>d<i> being the distance travelled, </i>R<i> the earth’s radius</i></td> 
     </tr> 
     <tr> 
      <td class="label">JavaScript:
       <div class="small grey">
        (all angles 
        <br>in radians)
       </div></td> 
      <td><pre class="code prettyprint>">
var ?2 = Math.asin( Math.sin(?1)*Math.cos(d/R) +
                    Math.cos(?1)*Math.sin(d/R)*Math.cos(brng) );
var ?2 = ?1 + Math.atan2(Math.sin(brng)*Math.sin(d/R)*Math.cos(?1),
                         Math.cos(d/R)-Math.sin(?1)*Math.sin(?2));</pre></td> 
     </tr> 
     <tr> 
      <td></td> 
      <td class="note">The longitude can be normalised to ?180…+180 using <code>(lon+540)%360-180</code></td> 
     </tr> 
     <tr> 
      <td class="label">Excel:
       <div class="small grey">
        (all angles 
        <br>in radians)
       </div></td> 
      <td class="code">lat2: =ASIN(SIN(lat1)*COS(d/R) + COS(lat1)*SIN(d/R)*COS(brng))<br> lon2: =lon1 + ATAN2(COS(d/R)-SIN(lat1)*SIN(lat2), SIN(brng)*SIN(d/R)*COS(lat1)) <br><span class="note">* Remember that Excel reverses the arguments to ATAN2 – see notes below</span></td> 
     </tr> 
    </tbody>
   </table> 
   <p class="note">For final bearing, simply take the <i>initial</i> bearing from the <i>end</i> point to the <i>start</i> point and reverse it with <code>(brng+180)%360</code>.</p> 
   <p>&nbsp;</p> 
   <hr> 
   <h3 id="intersection">Intersection of two paths given start points and bearings</h3> 
   <p>This is a rather more complex calculation than most others on this page, but I've been asked for it a number of times. This comes from Ed William’s <a href="http://www.edwilliams.org/avform.htm#Intersection">aviation formulary</a>. See below for the JavaScript.</p> 
   <form name="intersect" id="intersect"> 
    <fieldset>
     <legend>Intersection of two great-circle paths</legend> 
     <table class="inputs"> 
      <tbody>
       <tr> 
        <td>Point 1:</td> 
        <td> <input name="lat1" class="lat1" type="text" value="51.8853 N" title="Latitude 1">, <input name="lon1" class="lon1" type="text" value="0.2545 E" title="Longitude 1"> Brng 1: <input name="brng1" class="brng1" type="text" value="108.55°" title="Bearing 1"> </td> 
       </tr> 
       <tr> 
        <td>Point 2:</td> 
        <td> <input name="lat2" class="lat2" type="text" value="49.0034 N" title="Latitude 2">, <input name="lon2" class="lon2" type="text" value="2.5735 E" title="Longitude 2"> Brng 2: <input name="brng1" class="brng2" type="text" value="32.44°" title="Bearing 2"> </td> 
       </tr> 
      </tbody>
     </table> 
     <table class="outputs"> 
      <tbody>
       <tr> 
        <td>Intersection point:</td> 
        <td><output class="result-point" title="Intersection point"></output></td> 
       </tr> 
       <tr> 
        <td colspan="2"><p>&nbsp;</p></td> 
       </tr> 
      </tbody>
     </table> 
    </fieldset> 
   </form> 
   <table class="clear-floats"> 
    <tbody>
     <tr> 
      <td class="label">Formula:</td> 
      <td class="formula">?<sub>12</sub> = 2?asin( ?<span class="radicand">(sin²(??/2) + cos ?<sub>1</sub> ? cos ?<sub>2</sub> ? sin²(??/2))</span> )</td> 
      <td class="small grey align-right">angular dist. p1–p2</td> 
     </tr> 
     <tr> 
      <td></td> 
      <td class="formula">?<sub>a</sub> = acos( ( sin ?<sub>2</sub> ? sin ?<sub>1</sub> ? cos ?<sub>12</sub> ) / ( sin ?<sub>12</sub> ? cos ?<sub>1</sub> ) )<br> ?<sub>b</sub> = acos( ( sin ?<sub>1</sub> ? sin ?<sub>2</sub> ? cos ?<sub>12</sub> ) / ( sin ?<sub>12</sub> ? cos ?<sub>2</sub> ) )</td> 
      <td class="small grey align-right">initial / final bearings<br>between points 1 &amp; 2</td> 
     </tr> 
     <tr> 
      <td></td> 
      <td class="formula">if sin(?<sub>2</sub>??<sub>1</sub>) &gt; 0<br> &nbsp;&nbsp;&nbsp;&nbsp;?<sub>12</sub> = ?<sub>a</sub><br> &nbsp;&nbsp;&nbsp;&nbsp;?<sub>21</sub> = 2? ? ?<sub>b</sub><br> else<br> &nbsp;&nbsp;&nbsp;&nbsp;?<sub>12</sub> = 2? ? ?<sub>a</sub><br> &nbsp;&nbsp;&nbsp;&nbsp;?<sub>21</sub> = ?<sub>b</sub></td> 
      <td class="small grey align-right"></td> 
     </tr> 
     <tr> 
      <td></td> 
      <td class="formula">?<sub>1</sub> = ?<sub>13</sub> ? ?<sub>12</sub><br> ?<sub>2</sub> = ?<sub>21</sub> ? ?<sub>23</sub></td> 
      <td class="small grey align-right">angle p2–p1–p3<br>angle p1–p2–p3</td> 
     </tr> 
     <tr> 
      <td></td> 
      <td class="formula">?<sub>3</sub> = acos( ?cos ?<sub>1</sub> ? cos ?<sub>2</sub> + sin ?<sub>1</sub> ? sin ?<sub>2</sub> ? cos ?<sub>12</sub> )</td> 
      <td class="small grey align-right">angle p1–p2–p3</td> 
     </tr> 
     <tr> 
      <td></td> 
      <td class="formula">?<sub>13</sub> = atan2( sin ?<sub>12</sub> ? sin ?<sub>1</sub> ? sin ?<sub>2</sub> , cos ?<sub>2</sub> + cos ?<sub>1</sub> ? cos ?<sub>3</sub> )</td> 
      <td class="small grey align-right">angular dist. p1–p3</td> 
     </tr> 
     <tr> 
      <td></td> 
      <td class="formula">?<sub>3</sub> = asin( sin ?<sub>1</sub> ? cos ?<sub>13</sub> + cos ?<sub>1</sub> ? sin ?<sub>13</sub> ? cos ?<sub>13</sub> )</td> 
      <td class="small grey align-right">p3 lat</td> 
     </tr> 
     <tr> 
      <td></td> 
      <td class="formula">??<sub>13</sub> = atan2( sin ?<sub>13</sub> ? sin ?<sub>13</sub> ? cos ?<sub>1</sub> , cos ?<sub>13</sub> ? sin ?<sub>1</sub> ? sin ?<sub>3</sub> )</td> 
      <td class="small grey align-right">long p1–p3</td> 
     </tr> 
     <tr> 
      <td></td> 
      <td class="formula">?<sub>3</sub> = ?<sub>1</sub> + ??<sub>13</sub></td> 
      <td class="small grey align-right">p3 long</td> 
     </tr> 
     <tr> 
      <td class="label align-right"><i>where</i></td> 
      <td><p><i>?<sub>1</sub>, ?<sub>1</sub>, ?<sub>13</sub> : 1st start point &amp; (initial) bearing from 1st point towards intersection point<br> ?<sub>2</sub>, ?<sub>2</sub>, ?<sub>23</sub> : 2nd start point &amp; (initial) bearing from 2nd point towards intersection point<br> ?<sub>3</sub>, ?<sub>3</sub> : intersection point</i></p> <p><i>% = (floating point) modulo
         <!--, | | = abs--></i></p></td> 
     </tr> 
     <tr> 
      <td class="label align-right">note –</td> 
      <td>if sin ?<sub>1</sub> = 0 and sin ?<sub>2</sub> = 0: infinite solutions<br> if sin ?<sub>1</sub> ? sin ?<sub>2</sub> &lt; 0: ambiguous solution<br> this formulation is not always well-conditioned for meridional or equatorial lines</td> 
     </tr> 
    </tbody>
   </table> 
   <p>This is a lot simpler using vectors rather than spherical trigonometry: see <a href="latlong-vectors.html#intersection">latlong-vectors.html</a>.</p> 
   <hr> 
   <h3 id="cross-track">Cross-track distance</h3> 
   <p>Here’s a new one: I’ve sometimes been asked about distance of a point from a great-circle path (sometimes called cross track error).</p> 
   <table> 
    <tbody>
     <tr> 
      <td class="label">Formula: </td> 
      <td class="formula">d<sub>xt</sub> = asin( sin(?<sub>13</sub>) ? sin(?<sub>13</sub>??<sub>12</sub>) ) ? R</td> 
     </tr> 
     <tr> 
      <td class="label align-right"><i>where</i></td> 
      <td><i> ?<sub>13</sub> is (angular) distance from start point to third point<br> ?<sub>13</sub> is (initial) bearing from start point to third point<br> ?<sub>12</sub> is (initial) bearing from start point to end point<br> R is the earth’s radius<br> </i> </td> 
     </tr> 
     <tr> 
      <td class="label">JavaScript:</td> 
      <td><pre class="code prettyprint>">var dXt = Math.asin(Math.sin(d13/R)*Math.sin(?13-?12)) * R;</pre></td> 
     </tr> 
    </tbody>
   </table> 
   <p>Here, the great-circle path is identified by a start point and an end point – depending on what initial data you’re working from, you can use the formulæ above to obtain the relevant distance and bearings. The sign of d<sub>xt</sub> tells you which side of the path the third point is on.</p> 
   <p>The along-track distance, from the start point to the closest point on the path to the third point, is</p> 
   <table> 
    <tbody>
     <tr> 
      <td class="label">Formula: </td> 
      <td class="formula">d<sub>at</sub> = acos( cos(?<sub>13</sub>) / cos(?<sub>xt</sub>) ) ? R</td> 
     </tr> 
     <tr> 
      <td class="label align-right"><i>where</i></td> 
      <td><i> ?<sub>13</sub> is (angular) distance from start point to third point<br> ?<sub>xt</sub> is (angular) cross-track distance<br> R is the earth’s radius<br> </i> </td> 
     </tr> 
     <tr> 
      <td class="label">JavaScript:</td> 
      <td><pre class="code prettyprint>">var dAt = Math.acos(Math.cos(d13/R)/Math.cos(dXt/R)) * R;</pre></td> 
     </tr> 
    </tbody>
   </table> 
   <h3 id="clairaut">Closest point to the poles</h3> 
   <p>And: ‘Clairaut’s formula’ will give you the maximum latitude of a great circle path, given a bearing ? and latitude ? on the great circle: </p>
   <table> 
    <tbody>
     <tr> 
      <td class="label">Formula: </td> 
      <td class="formula">?<sub>max</sub> = acos( | sin ? ? cos ? | )</td> 
     </tr> 
     <tr> 
      <td class="label">JavaScript:</td> 
      <td><pre class="code prettyprint>">var ?Max = Math.acos(Math.abs(Math.sin(?)*Math.cos(?)));</pre></td> 
     </tr> 
    </tbody>
   </table> 
   <p>&nbsp;</p> 
   <hr> 
   <h3 id="rhumblines">Rhumb lines</h3> 
   <p>A ‘rhumb line’ (or loxodrome) is a path of constant bearing, which crosses all meridians at the same angle.</p> 
   <p>Sailors used to (and sometimes still) navigate along rhumb lines since it is easier to follow a constant compass bearing than to be continually adjusting the bearing, as is needed to follow a great circle. Rhumb lines are straight lines on a Mercator Projec­tion map (also helpful for naviga­tion).</p> 
   <p>Rhumb lines are generally longer than great-circle (orthodrome) routes. For instance, London to New York is 4% longer along a rhumb line than along a great circle – important for avia­tion fuel, but not particularly to sailing vessels. New York to Beijing – close to the most extreme example possible (though not sailable!) – is 30% longer along a rhumb line.</p> 
   <form name="rhumb-dist" id="rhumb-dist"> 
    <fieldset>
     <legend>Rhumb-line distance between two points</legend> 
     <table class="inputs"> 
      <tbody>
       <tr> 
        <td>Point 1:</td> 
        <td> <input name="lat1" class="lat1" type="text" value="50 21 59N" title="Latitude 1">, <input name="lon1" class="lon1" type="text" value="004 08 02W" title="Longitude 1"> </td> 
       </tr> 
       <tr> 
        <td>Point 2:</td> 
        <td> <input name="lat2" class="lat2" type="text" value="42 21 04N" title="Latitude 2">, <input name="lon2" class="lon2" type="text" value="071 02 27W" title="Longitude 2"> </td> 
       </tr> 
      </tbody>
     </table> 
     <table class="outputs"> 
      <tbody>
       <tr> 
        <td>Distance:</td> 
        <td><output class="result-dist" title="Distance (in km)"></output> km</td> 
       </tr> 
       <tr> 
        <td>Bearing:</td> 
        <td><output class="result-brng" title="Bearing (azimuth) between points"></output></td> 
       </tr> 
       <tr> 
        <td>Midpoint:</td> 
        <td><output class="result-midpt" title="Midpoint between points"></output></td> 
       </tr> 
       <tr> 
        <td> <p class="toggle-map"><a>view map</a></p> <p class="toggle-map hide"><a>hide map</a></p> </td> 
        <td></td> 
       </tr> 
      </tbody>
     </table> 
     <div id="map-rhumb-dist-canvas" class="map hide"></div> 
    </fieldset> 
   </form> 
   <form name="rhumb-dest" id="rhumb-dest" class="demo"> 
    <fieldset>
     <legend>Destination point along rhumb line given distance and bearing from start point</legend> 
     <table class="inputs"> 
      <tbody>
       <tr> 
        <td>Start point:</td> 
        <td> <input name="lat1" class="lat1" type="text" value="51 07 32N">, <input name="lon1" class="lon1" type="text" value="001 20 17E"> </td> 
       </tr> 
       <tr> 
        <td>Bearing:</td> 
        <td><input name="brng" class="brng" type="text" value="116°38?10"></td> 
       </tr> 
       <tr> 
        <td>Distance:</td> 
        <td><input name="dist" class="dist" type="number" step="any" value="40.23"> km</td> 
       </tr> 
      </tbody>
     </table> 
     <table class="outputs"> 
      <tbody>
       <tr> 
        <td>Destination point:</td> 
        <td><output class="result-point" title="Destination points"></output></td> 
       </tr> 
       <tr> 
        <td> <p class="toggle-map"><a>view map</a></p> <p class="toggle-map hide"><a>hide map</a></p> </td> 
        <td></td> 
       </tr> 
      </tbody>
     </table> 
     <div id="map-rhumb-dest-canvas" class="map hide"></div> 
     <p>&nbsp;</p> 
    </fieldset> 
   </form> 
   <p>Key to calculations of rhumb lines is the <i>inverse Gudermannian func­tion</i><a href="http://mathworld.wolfram.com/InverseGudermannian.html">¹</a>, which gives the height on a Mercator projec­tion map of a given latitude: <span class="formula">ln(tan? + sec?)</span> or <span class="formula">ln( tan(?/4+?/2) )</span>. This of course tends to infinity at the poles (in keeping with the Mercator projec­tion). <span class="grey">For obsessives, there is even an ellipsoidal version, the ‘isometric latitude’: <span class="formula">? = ln( tan(?/4+?/2) / [ (1?e?sin?) / (1+e?sin?)&nbsp;]<sup>e/2</sup>)</span>, or its better-conditioned equivalent <span class="formula">? = atanh(sin?) ? e?atanh(e?sin?)</span>.</span> </p> 
   <p>The formulæ to derive Mercator projection easting and northing coordinates from spherical latitude and longitude are then<a href="http://www.epsg.org/guides/docs/g7-2.pdf">¹</a></p> 
   <table class="width-full"> 
    <tbody>
     <tr> 
      <td></td> 
      <td class="formula">E = R ? ?</td> 
     </tr> 
     <tr> 
      <td></td> 
      <td class="formula">N = R ? ln( tan(?/4 + ?/2) )</td> 
     </tr> 
    </tbody>
   </table> 
   <p>The following formulæ are from Ed Williams’ aviation formulary.<a href="http://www.edwilliams.org/avform.htm#Rhumb">¹</a></p> 
   <h4 id="rhumb-distance">Distance</h4> 
   <p>Since a rhumb line is a straight line on a Mercator projec­tion, the distance between two points along a rhumb line is the length of that line (by Pythagoras); but the distor­tion of the projec­tion needs to be compensated for.</p> 
   <p>On a constant latitude course (travelling east-west), this compensa­tion is simply <span class="formula">cos?</span>; in the general case, it is <span class="formula">??/??</span> where <span class="formula">?? = ln( tan(?/4 + ?<sub>2</sub>/2) / tan(?/4 + ?<sub>1</sub>/2) )</span> (the ‘projected’ latitude difference)</p> 
   <table class="width-full"> 
    <tbody>
     <tr> 
      <td class="label">Formula: </td> 
      <td class="formula">?? = ln( tan(?/4 + ?<sub>2</sub>/2) / tan(?/4 + ?<sub>1</sub>/2) )</td> 
      <td class="small grey align-right">(‘projected’ latitude difference)</td> 
     </tr> 
     <tr> 
      <td></td> 
      <td class="formula">q = ??/?? (or cos? for E-W line)</td> 
      <td></td> 
     </tr> 
     <tr> 
      <td></td> 
      <td class="formula">d = ?<span class="radicand">(??² + q²???²)</span> ? R</td> 
      <td class="small grey align-right">(Pythagoras)</td> 
     </tr> 
     <tr> 
      <td class="label align-right">where</td> 
      <td colspan="2">? <i>is latitud</i>e, ? <i>is longitude</i>, ??<i> is taking shortest route (&lt;180°), </i>R<i> is the earth’s radius</i>, ln<i> is natural log</i></td> 
     </tr> 
     <tr> 
      <td class="label">JavaScript:
       <div class="small grey">
        (all angles 
        <br>in radians)
       </div></td> 
      <td colspan="2"><pre class="code prettyprint>">
var ?? = Math.log(Math.tan(Math.PI/4+?2/2)/Math.tan(Math.PI/4+?1/2));
var q = Math.abs(??) &gt; 10e-12 ? ??/?? : Math.cos(?1); // E-W course becomes ill-conditioned with 0/0

// if dLon over 180° take shorter rhumb line across the anti-meridian:
if (Math.abs(??) &gt; Math.PI) ?? = ??&gt;0 ? -(2*Math.PI-??) : (2*Math.PI+??);

var dist = Math.sqrt(??*?? + q*q*??*??) * R;</pre> </td> 
     </tr> 
    </tbody>
   </table> 
   <h4 id="rhumb-bearing">Bearing</h4> 
   <p>A rhumb line is a straight line on a Mercator projection, with an angle on the projec­tion equal to the compass bearing.</p> 
   <table class="width-full"> 
    <tbody>
     <tr> 
      <td class="label">Formula: </td> 
      <td class="formula">?? = ln( tan(?/4 + ?<sub>2</sub>/2) / tan(?/4 + ?<sub>1</sub>/2) )</td> 
      <td class="small grey align-right">(‘projected’ latitude difference)</td> 
     </tr> 
     <tr> 
      <td></td> 
      <td class="formula">? = atan2(??, ??)</td> 
      <td></td> 
     </tr> 
     <tr> 
      <td class="label align-right">where</td> 
      <td colspan="2">? <i>is latitud</i>e, ? <i>is longitude</i>, ??<i> is taking shortest route (&lt;180°), </i>R<i> is the earth’s radius</i>, ln<i> is natural log</i></td> 
     </tr> 
     <tr> 
      <td class="label">JavaScript:
       <div class="small grey">
        (all angles 
        <br>in radians)
       </div></td> 
      <td colspan="2"><pre class="code prettyprint>">
var ?? = Math.log(Math.tan(Math.PI/4+?2/2)/Math.tan(Math.PI/4+?1/2));

// if dLon over 180° take shorter rhumb line across the anti-meridian:
if (Math.abs(??) &gt; Math.PI) ?? = ??&gt;0 ? -(2*Math.PI-??) : (2*Math.PI+??);

var brng = Math.atan2(??, ??).toDegrees();</pre></td> 
     </tr> 
    </tbody>
   </table> 
   <h4 id="rhumb-destination">Destination</h4> 
   <p>Given a start point and a distance <i>d</i> along constant bearing <i>?</i>, this will calculate the destina­tion point. If you maintain a constant bearing along a rhumb line, you will gradually spiral in towards one of the poles. </p> 
   <table class="width-full"> 
    <tbody>
     <tr> 
      <td class="label">Formula: </td> 
      <td class="formula">? = d/R</td> 
      <td class="small grey align-right">(angular distance)</td> 
     </tr> 
     <tr> 
      <td></td> 
      <td class="formula">?<sub>2</sub> = ?<sub>1</sub> + ? ? cos ?</td> 
      <td></td> 
     </tr> 
     <tr> 
      <td></td> 
      <td class="formula">?? = ln( tan(?/4 + ?<sub>2</sub>/2) / tan(?/4 + ?<sub>1</sub>/2) )</td> 
      <td class="small grey align-right">(‘projected’ latitude difference)</td> 
     </tr> 
     <tr> 
      <td></td> 
      <td class="formula">q = ??/?? (or cos ? for E-W line)</td> 
      <td></td> 
     </tr> 
     <tr> 
      <td></td> 
      <td class="formula">?? = ? ? sin ? / q</td> 
      <td></td> 
     </tr> 
     <tr> 
      <td></td> 
      <td class="formula">?<sub>2</sub> = ?<sub>1</sub> + ??</td> 
      <td></td> 
     </tr> 
     <tr> 
      <td class="label align-right">where</td> 
      <td colspan="2">? <i>is latitude</i>, ? <i>is longitude</i>, ?? <i>is taking shortest route (&lt;180°), </i>ln<i> is natural log, </i>R<i> is the earth’s radius</i></td> 
     </tr> 
     <tr> 
      <td class="label">JavaScript:
       <div class="small grey">
        (all angles 
        <br>in radians)
       </div></td> 
      <td colspan="2"><pre class="code prettyprint>">
var ? = d/R;
var ?? = ? * Math.cos(?);
var ?2 = ?1 + ??;

var ?? = Math.log(Math.tan(?2/2+Math.PI/4)/Math.tan(?1/2+Math.PI/4));
var q = Math.abs(??) &gt; 10e-12 ? ?? / ?? : Math.cos(?1); // E-W course becomes ill-conditioned with 0/0

var ?? = ?*Math.sin(?)/q;
var ?2 = ?1 + ??;

// check for some daft bugger going past the pole, normalise latitude if so
if (Math.abs(?2) &gt; Math.PI/2) ?2 = ?2&gt;0 ? Math.PI-?2 : -Math.PI-?2;</pre></td> 
     </tr> 
     <tr> 
      <td></td> 
      <td colspan="2" class="note">The longitude can be normalised to ?180…+180 using <code>(lon+540)%360-180</code></td> 
     </tr> 
    </tbody>
   </table> 
   <h4>Mid-point</h4> 
   <p>This formula for calculating the ‘loxodromic midpoint’, the point half-way along a rhumb line between two points, is due to Robert Hill and Clive Tooth<sup><a href="http://mathforum.org/kb/message.jspa?messageID=148837">1</a></sup> (thx Axel!).</p> 
   <table> 
    <tbody>
     <tr> 
      <td class="label">Formula: </td> 
      <td class="formula">?<sub>m</sub> = (?<sub>1</sub>+?<sub>2</sub>) / 2</td> 
     </tr> 
     <tr> 
      <td></td> 
      <td class="formula">f<sub>1</sub> = tan(?/4 + ?<sub>1</sub>/2)</td> 
     </tr> 
     <tr> 
      <td></td> 
      <td class="formula">f<sub>2</sub> = tan(?/4 + ?<sub>2</sub>/2)</td> 
     </tr> 
     <tr> 
      <td></td> 
      <td class="formula">f<sub>m</sub> = tan(?/4+?<sub>m</sub>/2)</td> 
     </tr> 
     <tr> 
      <td></td> 
      <td class="formula">?<sub>m</sub> = [ (?<sub>2</sub>??<sub>1</sub>) ? ln(f<sub>m</sub>) + ?<sub>1</sub> ? ln(f<sub>2</sub>) ? ?<sub>2</sub> ? ln(f<sub>1</sub>) ] / ln(f<sub>2</sub>/f<sub>1</sub>)</td> 
     </tr> 
     <tr> 
      <td class="label align-right">where</td> 
      <td>? <i>is latitude</i>, ? <i>is longitude</i>, ln <i>is natural log</i></td> 
     </tr> 
     <tr> 
      <td class="label">JavaScript:
       <div class="small grey">
        (all angles 
        <br>in radians)
       </div></td> 
      <td> <pre class="code prettyprint>">
if (Math.abs(?2-?1) &gt; Math.PI) ?1 += 2*Math.PI; // crossing anti-meridian

var ?3 = (?1+?2)/2;
var f1 = Math.tan(Math.PI/4 + ?1/2);
var f2 = Math.tan(Math.PI/4 + ?2/2);
var f3 = Math.tan(Math.PI/4 + ?3/2);
var ?3 = ( (?2-?1)*Math.log(f3) + ?1*Math.log(f2) - ?2*Math.log(f1) ) / Math.log(f2/f1);

if (!isFinite(?3)) ?3 = (?1+?2)/2; // parallel of latitude</pre> </td> 
     </tr> 
     <tr> 
      <td></td> 
      <td class="note">The longitude can be normalised to ?180…+180 using <code>(lon+540)%360-180</code></td> 
     </tr> 
    </tbody>
   </table> 
   <hr> 
   <h3 id="using">Using the scripts in web pages</h3> 
   <p>Using these scripts in web pages would be something like the following:</p> 
   <pre class="prettyprint margin-l-1cm">
&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;title&gt;Using the scripts in web pages&lt;/title&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;script defer src="//cdn.rawgit.com/chrisveness/geodesy/v1.1.2/latlon-spherical.js"&gt;&lt;/script&gt;
    &lt;script defer src="//cdn.rawgit.com/chrisveness/geodesy/v1.1.2/dms.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelector('#calc-dist').onclick = function() {
                const lat1 = document.querySelector('#lat1').value;
                const lon1 = document.querySelector('#lon1').value;
                const lat2 = document.querySelector('#lat2').value;
                const lon2 = document.querySelector('#lon2').value;
                const p1 = new LatLon(Dms.parseDMS(lat1), Dms.parseDMS(lon1));
                const p2 = new LatLon(Dms.parseDMS(lat2), Dms.parseDMS(lon2));
                const dist = parseFloat(p1.distanceTo(p2).toPrecision(4));
                document.querySelector('#result-distance').textContent = dist;
            }
        });
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form&gt;
        Lat 1: &lt;input type="text" name="lat1" id="lat1"&gt;
        Lon 1: &lt;input type="text" name="lon1" id="lon1"&gt;
        Lat 2: &lt;input type="text" name="lat2" id="lat2"&gt;
        Lon 2: &lt;input type="text" name="lon2" id="lon2"&gt;
        &lt;button type="button" id="calc-dist"&gt;Calculate distance&lt;/button&gt;
        &lt;output id="result-distance"&gt;&lt;/output&gt; metres
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</pre> 
   <hr> 
   <h3 id="convertDecDMS">Convert between degrees-minutes-seconds &amp; decimal degrees</h3> 
   <form name="convert" id="convert"> 
    <table class="note"> 
     <tbody>
      <tr> 
       <td>Latitude</td> 
       <td>Longitude</td> 
       <td></td> 
       <td></td> 
      </tr> 
      <tr> 
       <td><input type="text" name="latD" id="latD" value="52.20472°N" class="note w8"></td> 
       <td><input type="text" name="lonD" id="lonD" value="000.14056°E" class="note w8"></td> 
       <td colspan="2">1° ? 111 km <span class="grey">(110.57 eq’l — 111.70 polar)</span></td> 
      </tr> 
      <tr> 
       <td><input type="text" name="latDM" id="latDM" value="52°12.283?N" class="note w8"></td> 
       <td><input type="text" name="lonDM" id="lonDM" value="000°08.433?E" class="note w8"></td> 
       <td>1? ? 1.85 km <span class="grey">(= 1 nm)</span></td> 
       <td>0.01° ? 1.11 km</td> 
      </tr> 
      <tr> 
       <td><input type="text" name="latDMS" id="latDMS" value="52°12?17.0?N" class="note w8"></td> 
       <td><input type="text" name="lonDMS" id="lonDMS" value="000°08?26.0?E" class="note w8"></td> 
       <td>1? ? 30.9 m</td> 
       <td>0.0001° ? 11.1 m</td> 
      </tr> 
     </tbody>
    </table> 
   </form> 
   <form>
    Display calculation results as: 
    <input type="radio" name="deg-format" id="deg-format-d" value="d"> 
    <span title="decimal">degrees</span> 
    <input type="radio" name="deg-format" id="deg-format-dm" value="dm"> 
    <span title="sow’s ear">deg/min</span> 
    <input type="radio" name="deg-format" id="deg-format-dms" value="dms"> 
    <span title="sexagesimal">deg/min/sec</span> 
   </form> 
   <hr> 
   <p id="notes"><i>Notes:</i></p> 
   <ul class="note"> 
    <li id="ellipsoid">Accuracy: since the earth is not quite a sphere, there are small errors in using spherical geometry; the earth is actually roughly <b>ellipsoidal</b> (or more precisely, oblate spheroidal) with a radius varying between about 6,378km (equatorial) and 6,357km (polar), and local radius of curvature varying from 6,336km (equatorial meridian) to 6,399km (polar). 6,371 km is the generally accepted value for the earth’s <a href="//en.wikipedia.org/wiki/Earth_radius#Mean_radius">mean radius</a>. This means that errors from assuming spherical geometry might be up to 0.55% crossing the equator, though generally below 0.3%, depending on latitude and direction of travel (<i>whuber</i> explores this in excellent detail on <a href="http://gis.stackexchange.com/questions/25494#25580">stackexchange</a>). An accuracy of better than 3m in 1km is mostly good enough for me, but if you want greater accuracy, you could use the <a href="latlong-vincenty.html">Vincenty</a> formula for calculating geodesic distances on ellipsoids, which gives results accurate to within 1mm. (Out of sheer perversity – I’ve never needed such accuracy – I looked up this formula and discovered the JavaScript implementation was simpler than I expected).</li> 
    <li>Trig functions take arguments in <b>radians</b>, so latitude, longitude, and bearings in <b>degrees</b> (either decimal or degrees/minutes/seconds) need to be converted to radians, rad = ?.deg/180. When converting radians back to degrees (deg = 180.rad/?), West is negative if using signed decimal degrees. For bearings, values in the range -? to +? [-180° to +180°] need to be converted to 0 to +2? [0°–360°]; this can be done by (brng+2.?)%2.? [or brng+360)%360] where % is the (floating point) modulo operator (note that different languages implement the <a href="https://en.wikipedia.org/wiki/Modulo_operation">modulo operation</a> in different ways).</li> 
    <li>All bearings are with respect to <b>true north</b>, 0°=N, 90°=E, etc; if you are working from a compass, magnetic north varies from true north in a complex way around the earth, and the difference has to be compensated for by variances indicated on local maps.</li> 
    <li>The <b>atan2</b>() function widely used here takes two arguments, atan2(y, x), and computes the arc tangent of the ratio y/x. It is more flexible than atan(y/x), since it handles x=0, and it also returns values in all 4 quadrants -? to +? (the atan function returns values in the range -?/2 to +?/2).</li> 
    <li>If you implement any formula involving atan2 in a spreadsheet (Microsoft <b>Excel</b>, LibreOffice Calc, Google Sheets, Apple Numbers), you will need to reverse the arguments, as <a href="http://office.microsoft.com/en-gb/excel/HP052089911033.aspx">Excel</a> etc have them the opposite way around from <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Math/atan2">JavaScript</a> – conventional order is atan2(y, x), but Excel uses atan2(x, y). To use atan2 in a (VBA) macro, you can use WorksheetFunction.Atan2(). </li> 
    <li>If you are using <b>Google Maps</b>, several of these functions are now provided in the Google Maps API V3 ‘spherical’ library (computeDistanceBetween(), computeHeading(), computeOffset(), interpolate(), etc; note they use a default Earth radius of 6,378,137 meters).</li> 
    <li>If you use UK Ordnance Survey Grid References, I have implemented a script for <a href="latlong-os-gridref.html">converting between Lat/Long &amp; OS Grid References</a>.</li> 
    <li>If you use UTM coordinates or MGRS grid references, I have implemented scripts for <a href="latlong-utm-mgrs.html">converting between Lat/Long, UTM, &amp; MGRS</a>.</li> 
    <li>I learned a lot from the US Census Bureau <a href="gis-faq-5.1.html">GIS FAQ</a> which is no longer available, so I’ve made a copy.</li> 
    <li>Thanks to Ed Williams’ <a href="http://www.edwilliams.org/avform.htm">Aviation Formulary</a> for many of the formulæ.</li> 
    <li>For <b>miles</b>, divide km by 1.609344</li> 
    <li>For <b>nautical miles</b>, divide km by 1.852</li> 
   </ul> 
   <hr class="fullwidth"> 
   <p id="postscript">See below for the JavaScript source code, also available on <a href="https://github.com/chrisveness/geodesy/blob/master/latlon-spherical.js">GitHub</a>. Note I use Greek letters in variables representing maths symbols conventionally presented as Greek letters: I value the great benefit in legibility over the minor inconvenience in typing (if you encounter any problems, ensure your <code>&lt;head&gt;</code> includes <code>&lt;meta charset="utf-8"&gt;</code>).</p> 
   <p>With its untyped C-style syntax, JavaScript reads remarkably close to pseudo-code: exposing the algorithms with a minimum of syntactic distractions. These functions should be simple to translate into other languages if required, though can also be used as-is in browsers and Node.js.</p> 
   <p>I have extended the base JavaScript Number object with toRadians() and toDegrees() methods: I don’t see great likelihood of conflicts, as these are ubiquitous operations.</p> 
   <p>I also have a page illustrating the use of the spherical law of cosines for <a href="latlong-db.html">selecting points from a database</a> within a specified bounding circle – the example is based on MySQL+PDO, but should be extensible to other DBMS platforms.</p> 
   <p id="spreadsheets">Several people have asked about example <b>Excel</b> spreadsheets, so I have implemented the <a href="latlong-distance+bearing.xls">distance &amp; bearing</a> and the <a href="latlong-dest-point.xls">destination point</a> formulæ as spreadsheets, in a form which breaks down the all stages involved to illustrate the operation.</p> 
   <p><i>January 2010</i>: I have revised the scripts to be structured as methods of a LatLon object. Of course, while JavaScript is <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript">object-oriented</a>, it is a <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Details_of_the_Object_Model">prototype-based rather than class-based</a> language, so this is not actually a class, but isolating code into a separate namespace is good JavaScript practice. If you’re not familiar with JavaScript syntax, <code>LatLon.prototype.distanceTo = function(point) { ... }</code>, for instance, defines a ‘<code>distanceTo</code>’ method of the <code>LatLon</code> object (/class) which takes a <code>LatLon</code> object as a parameter (and returns a number). The <i>Dms</i> namespace acts as a static class for geodesy formatting / parsing / conversion functions.</p> 
   <p><i>January 2015</i>: I have refactored the scripts to inter-operate better, and rationalised certain aspects: the JavaScript file is now latlon-spherical.js instead of simply latlon.js; distances are now always in metres; the earth’s radius is now a parameter to distance calculation methods rather than to the constructor; the previous <code>Geo</code> object is now <code>Dms</code>, to better indicate its purpose; the <code>destinationPoint</code> function has the distance parameter before the bearing.</p> 
   <p>Performance: as noted above, the haversine distance calculation takes around <a href="performance/latlong-spherical.html">2 – 5 micro­seconds</a> (hence around 200,000 – 500,000 per second). I have yet to complete timing tests on other calculations.</p> 
   <p id="other-languages"><b>Other languages</b>: I cannot support translations into other languages, but if you have ported the code to another language, I am happy to provide links here.</p> 
   <ul> 
    <li>Brian Lambert has made an <a href="https://github.com/softwarenerd/GreatCircle">Objective-C</a> version.</li> 
    <li>Jean Brouwers has made a <a href="https://github.com/mrJean1/PyGeodesy">Python</a> version.</li> 
   </ul> 
   <p id="licence"><a href="http://opensource.org/licenses/MIT" class="float-right"><img src="license-osi-mit.png" alt="OSI MIT License"></a> I offer these scripts for free use and adaptation to balance my debt to the open-source info-verse. You are welcome to re-use these scripts [under an <a href="http://opensource.org/licenses/MIT">MIT</a> licence, without any warranty express or implied] provided solely that you retain my copyright notice and a link to this page.</p> 
   <p id="donate"><a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&amp;hosted_button_id=3737803" class="float-right"> <img alt="Paypal donation" style="margin:4px" src="https://www.paypal.com/en_GB/i/btn/btn_donate_SM.gif"></a> If you would like to show your appreciation and support continued development of these scripts, I would most gratefully accept <a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&amp;hosted_button_id=3737803" title="Thank you!">donations</a>.</p> 
   <p>If you need any advice or development work done, I am available for consultancy.</p> 
   <p>If you have any queries or find any problems, contact me at <span class="rtl">ku.oc.epyt-elbavom@oeg-stpircs</span>.</p> 
   <p class="note"><i>© 2002-2017 Chris Veness</i></p> 
  </main> 
  <hr class="fullwidth"> 
  <pre class="fullwidth code prettyprint" id="latlon-src"></pre> 
  <hr class="fullwidth"> 
  <pre class="fullwidth code prettyprint" id="dms-src"></pre> 
  <!--[if lte IE 8]> <p>If IE8-, gets confused about line endings, you can view source at
    <a href="https://github.com/chrisveness/geodesy/blob/master/latlon.js">GitHub</a></p> <![endif]--> 
  <!-- 2012-10-07: phi, lambda for lat, lon --> 
  <!-- 2014-04-27: greek letters throughout, Gudermannian --> 
  <!-- 2014-06-27: rationalised script (all within listeners) -->   
 </body>
</html>