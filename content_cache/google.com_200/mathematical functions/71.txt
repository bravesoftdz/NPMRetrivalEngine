<!doctype html>
<html>
 <head> 
  <meta charset="utf-8"> 
  <meta name="viewport" content="width=device-width, initial-scale=1"> 
  <title>
    New number and Math features in ES6
  </title> 
  <link rel="icon" type="image/png" href="../../img/2ality_logo_32.png" sizes="32x32"> 
  <link rel="stylesheet" href="../../site.css"> 
  <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css"> 
  <link href="https://fonts.googleapis.com/css?family=Lato:700|Open+Sans|Source+Code+Pro|Libre+Baskerville:700" rel="stylesheet"> 
  <link rel="alternate" type="application/atom+xml" href="http://feeds.feedburner.com/2ality" title="2ality feed"> 
  <!--  Metadata for Google, Facebook, Twitter --> 
  <meta name="description" content="This blog post describes the new number and `Math` features of ECMAScript 6."> 
  <meta property="og:site_name" content="2ality"> 
  <meta name="twitter:site" content="@2ality"> 
 </head> 
 <body> 
  <div id="reactHtml">
   <div data-reactroot="" data-reactid="1" data-react-checksum="-2075702353">
    <div id="top_row" class="no-link" data-reactid="2">
     <div class="no-link" style="color:white;background:darkblue;width:100%;text-align:center;padding-top:0.4em;padding-bottom:0.4em;margin-bottom:0.6em;" data-reactid="3">
      <a href="http://exploringjs.com/" data-reactid="4">JS&nbsp;books (free&nbsp;online)</a>
      <span class="separator" data-reactid="5"> | </span>
      <a href="http://esnextnews.com/" data-reactid="6">Newsletter</a>
      <span class="separator" data-reactid="7"> | </span>
      <a href="http://dr-axel.de/contact.html" data-reactid="8">Training</a>
     </div>
     <div id="blog_name" data-reactid="9">
      <a href="../../index.html" data-reactid="10">2ality – JavaScript and more</a>
     </div>
     <div id="lower-link-bar" class="no-link" data-reactid="11">
      <a href="../../p/about.html" data-reactid="12">About</a>
      <span class="separator" data-reactid="13"> | </span>
      <a href="../../p/donate.html" data-reactid="14">Donate</a>
      <span class="separator" data-reactid="15"> | </span>
      <a href="../../p/subscribe.html" data-reactid="16">Subscribe</a>
      <span class="separator" data-reactid="17"> | </span>
      <a href="../../archive.html" data-reactid="18">Archive</a>
      <span class="separator" data-reactid="19"> | </span>
      <a href="https://cse.google.com/cse/publicurl?cx=005653361008053745020:pdru5pmwmgi" data-reactid="20">Search</a>
      <span class="separator" data-reactid="21"> | </span>
      <a href="http://exploringjs.com/es2016-es2017/" data-reactid="22">ES2016+ES2017</a>
      <span class="separator" data-reactid="23"> | </span>
      <a href="../../2017/02/ecmascript-2018.html" data-reactid="24">ES2018</a>
     </div>
    </div>
    <div id="bottom_row" data-reactid="25">
     <div class="number-headings" id="page-core" data-reactid="26">
      <h1 data-reactid="27">New number and Math features in ES6</h1>
      <div class="date-and-tags" data-reactid="28">
       <!-- react-text: 29 -->[
       <!-- /react-text -->
       <!-- react-text: 30 -->2015-04-13
       <!-- /react-text -->
       <!-- react-text: 31 -->] 
       <!-- /react-text -->
       <a href="" data-reactid="32">esnext</a>
       <!-- react-text: 33 -->, 
       <!-- /react-text -->
       <a href="" data-reactid="34">dev</a>
       <!-- react-text: 35 -->, 
       <!-- /react-text -->
       <a href="" data-reactid="36">javascript</a>
      </div>
      <div id="adbox" data-reactid="37">
       <div id="adbox-explain" data-reactid="38">
        (Ad, please don’t block)
       </div>
       <script async type="text/javascript" src="https://cdn.carbonads.com/carbon.js?zoneid=1673&amp;serve=C6AILKT&amp;placement=2alitycom" id="_carbonads_js" data-reactid="39"></script>
      </div>
      <div data-reactid="40">
       <p>This blog post describes the new number and <code>Math</code> features of <a href="http://exploringjs.com/">ECMAScript 6</a>.</p> 
       <!--more--> 
       <h2 id="overview">Overview&nbsp;&nbsp;<a class="header-anchor" href="#overview" aria-hidden="true">#</a></h2> 
       <p>You can now specify integers in binary and octal notation:</p> 
       <pre><code class="language-repl">&gt; 0xFF // ES5: hexadecimal
255
&gt; 0b11 // ES6: binary
3
&gt; 0o10 // ES6: octal
8
</code></pre> 
       <p>The global object <code>Number</code> gained a few new properties. Among others:</p> 
       <ul> 
        <li><code>Number.EPSILON</code> for comparing floating point numbers with a tolerance for rounding errors.</li> 
        <li>A method and constants for determining whether a JavaScript integer is <em>safe</em> (within the signed 53 bit range in which there is no loss of precision).</li> 
       </ul> 
       <h2 id="new-integer-literals">New integer literals&nbsp;&nbsp;<a class="header-anchor" href="#new-integer-literals" aria-hidden="true">#</a></h2> 
       <p>ECMAScript 5 already has literals for hexadecimal integers:</p> 
       <pre><code class="language-repl">&gt; 0x9
9
&gt; 0xA
10
&gt; 0x10
16
&gt; 0xFF
255
</code></pre> 
       <p>ECMAScript 6 brings two new kinds of integer literals:</p> 
       <ul> 
        <li> <p>Binary literals have the prefix <code>0b</code> or <code>0B</code>:</p> <pre><code class="language-repl">&gt; 0b11
3
&gt; 0b100
4
</code></pre> </li> 
        <li> <p>Octal literals have the prefix <code>0o</code> or <code>0O</code> (yes, that’s a zero followed by the capital letter O; you’ll be fine if you use the first variant):</p> <pre><code class="language-repl">&gt; 0o7
7
&gt; 0o10
8
</code></pre> </li> 
       </ul> 
       <p>Remember that the method <code>Number.prototype.toString(radix)</code> can be used to convert numbers back:</p> 
       <pre><code class="language-repl">&gt; (255).toString(16)
'ff'
&gt; (4).toString(2)
'100'
&gt; (8).toString(8)
'10'
</code></pre> 
       <h3 id="use-case-for-octal-literals-unix-style-file-permissions">Use case for octal literals: Unix-style file permissions&nbsp;&nbsp;<a class="header-anchor" href="#use-case-for-octal-literals-unix-style-file-permissions" aria-hidden="true">#</a></h3> 
       <p>In the Node.js <a href="https://nodejs.org/api/fs.html">file system module</a>, several functions have the parameter <code>mode</code>. Its value is used to specify file permissions, via an encoding that is a holdover from Unix:</p> 
       <ul> 
        <li>Permissions are specified for three categories of users: 
         <ul> 
          <li>User: the owner of the file</li> 
          <li>Group: the members of the group associated with the file</li> 
          <li>All: everyone</li> 
         </ul> </li> 
        <li>Per category, the following permissions can be granted: 
         <ul> 
          <li>r (read): the users in the category are allowed to read the file</li> 
          <li>w (write): the users in the category are allowed to change the file</li> 
          <li>x (execute): the users in the category are allowed to run the file</li> 
         </ul> </li> 
       </ul> 
       <p>That means that permissions can be represented by 9 bits (3 categories with 3 permissions each):</p> 
       <table class="framed"> 
        <thead> 
         <tr> 
          <th></th> 
          <th>User</th> 
          <th>Group</th> 
          <th>All</th> 
         </tr> 
        </thead> 
        <tbody> 
         <tr> 
          <td>Permissions</td> 
          <td>r, w, x</td> 
          <td>r, w, x</td> 
          <td>r, w, x</td> 
         </tr> 
         <tr> 
          <td>Bit</td> 
          <td>8, 7, 6</td> 
          <td>5, 4, 3</td> 
          <td>2, 1, 0</td> 
         </tr> 
        </tbody> 
       </table> 
       <p>The permissions of a single category of users are stored in 3 bits:</p> 
       <table class="framed"> 
        <thead> 
         <tr> 
          <th>Bits</th> 
          <th>Permissions</th> 
          <th>Octal digit</th> 
         </tr> 
        </thead> 
        <tbody> 
         <tr> 
          <td>000</td> 
          <td>–––</td> 
          <td>0</td> 
         </tr> 
         <tr> 
          <td>001</td> 
          <td>––x</td> 
          <td>1</td> 
         </tr> 
         <tr> 
          <td>010</td> 
          <td>–w–</td> 
          <td>2</td> 
         </tr> 
         <tr> 
          <td>011</td> 
          <td>–wx</td> 
          <td>3</td> 
         </tr> 
         <tr> 
          <td>100</td> 
          <td>r––</td> 
          <td>4</td> 
         </tr> 
         <tr> 
          <td>101</td> 
          <td>r–x</td> 
          <td>5</td> 
         </tr> 
         <tr> 
          <td>110</td> 
          <td>rw–</td> 
          <td>6</td> 
         </tr> 
         <tr> 
          <td>111</td> 
          <td>rwx</td> 
          <td>7</td> 
         </tr> 
        </tbody> 
       </table> 
       <p>That means that octal numbers are a compact representation of all permissions, you only need 3 digits, one digit per category of users. Two examples:</p> 
       <ul> 
        <li>755 = 111,101,101: I can change, read and execute; everyone else can only read and execute.</li> 
        <li>640 = 110,100,000: I can read and write; group members can read; everyone can’t access at all.</li> 
       </ul> 
       <h3 id="parseint-and-the-new-integer-literals"><code>parseInt()</code> and the new integer literals&nbsp;&nbsp;<a class="header-anchor" href="#parseint-and-the-new-integer-literals" aria-hidden="true">#</a></h3> 
       <p><code>parseInt()</code> has the following signature:</p> 
       <pre><code class="language-js"><span class="hljs-built_in">parseInt</span>(string, radix?)
</code></pre> 
       <p>It provides special support for the hexadecimal literal notation – the prefix <code>0x</code> (or <code>0X</code>) of <code>string</code> is removed if:</p> 
       <ul> 
        <li><code>radix</code> is missing or 0. Then <code>radix</code> is set to 16.</li> 
        <li><code>radix</code> is already 16.</li> 
       </ul> 
       <p>For example:</p> 
       <pre><code class="language-repl">&gt; parseInt('0xFF')
255
&gt; parseInt('0xFF', 0)
255
&gt; parseInt('0xFF', 16)
255
</code></pre> 
       <p>In all other cases, digits are only parsed until the first non-digit:</p> 
       <pre><code class="language-repl">&gt; parseInt('0xFF', 10)
0
&gt; parseInt('0xFF', 17)
0
</code></pre> 
       <p><code>parseInt()</code> does not have special support for binary or octal literals!</p> 
       <pre><code class="language-repl">&gt; parseInt('0b111')
0
&gt; parseInt('0b111', 2)
0
&gt; parseInt('111', 2)
7

&gt; parseInt('0o10')
0
&gt; parseInt('0o10', 8)
0
&gt; parseInt('10', 8)
8
</code></pre> 
       <p>If you want to parse these kinds of literals, you need to use <code>Number()</code>:</p> 
       <pre><code class="language-repl">&gt; Number('0b111')
7
&gt; Number('0o10')
8
</code></pre> 
       <p>Alternatively, you can also remove the prefix and use <code>parseInt()</code> with the appropriate radix:</p> 
       <pre><code class="language-repl">&gt; parseInt('111', 2)
7
&gt; parseInt('10', 8)
8
</code></pre> 
       <h2 id="new-number-constructor-properties">New <code>Number</code> constructor properties&nbsp;&nbsp;<a class="header-anchor" href="#new-number-constructor-properties" aria-hidden="true">#</a></h2> 
       <p>This section describes new properties that the constructor <code>Number</code> has picked up in ECMAScript 6.</p> 
       <h3 id="previously-global-functions">Previously global functions&nbsp;&nbsp;<a class="header-anchor" href="#previously-global-functions" aria-hidden="true">#</a></h3> 
       <p>Four number-related functions are already available as global functions and have been added (with no or little modifications) to <code>Number</code>, as methods: <code>isFinite</code>, <code>isNaN</code>, <code>parseFloat</code> and <code>parseInt</code>.</p> 
       <h4 id="numberisfinitenumber"><code>Number.isFinite(number)</code>&nbsp;&nbsp;<a class="header-anchor" href="#numberisfinitenumber" aria-hidden="true">#</a></h4> 
       <p>Is <code>number</code> an actual number (neither <code>Infinity</code> nor <code>-Infinity</code> nor <code>NaN</code>)?</p> 
       <pre><code class="language-repl">&gt; Number.isFinite(Infinity)
false
&gt; Number.isFinite(-Infinity)
false
&gt; Number.isFinite(NaN)
false
&gt; Number.isFinite(123)
true
</code></pre> 
       <p>The advantage of this method is that it does not coerce its parameter to number (whereas the global function does):</p> 
       <pre><code class="language-repl">&gt; Number.isFinite('123')
false
&gt; isFinite('123')
true
</code></pre> 
       <h4 id="numberisnannumber"><code>Number.isNaN(number)</code>&nbsp;&nbsp;<a class="header-anchor" href="#numberisnannumber" aria-hidden="true">#</a></h4> 
       <p>Is <code>number</code> the value <code>NaN</code>? Making this check via <code>===</code> is hacky. <code>NaN</code> is the only value that is not equal to itself:</p> 
       <pre><code class="language-repl">&gt; let x = NaN;
&gt; x === NaN
false
</code></pre> 
       <p>Therefore, this expression is used to check for it</p> 
       <pre><code class="language-repl">&gt; x !== x
true
</code></pre> 
       <p>Using <code>Number.isNaN()</code> is more self-descriptive:</p> 
       <pre><code class="language-repl">&gt; Number.isNaN(x)
true
</code></pre> 
       <p><code>Number.isNan()</code> also has the advantage of not coercing its parameter to number (whereas the global function does):</p> 
       <pre><code class="language-repl">&gt; Number.isNaN('???')
false
&gt; isNaN('???')
true
</code></pre> 
       <h4 id="numberparsefloat-and-numberparseint"><code>Number.parseFloat</code> and <code>Number.parseInt</code>&nbsp;&nbsp;<a class="header-anchor" href="#numberparsefloat-and-numberparseint" aria-hidden="true">#</a></h4> 
       <p>The following two methods work exactly like the global functions with the same names. They were added to <code>Number</code> for completeness sake; now all number-related functions are available there.</p> 
       <ul> 
        <li><code>Number.parseFloat(string)</code></li> 
        <li><code>Number.parseInt(string, radix)</code></li> 
       </ul> 
       <h3 id="numberepsilon">Number.EPSILON&nbsp;&nbsp;<a class="header-anchor" href="#numberepsilon" aria-hidden="true">#</a></h3> 
       <p>Especially with decimal fractions, rounding errors can become a problem in JavaScript. For example, 0.1 and 0.2 can’t be represented precisely, which you notice if you add them and compare them to 0.3 (which can’t be represented precisely, either).</p> 
       <pre><code class="language-repl">&gt; 0.1 + 0.2 === 0.3
false
</code></pre> 
       <p><code>Number.EPSILON</code> specifies a reasonable margin of error when comparing floating point numbers. It provides a better way to compare floating point values, as demonstrated by the following function.</p> 
       <pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">epsEqu</span>(<span class="hljs-params">x, y</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.abs(x - y) &lt; <span class="hljs-built_in">Number</span>.EPSILON;
}
<span class="hljs-built_in">console</span>.log(epsEqu(<span class="hljs-number">0.1</span>+<span class="hljs-number">0.2</span>, <span class="hljs-number">0.3</span>)); <span class="hljs-comment">// true</span>
</code></pre> 
       <h3 id="numberisintegernumber"><code>Number.isInteger(number)</code>&nbsp;&nbsp;<a class="header-anchor" href="#numberisintegernumber" aria-hidden="true">#</a></h3> 
       <p>JavaScript has only floating point numbers (doubles). Accordingly, integers are simply floating point numbers without a decimal fraction.</p> 
       <p><code>Number.isInteger(number)</code> returns <code>true</code> if <code>number</code> is a number and does not have a decimal fraction.</p> 
       <pre><code class="language-repl">&gt; Number.isInteger(-17)
true
&gt; Number.isInteger(33)
true
&gt; Number.isInteger(33.1)
false
&gt; Number.isInteger('33')
false
&gt; Number.isInteger(NaN)
false
&gt; Number.isInteger(Infinity)
false
</code></pre> 
       <h3 id="safe-integers">Safe Integers&nbsp;&nbsp;<a class="header-anchor" href="#safe-integers" aria-hidden="true">#</a></h3> 
       <p>JavaScript numbers have only enough storage space to represent 53 bit signed integers. That is, integers <em>i</em> in the range ?2^53^ &lt; <em>i</em> &lt; 2^53^ are <em>safe</em>. What exactly that means is explained momentarily. The following properties help determine whether a JavaScript integer is safe:</p> 
       <ul> 
        <li><code>Number.isSafeInteger(number)</code></li> 
        <li><code>Number.MIN_SAFE_INTEGER</code></li> 
        <li><code>Number.MAX_SAFE_INTEGER</code></li> 
       </ul> 
       <p>The notion of <em>safe integers</em> centers on how mathematical integers are represented in JavaScript. In the range (?2^53^, 2^53^) (excluding the lower and upper bounds), JavaScript integers are <em>safe</em>: there is a one-to-one mapping between them and the mathematical integers they represent.</p> 
       <p>Beyond this range, JavaScript integers are <em>unsafe</em>: two or more mathematical integers are represented as the same JavaScript integer. For example, starting at 2^53^, JavaScript can represent only every second mathematical integer:</p> 
       <pre><code class="language-repl">&gt; Math.pow(2, 53)
9007199254740992

&gt; 9007199254740992
9007199254740992
&gt; 9007199254740993
9007199254740992
&gt; 9007199254740994
9007199254740994
&gt; 9007199254740995
9007199254740996
&gt; 9007199254740996
9007199254740996
&gt; 9007199254740997
9007199254740996
</code></pre> 
       <p>Therefore, a safe JavaScript integer is one that unambiguously represents a single mathematical integer.</p> 
       <h4 id="the-properties-of-number">The properties of <code>Number</code>&nbsp;&nbsp;<a class="header-anchor" href="#the-properties-of-number" aria-hidden="true">#</a></h4> 
       <p>The two <code>Number</code> properties specifying the lower and upper bound of safe integers could be defined as follows:</p> 
       <pre><code class="language-js"><span class="hljs-built_in">Number</span>.MAX_SAFE_INTEGER = <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">53</span>)<span class="hljs-number">-1</span>;
<span class="hljs-built_in">Number</span>.MIN_SAFE_INTEGER = -<span class="hljs-built_in">Number</span>.MAX_SAFE_INTEGER;
</code></pre> 
       <p><code>Number.isSafeInteger()</code> determines whether a JavaScript number is a safe integer and could be defined as follows:</p> 
       <pre><code class="language-js"><span class="hljs-built_in">Number</span>.isSafeInteger = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>{
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">typeof</span> n === <span class="hljs-string">'number'</span> &amp;&amp;
        <span class="hljs-built_in">Math</span>.round(n) === n &amp;&amp;
        <span class="hljs-built_in">Number</span>.MIN_SAFE_INTEGER &lt;= n &amp;&amp;
        n &lt;= <span class="hljs-built_in">Number</span>.MAX_SAFE_INTEGER);
}
</code></pre> 
       <p>For a given value <code>n</code>, this function first checks whether <code>n</code> is a number and an integer. If both checks succeed, <code>n</code> is safe if it is greater than or equal to <code>MIN_SAFE_INTEGER</code> and less than or equal to <code>MAX_SAFE_INTEGER</code>.</p> 
       <h4 id="safe-results-of-arithmetic-computations">Safe results of arithmetic computations&nbsp;&nbsp;<a class="header-anchor" href="#safe-results-of-arithmetic-computations" aria-hidden="true">#</a></h4> 
       <p>How can we make sure that results of arithmetic computations are correct? For example, the following result is clearly not correct:</p> 
       <pre><code class="language-repl">&gt; 9007199254740990 + 3
9007199254740992
</code></pre> 
       <p>We have two safe operands, but an unsafe result:</p> 
       <pre><code class="language-repl">&gt; Number.isSafeInteger(9007199254740990)
true
&gt; Number.isSafeInteger(3)
true
&gt; Number.isSafeInteger(9007199254740992)
false
</code></pre> 
       <p>The following result is also incorrect:</p> 
       <pre><code class="language-repl">&gt; 9007199254740995 - 10
9007199254740986
</code></pre> 
       <p>This time, the result is safe, but one of the operands isn’t:</p> 
       <pre><code class="language-repl">&gt; Number.isSafeInteger(9007199254740995)
false
&gt; Number.isSafeInteger(10)
true
&gt; Number.isSafeInteger(9007199254740986)
true
</code></pre> 
       <p>Therefore, the result of applying an integer operator <code>op</code> is guaranteed to be correct only if all operands and the result are safe. More formally:</p> 
       <pre><code class="language-js">isSafeInteger(a) &amp;&amp; isSafeInteger(b) &amp;&amp; isSafeInteger(a op b)
</code></pre> 
       <p>implies that <code>a op b</code> is a correct result.</p> 
       <h4 id="source-of-this-section">Source of this section&nbsp;&nbsp;<a class="header-anchor" href="#source-of-this-section" aria-hidden="true">#</a></h4> 
       <ul> 
        <li>“<a href="https://mail.mozilla.org/pipermail/es-discuss/2013-August/032991.html">Clarify integer and safe integer resolution</a>”, email by Mark S. Miller to the es-discuss mailing list.</li> 
       </ul> 
       <h2 id="math">Math&nbsp;&nbsp;<a class="header-anchor" href="#math" aria-hidden="true">#</a></h2> 
       <p>The global object <code>Math</code> has several new methods in ECMAScript 6.</p> 
       <h3 id="various-numerical-functionality">Various numerical functionality&nbsp;&nbsp;<a class="header-anchor" href="#various-numerical-functionality" aria-hidden="true">#</a></h3> 
       <h4 id="mathsignx"><code>Math.sign(x)</code>&nbsp;&nbsp;<a class="header-anchor" href="#mathsignx" aria-hidden="true">#</a></h4> 
       <p>Returns the sign of <code>x</code> as <code>-1</code> or <code>+1</code>. Unless <code>x</code> is either <code>NaN</code> or zero; then <code>x</code> is returned<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>.</p> 
       <pre><code class="language-repl">&gt; Math.sign(-8)
-1
&gt; Math.sign(3)
1

&gt; Math.sign(0)
0
&gt; Math.sign(NaN)
NaN

&gt; Math.sign(-Infinity)
-1
&gt; Math.sign(Infinity)
1
</code></pre> 
       <h4 id="mathtruncx"><code>Math.trunc(x)</code>&nbsp;&nbsp;<a class="header-anchor" href="#mathtruncx" aria-hidden="true">#</a></h4> 
       <p>Removes the decimal fraction of <code>x</code>.</p> 
       <pre><code class="language-repl">&gt; Math.trunc(3.1)
3
&gt; Math.trunc(3.9)
3
&gt; Math.trunc(-3.1)
-3
&gt; Math.trunc(-3.9)
-3
</code></pre> 
       <h4 id="mathcbrtx"><code>Math.cbrt(x)</code>&nbsp;&nbsp;<a class="header-anchor" href="#mathcbrtx" aria-hidden="true">#</a></h4> 
       <p>Returns the cube root of <code>x</code> (?x).</p> 
       <pre><code class="language-repl">&gt; Math.cbrt(8)
2
</code></pre> 
       <h3 id="using-0-instead-of-1-with-exponentiation-and-logarithm">Using 0 instead of 1 with exponentiation and logarithm&nbsp;&nbsp;<a class="header-anchor" href="#using-0-instead-of-1-with-exponentiation-and-logarithm" aria-hidden="true">#</a></h3> 
       <p>A small fraction can be represented more precisely if it comes after zero. I’ll demonstrate this with decimal fractions. (Internally, JavaScript’s floating point numbers are base 2, but externally you see them as base 10. The same basic principles w.r.t. precision apply in either case.) Floating point numbers with base 10 are represented as <em>mantissa</em> × 10^<em>exponent</em>^. If a zero comes before the dot then small fractions have less significant digits. For example:</p> 
       <ul> 
        <li>(A) 0.000000234 = 2.34 × 10^?7^. Significant digits: 234</li> 
        <li>(B) 1.000000234 = 1.000000234 × 10^0^. Significant digits: 1000000234</li> 
       </ul> 
       <p>Precision-wise, the exponent is not an issue here, the significant digits and the capacity of the mantissa are. That’s why (A) gives you higher precision than (B).</p> 
       <p>You can see this in the following interaction: The first number (1 × 10^?16^) registers as different from zero, while the same number added to 1 registers as 1.</p> 
       <pre><code class="language-repl">&gt; 1e-16 === 0
false
&gt; 1 + 1e-16 === 1
true
</code></pre> 
       <h4 id="mathexpm1x"><code>Math.expm1(x)</code>&nbsp;&nbsp;<a class="header-anchor" href="#mathexpm1x" aria-hidden="true">#</a></h4> 
       <p>Returns <code>Math.exp(x)-1</code>. The inverse of <code>Math.log1p()</code>.</p> 
       <p>Therefore, this method provides higher precision whenever <code>Math.exp()</code> has results close to 1. You can see the difference between the two in the following interaction:</p> 
       <pre><code class="language-repl">&gt; Math.expm1(1e-10)
1.00000000005e-10
&gt; Math.exp(1e-10)-1
1.000000082740371e-10
</code></pre> 
       <p>The former is the better result, which you can verify by using a library (such as <a href="https://github.com/MikeMcl/decimal.js/">decimal.js</a>) for floating point numbers with arbitrary precision (“bigfloats”):</p> 
       <pre><code class="language-repl">&gt; var Decimal = require('decimal.js').config({precision:50});
&gt; new Decimal(1e-10).exp().minus(1).toString()
'1.000000000050000000001666666666708333333e-10'
</code></pre> 
       <h4 id="mathlog1px"><code>Math.log1p(x)</code>&nbsp;&nbsp;<a class="header-anchor" href="#mathlog1px" aria-hidden="true">#</a></h4> 
       <p>Returns <code>Math.log(1 + x)</code>. The inverse of <code>Math.expm1()</code>.</p> 
       <p>Therefore, this method lets you specify parameters that are close to 1 with a higher precision.</p> 
       <p>We have already established that <code>1 + 1e-16 === 1</code>. Therefore, it is no surprise that the following two calls of <code>log()</code> produce the same result:</p> 
       <pre><code class="language-repl">&gt; Math.log(1 + 1e-16)
0
&gt; Math.log(1 + 0)
0
</code></pre> 
       <p>In contrast, <code>log1p()</code> produces different results:</p> 
       <pre><code class="language-repl">&gt; Math.log1p(1e-16)
1e-16
&gt; Math.log1p(0)
0
</code></pre> 
       <h3 id="logarithms-to-base-2-and-10">Logarithms to base 2 and 10&nbsp;&nbsp;<a class="header-anchor" href="#logarithms-to-base-2-and-10" aria-hidden="true">#</a></h3> 
       <h4 id="mathlog2x"><code>Math.log2(x)</code>&nbsp;&nbsp;<a class="header-anchor" href="#mathlog2x" aria-hidden="true">#</a></h4> 
       <p>Computes the logarithm to base 2.</p> 
       <pre><code class="language-repl">&gt; Math.log2(8)
3
</code></pre> 
       <h4 id="mathlog10x"><code>Math.log10(x)</code>&nbsp;&nbsp;<a class="header-anchor" href="#mathlog10x" aria-hidden="true">#</a></h4> 
       <p>Computes the logarithm to base 10.</p> 
       <pre><code class="language-repl">&gt; Math.log10(100)
2
</code></pre> 
       <h3 id="support-for-compiling-to-javascript">Support for compiling to JavaScript&nbsp;&nbsp;<a class="header-anchor" href="#support-for-compiling-to-javascript" aria-hidden="true">#</a></h3> 
       <p><a href="https://github.com/kripken/emscripten">Emscripten</a> pioneered a coding style that was later picked up by <a href="http://asmjs.org/">asm.js</a>: The operations of a virtual machine (think bytecode) are expressed in static subset of JavaScript. That subset can be executed efficiently by JavaScript engines: If it is the result of a compilation from C++, it runs at about 70% of native speed.</p> 
       <h4 id="mathfroundx"><code>Math.fround(x)</code>&nbsp;&nbsp;<a class="header-anchor" href="#mathfroundx" aria-hidden="true">#</a></h4> 
       <p>Rounds <code>x</code> to a 32 bit floating point value (<code>float</code>). Used by asm.js to tell an engine to internally use a <code>float</code> value.</p> 
       <h4 id="mathimulx-y"><code>Math.imul(x, y)</code>&nbsp;&nbsp;<a class="header-anchor" href="#mathimulx-y" aria-hidden="true">#</a></h4> 
       <p>Multiplies the two 32 bit integers <code>x</code> and <code>y</code> and returns the lower 32 bits of the result. This is the only 32 bit basic math operation that can’t be simulated by using a JavaScript operator and coercing the result back to 32 bits. For example, <code>idiv</code> could be implemented as follows:</p> 
       <pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">idiv</span>(<span class="hljs-params">x, y</span>) </span>{
    <span class="hljs-keyword">return</span> (x / y) | <span class="hljs-number">0</span>;
}
</code></pre> 
       <p>In contrast, multiplying two large 32 bit integers may produce a double that is so large that lower bits are lost.</p> 
       <h3 id="bitwise-operations">Bitwise operations&nbsp;&nbsp;<a class="header-anchor" href="#bitwise-operations" aria-hidden="true">#</a></h3> 
       <ul> 
        <li> <p><code>Math.clz32(x)</code><br> Counts the leading zero bits in the 32 bit integer <code>x</code>.</p> <pre><code class="language-repl">&gt; Math.clz32(0b01000000000000000000000000000000)
1
&gt; Math.clz32(0b00100000000000000000000000000000)
2
&gt; Math.clz32(2)
30
&gt; Math.clz32(1)
31
</code></pre> </li> 
       </ul> 
       <h3 id="trigonometric-methods">Trigonometric methods&nbsp;&nbsp;<a class="header-anchor" href="#trigonometric-methods" aria-hidden="true">#</a></h3> 
       <ul> 
        <li> <p><code>Math.sinh(x)</code><br> Computes the hyperbolic sine of <code>x</code>.</p> </li> 
        <li> <p><code>Math.cosh(x)</code><br> Computes the hyperbolic cosine of <code>x</code>.</p> </li> 
        <li> <p><code>Math.tanh(x)</code><br> Computes the hyperbolic tangent of <code>x</code>.</p> </li> 
        <li> <p><code>Math.asinh(x)</code><br> Computes the inverse hyperbolic sine of <code>x</code>.</p> </li> 
        <li> <p><code>Math.acosh(x)</code><br> Computes the inverse hyperbolic cosine of <code>x</code>.</p> </li> 
        <li> <p><code>Math.atanh(x)</code><br> Computes the inverse hyperbolic tangent of <code>x</code>.</p> </li> 
        <li> <p><code>Math.hypot(...values)</code><br> Computes the square root of the sum of squares of its arguments.</p> </li> 
       </ul> 
       <hr class="footnotes-sep"> 
       <section class="footnotes"> 
        <ol class="footnotes-list"> 
         <li id="fn1" class="footnote-item"><p>While that is something that you normally don’t see, that means that <code>-0</code> produces the result <code>-0</code> and <code>+0</code> produces the result <code>+0</code>. <a href="#fnref1" class="footnote-backref">??</a></p> </li> 
        </ol> 
       </section> 
      </div>
      <div style="margin-top:3em;" data-reactid="41"> 
       <hr> 
       <div id="disqus_thread"></div> 
       <script>
                var disqus_config = function () {
                    this.page.url = 'http://www.2ality.com/2015/04/numbers-math-es6.html';
                    this.page.identifier = 'http://www.2ality.com/2015/04/numbers-math-es6.html';
                };
                (function() {  // DON'T EDIT BELOW THIS LINE
                    var d = document, s = d.createElement('script');

                    s.src = 'https://2ality.disqus.com/embed.js';

                    s.setAttribute('data-timestamp', +new Date());
                    (d.head || d.body).appendChild(s);
                })();
            </script> 
       <noscript>
        Please enable JavaScript to view the 
        <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
       </noscript> 
      </div>
     </div>
     <div id="right_column" data-reactid="42">
      <div class="no-link" style="text-align:center;" data-reactid="43">
       <a href="http://rauschma.de/" data-reactid="44"><img style="margin-left:auto;margin-right:auto;" width="180px" height="180px" src="../../img/axel_head.jpg" data-reactid="45"><br data-reactid="46">
        <!-- react-text: 47 -->Dr. Axel Rauschmayer
        <!-- /react-text --></a>
       <br data-reactid="48">
       <a href="https://twitter.com/rauschma" data-reactid="49">Twitter</a>
       <!-- react-text: 50 -->, 
       <!-- /react-text -->
       <a href="https://social.tchncs.de/@rauschma" data-reactid="51">Mastodon</a>
      </div>
      <div data-reactid="52">
       <h2 data-reactid="53">Most popular (last 30 days)</h2>
       <!-- react-text: 54 -->Loading...
       <!-- /react-text -->
      </div>
     </div>
    </div>
   </div>
  </div> 
  <script defer>
    var pageData = {"metaDescription":"This blog post describes the new number and `Math` features of ECMAScript 6.","relativeWebPath":"2015/04/numbers-math-es6.html","titleText":"New number and Math features in ES6","titleHtml":"New number and Math features in ES6","date":"2015-04-13","tagsArray":["esnext","dev","javascript"],"postHtml":"<p>This blog post describes the new number and <code>Math</code> features of <a href=\"http://exploringjs.com/\">ECMAScript 6</a>.</p>\n<!--more-->\n<h2 id=\"overview\">Overview  <a class=\"header-anchor\" href=\"#overview\" aria-hidden=\"true\">#</a></h2>\n<p>You can now specify integers in binary and octal notation:</p>\n<pre><code class=\"language-repl\">&gt; 0xFF // ES5: hexadecimal\n255\n&gt; 0b11 // ES6: binary\n3\n&gt; 0o10 // ES6: octal\n8\n</code></pre>\n<p>The global object <code>Number</code> gained a few new properties. Among others:</p>\n<ul>\n<li><code>Number.EPSILON</code> for comparing floating point numbers with a tolerance for rounding errors.</li>\n<li>A method and constants for determining whether a JavaScript integer is <em>safe</em> (within the signed 53 bit range in which there is no loss of precision).</li>\n</ul>\n<h2 id=\"new-integer-literals\">New integer literals  <a class=\"header-anchor\" href=\"#new-integer-literals\" aria-hidden=\"true\">#</a></h2>\n<p>ECMAScript 5 already has literals for hexadecimal integers:</p>\n<pre><code class=\"language-repl\">&gt; 0x9\n9\n&gt; 0xA\n10\n&gt; 0x10\n16\n&gt; 0xFF\n255\n</code></pre>\n<p>ECMAScript 6 brings two new kinds of integer literals:</p>\n<ul>\n<li>\n<p>Binary literals have the prefix <code>0b</code> or <code>0B</code>:</p>\n<pre><code class=\"language-repl\">&gt; 0b11\n3\n&gt; 0b100\n4\n</code></pre>\n</li>\n<li>\n<p>Octal literals have the prefix <code>0o</code> or <code>0O</code> (yes, that’s a zero followed by the capital letter O; you’ll be fine if you use the first variant):</p>\n<pre><code class=\"language-repl\">&gt; 0o7\n7\n&gt; 0o10\n8\n</code></pre>\n</li>\n</ul>\n<p>Remember that the method <code>Number.prototype.toString(radix)</code> can be used to convert numbers back:</p>\n<pre><code class=\"language-repl\">&gt; (255).toString(16)\n'ff'\n&gt; (4).toString(2)\n'100'\n&gt; (8).toString(8)\n'10'\n</code></pre>\n<h3 id=\"use-case-for-octal-literals-unix-style-file-permissions\">Use case for octal literals: Unix-style file permissions  <a class=\"header-anchor\" href=\"#use-case-for-octal-literals-unix-style-file-permissions\" aria-hidden=\"true\">#</a></h3>\n<p>In the Node.js <a href=\"https://nodejs.org/api/fs.html\">file system module</a>, several functions have the parameter <code>mode</code>. Its value is used to specify file permissions, via an encoding that is a holdover from Unix:</p>\n<ul>\n<li>Permissions are specified for three categories of users:\n<ul>\n<li>User: the owner of the file</li>\n<li>Group: the members of the group associated with the file</li>\n<li>All: everyone</li>\n</ul>\n</li>\n<li>Per category, the following permissions can be granted:\n<ul>\n<li>r (read): the users in the category are allowed to read the file</li>\n<li>w (write): the users in the category are allowed to change the file</li>\n<li>x (execute): the users in the category are allowed to run the file</li>\n</ul>\n</li>\n</ul>\n<p>That means that permissions can be represented by 9 bits (3 categories with 3 permissions each):</p>\n<table class=\"framed\">\n<thead>\n<tr>\n<th></th>\n<th>User</th>\n<th>Group</th>\n<th>All</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Permissions</td>\n<td>r, w, x</td>\n<td>r, w, x</td>\n<td>r, w, x</td>\n</tr>\n<tr>\n<td>Bit</td>\n<td>8, 7, 6</td>\n<td>5, 4, 3</td>\n<td>2, 1, 0</td>\n</tr>\n</tbody>\n</table>\n<p>The permissions of a single category of users are stored in 3 bits:</p>\n<table class=\"framed\">\n<thead>\n<tr>\n<th>Bits</th>\n<th>Permissions</th>\n<th>Octal digit</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>000</td>\n<td>–––</td>\n<td>0</td>\n</tr>\n<tr>\n<td>001</td>\n<td>––x</td>\n<td>1</td>\n</tr>\n<tr>\n<td>010</td>\n<td>–w–</td>\n<td>2</td>\n</tr>\n<tr>\n<td>011</td>\n<td>–wx</td>\n<td>3</td>\n</tr>\n<tr>\n<td>100</td>\n<td>r––</td>\n<td>4</td>\n</tr>\n<tr>\n<td>101</td>\n<td>r–x</td>\n<td>5</td>\n</tr>\n<tr>\n<td>110</td>\n<td>rw–</td>\n<td>6</td>\n</tr>\n<tr>\n<td>111</td>\n<td>rwx</td>\n<td>7</td>\n</tr>\n</tbody>\n</table>\n<p>That means that octal numbers are a compact representation of all permissions, you only need 3 digits, one digit per category of users. Two examples:</p>\n<ul>\n<li>755 = 111,101,101: I can change, read and execute; everyone else can only read and execute.</li>\n<li>640 = 110,100,000: I can read and write; group members can read; everyone can’t access at all.</li>\n</ul>\n<h3 id=\"parseint-and-the-new-integer-literals\"><code>parseInt()</code> and the new integer literals  <a class=\"header-anchor\" href=\"#parseint-and-the-new-integer-literals\" aria-hidden=\"true\">#</a></h3>\n<p><code>parseInt()</code> has the following signature:</p>\n<pre><code class=\"language-js\"><span class=\"hljs-built_in\">parseInt</span>(string, radix?)\n</code></pre>\n<p>It provides special support for the hexadecimal literal notation – the prefix <code>0x</code> (or <code>0X</code>) of <code>string</code> is removed if:</p>\n<ul>\n<li><code>radix</code> is missing or 0. Then <code>radix</code> is set to 16.</li>\n<li><code>radix</code> is already 16.</li>\n</ul>\n<p>For example:</p>\n<pre><code class=\"language-repl\">&gt; parseInt('0xFF')\n255\n&gt; parseInt('0xFF', 0)\n255\n&gt; parseInt('0xFF', 16)\n255\n</code></pre>\n<p>In all other cases, digits are only parsed until the first non-digit:</p>\n<pre><code class=\"language-repl\">&gt; parseInt('0xFF', 10)\n0\n&gt; parseInt('0xFF', 17)\n0\n</code></pre>\n<p><code>parseInt()</code> does not have special support for binary or octal literals!</p>\n<pre><code class=\"language-repl\">&gt; parseInt('0b111')\n0\n&gt; parseInt('0b111', 2)\n0\n&gt; parseInt('111', 2)\n7\n\n&gt; parseInt('0o10')\n0\n&gt; parseInt('0o10', 8)\n0\n&gt; parseInt('10', 8)\n8\n</code></pre>\n<p>If you want to parse these kinds of literals, you need to use <code>Number()</code>:</p>\n<pre><code class=\"language-repl\">&gt; Number('0b111')\n7\n&gt; Number('0o10')\n8\n</code></pre>\n<p>Alternatively, you can also remove the prefix and use <code>parseInt()</code> with the appropriate radix:</p>\n<pre><code class=\"language-repl\">&gt; parseInt('111', 2)\n7\n&gt; parseInt('10', 8)\n8\n</code></pre>\n<h2 id=\"new-number-constructor-properties\">New <code>Number</code> constructor properties  <a class=\"header-anchor\" href=\"#new-number-constructor-properties\" aria-hidden=\"true\">#</a></h2>\n<p>This section describes new properties that the constructor <code>Number</code> has picked up in ECMAScript 6.</p>\n<h3 id=\"previously-global-functions\">Previously global functions  <a class=\"header-anchor\" href=\"#previously-global-functions\" aria-hidden=\"true\">#</a></h3>\n<p>Four number-related functions are already available as global functions and have been added (with no or little modifications) to <code>Number</code>, as methods: <code>isFinite</code>, <code>isNaN</code>, <code>parseFloat</code> and <code>parseInt</code>.</p>\n<h4 id=\"numberisfinitenumber\"><code>Number.isFinite(number)</code>  <a class=\"header-anchor\" href=\"#numberisfinitenumber\" aria-hidden=\"true\">#</a></h4>\n<p>Is <code>number</code> an actual number (neither <code>Infinity</code> nor <code>-Infinity</code> nor <code>NaN</code>)?</p>\n<pre><code class=\"language-repl\">&gt; Number.isFinite(Infinity)\nfalse\n&gt; Number.isFinite(-Infinity)\nfalse\n&gt; Number.isFinite(NaN)\nfalse\n&gt; Number.isFinite(123)\ntrue\n</code></pre>\n<p>The advantage of this method is that it does not coerce its parameter to number (whereas the global function does):</p>\n<pre><code class=\"language-repl\">&gt; Number.isFinite('123')\nfalse\n&gt; isFinite('123')\ntrue\n</code></pre>\n<h4 id=\"numberisnannumber\"><code>Number.isNaN(number)</code>  <a class=\"header-anchor\" href=\"#numberisnannumber\" aria-hidden=\"true\">#</a></h4>\n<p>Is <code>number</code> the value <code>NaN</code>? Making this check via <code>===</code> is hacky. <code>NaN</code> is the only value that is not equal to itself:</p>\n<pre><code class=\"language-repl\">&gt; let x = NaN;\n&gt; x === NaN\nfalse\n</code></pre>\n<p>Therefore, this expression is used to check for it</p>\n<pre><code class=\"language-repl\">&gt; x !== x\ntrue\n</code></pre>\n<p>Using <code>Number.isNaN()</code> is more self-descriptive:</p>\n<pre><code class=\"language-repl\">&gt; Number.isNaN(x)\ntrue\n</code></pre>\n<p><code>Number.isNan()</code> also has the advantage of not coercing its parameter to number (whereas the global function does):</p>\n<pre><code class=\"language-repl\">&gt; Number.isNaN('???')\nfalse\n&gt; isNaN('???')\ntrue\n</code></pre>\n<h4 id=\"numberparsefloat-and-numberparseint\"><code>Number.parseFloat</code> and <code>Number.parseInt</code>  <a class=\"header-anchor\" href=\"#numberparsefloat-and-numberparseint\" aria-hidden=\"true\">#</a></h4>\n<p>The following two methods work exactly like the global functions with the same names. They were added to <code>Number</code> for completeness sake; now all number-related functions are available there.</p>\n<ul>\n<li><code>Number.parseFloat(string)</code></li>\n<li><code>Number.parseInt(string, radix)</code></li>\n</ul>\n<h3 id=\"numberepsilon\">Number.EPSILON  <a class=\"header-anchor\" href=\"#numberepsilon\" aria-hidden=\"true\">#</a></h3>\n<p>Especially with decimal fractions, rounding errors can become a problem in JavaScript. For example, 0.1 and 0.2 can’t be represented precisely, which you notice if you add them and compare them to 0.3 (which can’t be represented precisely, either).</p>\n<pre><code class=\"language-repl\">&gt; 0.1 + 0.2 === 0.3\nfalse\n</code></pre>\n<p><code>Number.EPSILON</code> specifies a reasonable margin of error when comparing floating point numbers. It provides a better way to compare floating point values, as demonstrated by the following function.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">epsEqu</span>(<span class=\"hljs-params\">x, y</span>) </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Math</span>.abs(x - y) &lt; <span class=\"hljs-built_in\">Number</span>.EPSILON;\n}\n<span class=\"hljs-built_in\">console</span>.log(epsEqu(<span class=\"hljs-number\">0.1</span>+<span class=\"hljs-number\">0.2</span>, <span class=\"hljs-number\">0.3</span>)); <span class=\"hljs-comment\">// true</span>\n</code></pre>\n<h3 id=\"numberisintegernumber\"><code>Number.isInteger(number)</code>  <a class=\"header-anchor\" href=\"#numberisintegernumber\" aria-hidden=\"true\">#</a></h3>\n<p>JavaScript has only floating point numbers (doubles). Accordingly, integers are simply floating point numbers without a decimal fraction.</p>\n<p><code>Number.isInteger(number)</code> returns <code>true</code> if <code>number</code> is a number and does not have a decimal fraction.</p>\n<pre><code class=\"language-repl\">&gt; Number.isInteger(-17)\ntrue\n&gt; Number.isInteger(33)\ntrue\n&gt; Number.isInteger(33.1)\nfalse\n&gt; Number.isInteger('33')\nfalse\n&gt; Number.isInteger(NaN)\nfalse\n&gt; Number.isInteger(Infinity)\nfalse\n</code></pre>\n<h3 id=\"safe-integers\">Safe Integers  <a class=\"header-anchor\" href=\"#safe-integers\" aria-hidden=\"true\">#</a></h3>\n<p>JavaScript numbers have only enough storage space to represent 53 bit signed integers. That is, integers <em>i</em> in the range ?2^53^ &lt; <em>i</em> &lt; 2^53^ are <em>safe</em>. What exactly that means is explained momentarily. The following properties help determine whether a JavaScript integer is safe:</p>\n<ul>\n<li><code>Number.isSafeInteger(number)</code></li>\n<li><code>Number.MIN_SAFE_INTEGER</code></li>\n<li><code>Number.MAX_SAFE_INTEGER</code></li>\n</ul>\n<p>The notion of <em>safe integers</em> centers on how mathematical integers are represented in JavaScript. In the range (?2^53^, 2^53^) (excluding the lower and upper bounds), JavaScript integers are <em>safe</em>: there is a one-to-one mapping between them and the mathematical integers they represent.</p>\n<p>Beyond this range, JavaScript integers are <em>unsafe</em>: two or more mathematical integers are represented as the same JavaScript integer. For example, starting at 2^53^, JavaScript can represent only every second mathematical integer:</p>\n<pre><code class=\"language-repl\">&gt; Math.pow(2, 53)\n9007199254740992\n\n&gt; 9007199254740992\n9007199254740992\n&gt; 9007199254740993\n9007199254740992\n&gt; 9007199254740994\n9007199254740994\n&gt; 9007199254740995\n9007199254740996\n&gt; 9007199254740996\n9007199254740996\n&gt; 9007199254740997\n9007199254740996\n</code></pre>\n<p>Therefore, a safe JavaScript integer is one that unambiguously represents a single mathematical integer.</p>\n<h4 id=\"the-properties-of-number\">The properties of <code>Number</code>  <a class=\"header-anchor\" href=\"#the-properties-of-number\" aria-hidden=\"true\">#</a></h4>\n<p>The two <code>Number</code> properties specifying the lower and upper bound of safe integers could be defined as follows:</p>\n<pre><code class=\"language-js\"><span class=\"hljs-built_in\">Number</span>.MAX_SAFE_INTEGER = <span class=\"hljs-built_in\">Math</span>.pow(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">53</span>)<span class=\"hljs-number\">-1</span>;\n<span class=\"hljs-built_in\">Number</span>.MIN_SAFE_INTEGER = -<span class=\"hljs-built_in\">Number</span>.MAX_SAFE_INTEGER;\n</code></pre>\n<p><code>Number.isSafeInteger()</code> determines whether a JavaScript number is a safe integer and could be defined as follows:</p>\n<pre><code class=\"language-js\"><span class=\"hljs-built_in\">Number</span>.isSafeInteger = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">n</span>) </span>{\n    <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-keyword\">typeof</span> n === <span class=\"hljs-string\">'number'</span> &amp;&amp;\n        <span class=\"hljs-built_in\">Math</span>.round(n) === n &amp;&amp;\n        <span class=\"hljs-built_in\">Number</span>.MIN_SAFE_INTEGER &lt;= n &amp;&amp;\n        n &lt;= <span class=\"hljs-built_in\">Number</span>.MAX_SAFE_INTEGER);\n}\n</code></pre>\n<p>For a given value <code>n</code>, this function first checks whether <code>n</code> is a number and an integer. If both checks succeed, <code>n</code> is safe if it is greater than or equal to <code>MIN_SAFE_INTEGER</code> and less than or equal to <code>MAX_SAFE_INTEGER</code>.</p>\n<h4 id=\"safe-results-of-arithmetic-computations\">Safe results of arithmetic computations  <a class=\"header-anchor\" href=\"#safe-results-of-arithmetic-computations\" aria-hidden=\"true\">#</a></h4>\n<p>How can we make sure that results of arithmetic computations are correct? For example, the following result is clearly not correct:</p>\n<pre><code class=\"language-repl\">&gt; 9007199254740990 + 3\n9007199254740992\n</code></pre>\n<p>We have two safe operands, but an unsafe result:</p>\n<pre><code class=\"language-repl\">&gt; Number.isSafeInteger(9007199254740990)\ntrue\n&gt; Number.isSafeInteger(3)\ntrue\n&gt; Number.isSafeInteger(9007199254740992)\nfalse\n</code></pre>\n<p>The following result is also incorrect:</p>\n<pre><code class=\"language-repl\">&gt; 9007199254740995 - 10\n9007199254740986\n</code></pre>\n<p>This time, the result is safe, but one of the operands isn’t:</p>\n<pre><code class=\"language-repl\">&gt; Number.isSafeInteger(9007199254740995)\nfalse\n&gt; Number.isSafeInteger(10)\ntrue\n&gt; Number.isSafeInteger(9007199254740986)\ntrue\n</code></pre>\n<p>Therefore, the result of applying an integer operator <code>op</code> is guaranteed to be correct only if all operands and the result are safe. More formally:</p>\n<pre><code class=\"language-js\">isSafeInteger(a) &amp;&amp; isSafeInteger(b) &amp;&amp; isSafeInteger(a op b)\n</code></pre>\n<p>implies that <code>a op b</code> is a correct result.</p>\n<h4 id=\"source-of-this-section\">Source of this section  <a class=\"header-anchor\" href=\"#source-of-this-section\" aria-hidden=\"true\">#</a></h4>\n<ul>\n<li>“<a href=\"https://mail.mozilla.org/pipermail/es-discuss/2013-August/032991.html\">Clarify integer and safe integer resolution</a>”, email by Mark S. Miller to the es-discuss mailing list.</li>\n</ul>\n<h2 id=\"math\">Math  <a class=\"header-anchor\" href=\"#math\" aria-hidden=\"true\">#</a></h2>\n<p>The global object <code>Math</code> has several new methods in ECMAScript 6.</p>\n<h3 id=\"various-numerical-functionality\">Various numerical functionality  <a class=\"header-anchor\" href=\"#various-numerical-functionality\" aria-hidden=\"true\">#</a></h3>\n<h4 id=\"mathsignx\"><code>Math.sign(x)</code>  <a class=\"header-anchor\" href=\"#mathsignx\" aria-hidden=\"true\">#</a></h4>\n<p>Returns the sign of <code>x</code> as <code>-1</code> or <code>+1</code>. Unless <code>x</code> is either <code>NaN</code> or zero; then <code>x</code> is returned<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup>.</p>\n<pre><code class=\"language-repl\">&gt; Math.sign(-8)\n-1\n&gt; Math.sign(3)\n1\n\n&gt; Math.sign(0)\n0\n&gt; Math.sign(NaN)\nNaN\n\n&gt; Math.sign(-Infinity)\n-1\n&gt; Math.sign(Infinity)\n1\n</code></pre>\n<h4 id=\"mathtruncx\"><code>Math.trunc(x)</code>  <a class=\"header-anchor\" href=\"#mathtruncx\" aria-hidden=\"true\">#</a></h4>\n<p>Removes the decimal fraction of <code>x</code>.</p>\n<pre><code class=\"language-repl\">&gt; Math.trunc(3.1)\n3\n&gt; Math.trunc(3.9)\n3\n&gt; Math.trunc(-3.1)\n-3\n&gt; Math.trunc(-3.9)\n-3\n</code></pre>\n<h4 id=\"mathcbrtx\"><code>Math.cbrt(x)</code>  <a class=\"header-anchor\" href=\"#mathcbrtx\" aria-hidden=\"true\">#</a></h4>\n<p>Returns the cube root of <code>x</code> (?x).</p>\n<pre><code class=\"language-repl\">&gt; Math.cbrt(8)\n2\n</code></pre>\n<h3 id=\"using-0-instead-of-1-with-exponentiation-and-logarithm\">Using 0 instead of 1 with exponentiation and logarithm  <a class=\"header-anchor\" href=\"#using-0-instead-of-1-with-exponentiation-and-logarithm\" aria-hidden=\"true\">#</a></h3>\n<p>A small fraction can be represented more precisely if it comes after zero. I’ll demonstrate this with decimal fractions. (Internally, JavaScript’s floating point numbers are base 2, but externally you see them as base 10. The same basic principles w.r.t. precision apply in either case.) Floating point numbers with base 10 are represented as <em>mantissa</em> × 10^<em>exponent</em>^. If a zero comes before the dot then small fractions have less significant digits. For example:</p>\n<ul>\n<li>(A) 0.000000234 = 2.34 × 10^?7^. Significant digits: 234</li>\n<li>(B) 1.000000234 = 1.000000234 × 10^0^. Significant digits: 1000000234</li>\n</ul>\n<p>Precision-wise, the exponent is not an issue here, the significant digits and the capacity of the mantissa are. That’s why (A) gives you higher precision than (B).</p>\n<p>You can see this in the following interaction: The first number (1 × 10^?16^) registers as different from zero, while the same number added to 1 registers as 1.</p>\n<pre><code class=\"language-repl\">&gt; 1e-16 === 0\nfalse\n&gt; 1 + 1e-16 === 1\ntrue\n</code></pre>\n<h4 id=\"mathexpm1x\"><code>Math.expm1(x)</code>  <a class=\"header-anchor\" href=\"#mathexpm1x\" aria-hidden=\"true\">#</a></h4>\n<p>Returns <code>Math.exp(x)-1</code>. The inverse of <code>Math.log1p()</code>.</p>\n<p>Therefore, this method provides higher precision whenever <code>Math.exp()</code> has results close to 1. You can see the difference between the two in the following interaction:</p>\n<pre><code class=\"language-repl\">&gt; Math.expm1(1e-10)\n1.00000000005e-10\n&gt; Math.exp(1e-10)-1\n1.000000082740371e-10\n</code></pre>\n<p>The former is the better result, which you can verify by using a library (such as <a href=\"https://github.com/MikeMcl/decimal.js/\">decimal.js</a>) for floating point numbers with arbitrary precision (“bigfloats”):</p>\n<pre><code class=\"language-repl\">&gt; var Decimal = require('decimal.js').config({precision:50});\n&gt; new Decimal(1e-10).exp().minus(1).toString()\n'1.000000000050000000001666666666708333333e-10'\n</code></pre>\n<h4 id=\"mathlog1px\"><code>Math.log1p(x)</code>  <a class=\"header-anchor\" href=\"#mathlog1px\" aria-hidden=\"true\">#</a></h4>\n<p>Returns <code>Math.log(1 + x)</code>. The inverse of <code>Math.expm1()</code>.</p>\n<p>Therefore, this method lets you specify parameters that are close to 1 with a higher precision.</p>\n<p>We have already established that <code>1 + 1e-16 === 1</code>. Therefore, it is no surprise that the following two calls of <code>log()</code> produce the same result:</p>\n<pre><code class=\"language-repl\">&gt; Math.log(1 + 1e-16)\n0\n&gt; Math.log(1 + 0)\n0\n</code></pre>\n<p>In contrast, <code>log1p()</code> produces different results:</p>\n<pre><code class=\"language-repl\">&gt; Math.log1p(1e-16)\n1e-16\n&gt; Math.log1p(0)\n0\n</code></pre>\n<h3 id=\"logarithms-to-base-2-and-10\">Logarithms to base 2 and 10  <a class=\"header-anchor\" href=\"#logarithms-to-base-2-and-10\" aria-hidden=\"true\">#</a></h3>\n<h4 id=\"mathlog2x\"><code>Math.log2(x)</code>  <a class=\"header-anchor\" href=\"#mathlog2x\" aria-hidden=\"true\">#</a></h4>\n<p>Computes the logarithm to base 2.</p>\n<pre><code class=\"language-repl\">&gt; Math.log2(8)\n3\n</code></pre>\n<h4 id=\"mathlog10x\"><code>Math.log10(x)</code>  <a class=\"header-anchor\" href=\"#mathlog10x\" aria-hidden=\"true\">#</a></h4>\n<p>Computes the logarithm to base 10.</p>\n<pre><code class=\"language-repl\">&gt; Math.log10(100)\n2\n</code></pre>\n<h3 id=\"support-for-compiling-to-javascript\">Support for compiling to JavaScript  <a class=\"header-anchor\" href=\"#support-for-compiling-to-javascript\" aria-hidden=\"true\">#</a></h3>\n<p><a href=\"https://github.com/kripken/emscripten\">Emscripten</a> pioneered a coding style that was later picked up by <a href=\"http://asmjs.org/\">asm.js</a>: The operations of a virtual machine (think bytecode) are expressed in static subset of JavaScript. That subset can be executed efficiently by JavaScript engines: If it is the result of a compilation from C++, it runs at about 70% of native speed.</p>\n<h4 id=\"mathfroundx\"><code>Math.fround(x)</code>  <a class=\"header-anchor\" href=\"#mathfroundx\" aria-hidden=\"true\">#</a></h4>\n<p>Rounds <code>x</code> to a 32 bit floating point value (<code>float</code>). Used by asm.js to tell an engine to internally use a <code>float</code> value.</p>\n<h4 id=\"mathimulx-y\"><code>Math.imul(x, y)</code>  <a class=\"header-anchor\" href=\"#mathimulx-y\" aria-hidden=\"true\">#</a></h4>\n<p>Multiplies the two 32 bit integers <code>x</code> and <code>y</code> and returns the lower 32 bits of the result. This is the only 32 bit basic math operation that can’t be simulated by using a JavaScript operator and coercing the result back to 32 bits. For example, <code>idiv</code> could be implemented as follows:</p>\n<pre><code class=\"language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">idiv</span>(<span class=\"hljs-params\">x, y</span>) </span>{\n    <span class=\"hljs-keyword\">return</span> (x / y) | <span class=\"hljs-number\">0</span>;\n}\n</code></pre>\n<p>In contrast, multiplying two large 32 bit integers may produce a double that is so large that lower bits are lost.</p>\n<h3 id=\"bitwise-operations\">Bitwise operations  <a class=\"header-anchor\" href=\"#bitwise-operations\" aria-hidden=\"true\">#</a></h3>\n<ul>\n<li>\n<p><code>Math.clz32(x)</code><br>\nCounts the leading zero bits in the 32 bit integer <code>x</code>.</p>\n<pre><code class=\"language-repl\">&gt; Math.clz32(0b01000000000000000000000000000000)\n1\n&gt; Math.clz32(0b00100000000000000000000000000000)\n2\n&gt; Math.clz32(2)\n30\n&gt; Math.clz32(1)\n31\n</code></pre>\n</li>\n</ul>\n<h3 id=\"trigonometric-methods\">Trigonometric methods  <a class=\"header-anchor\" href=\"#trigonometric-methods\" aria-hidden=\"true\">#</a></h3>\n<ul>\n<li>\n<p><code>Math.sinh(x)</code><br>\nComputes the hyperbolic sine of <code>x</code>.</p>\n</li>\n<li>\n<p><code>Math.cosh(x)</code><br>\nComputes the hyperbolic cosine of <code>x</code>.</p>\n</li>\n<li>\n<p><code>Math.tanh(x)</code><br>\nComputes the hyperbolic tangent of <code>x</code>.</p>\n</li>\n<li>\n<p><code>Math.asinh(x)</code><br>\nComputes the inverse hyperbolic sine of <code>x</code>.</p>\n</li>\n<li>\n<p><code>Math.acosh(x)</code><br>\nComputes the inverse hyperbolic cosine of <code>x</code>.</p>\n</li>\n<li>\n<p><code>Math.atanh(x)</code><br>\nComputes the inverse hyperbolic tangent of <code>x</code>.</p>\n</li>\n<li>\n<p><code>Math.hypot(...values)</code><br>\nComputes the square root of the sum of squares of its arguments.</p>\n</li>\n</ul>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>While that is something that you normally don’t see, that means that <code>-0</code> produces the result <code>-0</code> and <code>+0</code> produces the result <code>+0</code>. <a href=\"#fnref1\" class=\"footnote-backref\">??</a></p>\n</li>\n</ol>\n</section>\n","webRootPath":"../../","webImagePath":"../../img/","webDataPath":"../../data/","widgetData":{}};
  </script> 
  <script defer src="../../script/PostPage.bundle.js"></script> 
  <script defer>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-46839352-1', 'auto');
    ga('send', 'pageview');
  </script>  
 </body>
</html>