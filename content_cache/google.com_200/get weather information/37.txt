<!doctype html>
<html class="no-js hasSidebar hasPageActions hasBreadcrumb " lang="en-us" dir="ltr">
 <head> 
  <meta charset="utf-8"> 
  <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
  <meta property="og:title" content="Microservices hosted in Docker - C#"> 
  <meta property="og:image" content="https://docs.microsoft.com/_themes/docs.theme/master/en-us/_themes/images/microsoft-header.png"> 
  <meta name="twitter:card" content="summary"> 
  <meta name="twitter:site" content="@docsmsft"> 
  <meta name="twitter:title" content="Microservices hosted in Docker - C#"> 
  <meta name="twitter:description" content="Learn to create asp.net core services that run in Docker containers"> 
  <meta name="twitter:image" content="https://docs.microsoft.com/_themes/docs.theme/master/en-us/_themes/images/microsoft-header.png"> 
  <meta name="twitter:image:alt" content="Microsoft Logo"> 
  <meta name="author" content="BillWagner"> 
  <meta name="ms.author" content="wiwagn"> 
  <meta name="manager" content="wpickett"> 
  <meta name="breadcrumb_path" content="/dotnet/toc.json"> 
  <meta name="apiPlatform" content="dotnet"> 
  <meta name="uhfHeaderId" content="MSDocsHeader-DotNet"> 
  <meta name="ms.devlang" content="csharp"> 
  <meta name="ms.assetid" content="87e93838-a363-4813-b859-7356023d98ed"> 
  <meta name="description" content="Learn to create asp.net core services that run in Docker containers"> 
  <meta name="keywords" content=".NET, .NET Core, Docker, C#, ASP.NET, Microservice"> 
  <meta name="ms.topic" content="article"> 
  <meta name="ms.date" content="02/03/2017"> 
  <meta name="ms.technology" content="dotnet-docker"> 
  <meta name="ms.prod" content=".net-core"> 
  <meta name="search.ms_sitename" content="Docs"> 
  <meta name="search.ms_docsetname" content="core-docs"> 
  <meta name="locale" content="en-us"> 
  <meta name="site_name" content="Docs"> 
  <meta name="search.ms_product" content="VS"> 
  <meta name="depot_name" content="VS.core-docs"> 
  <meta name="updated_at" content="2017-08-23 09:54 AM"> 
  <meta name="gitcommit" content="https://github.com/dotnet/docs/blob/306c608dc7f97594ef6f72ae0f5aaba596c936e1/docs/csharp/tutorials/microservices.md"> 
  <meta name="original_content_git_url" content="https://github.com/dotnet/docs/blob/live/docs/csharp/tutorials/microservices.md"> 
  <meta name="document_id" content="948bdbcf-e49f-bd3a-89c4-d83f86cfddc5"> 
  <meta name="pagetype" content="Conceptual"> 
  <meta name="toc_rel" content="toc.json"> 
  <meta name="pdf_url_template" content="https://docs.microsoft.com/pdfstore/en-us/VS.core-docs/{branchName}{pdfName}"> 
  <meta name="word_count" content="2773"> 
  <meta name="scope" content=".NET"> 
  <link href="https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/microservices" rel="canonical"> 
  <title>Microservices hosted in Docker - C# | Microsoft Docs</title> 
  <link rel="stylesheet" href="/_themes/docs.theme/master/en-us/_themes/css/870b0825531b1b071dff.site.css "> 
  <link rel="stylesheet" href="/_themes/docs.theme/master/en-us/_themes/css/870b0825531b1b071dff.conceptual.css "> 
  <script>
	var msDocs = {
		data:{
			contentLocale: 'en-us',
			contentDir: 'ltr',
			userLocale: 'en-us',
			userDir: 'ltr',
			pathToTheme: '/_themes/docs.theme/master/en-us/_themes/',
			pageTemplate: 'Conceptual',
			brand: '',
			forceVersionPicker:false		},
		functions:{},
		settings:{
			extendBreadcrumb: false
		}
	};
	if (!('Promise' in window && 'resolve' in window.Promise && 'reject' in window.Promise && 'all' in window.Promise && 'race' in window.Promise)) {
		document.write('<script src="/_themes/docs.theme/master/en-us/_themes/global/js/bluebird.min.js"><\/script>');
	}
	</script> 
  <!--[if lt IE 9]>
		<script src="https://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.12.4.min.js"></script>
		<script src="/_themes/docs.theme/master/en-us/_themes/global/js/polyfills/all.js"></script>
	<![endif]--> 
  <!--[if gte IE 9]><!--> 
  <script src="https://ajax.aspnetcdn.com/ajax/jQuery/jquery-2.2.4.min.js"></script> 
  <!--<![endif]--> 
  <script>window.jQuery || document.write('<script src="/_themes/docs.theme/master/en-us/_themes/global/js/jquery/jquery-1.12.4.min.js"><\/script>')</script> 
  <script src="/_themes/docs.theme/master/en-us/_themes/global/js/global.min.js?v=263"></script> 
 </head> 
 <body> 
  <div id="headerAreaHolder" ms.pgarea="header" data-bi-name="header"> 
   <div id="uhfPlaceHolder" class="c-me"></div> 
  </div> 
  <div class="container mainContainer" lang="en-us" dir="ltr" ms.pgarea="body" data-bi-name="body"> 
   <main role="main" ms.cmpgrp="content" data-bi-name="content"> 
    <div id="main"> 
     <h1 id="microservices-hosted-in-docker" sourcefile="docs/csharp/tutorials/microservices.md" sourcestartlinenumber="15" sourceendlinenumber="15">Microservices hosted in Docker</h1> 
     <div class="metadata loading" ms.cmpgrp="page info" data-bi-name="page info"> 
      <div> 
       <time class="date" datetime="2/3/2017 12:00:00 AM">2017-2-3</time> 
       <span class="reading-time">13 minutes to read</span> 
       <span class="contributors-text">Contributors</span> 
       <ul class="contributors" ms.cmpgrp="contributors" data-bi-name="contributors"> 
        <li><a href="https://github.com/BillWagner" title="Bill Wagner" ms.cmpnm="contributorprofile" data-bi-name="contributorprofile"><img src="https://github.com/BillWagner.png?size=16" alt="Bill Wagner"></a></li> 
        <li><a href="https://github.com/GuardRex" title="Luke Latham" ms.cmpnm="contributorprofile" data-bi-name="contributorprofile"><img src="https://github.com/GuardRex.png?size=16" alt="Luke Latham"></a></li> 
        <li><a href="https://github.com/gldraphael" title="Galdin Raphael" ms.cmpnm="contributorprofile" data-bi-name="contributorprofile"><img src="https://github.com/gldraphael.png?size=16" alt="Galdin Raphael"></a></li> 
        <li><a href="https://github.com/TianqiZhang" title="Tianqi Zhang" ms.cmpnm="contributorprofile" data-bi-name="contributorprofile"><img src="https://github.com/TianqiZhang.png?size=16" alt="Tianqi Zhang"></a></li> 
        <li><a href="https://github.com/yishengjin1413" title="yishengjin1413" ms.cmpnm="contributorprofile" data-bi-name="contributorprofile"><img src="https://github.com/yishengjin1413.png?size=16" alt="yishengjin1413"></a></li> 
        <li><a href="https://github.com/dotnet/docs/blob/master/docs/csharp/tutorials/microservices.md" ms.cmpnm="contributorshowall" data-bi-name="contributorshowall">all</a></li> 
       </ul> 
      </div> 
      <nav id="center-doc-outline" class="doc-outline" ms.cmpgrp="intopic toc" data-bi-name="intopic toc" role="navigation" aria-label="On page navigation"> 
       <h3>In this article</h3> 
      </nav> 
     </div> 
     <div>
      <div class="content"> 
       <h2 id="introduction">Introduction</h2> 
       <p>This tutorial details the tasks necessary to build and deploy an ASP.NET Core microservice in a Docker container. During the course of this tutorial, you'll learn:</p> 
       <ul> 
        <li>How to generate an ASP.NET Core application using Yeoman</li> 
        <li>How to create a development Docker environment</li> 
        <li>How to build a Docker image based on an existing image.</li> 
        <li>How to deploy your service into a Docker container.</li> 
       </ul> 
       <p>Along the way, you'll also see some C# language features:</p> 
       <ul> 
        <li>How to convert C# objects into JSON payloads.</li> 
        <li>How to build immutable Data Transfer Objects</li> 
        <li>How to process incoming HTTP Requests and generate the HTTP Response</li> 
        <li>How to work with nullable value types</li> 
       </ul> 
       <p>You can <a href="https://github.com/dotnet/docs/tree/master/samples/csharp/getting-started/WeatherMicroservice" data-linktype="external">view or download the sample app</a> for this topic. For download instructions, see <a href="../../samples-and-tutorials/index#viewing-and-downloading-samples" data-linktype="relative-path">Samples and Tutorials</a>.</p> 
       <h3 id="why-docker">Why Docker?</h3> 
       <p>Docker makes it easy to create standard machine images to host your services in a data center, or the public cloud. Docker enables you to configure the image, and replicate it as needed to scale the installation of your application.</p> 
       <p>All the code in this tutorial will work in any .NET Core environment. The additional tasks for a Docker installation will work for an ASP.NET Core application. </p> 
       <h2 id="prerequisites">Prerequisites</h2> 
       <p>You’ll need to setup your machine to run .NET core. You can find the installation instructions on the <a href="https://www.microsoft.com/net/core" data-linktype="external">.NET Core</a> page. You can run this application on Windows, Ubuntu Linux, macOS or in a Docker container. You’ll need to install your favorite code editor. The descriptions below use <a href="https://code.visualstudio.com/" data-linktype="external">Visual Studio Code</a> which is an open source, cross platform editor. However, you can use whatever tools you are comfortable with.</p> 
       <p>You'll also need to install the Docker engine. See the <a href="http://www.docker.com/products/docker" data-linktype="external">Docker Installation page</a> for instructions for your platform. Docker can be installed in many Linux distributions, macOS, or Windows. The page referenced above contains sections to each of the available installations.</p> 
       <p>Most components to be installed are done by a package manager. If you have node.js's package manager <code>npm</code> installed you can skip this step. Otherwise install the latest NodeJs from <a href="https://nodejs.org" data-linktype="external">nodejs.org</a> which will install the npm package manager. </p> 
       <p>At this point you will need to install a number of command line tools that support ASP.NET core development. The command line templates use Yeoman, Bower, Grunt, and Gulp. If you have them installed that is good, otherwise type the following into your favorite shell:</p> 
       <p><code>npm install -g yo bower grunt-cli gulp</code></p> 
       <p>The <code>-g</code> option indicates that it is a global install, and those tools are available system wide. (A local install scopes the package to a single project). Once you've installed those core tools, you need to install the yeoman asp.net template generators:</p> 
       <p><code>npm install -g generator-aspnet</code></p> 
       <h2 id="create-the-application">Create the Application</h2> 
       <p>Now that you've installed all the tools, create a new asp.net core application. To use the command line generator, execute the following yeoman command in your favorite shell:</p> 
       <p><code>yo aspnet</code></p> 
       <p>This command prompts you to select what Type of application you want to create. For this microservice, you want the simplest, most lightweight web application possible, so select 'Empty Web Application'. The template will prompt you for a name. Select 'WeatherMicroservice'. </p> 
       <p>The template creates eight files for you:</p> 
       <ul> 
        <li>A .gitignore, customized for asp.net core applications.</li> 
        <li>A Startup.cs file. This contains the basis of the application.</li> 
        <li>A Program.cs file. This contains the entry point of the application.</li> 
        <li>A WeatherMicroservice.csproj file. This is the build file for the application.</li> 
        <li>A Dockerfile. This script creates a Docker image for the application.</li> 
        <li>A README.md. This contains links to other asp.net core resources.</li> 
        <li>A web.config file. This contains basic configuration information.</li> 
        <li>A runtimeconfig.template.json file. This contains debugging settings used by IDEs.</li> 
       </ul> 
       <p>Now you can run the template generated application. That's done using a series of tools from the command line. The <code>dotnet</code> command runs the tools necessary for .NET development. Each verb executes a different command</p> 
       <p>The first step is to restore all the dependencies:</p> 
       <pre><code class="lang-console">dotnet restore
</code></pre>
       <p>Dotnet restore uses the NuGet package manager to install all the necessary packages into the application directory. It also generates a project.json.lock file. This file contains information about each package that is referenced. After restoring all the dependencies, you build the application:</p> 
       <pre><code class="lang-console">dotnet build
</code></pre>
       <p>And once you build the application, you run it from the command line:</p> 
       <pre><code class="lang-console">dotnet run
</code></pre>
       <p>The default configuration listens to <a href="http://localhost:5000" data-linktype="external">http://localhost:5000</a>. You can open a browser and navigate to that page and see a "Hello World!" message.</p> 
       <h3 id="anatomy-of-an-aspnet-core-application">Anatomy of an ASP.NET Core application</h3> 
       <p>Now that you've built the application, let's look at how this functionality is implemented. There are two of the generated files that are particularly interesting at this point: project.json and Startup.cs. </p> 
       <p>Project.json contains information about the project. The two nodes you'll often work with are 'dependencies' and 'frameworks'. The dependencies node lists all the packages that are needed for this application. At the moment, this is a small node, needing only the packages that run the web server.</p> 
       <p>The 'frameworks' node specifies the versions and configurations of the .NET framework that will run this application.</p> 
       <p>The application is implemented in Startup.cs. This file contains the startup class.</p> 
       <p>The two methods are called by the asp.net core infrastructure to configure and run the application. The <code>ConfigureServices</code> method describes the services that are necessary for this application. You're building a lean microservice, so it doesn't need to configure any dependencies. The <code>Configure</code> method configures the handlers for incoming HTTP Requests. The template generates a simple handler that responds to any request with the text 'Hello World!'.</p> 
       <h2 id="build-a-microservice">Build a microservice</h2> 
       <p>The service you're going to build will deliver weather reports from anywhere around the globe. In a production application, you'd call some service to retrieve weather data. For our sample, we'll generate a random weather forecast. </p> 
       <p>There are a number of tasks you'll need to perform in order to implement our random weather service:</p> 
       <ul> 
        <li>Parse the incoming request to read the latitude and longitude.</li> 
        <li>Generate some random forecast data.</li> 
        <li>Convert that random forecast data from C# objects into JSON packets.</li> 
        <li>Set the response header to indicate that your service sends back JSON.</li> 
        <li>Write the response.</li> 
       </ul> 
       <p>The next sections walk you through each of these steps.</p> 
       <h3 id="parsing-the-query-string">Parsing the Query String.</h3> 
       <p>You'll begin by parsing the query string. The service will accept 'lat' and 'long' arguments on the query string in this form:</p> 
       <p><code>http://localhost:5000/?lat=-35.55&amp;long=-12.35</code> </p> 
       <p>All the changes you need to make are in the lambda expression defined as the argument to <code>app.Run</code> in your startup class.</p> 
       <p>The argument on the lambda expression is the <code>HttpContext</code> for the request. One of its properties is the <code>Request</code> object. The <code>Request</code> object has a <code>Query</code> property that contains a dictionary of all the values on the query string for the request. The first addition is to find the latitude and longitude values:</p> 
       <pre><code class="lang-csharp" data-src="https://github.com/dotnet/docs/blob/live/samples/csharp/getting-started/WeatherMicroservice/Startup.cs" name="ReadQueryString" title="read variables from the query string">var latString = context.Request.Query["lat"].FirstOrDefault();
var longString = context.Request.Query["long"].FirstOrDefault();
</code></pre>
       <p>The Query dictionary values are <code>StringValue</code> type. That type can contain a collection of strings. For your weather service, each value is a single string. That's why there's the call to <code>FirstOrDefault()</code> in the code above. </p> 
       <p>Next, you need to convert the strings to doubles. The method you'll use to convert the string to a double is <code>double.TryParse()</code>:</p> 
       <pre><code class="lang-csharp">bool TryParse(string s, out double result);
</code></pre>
       <p>This method leverages C# out parameters to indicate if the input string can be converted to a double. If the string does represent a valid representation for a double, the method returns true, and the <code>result</code> argument contains the value. If the string does not represent a valid double, the method returns false.</p> 
       <p>You can adapt that API with the use of an <em>extension method</em> that returns a <em>nullable double</em>. A <em>nullable value type</em> is a type that represents some value type, and can also hold a missing, or null value. A nullable type is represented by appending the <code>?</code> character to the type declaration. </p> 
       <p>Extension methods are methods that are defined as static methods, but by adding the <code>this</code> modifier on the first parameter, can be called as though they are members of that class. Extension methods may only be defined in static classes. Here's the definition of the class containing the extension method for parse:</p> 
       <pre><code class="lang-csharp" data-src="https://github.com/dotnet/docs/blob/live/samples/csharp/getting-started/WeatherMicroservice/Extensions.cs" name="TryParseExtension" title="try parse to a nullable">public static class Extensions
{
    public static double? TryParse(this string input)
    {
        double result;
        if (double.TryParse(input, out result))
        {
            return result;
        }
        else
        {
            return default(double?);
        }
    }
}
</code></pre>
       <p>The <code>default(double?)</code> expression returns the default value for the <code>double?</code> type. That default value is the null (or missing) value.</p> 
       <p>You can use this extension method to convert the query string arguments into the double type:</p> 
       <pre><code class="lang-csharp" data-src="https://github.com/dotnet/docs/blob/live/samples/csharp/getting-started/WeatherMicroservice/Startup.cs" name="UseTryParse" title="Use the try parse extension method">var latitude = latString.TryParse();
var longitude = longString.TryParse();
</code></pre>
       <p>To easily test the parsing code, update the response to include the values of the arguments:</p> 
       <pre><code class="lang-csharp" data-src="https://github.com/dotnet/docs/blob/live/samples/csharp/getting-started/WeatherMicroservice/Startup.cs" name="WriteResponse" title="Write the output response">await context.Response.WriteAsync($"Retrieving Weather for lat: {latitude}, long: {longitude}");                
</code></pre>
       <p>At this point, you can run the web application and see if your parsing code is working. Add values to the web request in a browser, and you should see the updated results.</p> 
       <h3 id="build-a-random-weather-forecast">Build a random weather forecast</h3> 
       <p>Your next task is to build a random weather forecast. Let's start with a data container that holds the values you'd want for a weather forecast:</p> 
       <pre><code class="lang-csharp">public class WeatherReport
{
    private static readonly string[] PossibleConditions = new string[]
    {
        "Sunny",
        "Mostly Sunny",
        "Partly Sunny",
        "Partly Cloudy",
        "Mostly Cloudy",
        "Rain"
    };

    public int HiTemperature { get; }
    public int LoTemperature { get; }
    public int AverageWindSpeed { get; }
    public string Conditions { get; }
}
</code></pre>
       <p>Next, build a constructor that randomly sets those values. This constructor uses the values for the latitude and longitude to seed the Random number generator. That means the forecast for the same location is the same. If you change the arguments for the latitude and longitude, you'll get a different forecast (because you start with a different seed.)</p> 
       <pre><code class="lang-csharp" data-src="https://github.com/dotnet/docs/blob/live/samples/csharp/getting-started/WeatherMicroservice/WeatherReport.cs" name="WeatherReportConstructor" title="Weather Report Constructor">public WeatherReport(double latitude, double longitude, int daysInFuture)
{
    var generator = new Random((int)(latitude + longitude) + daysInFuture);

    HiTemperature = generator.Next(40, 100);
    LoTemperature = generator.Next(0, HiTemperature);
    AverageWindSpeed = generator.Next(0, 45);
    Conditions = PossibleConditions[generator.Next(0, PossibleConditions.Length - 1)];
}
</code></pre>
       <p>You can now generate the 5-day forecast in your response method:</p> 
       <pre><code class="lang-csharp" data-src="https://github.com/dotnet/docs/blob/live/samples/csharp/getting-started/WeatherMicroservice/Startup.cs" name="GenerateRandomReport" title="Generate a random weather report">if (latitude.HasValue &amp;&amp; longitude.HasValue)
{
    var forecast = new List&lt;WeatherReport&gt;();
    for (var days = 1; days &lt; 6; days++)
    {
        forecast.Add(new WeatherReport(latitude.Value, longitude.Value, days));
    }
    var json = JsonConvert.SerializeObject(forecast, Formatting.Indented);
    context.Response.ContentType = "application/json; charset=utf-8";
    await context.Response.WriteAsync(json);
}
</code></pre>
       <h3 id="build-the-json-response">Build the JSON response.</h3> 
       <p>The final code task on the server is to convert the WeatherReport array into a JSON packet, and send that back to the client. Let's start by creating the JSON packet. You'll add the NewtonSoft JSON Serializer to the list of dependencies. You can do that using the <code>dotnet</code> CLI:</p> 
       <pre><code>dotnet add package Newtonsoft.Json
</code></pre>
       <p>Then, you can use the <code>JsonConvert</code> class to write the object to a string:</p> 
       <pre><code class="lang-csharp" data-src="https://github.com/dotnet/docs/blob/live/samples/csharp/getting-started/WeatherMicroservice/Startup.cs" name="ConvertToJson" title="Convert objects to JSON">var json = JsonConvert.SerializeObject(forecast, Formatting.Indented);
context.Response.ContentType = "application/json; charset=utf-8";
await context.Response.WriteAsync(json);
</code></pre>
       <p>The code above converts the forecast object (a list of <code>WeatherForecast</code> objects) into a JSON packet. After you've constructed the response packet, you set the content type to <code>application/json</code>, and write the string.</p> 
       <p>The application now runs and returns random forecasts.</p> 
       <h2 id="build-a-docker-image">Build a Docker image</h2> 
       <p>Our final task is to run the application in Docker. We'll create a Docker container that runs a Docker image that represents our application.</p> 
       <p>A <strong><em>Docker Image</em></strong> is a file that defines the environment for running the application.</p> 
       <p>A <strong><em>Docker Container</em></strong> represents a running instance of a Docker image.</p> 
       <p>By analogy, you can think of the <em>Docker Image</em> as a <em>class</em>, and the <em>Docker Container</em> as an object, or an instance of that class. </p> 
       <p>The Dockerfile created by the asp.net template will serve for our purposes. Let's go over its contents.</p> 
       <p>The first line specifies the source image:</p> 
       <pre><code>FROM microsoft/dotnet:1.1-sdk-msbuild
</code></pre>
       <p>Docker allows you to configure a machine image based on a source template. That means you don't have to supply all the machine parameters when you start, you only need to supply any changes. The changes here will be to include our application.</p> 
       <p>In this first sample, we'll use the <code>1.1-sdk-msbuild</code> version of the dotnet image. This is the easiest way to create a working Docker environment. This image include the dotnet core runtime, and the dotnet SDK. That makes it easier to get started and build, but does create a larger image.</p> 
       <p>The next five lines setup and build your application:</p> 
       <pre><code>WORKDIR /app

# copy csproj and restore as distinct layers

COPY WeatherMicroservice.csproj .
RUN dotnet restore

# copy and build everything else

COPY . .

# RUN dotnet restore
RUN dotnet publish -c Release -o out
</code></pre>
       <p>This will copy the project file from the current directory to the docker VM, and restore all the packages. Using the dotnet CLI means that the Docker image must include the .NET Core SDK. After that, the rest of your application gets copied, and the dotnet publish command builds and packages your application.</p> 
       <p>The final line of the file runs the application:</p> 
       <pre><code>ENTRYPOINT ["dotnet", "out/WeatherMicroservice.dll", "--server.urls", "http://0.0.0.0:5000"]
</code></pre>
       <p>This configured port is referenced in the <code>--server.urls</code> argument to <code>dotnet</code> on the last line of the Dockerfile. The <code>ENTRYPOINT</code> command informs Docker what command and command line options start the service. </p> 
       <h2 id="building-and-running-the-image-in-a-container">Building and running the image in a container.</h2> 
       <p>Let's build an image and run the service inside a Docker container. You don't want all the files from your local directory copied into the image. Instead, you'll build the application in the container. You'll create a <code>.dockerignore</code> file to specify the directories that are not copied into the image. You don't want any of the build assets copied. Specify the build and publish directories in the <code>.dockerignore</code> file:</p> 
       <pre><code>bin/*
obj/*
out/*
</code></pre>
       <p>You build the image using the docker build command. Run the following command from the directory containing your code.</p> 
       <pre><code class="lang-console">docker build -t weather-microservice .
</code></pre>
       <p>This command builds the container image based on all the information in your Dockerfile. The <code>-t</code> argument provides a tag, or name, for this container image. In the command line above, the tag used for the Docker container is <code>weather-microservice</code>. When this command completes, you have a container ready to run your new service. </p> 
       <p>Run the following command to start the container and launch your service:</p> 
       <pre><code class="lang-console">docker run -d -p 80:5000 --name hello-docker weather-microservice
</code></pre>
       <p>The <code>-d</code> option means to run the container detached from the current terminal. That means you won't see the command output in your terminal. The <code>-p</code> option indicates the port mapping between the service and the host. Here it says that any incoming request on port 80 should be forwarded to port 5000 on the container. Using 5000 matches the port your service is listening on from the command line arguments specified in the Dockerfile above. The <code>--name</code> argument names your running container. It's a convenient name you can use to work with that container. </p> 
       <p>You can see if the image is running by checking the command:</p> 
       <pre><code class="lang-console">docker ps
</code></pre>
       <p>If your container is running, you'll see a line that lists it in the running processes. (It may be the only one).</p> 
       <p>You can test your service by opening a browser and navigating to localhost, and specifying a latitude and longitude:</p> 
       <pre><code>http://localhost/?lat=35.5&amp;long=40.75
</code></pre>
       <h2 id="attaching-to-a-running-container">Attaching to a running container</h2> 
       <p>When you ran your sevice in a command window, you could see diagnostic information printed for each request. You don't see that information when your container is running in detached mode. The Docker attach command enables you to attach to a running container so that you can see the log information. Run this command from a command window:</p> 
       <pre><code class="lang-console">docker attach --sig-proxy=false hello-docker
</code></pre>
       <p>The <code>--sig-proxy=false</code> argument means that <code>Ctrl-C</code> commands do not get sent to the container process, but rather stop the <code>docker attach</code> command. The final argument is the name given to the container in the <code>docker run</code> command. </p> 
       <div class="NOTE">
        <h5>Note</h5>
        <p>You can also use the docker assigned container ID to refer to any container. If you didn't specify a name for your container in <code>docker run</code> you must use the container id.</p> 
       </div> 
       <p>Open a browser and navigate to your service. You'll see the diagnostic messages in the command windows from the attached running container.</p> 
       <p>Press <code>Ctrl-C</code> to stop the attach process.</p> 
       <p>When you are done working with your container, you can stop it:</p> 
       <pre><code class="lang-console">docker stop hello-docker
</code></pre>
       <p>The container and image is still available for you to restart. If you want to remove the container from your machine, you use this command:</p> 
       <pre><code class="lang-console">docker rm hello-docker
</code></pre>
       <p>If you want to remove unused images from your machine, you use this command:</p> 
       <pre><code class="lang-console">docker rmi weather-microservice
</code></pre>
       <h2 id="conclusion">Conclusion</h2> 
       <p>In this tutorial, you built an asp.net core microservice, and added a few simple features.</p> 
       <p>You built a docker container image for that service, and ran that container on your machine. You attached a terminal window to the service, and saw the diagnostic messages from your service.</p> 
       <p>Along the way, you saw several features of the C# language in action.</p> 
      </div>
     </div> 
     <div id="comments-container" ms.cmpgrp="comments" data-bi-name="comments" role="form"></div> 
    </div> 
   </main> 
   <div class="pageActions"> 
    <div id="page-actions" ms.cmpgrp="pageactions" data-bi-name="pageactions" role="complementary"> 
     <div id="page-actions-content"> 
      <ul class="action-list"> 
       <li> <a href="#comments-container" id="comments-link" ms.cmpnm="comments" data-bi-name="comments"> <i class="icon icon-comments"></i>Comments </a> </li> 
       <li id="contenteditbtn"> <a href="https://github.com/dotnet/docs/blob/master/docs/csharp/tutorials/microservices.md" title="Edit This Document" ms.cmpnm="edit" data-bi-name="edit"> <i class="icon icon-editor"></i>Edit </a> </li> 
       <li> <a href="#" class="sharebutton" title="Share This Document" ms.cmpnm="share" data-bi-name="share"><i class="icon icon-share"></i>Share</a> 
        <div class="share-container"> 
         <div>
          <a href="" class="share-twitter" ms.cmpnm="twitter" data-bi-name="twitter"><i class="icon icon-twitter"></i>Twitter</a>
         </div> 
         <div>
          <a href="" class="share-linkedin" ms.cmpnm="share-linkedin" data-bi-name="linkedin"><i class="icon icon-linkedin"></i>LinkedIn</a>
         </div> 
         <div>
          <a href="" class="share-facebook" ms.cmpnm="facebook" data-bi-name="facebook"><i class="icon icon-facebook"></i>Facebook</a>
         </div> 
         <div>
          <a href="" class="share-email" ms.cmpnm="email" data-bi-name="email"><i class="icon icon-email"></i>Email</a>
         </div> 
        </div> </li> 
       <li class="typeSep">|</li> 
       <li> <label for="theme-selector">Theme</label> <select id="theme-selector" data-bi-name="select-theme"> <option value="" class="removedOnload"></option> <option value="">Light</option> <option value="theme_night">Dark</option> </select> </li> 
      </ul> 
      <nav id="side-doc-outline" class="doc-outline" ms.cmpnm="intopic toc" data-bi-name="intopic toc" role="navigation" aria-label="On page navigation"> 
       <h3>In this article</h3> 
      </nav> 
     </div> 
    </div> 
   </div> 
   <ul class="breadcrumbs" ms.cmpgrp="breadcrumb" data-bi-name="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList" role="navigation" aria-label="Breadcrumb">
    <li></li>
   </ul> 
   <div class="sidebar" id="sidebar" ms.cmpgrp="left toc" data-bi-name="left toc" role="navigation" aria-label="Main Navigation" lang="en-us" dir="ltr"> 
    <div id="sidebarContent"> 
     <div class="filterHolder"> 
     </div> 
     <nav class="toc"></nav> 
     <div class="pdfDownloadHolder"></div> 
    </div> 
    <div class="tocSpace"></div> 
   </div> 
   <div id="menu-nav" class="dropdown-container" lang="en-us" dir="ltr"> 
    <div class="dropdown dropdown-full mobilenavi"> 
     <select> </select> 
    </div> 
   </div> 
  </div> 
  <div id="openFeedbackContainer" class="openfeedback-container footer-layout"></div> 
  <div class="container footerContainer"> 
   <footer id="footer" ms.pgarea="footer" data-bi-name="footer" class="footer-layout"> 
    <div class="container" role="contentinfo"> 
     <a data-mscc-ic="false" id="locale-selector-link" href="#" data-bi-name="select-locale" ms.cmpnm="select-locale"></a> 
     <ul class="links" ms.cmpgrp="footerlinks" data-bi-name="footerlinks"> 
      <li><a data-mscc-ic="false" href="https://docs.microsoft.com/teamblog" ms.cmpnm="bloglink" data-bi-name="bloglink">Blog</a></li> 
      <li><a data-mscc-ic="false" href="//privacy.microsoft.com/en-us/" ms.cmpnm="privacy" data-bi-name="privacy">Privacy &amp; Cookies</a></li> 
      <li><a data-mscc-ic="false" href="/en-us/legal/termsofuse" ms.cmpnm="termsofuse" data-bi-name="termsofuse">Terms of Use</a></li> 
      <li><a data-mscc-ic="false" href="//aka.ms/sitefeedback" ms.cmpnm="feedback" data-bi-name="feedback">Feedback</a></li> 
      <li id="impressum-section" hidden><a data-mscc-ic="false" id="impressum-link" href="#" ms.cmpnm="impressum" data-bi-name="impressum">Impressum</a></li> 
      <li><a data-mscc-ic="false" href="https://www.microsoft.com/en-us/legal/intellectualproperty/Trademarks/EN-US.aspx" ms.cmpnm="trademarks" data-bi-name="trademarks">Trademarks</a></li> 
     </ul> 
    </div> 
   </footer> 
  </div> 
  <script src="/_themes/docs.theme/master/en-us/_themes/javascript/870b0825531b1b071dff.conceptual.js"></script>  
 </body>
</html>