<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN" "http://www.w3.org/TR/REC-html40/frameset.dtd">
<!--NewPage-->
<html>
 <head> 
  <!-- Generated by javadoc on Fri Sep 13 09:37:03 PDT 2002 --> 
  <title>
Java Telephony API (JTAPI) Specification&lt;br&gt; Version 1.4 &lt;br&gt;(Final Release): Package javax.telephony
</title> 
  <link REL="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style"> 
 </head> 
 <body bgcolor="white"> 
  <!-- ========== START OF NAVBAR ========== --> 
  <a name="navbar_top">
   <!-- --></a> 
  <table border="0" width="100%" cellpadding="1" cellspacing="0"> 
   <tbody>
    <tr> 
     <td colspan="2" bgcolor="#EEEEFF" class="NavBarCell1"> <a name="navbar_top_firstrow">
       <!-- --></a> 
      <table border="0" cellpadding="0" cellspacing="3"> 
       <tbody>
        <tr align="center" valign="top"> 
         <td bgcolor="#EEEEFF" class="NavBarCell1"> <a href="../../overview-summary.html"><font class="NavBarFont1"><b>Overview</b></font></a>&nbsp;</td> 
         <td bgcolor="#FFFFFF" class="NavBarCell1Rev"> &nbsp;<font class="NavBarFont1Rev"><b>Package</b></font>&nbsp;</td> 
         <td bgcolor="#EEEEFF" class="NavBarCell1"> <font class="NavBarFont1">Class</font>&nbsp;</td> 
         <td bgcolor="#EEEEFF" class="NavBarCell1"> <a href="package-tree.html"><font class="NavBarFont1"><b>Tree</b></font></a>&nbsp;</td> 
         <td bgcolor="#EEEEFF" class="NavBarCell1"> <a href="../../deprecated-list.html"><font class="NavBarFont1"><b>Deprecated</b></font></a>&nbsp;</td> 
         <td bgcolor="#EEEEFF" class="NavBarCell1"> <a href="../../index-all.html"><font class="NavBarFont1"><b>Index</b></font></a>&nbsp;</td> 
         <td bgcolor="#EEEEFF" class="NavBarCell1"> <a href="../../help-doc.html"><font class="NavBarFont1"><b>Help</b></font></a>&nbsp;</td> 
        </tr> 
       </tbody>
      </table> </td> 
     <td align="right" valign="top" rowspan="3"><em> JSR-043: JTAPI-1.4</em> </td> 
    </tr> 
    <tr> 
     <td bgcolor="white" class="NavBarCell2"><font size="-2"> &nbsp;PREV PACKAGE&nbsp; &nbsp;<a href="../../javax/telephony/callcenter/package-summary.html"><b>NEXT PACKAGE</b></a></font></td> 
     <td bgcolor="white" class="NavBarCell2"><font size="-2"> <a href="../../index.html" target="_top"><b>FRAMES</b></a> &nbsp; &nbsp;<a href="package-summary.html" target="_top"><b>NO FRAMES</b></a></font></td> 
    </tr> 
   </tbody>
  </table> 
  <!-- =========== END OF NAVBAR =========== --> 
  <hr> 
  <h2> Package javax.telephony </h2> The Java Telephony API (JTAPI) is a portable, object-oriented application programming interface for Java-based computer-telephony applications. 
  <p> <b>See: </b> <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#package_description"><b>Description</b></a> </p>
  <p> </p>
  <table border="1" cellpadding="3" cellspacing="0" width="100%"> 
   <tbody>
    <tr bgcolor="#CCCCFF" class="TableHeadingColor"> 
     <td colspan="2"><font size="+2"> <b>Interface Summary</b></font></td> 
    </tr> 
    <tr bgcolor="white" class="TableRowColor"> 
     <td width="15%"><b><a href="Address.html"><i>Address</i></a></b></td> 
     <td>An <code>Address</code> object represents what we commonly think of as a "telephone number".</td> 
    </tr> 
    <tr bgcolor="white" class="TableRowColor"> 
     <td width="15%"><b><a href="AddressEvent.html"><i>AddressEvent</i></a></b></td> 
     <td>The <code>AddressEvent</code> interface is the base interface for all Address-related events.</td> 
    </tr> 
    <tr bgcolor="white" class="TableRowColor"> 
     <td width="15%"><b><a href="AddressListener.html"><i>AddressListener</i></a></b></td> 
     <td>The <code>AddressListener</code> interface reports all changes which happen to the Address object.</td> 
    </tr> 
    <tr bgcolor="white" class="TableRowColor"> 
     <td width="15%"><b><a href="AddressObserver.html"><i>AddressObserver</i></a></b></td> 
     <td><b>Deprecated.</b>&nbsp;<i>As of JTAPI 1.4, replaced by <a href="../../javax/telephony/AddressListener.html"><code>AddressListener</code></a></i></td> 
    </tr> 
    <tr bgcolor="white" class="TableRowColor"> 
     <td width="15%"><b><a href="Call.html"><i>Call</i></a></b></td> 
     <td>A <code>Call</code> object models a telephone call.</td> 
    </tr> 
    <tr bgcolor="white" class="TableRowColor"> 
     <td width="15%"><b><a href="CallEvent.html"><i>CallEvent</i></a></b></td> 
     <td>The <code>CallEvent</code> interface is the base interface for all Call-related events.</td> 
    </tr> 
    <tr bgcolor="white" class="TableRowColor"> 
     <td width="15%"><b><a href="CallListener.html"><i>CallListener</i></a></b></td> 
     <td>The <code>CallListener</code> interface reports all changes to the Call object.</td> 
    </tr> 
    <tr bgcolor="white" class="TableRowColor"> 
     <td width="15%"><b><a href="CallObserver.html"><i>CallObserver</i></a></b></td> 
     <td><b>Deprecated.</b>&nbsp;<i>As of JTAPI 1.4, replaced by <a href="../../javax/telephony/CallListener.html"><code>CallListener</code></a></i></td> 
    </tr> 
    <tr bgcolor="white" class="TableRowColor"> 
     <td width="15%"><b><a href="Connection.html"><i>Connection</i></a></b></td> 
     <td>A <code>Connection</code> represents a link (i.e. an association) between a <a href="../../javax/telephony/Call.html"><code>Call</code></a> object and an <a href="../../javax/telephony/Address.html"><code>Address</code></a> object.</td> 
    </tr> 
    <tr bgcolor="white" class="TableRowColor"> 
     <td width="15%"><b><a href="ConnectionEvent.html"><i>ConnectionEvent</i></a></b></td> 
     <td>The <code>ConnectionEvent</code> interface is the base event interface for all Connection-related events.</td> 
    </tr> 
    <tr bgcolor="white" class="TableRowColor"> 
     <td width="15%"><b><a href="ConnectionListener.html"><i>ConnectionListener</i></a></b></td> 
     <td>This interface is an extension of the <code>CallListener</code> interface, and reports state changes both of the Call and its Connections.</td> 
    </tr> 
    <tr bgcolor="white" class="TableRowColor"> 
     <td width="15%"><b><a href="Event.html"><i>Event</i></a></b></td> 
     <td>The <code>Event</code> interface is the parent of all JTAPI event interfaces.</td> 
    </tr> 
    <tr bgcolor="white" class="TableRowColor"> 
     <td width="15%"><b><a href="JtapiPeer.html"><i>JtapiPeer</i></a></b></td> 
     <td>The <code>JtapiPeer</code> interface represents a vendor's particular implementation of the Java Telephony API.</td> 
    </tr> 
    <tr bgcolor="white" class="TableRowColor"> 
     <td width="15%"><b><a href="MetaEvent.html"><i>MetaEvent</i></a></b></td> 
     <td>The <code>MetaEvent</code> interface is the base interface for all JTAPI Meta events.</td> 
    </tr> 
    <tr bgcolor="white" class="TableRowColor"> 
     <td width="15%"><b><a href="MultiCallMetaEvent.html"><i>MultiCallMetaEvent</i></a></b></td> 
     <td>The <code>MultiCallMetaEvent</code> interface is the base interface for all multiple-call Call Meta events (multi-call MetaEvent).</td> 
    </tr> 
    <tr bgcolor="white" class="TableRowColor"> 
     <td width="15%"><b><a href="Provider.html"><i>Provider</i></a></b></td> 
     <td>A <code>Provider</code> represents the telephony software-entity that interfaces with a telephony subsystem.</td> 
    </tr> 
    <tr bgcolor="white" class="TableRowColor"> 
     <td width="15%"><b><a href="ProviderEvent.html"><i>ProviderEvent</i></a></b></td> 
     <td>The <code>ProviderEvent</code> interface is the base interface for all Provider related events.</td> 
    </tr> 
    <tr bgcolor="white" class="TableRowColor"> 
     <td width="15%"><b><a href="ProviderListener.html"><i>ProviderListener</i></a></b></td> 
     <td>The <code>ProviderListener</code> interface reports all changes which happen to the Provider object.</td> 
    </tr> 
    <tr bgcolor="white" class="TableRowColor"> 
     <td width="15%"><b><a href="ProviderObserver.html"><i>ProviderObserver</i></a></b></td> 
     <td><b>Deprecated.</b>&nbsp;<i>As of JTAPI 1.4, replaced by <a href="../../javax/telephony/ProviderListener.html"><code>ProviderListener</code></a></i></td> 
    </tr> 
    <tr bgcolor="white" class="TableRowColor"> 
     <td width="15%"><b><a href="SingleCallMetaEvent.html"><i>SingleCallMetaEvent</i></a></b></td> 
     <td>The <code>SingleCallMetaEvent</code> interface is the base interface for all single-call Call Meta events.</td> 
    </tr> 
    <tr bgcolor="white" class="TableRowColor"> 
     <td width="15%"><b><a href="Terminal.html"><i>Terminal</i></a></b></td> 
     <td>A <code>Terminal</code> represents a physical hardware endpoint connected to the telephony domain.</td> 
    </tr> 
    <tr bgcolor="white" class="TableRowColor"> 
     <td width="15%"><b><a href="TerminalConnection.html"><i>TerminalConnection</i></a></b></td> 
     <td>The <code>TerminalConnection</code> represents the relationship between a Connection and a Terminal.</td> 
    </tr> 
    <tr bgcolor="white" class="TableRowColor"> 
     <td width="15%"><b><a href="TerminalConnectionEvent.html"><i>TerminalConnectionEvent</i></a></b></td> 
     <td>The <code>TerminalConnectionEvent</code> interface is the base event interface for all TerminalConnection-related events.</td> 
    </tr> 
    <tr bgcolor="white" class="TableRowColor"> 
     <td width="15%"><b><a href="TerminalConnectionListener.html"><i>TerminalConnectionListener</i></a></b></td> 
     <td>This interface is an extension of the <code>ConnectionListener</code> interface, and reports state changes of the Call, its Connections and its TerminalConnections.</td> 
    </tr> 
    <tr bgcolor="white" class="TableRowColor"> 
     <td width="15%"><b><a href="TerminalEvent.html"><i>TerminalEvent</i></a></b></td> 
     <td>The <code>TerminalEvent</code> interface is the base interface for all Terminal- related events.</td> 
    </tr> 
    <tr bgcolor="white" class="TableRowColor"> 
     <td width="15%"><b><a href="TerminalListener.html"><i>TerminalListener</i></a></b></td> 
     <td>The <code>TerminalListener</code> interface reports all changes which happen to the Terminal object.</td> 
    </tr> 
    <tr bgcolor="white" class="TableRowColor"> 
     <td width="15%"><b><a href="TerminalObserver.html"><i>TerminalObserver</i></a></b></td> 
     <td><b>Deprecated.</b>&nbsp;<i>As of JTAPI 1.4, replaced by <a href="../../javax/telephony/TerminalListener.html"><code>TerminalListener</code></a></i></td> 
    </tr> 
   </tbody>
  </table> &nbsp; 
  <p> </p>
  <table border="1" cellpadding="3" cellspacing="0" width="100%"> 
   <tbody>
    <tr bgcolor="#CCCCFF" class="TableHeadingColor"> 
     <td colspan="2"><font size="+2"> <b>Class Summary</b></font></td> 
    </tr> 
    <tr bgcolor="white" class="TableRowColor"> 
     <td width="15%"><b><a href="JtapiPeerFactory.html">JtapiPeerFactory</a></b></td> 
     <td>The <code>JtapiPeerFactory</code> class is a class by which applications obtain a Provider object.</td> 
    </tr> 
   </tbody>
  </table> &nbsp; 
  <p> </p>
  <table border="1" cellpadding="3" cellspacing="0" width="100%"> 
   <tbody>
    <tr bgcolor="#CCCCFF" class="TableHeadingColor"> 
     <td colspan="2"><font size="+2"> <b>Exception Summary</b></font></td> 
    </tr> 
    <tr bgcolor="white" class="TableRowColor"> 
     <td width="15%"><b><a href="InvalidArgumentException.html">InvalidArgumentException</a></b></td> 
     <td>An <code>InvalidArgumentException</code> indicates an argument passed to the method is invalid.</td> 
    </tr> 
    <tr bgcolor="white" class="TableRowColor"> 
     <td width="15%"><b><a href="InvalidPartyException.html">InvalidPartyException</a></b></td> 
     <td>An <code>InvalidPartyException</code> indicates that a party given as an argument to the method call was invalid.</td> 
    </tr> 
    <tr bgcolor="white" class="TableRowColor"> 
     <td width="15%"><b><a href="InvalidStateException.html">InvalidStateException</a></b></td> 
     <td>An <code>InvalidStateException</code> indicates the current state of an object involved in the method invocation does not meet the acceptable pre-conditions for the method.</td> 
    </tr> 
    <tr bgcolor="white" class="TableRowColor"> 
     <td width="15%"><b><a href="JtapiPeerUnavailableException.html">JtapiPeerUnavailableException</a></b></td> 
     <td>The <code>JtapiPeerUnavailableException</code> indicates that the JtapiPeer (that is, a particular implementation of JTAPI) is unavailable on the current system.</td> 
    </tr> 
    <tr bgcolor="white" class="TableRowColor"> 
     <td width="15%"><b><a href="MethodNotSupportedException.html">MethodNotSupportedException</a></b></td> 
     <td>The <code>MethodNotSupportedException</code> indicates that the method which was invoked is not supported by the implementation.</td> 
    </tr> 
    <tr bgcolor="white" class="TableRowColor"> 
     <td width="15%"><b><a href="PlatformException.html">PlatformException</a></b></td> 
     <td>A <code>PlatformException</code> indicates an implementation-specific exception.</td> 
    </tr> 
    <tr bgcolor="white" class="TableRowColor"> 
     <td width="15%"><b><a href="PrivilegeViolationException.html">PrivilegeViolationException</a></b></td> 
     <td>A <code>PrivilegeViolationException</code> indicates that an action pertaining to a certain object failed because the application did not have the proper security permissions to execute that command.</td> 
    </tr> 
    <tr bgcolor="white" class="TableRowColor"> 
     <td width="15%"><b><a href="ProviderUnavailableException.html">ProviderUnavailableException</a></b></td> 
     <td>The <code>ProviderUnavailableException</code> indicates that the Provider is currently not available to the application.</td> 
    </tr> 
    <tr bgcolor="white" class="TableRowColor"> 
     <td width="15%"><b><a href="ResourceUnavailableException.html">ResourceUnavailableException</a></b></td> 
     <td>The <code>ResourceUnavailableException</code> indicates that a resource inside the system in not available to complete an operation.</td> 
    </tr> 
   </tbody>
  </table> &nbsp; 
  <p> <a name="package_description">
    <!-- --></a></p>
  <h2> Package javax.telephony Description </h2> 
  <p> </p>
  <p>The Java Telephony API (JTAPI) is a portable, object-oriented application programming interface for Java-based computer-telephony applications. </p> 
  <h1>The Java<font size="2"><sup><tt>TM</tt></sup></font> Telephony API </h1> 
  <h2>Introduction </h2> 
  <p>JTAPI serves a broad audience, from call center application developers to web page designers. JTAPI supports both first- and third-party telephony application domains. The API is designed to make programming simple applications easy, while providing those features necessary for advanced telephony applications. </p> 
  <p>The Java Telephony API is, in fact, a set of API's. The "core" API provides the basic <em>call model</em> and rudimentary telephony features, such as placing telephone calls and answering telephone calls. The core API is surrounded by standard extension APIs providing functionality for specific telephony domains, such as call centers and media stream access. The JTAPI core and extension package architectures are described later in this document. </p> 
  <p>Applications written using the Java Telephony API are portable across the various computer platforms and telephone systems. Implementations of JTAPI will be available for existing computer-telephony integration platforms such as Sun Microsystem's SunXTL<font size="1"><sup>TM</sup></font>, Microsoft and Intel's TAPI, Novell and Avaya's TSAPI, and IBM's CallPath. Additionally, independent hardware vendors may choose to provide implementations of the Java Telephony API on top of their own proprietary hardware. </p> 
  <p><br> </p> 
  <h3>Overview Document Organization </h3> 
  <p>This document is organized into the following sections: </p> 
  <table border="0" cellpadding="2" width="100%"> 
   <tbody>
    <tr> 
     <td width="20%"><a href="#FEATURES">Java Telephony API Features</a> </td> 
     <td width="80%">Describes the features of JTAPI and the principles on which it was designed. </td> 
    </tr> 
    <tr> 
     <td width="20%"><a href="#CONFIGURATIONS">Supported Configurations</a> </td> 
     <td width="80%">Summarizes the environments in which JTAPI may be used and the computer and software configurations for which it was designed. </td> 
    </tr> 
    <tr> 
     <td width="20%"><a href="#ARCHITECTURE">Java Telephony Package Architecture</a> </td> 
     <td width="80%">Summarizes how the Java Telephony API is organized into various Java language packages. A brief description accompanies each package along with links to more detailed documentation. </td> 
    </tr> 
    <tr> 
     <td width="20%"><a href="#CALLMODEL">The Java Telephony Call Model</a> </td> 
     <td width="80%">Describes how telephone calls and different objects that make up telephone calls are represented in this API. </td> 
    </tr> 
    <tr> 
     <td width="20%"><a href="#COREMETHODS">Core Package Methods</a> </td> 
     <td width="80%">Provides a brief summary of the key methods available in the core package which perform the most basic telephony operations, such as placing a telephone call, answering a telephone call, and disconnecting a connection to a telephone call. </td> 
    </tr> 
    <tr> 
     <td width="20%"><a href="#CONNECTIONSTATES">Connection Object States</a> </td> 
     <td width="80%">Describes the states in which the Connection object can exist. It provides a description of the allowable transitions from each state. </td> 
    </tr> 
    <tr> 
     <td width="20%"><a href="#TERMINALCONNECTIONSTATES">TerminalConnection Object States</a> </td> 
     <td width="80%">Describes the states in which the TerminalConnection object can exist. It provides a description of the allowable transitions from each state. </td> 
    </tr> 
    <tr> 
     <td width="20%"><a href="#PLACINGCALL">Placing a Telephone Call</a> </td> 
     <td width="80%">One of the most common features used in any telephony API is placing a telephone call. This section describes the JTAPI method invocations required to place a telephone call, and examines state changes in the call model. This analysis will explain how calls are placed, answered, and terminated. </td> 
    </tr> 
    <tr> 
     <td width="20%"><a href="#EVENTDELIVERY">The Java Telephony Event Delivery Model</a> </td> 
     <td width="80%">Describes the JTAPI event delivery model - the Listener model (formerly the Observer model). Applications use listeners for asynchronous notification of changes in the state of the JTAPI call model.</td> 
    </tr> 
    <tr> 
     <td width="20%"><a href="#EXAMPLES">Application Code Examples</a> </td> 
     <td width="80%">Provides two real-life code examples using the Java Telephony API. One example places a telephone call to a specified telephone number. The other example shows a designated Terminal answering an incoming telephone call. </td> 
    </tr> 
    <tr> 
     <td width="20%"><a href="#PROVIDER">Locating and Obtaining Providers</a> </td> 
     <td width="80%">Describes the manner in which applications create and obtain JTAPI Provider objects. </td> 
    </tr> 
    <tr> 
     <td width="20%"><a href="#SECURITY">Security</a> </td> 
     <td width="80%">Summarizes the JTAPI security strategy. </td> 
    </tr> 
   </tbody>
  </table> 
  <h3>History of the Java Telephony API </h3> 
  <p>The Java Telephony API specification represents the combined efforts of design teams from Sun Microsystems, Avaya, Nortel, Novell, Intel, and IBM, operating under the direction of JavaSoft on versions 1.0 and 1.1, and teams from Sun Microsystems, Avaya, Nortel, IBM, Siemens, and Dialogic, working within the Enterprise Computer Telephony Forum on version 1.2.</p> 
  <p>Major contributors to the ECTF experts group for release 1.3 were Nortel, Dialogic, Nokia, Avaya and IBM; major contributors to release 1.4 effort were Avaya, Dialogic, IBM, Netergy Networks, Pingtel and OpenComm do Brasil Ltda.</p> 
  <p>The Java Telephony API version 1.0 specification was released to the public on November 1, 1996. Version 1.1 was released to the public on February 1, 1997; version 1.2 was released to the public in December 1997; version 1.3 was released for early access on April 7, 1999., and its final public release was on July 23, 1999; version 1.4 was released for public review on June 18, 2001, and the final release is expected in Sept of 2001.</p> 
  <table border="1" align="center"> 
   <tbody>
    <tr> 
     <th> Release </th> 
     <th> Early Release Date </th> 
     <th> Final Public Release Date </th> 
    </tr> 
    <tr>
     <td> 1.0 </td>
     <td> </td>
     <td> November 1 1996 </td>
    </tr> 
    <tr>
     <td> 1.1 </td>
     <td> </td>
     <td> February 1, 1997 </td>
    </tr> 
    <tr>
     <td> 1.2 </td>
     <td> </td>
     <td> December 1997 </td>
    </tr> 
    <tr>
     <td> 1.3 </td>
     <td> April 7, 1999 </td>
     <td> July 23, 1999 </td>
    </tr> 
    <tr>
     <td> 1.4 </td>
     <td> June 18, 2001 </td>
     <td> Sept 18, 2001 </td>
    </tr> 
   </tbody>
  </table> 
  <h2><a name="FEATURES">Java Telephony Features</a> </h2> 
  <p>The features and guiding design principles for the Java Telephony API are: </p> 
  <ul> 
   <li>Brings simplicity to the most basic telephony applications </li> 
   <li>Provides a scalable framework that spans desktop applications to distributed call center telephony applications </li> 
   <li>Interfaces applications directly to service providers or acts as a Java interface to existing telephony APIs, such as TSAPI and TAPI<font size="1"><sup>TM</sup></font> </li> 
   <li>Based on a simple core that is augmented with standard extension packages </li> 
   <li>Runs on a wide range of hardware configurations, wherever Java run-time can be used </li> 
  </ul> 
  <h2><a name="CONFIGURATIONS">Supported Configurations</a> </h2> 
  <p>JTAPI runs on a variety of system configurations, including centralized servers with direct access to telephony resources, and remote network computers with access to telephony resources over a network. In the first configuration, a network computer is running the JTAPI application and is accessing telephony resources over a network, as illustrated in <a href="#NETWORKCOMPUTER">Figure 1.</a> In the second configuration, the application is running on a computer with its own telephony resources, as illustrated in <a href="#DESKTOPCOMPUTER">Figure 2.</a> </p> 
  <h3><a name="NETWORKCOMPUTER">Network Computer (NC) Configuration </a></h3> 
  <p>In a network configuration, the JTAPI application or Java applet runs on a remote workstation. This workstation can be a network computer with only a display, keyboard, processor, and some memory. It accesses network resources, making use of a centralized server that manages telephony resources. JTAPI communicates with this server via a remote communication mechanism, such as Java's Remote Method Invocation (RMI) or a telephony protocol. The following diagram shows this configuration. </p> 
  <p align="center"><img src="doc-files/network.gif" alt="Network diagram" width="324" height="324"> </p> 
  <p align="center"><strong>Figure 1: Network Configuration </strong></p> 
  <h3><a name="DESKTOPCOMPUTER">Desktop Computer Configuration</a> </h3> 
  <p>In a desktop configuration, the JTAPI application or Java applet runs on the same workstation that houses the telephony resources. The following diagram shows the desktop configuration. </p> 
  <p align="center"><img src="doc-files/desktop.gif" alt="Desktop configuration" width="229" height="162"> </p> 
  <p align="center"><strong>Figure 2: Desktop Configuration </strong></p> 
  <p><br> <br> </p> 
  <h2><a name="ARCHITECTURE">Java Telephony Package Architecture </a></h2> 
  <p>The Java Telephony API is composed of a set of Java language <em>packages.</em> Each package provides a specific piece of functionality for a certain aspect of computer-telephony applications. Implementations of telephony servers choose the packages they support, depending upon the capabilities of their underlying platform and hardware. Applications may query for the packages supported by the implementation they are currently using. Additionally, application developers may concern themselves with only the supported packages applications need to accomplish a task. The diagram below depicts the architecture of the JTAPI packages. </p> 
  <p align="center"><img src="doc-files/packages.gif" alt="JTAPI package architecture" width="595" height="259"> </p> 
  <p align="center">Figure 3: Core/Extension Package Relationship </p> 
  <p>At the center of the Java Telephony API is the "core" package. The core package provides the basic framework to model telephone calls and rudimentary telephony features. These features include placing a telephone call, answering a telephone call, and disconnecting a connection to a telephone call. Simple telephony applications will only need to use the core to accomplish their tasks, and do not need to concern themselves with the details of other packages. For example, the core package permits applet designers to add telephone capabilities to a Web page with ease. </p> 
  <p>A number of "standard extension" packages extend the JTAPI core package . These extension packages each bring additional telephony functionality to the API. Currently, the following extension packages exist for this API: call control, call center, media, phone, private data, and capabilities packages. Each package is summarized below in terms of the features it brings to JTAPI, and is linked to a separate overview document and specifications. </p> 
  <p>The JTAPI package architecture is a two-way street for both implementations and applications. In other words, telephony server implementations choose which extension packages (in addition to the core package) they implement, based upon the capabilities of the underlying hardware. Applications choose the extension packages (in addition to the core package) they need to use to accomplish the desired tasks of the application. Applications may query the implementation for the extension packages the implementation supports, and the application developer does not need to concern himself/herself with the details of any packages not needed for the application. </p> 
  <p><br> </p> 
  <h3>Java Telephony Standard Extension Packages </h3> 
  <p>Each JTAPI extension package has its own specification describing its extensions to the core API, and in most cases has its own separate overview document describing it. The chart below lists each extension package available, with a link to the individual overview document, if it exists. </p> 
  <table border="0" cellpadding="2" width="100%"> 
   <tbody>
    <tr> 
     <td width="20%"><a href="callcontrol/package-summary.html">Call Control Package</a> </td> 
     <td width="80%">The <em><strong>javax.telephony.callcontrol</strong></em> package extends the core package by providing more advanced call-control features such as placing calls on hold, transferring telephone calls, and conferencing telephone calls. This package also provides a more detailed state model of telephone calls. </td> 
    </tr> 
    <tr> 
     <td width="20%"><a href="callcenter/package-summary.html">Call Center Package</a> </td> 
     <td width="80%">The <em><strong>javax.telephony.callcenter</strong></em> package provides applications the ability to perform advanced features necessary for managing large call centers. Examples of these advanced features include: Routing, Automated Call Distribution (ACD), Predictive Calling, and associating application data with telephony objects. </td> 
    </tr> 
    <tr> 
     <td width="20%"><a href="media/package-summary.html">Media Package</a> </td> 
     <td width="80%">The <em><strong>javax.telephony.media</strong></em> Package enables applications to manipulate the content of the media streams associated with a telephone call. Applications can easily generate and detect DTMF (and other) tones, play and record prompts and messages, even use Automatic Speech Recognition (ASR) and Text-to-Speech technologies. </td> 
    </tr> 
    <tr> 
     <td width="20%"><a href="phone/package-summary.html">Phone Package</a> </td> 
     <td width="80%">The <em><strong>javax.telephony.phone</strong></em> package permits applications to control the physical features of telephone hardware phone sets. Implementations may describe Terminals as collections of components, where each of these component-types has interfaces in this package. </td> 
    </tr> 
    <tr> 
     <td width="20%">Capabilities Package </td> 
     <td width="80%">The <em><strong>javax.telephony.capabilities</strong></em> package allows applications to query whether certain actions may be performed. Capabilities take two forms: <em>static</em> capabilities indicate whether an implementation supports a feature; <em>dynamic</em> capabilities indicate whether a certain action is allowable given the current state of the call model. </td> 
    </tr> 
    <tr> 
     <td width="20%">Private Data Package </td> 
     <td width="80%">The <em><strong>javax.telephony.privatedata</strong></em> package enables applications to communicate data directly with the underlying hardware switch. This data may be used to instruct the switch to perform a switch-specific action. Applications may also use the package to "piggy-back" a piece of data with a Java Telephony API object. </td> 
    </tr> 
   </tbody>
  </table> 
  <p><br> <br> </p> 
  <h2><a name="CALLMODEL">The Java Telephony Call Model </a></h2> 
  <p>The JTAPI <em>call model</em> consists of a half-dozen Java objects. These objects are defined using Java interfaces in the core package. Each call model object represents either a physical or logical entity in the telephone world. The primary purpose of these call model objects is to describe telephone calls and the endpoints involved in a telephone call. These call model objects are related to one another in specific ways, which are summarized below and described in more detail in the core package specification. </p> 
  <p>The following diagram shows the JTAPI call model and the objects that compose the call model. A description of each object follow the diagram. </p> 
  <p align="center"><img src="doc-files/cmodel.gif" alt="Call Model" width="468" height="504"> </p> 
  <p align="center"><strong>Figure 4: JTAPI Call Model </strong></p> 
  <h3>Provider Object </h3> 
  <p>The Provider object is an abstraction of telephony service-provider software. The provider might manage a PBX connected to a server, a telephony/fax card in a desktop machine, or a computer networking technology, such as IP. A Provider hides the service-specific aspects of the telephony subsystem and enables Java applications and applets to interact with the telephony subsystem in a device-independent manner. </p> 
  <h3>Call Object </h3> 
  <p>The Call object represents a telephone call, the information flowing between the service provider and the call participants. A telephone call comprises a Call object and zero or more connections. In a two-party call scenario, a telephone call has one Call object and two connections. A conference call is three or more connections associated with one Call object. </p> 
  <h3>Address Object </h3> 
  <p>The Address object represents a telephone number. It is an abstraction for the logical endpoint of a telephone call. Note that this is quite distinct from a physical endpoint. In fact, one address may correspond to several physical endpoints (i.e. Terminals) </p> 
  <h3>Connection Object </h3> 
  <p>A Connection object models the communication link between a Call object and an Address object. This relationship is also referred to as a "logical" view, because it is concerned with the relationship between the Call and the Address (i.e. a logical endpoint). Connection objects may be in one of several states, indicating the current state of the relationship between the Call and the Address. These Connection states are summarized later. </p> 
  <h3>Terminal Object </h3> 
  <p>The Terminal object represents a physical device such as a telephone and its associated properties. Each Terminal object may have one or more Address Objects (telephone numbers) associated with it, as in the case of some office phones capable of managing multiple call appearances. The Terminal is also known as the "physical" endpoint of a call, because it corresponds to a physical piece of hardware. </p> 
  <h3>TerminalConnection Object </h3> 
  <p>TerminalConnection objects model the relationship between a Connection and the physical endpoint of a Call, which is represented by the Terminal object. This relationship is also known as the "physical" view of the Connection (in contrast to the Connection, which models the logical view). The TerminalConnection describes the current state of relationship between the Connection and a particular Terminal. The states associated with the TerminalConnection are described later in this document. </p> 
  <p><br> <br> </p> 
  <h2><a name="COREMETHODS">Core Package Methods </a></h2> 
  <p>The core package defines three methods to support its primary features: placing a telephone call, answering a telephone call, and disconnecting a connection to a telephone call. These methods are <strong>Call.connect()</strong>, <strong>TerminalConnection.answer()</strong>, and <strong>Connection.disconnect()</strong>, respectively. </p> 
  <h3>Call.connect() </h3> 
  <p>Once an application has an idle call object (obtained via <strong>Provider.createCall()</strong>), it may place a telephone call using the <strong>Call.connect()</strong> method. The application must specify the originating Terminal (physical endpoint) and the originating Address (logical endpoint) on that Terminal (in the case that a Terminal has multiple telephone numbers on it). It also provides the destination telephone number string. Two Connection objects are returned from the <strong>Call.connect()</strong> method, representing the originating and destination ends of the telephone call. </p> 
  <h3>TerminalConnection.answer() </h3> 
  <p>Applications monitor with listeners (discussed later) on Terminals for when incoming calls are presented. An incoming telephone call to a Terminal is indicated by a TerminalConnection to that Terminal in the RINGING state (see TerminalConnection states below). At that time, applications may invoke the <strong>TerminalConnection.answer()</strong> to answer that incoming telephone call. </p> 
  <h3>Connection.disconnect() </h3> 
  <p>The <strong>Connection.disconnect()</strong> method is used to remove an Address from the telephone call. The Connection object represents the relationship of that Address to the telephone call. Applications typically invoke this method when the Connection is in the CONNECTED state, resulting in the Connection moving to the DISCONNECTED state. In the core package, application may only remove entire Addresses from the Call, and all of the Terminals associated with that Address which are part of the call are removed as well. The call control extension package provides the ability for application to remove individual Terminals only from the Call. </p> 
  <p><br> <br> </p> 
  <h2><a name="CONNECTIONSTATES">Connection Object States </a></h2> 
  <p>A Connection object is always in a <em>state</em> that reflects the relationship between a Call and an Address. The state in which a Connection exists is not only important to the application for information purposes, it is always an indication of which methods and actions can be invoked on the Connection object. </p> 
  <p>The state changes which Connection objects undergo are governed by rules shown below in a state transition diagram. This diagram guarantees to application developers the possible states in which the Connection object can transition given some current state. These state transition rules are invaluable to application developers. The diagram below shows the possible state transitions for the Connection object. Following this diagram is a brief summary of the meaning of each state. </p> 
  <p align="center"><img src="doc-files/core-connectionstates.gif" alt="Summary of states" width="460" height="298"> </p> 
  <p align="center">Figure 5: Connection State Transitions </p> 
  <h3>IDLE state </h3> 
  <p>The IDLE state is the initial state for all new Connection objects. Connections typically transition quickly out of the IDLE state into another state. A Connection in the IDLE state indicates that the party has just joined the telephone call in some form. No Core methods are valid on Connections in the IDLE state. </p> 
  <h3>INPROGRESS state </h3> 
  <p>The INPROGRESS state indicates that a telephone call is currently being placed to this destination endpoint. </p> 
  <h3>ALERTING state </h3> 
  <p>The ALERTING state indicates that the destination party of a telephone call is being alerted to an incoming telephone call. </p> 
  <h3>CONNECTED state </h3> 
  <p>The CONNECTED state indicates that a party is actively part of a telephone call. A Connection in the CONNECTED state implies that the associated party is talking to the other parties on the call or is connected to tone. </p> 
  <h3>DISCONNECTED state </h3> 
  <p>The DISCONNECTED state indicates that a party is no longer a part of a telephone call. No methods are valid for Connections in the DISCONNECTED state. </p> 
  <h3>FAILED state </h3> 
  <p>The FAILED state indicates that a telephone call placed to the endpoint has failed. For example, if an application uses Call.connect() to place a telephone call to a party who is busy, the Connection associated with the called party transitions into the FAILED state. </p> 
  <h3>UNKNOWN state </h3> 
  <p>The UNKNOWN state indicates that the Provider cannot determine the state of the Connection at the present time. A Connection may transition in and out of the UNKNOWN state at any time, unless it is in either the DISCONNECTED or FAILED state. The effects of the invocation of any method on a Connection in this state are unpredictable. </p> 
  <p><br> <br> </p> 
  <h2><a name="TERMINALCONNECTIONSTATES">TerminalConnection Object States </a></h2> 
  <p>The TerminalConnection object represents the relationship between a Terminal and a Connection. As mentioned previously, these objects represent a physical view of the Call, describing which physical Terminal endpoints are part of the telephone call. Similar to Connection objects, TerminalConnection objects have their own set of states and state transition diagram. This state transition diagram, with a brief description of each state follows. </p> 
  <p align="center"><img src="doc-files/core-terminalconnectionstates.gif" alt="State transition diagram" width="398" height="288"> </p> 
  <p align="center">Figure 6: TerminalConnection state transitions </p> 
  <h3>IDLE state </h3> 
  <p>The IDLE state is the initial state for all TerminalConnection objects. It has the same connotation for the Connection object's IDLE state. </p> 
  <h3>ACTIVE state </h3> 
  <p>The ACTIVE state indicates a Terminal is actively part of a telephone call. This often implies that the Terminal handset is off-hook. </p> 
  <h3>RINGING state </h3> 
  <p>The RINGING state indicates that a Terminal is signaling to a user that an incoming telephone call is present at the Terminal. </p> 
  <h3>DROPPED state </h3> 
  <p>The DROPPED state indicates that a Terminal was once part of a telephone call, but has since dropped off of that telephone call. The DROPPED state is the final state for all TerminalConnections. </p> 
  <h3>PASSIVE state </h3> 
  <p>The PASSIVE state indicates a Terminal is part of a telephone call, but not actively so. A TerminalConnection in the PASSIVE state indicates that a resource on the Terminal is being used by this telephone call. Packages providing advanced features permit Terminals to join calls from the PASSIVE state. </p> 
  <h3>UNKNOWN state </h3> 
  <p>The UNKNOWN state indicates that the Provider is unable to determine the current state of a TerminalConnection. It has a similar connotation to that of the Connection object's UNKNOWN state. </p> 
  <p><br> <br> </p> 
  <h2><a name="PLACINGCALL">Placing a Telephone Call</a> </h2> 
  <p>The past several sections have outlines the JTAPI call model, the essential methods in the core package, and the Connection and TerminalConnection states. This section ties all of this information together, presenting a common scenario found in most telephony applications. This section describes the state changes the entire call model typically undergoes when an application places a simple telephone call. Readers will come away with a coherent understanding of the call model changes for this simple example. </p> 
  <p>The vehicle used to describe the state changes undergone by the call model is the diagram below. This diagram is a <em>call model timing diagram</em>, where changes in the various objects are depicted as times increases down the vertical axis. Such a diagram is given below describing the typical state changes after an application invokes the <strong>Call.connect()</strong> method. </p> 
  <p align="center"><img src="doc-files/timeline.gif" alt="Typical state change" width="454" height="360"> </p> 
  <p align="center">Figure 7: Call Model timing diagram </p> 
  <p>In the diagram above, discrete time steps are denoted by integers down the vertical axis. Time increases down this axis,but the integers are not meant to indicate real (clock) time. </p> 
  <p>This diagram, as a whole, represents a single telephone Call. In this case, the diagram represents a two-party telephone call (The <strong>Call.connect()</strong> method always results in a two-party call). The diagram may be broken into two parts: the left half and the right half. The left half represents the originating-end of the telephone call and the right half represents the destination-end of the telephone call. </p> 
  <p>On the left-hand (originating) side of the diagram, the two vertical lines represent the originating Terminal and Address (which are arguments to the <strong>Call.connect()</strong> method) objects, as indicated on the diagram. The horizontal lines represent either Connection objects or TerminalConnection objects as marked. Note that the Connection objects are drawn in the inner- most regions, whereas the TerminalConnection objects are drawn in the outer- most regions. </p> 
  <p>Similarly, on the right-hand (destination) side of the diagram, the two vertical lines represent the destination Address and Terminals. In this example, there are two destination Terminals associated with the destination Address. This configuration has been depicted previously in Figure 4. Note that since there are two Terminals, there are two TerminalConnection objects on the destination side. </p> 
  <p>This diagram can be read as follows: as time passes the Connection and TerminalConnection objects change states. The appearance of a new Connection or TerminalConnection horizontal line corresponds to a new object of that type being created. </p> 
  <p>In the example of placing a telephone call, we see that after the two Connections are created in the IDLE state, the originating Connection transitions to the CONNECTED state, while the destination Connection transitions to the INPROGRESS state. At that time, a TerminalConnection to the originating Terminal is created and transitions to the ACTIVE state. When the destination Connection transitions to the ALERTING state, two TerminalConnections are created in the RINGING state. </p> 
  <p>At this point, a person at one of the destination Terminals answers the call. When this happens, that TerminalConnection moves to the ACTIVE state, and the other TerminalConnection moves to the PASSIVE state. At the same time, the destination Connection concurrently moves to the CONNECTED state. When the telephone call ends, all Connections move to the DISCONNECTED state, and all TerminalConnections move to the DROPPED state. </p> 
  <p>As a final point, this document has used the terms "logical" and "physical" view of a telephone call. This diagram makes these concepts clear. An application can monitor the state changes of the Connection object (i.e. the logical view). By looking at the diagram, the reader can understand that these states provide a higher-level view of the progress of the telephone call. The TerminalConnection state changes represent the physical view. By monitoring the TerminalConnection state changes, applications can find out what is happening at each physical endpoint.</p> 
  <p><br> <br> </p> 
  <h2><a name="EVENTDELIVERY">The Java Telephony Event Delivery Model </a></h2> 
  <h3>Introduction</h3> 
  <p>The Java Telephony API asynchronously notifies applications of various changes in the JTAPI call model. These changes may include the state change of an object or the creation of an object. </p> 
  <h3>Listeners and Observers</h3> 
  <p>Prior to JTAPI release 1.3, the Java observer/observable model was the pattern that JTAPI applications could follow to receive events from a JTAPI implementation using the JTAPI API.</p> 
  <p>With JTAPI releases 1.3 (packages Core, Media, Mobile) and 1.4 (packages Callcontrol, Callcenter, Phone, Private), applications could transition to using an event delivery scheme based in spirit on <a href="http://java.sun.com/products/jdk/1.2/docs/guide/awt/designspec/events.html#919734"> the Java 1.1 delegation-based event model</a> (or "Listener model"). JTAPI releases 1.3 and 1.4 also include the Observer methods and events, but deprecate them. </p> 
  <h3>Listener Interfaces and Events</h3> 
  <p> An application defines an object which implements all the methods defined in a particular Listener interface; then the application may present that object as a Listener for that interface. </p> 
  <p>The JTAPI Listener model defines <i>Listener interfaces</i>. It goes further to define <i>JTAPI events</i>, extended from <a href="javax/telephony/Event.html">javax.telephony.Event</a>, representing a family of JTAPI call model changes. Finally each specific JTAPI call model change is indicated by a specific <i>event ID</i> (returned by the <code>Event.getID</code> method). </p> 
  <p> For example, an object implementing the <a href="javax/telephony/CallListener.html">javax.telephony.CallListener</a> interface may expect a <a href="javax/telephony/CallEvent.html">javax.telephony.CallEvent</a> to carry one of the following <a href="javax/telephony/CallEvent.html#field_summary">event IDs</a>: <code>javax.telephony.CallEvent.CALL_VALID</code> (or just <code>CALL_VALID</code>), <code>CALL_INVALID</code> or <code>EVENT_TRANSMISSION_ENDED</code>. Each of these event IDs indicate the specific call model change which occurred. </p> 
  <p> A Listener interface defines a set of methods which the application object must implement. One method is defined in the interface for each event plus event ID that may be reported to the application object. </p> 
  <h3>Objects and Listeners</h3> 
  <p>The Provider, Call, Terminal, and Address objects have Listeners. The interfaces corresponding to these listeners are ProviderListener, CallListener, TerminalListener, and AddressListener, respectively.</p> 
  <p>The ProviderListener reports all state changes to the Provider object. For the core package, state changes are reported when the Provider changes state from OUT_OF_SERVICE, to IN_SERVICE, to SHUTDOWN. Note that an event ID, and a Listener method, is defined for each state change that may be reported by a JTAPI event. </p> 
  <p>The Call listener reports state change information for all Connections and TerminalConnections that are part of the telephone call as well as state changes to the Call itself. These state changes are reported on neither the Address nor the Terminal listeners. </p> 
  <p>At times, the application may want to monitor Address or Terminal objects for incoming telephone calls. In these instances, the application uses the <strong>Address.addCallListener()</strong> or the <strong>Terminal.addCallListener()</strong> methods. These methods instruct the implementation to automatically add a CallListener to any calls that come to an Address or Terminal. These CallListeners are removed once the call leaves the Address or Terminal. </p> 
  <p>The Address and Terminal listeners report any state changes in these objects. In the core package there are no events for these objects. The AddressListener and TerminalListener interfaces still exist, however, so other packages may extend these interfaces. </p> 
  <p><br> <br> </p> 
  <h2><a name="EXAMPLES">Application Code Examples </a></h2> 
  <p>This section presents two application code examples. The first places a telephone call, and the second answers an incoming telephone call to a Terminal. </p> 
  <p>Note that the outgoing application code example does not make any blocking JTAPI calls in listener code - it only examines the evlist it receives as a parameter - while the incoming call application code uses "inner classes", defined in JDK<font size="1"><sup>TM</sup></font> 1.1, to avoid making blocking JTAPI calls in Listener code. </p> 
  <p><br> <br> </p> 
  <h3>Outgoing Telephone Call Example </h3> 
  <p>The following code example places a telephone call using the core Call.connect() method. It, however, looks for the states provided by the Call Control package. </p> 
  <pre>
import javax.telephony.*;
import javax.telephony.events.*;

/*
 * The MyOutCallObserver class implements the CallObserver
 * interface and receives all events associated with the Call.
 */
 
public class MyOutCallObserver implements CallObserver {
 
  public void callChangedEvent(CallEv[] evlist) {
 
    for (int i = 0; i &lt; evlist.length; i++) {
 
      if (evlist[i] instanceof ConnEv) {
 
        String name = null;
        try {
          Connection connection = ((ConnEv)evlist[i]).getConnection();
          Address addr = connection.getAddress();
          name = addr.getName();
        } catch (Exception excp) {
          // Handle Exceptions
        }
        String msg = "Connection to Address: " + name + " is ";
 
        if (evlist[i].getID() == ConnAlertingEv.ID) {
          System.out.println(msg + "ALERTING");
        }
        else if (evlist[i].getID() == ConnInProgressEv.ID) {
          System.out.println(msg + "INPROGRESS");
        }
        else if (evlist[i].getID() == ConnConnectedEv.ID) {
          System.out.println(msg + "CONNECTED");
        }
        else if (evlist[i].getID() == ConnDisconnectedEv.ID) {
          System.out.println(msg + "DISCONNECTED");
        }
      }  
    }
  }
}


         ------------------------------------------------------


import javax.telephony.*;
import javax.telephony.events.*;
import MyOutCallObserver;


/*
 * Places a telephone call from 476111 to 5551212
 */
public class Outcall {
 
  public static final void main(String args[]) {
 
    /*
     * Create a provider by first obtaining the default implementation of
     * JTAPI and then the default provider of that implementation.
     */
    Provider myprovider = null;
    try {
      JtapiPeer peer = JtapiPeerFactory.getJtapiPeer(null);
      myprovider = peer.getProvider(null);
    } catch (Exception excp) {
      System.out.println("Can't get Provider: " + excp.toString());
      System.exit(0);
    }
 
   /*
    * We need to get the appropriate objects associated with the
    * originating side of the telephone call. We ask the Address for a list
    * of Terminals on it and arbitrarily choose one.
    */
    Address origaddr = null;
    Terminal origterm = null;
    try {
      origaddr = myprovider.getAddress("4761111");
 
      /* Just get some Terminal on this Address */
      Terminal[] terminals = origaddr.getTerminals();
      if (terminals == null) {
        System.out.println("No Terminals on Address.");
        System.exit(0);
      }  
      origterm = terminals[0];
    } catch (Exception excp) {
      // Handle exceptions;
    }
 
 
    /*
     * Create the telephone call object and add an observer.
     */
    Call mycall = null;
    try {
      mycall = myprovider.createCall();
      mycall.addObserver(new MyOutCallObserver());
    } catch (Exception excp) {
      // Handle exceptions
    }
 
    /*
     * Place the telephone call.
     */
    try {
      Connection c[] = mycall.connect(origterm, origaddr, "5551212");
    } catch (Exception excp) {
      // Handle all Exceptions
    }
  }
}

</pre> 
  <p><br> <br> </p> 
  <h3>Incoming Telephone Call Example </h3> 
  <p>The following code example illustrates how an application answers a Call at a particular Terminal. It shows how applications accept calls when (and if) offered. This code example greatly resembles the core InCall code example. </p> 
  <pre>
import javax.telephony.*;
import javax.telephony.events.*;

import javax.telephony.*;
import javax.telephony.events.*;

/*
 * The MyInCallObserver class implements the CallObserver and
 * recieves all Call-related events.
 */
 
public class MyInCallObserver implements CallObserver {
 
  public void callChangedEvent(CallEv[] evlist) {
    TerminalConnection termconn;
    String name;
    for (int i = 0; i &lt; evlist.length; i++) {
 
      if (evlist[i] instanceof TermConnEv) {
        termconn = null;
        name = null;
 
        try {
          TermConnEv tcev = (TermConnEv)evlist[i];
          Terminal term = termconn.getTerminal();
          termconn = tcev.getTerminalConnection();
          name = term.getName();
        } catch (Exception excp) {
          // Handle exceptions.
        }

        String msg = "TerminalConnection to Terminal: " + name + " is ";
 
        if (evlist[i].getID() == TermConnActiveEv.ID) {
          System.out.println(msg + "ACTIVE");
        }
        else if (evlist[i].getID() == TermConnRingingEv.ID) {
          System.out.println(msg + "RINGING");
 
          /* Answer the telephone Call using "inner class" thread */
          try {
		final TerminalConnection _tc = termconn;
	     	Runnable r = new Runnable() {
		  public void run(){
		    try{
				_tc.answer();
		    } catch (Exception excp){
		      // handle answer exceptions
		    }
			};
		
		};
		Thread T = new Thread(r);
		T.start();
          } catch (Exception excp) {
            // Handle Exceptions;
          }
        } else if (evlist[i].getID() == TermConnDroppedEv.ID) {
          System.out.println(msg + "DROPPED");
        }
      }  
    }
  }
}

            ----------------------------------------------------

import javax.telephony.*;
import javax.telephony.events.*;
import MyInCallObserver;

/*
 * Create a provider and monitor a particular terminal for an incoming call.
 */
public class Incall {
 
  public static final void main(String args[]) {
 
    /*
     * Create a provider by first obtaining the default implementation of
     * JTAPI and then the default provider of that implementation.
     */
    Provider myprovider = null;
    try {
      JtapiPeer peer = JtapiPeerFactory.getJtapiPeer(null);
      myprovider = peer.getProvider(null);
    } catch (Exception excp) {
      System.out.println("Can't get Provider: " + excp.toString());
      System.exit(0);
    }
 
    /*
     * Get the terminal we wish to monitor and add a call observer to that
     * Terminal. This will place a call observer on all call which come to
     * that terminal. We are assuming that Terminals are named after some
     * primary telephone number on them.
     */
    try {
      Terminal terminal = myprovider.getTerminal("4761111");
      terminal.addCallObserver(new MyInCallObserver());
    } catch (Exception excp) {
      System.out.println("Can't get Terminal: " + excp.toString());
      System.exit(0);
  }
  }
}

</pre> 
  <p><br> <br> </p> 
  <h2><a name="PROVIDER">Locating and Obtaining Providers </a></h2> 
  <p>The Java Telephony API defines a convention by which telephony server implementations of JTAPI make their services available to applications. </p> 
  <p>The two elements that link an application to a server are: </p> 
  <h3>JtapiPeerFactory </h3> 
  <p>The JtapiPeerFactory class is the first point of contact for an application that needs telephony services. It has the ability to return a named JtapiPeer object or a default JtapiPeer object. It is defined as a static class. </p> 
  <h3>JtapiPeer </h3> 
  <p>The JtapiPeer interface is the basis for a vendor's particular implementation of the Java Telephony API. Each vendor that provides an implementation of JTAPI must implement this interface in a class that can be loaded by the JtapiPeerFactory. </p> 
  <p>It is through a class that implements the JtapiPeer object that an application gets a Provider object. </p> 
  <h3>JtapiPeerFactory: Getting Started </h3> 
  <p>The JtapiPeerFactory is a static class defined in JTAPI. Its sole public method, <em>getJtapiPeer() </em>gets the JtapiPeer implementation requested or it returns a default implementation. </p> 
  <p><em>getJtapiPeer() </em>takes the name of the desired JTAPI server implementation class as a parameter to return an object instance of that class. If no name is provided, <em>getJtapiPeer() </em>returns the default JTAPI server implementation object. </p> 
  <h3>JtapiPeer: Getting a Provider Object </h3> 
  <p>JtapiPeer is an interface. It is used by the JTAPI server implementors. It defines the methods that applications use to get Provider objects, to query services available on those providers, and to get the name of the JtapiPeer object instance. By creating a class that implements the JtapiPeer interface, JTAPI implementations make the following methods available to applications. </p> 
  <p>Applications use the <em>JtapiPeer.getProvider()</em> method to obtain new Provider objects. Each implementation may support one or more different "services" (e.g. for different types of underlying network substrate). A list of available services can be obtained via the <em>JtapiPeer.getServices()</em> method. </p> 
  <p>Applications may also supply optional arguments to the Provider. These arguments are appended to the string argument passed to the <em>JtapiPeer.getProvider()</em> method. The string argument has the following format: </p> 
  <p>&lt; service name &gt; ; arg1 = val1; arg2 = val2; ... </p> 
  <p>Where &lt; service name &gt; is not optional, and each optional argument pair which follows is separated by a semi-colon. The keys for these arguments are implementation specific, except for two standard-defined keys: </p> 
  <ol> 
   <li>login: provides the login user name to the Provider. </li> 
   <li>passwd: provides a password to the Provider. </li> 
  </ol> 
  <p>Applications use the <em>JtapiPeer.getName()</em> method to get the name of this JtapiPeer object instance. It has a <em>name </em>parameter, which is the same name used as an argument to the <em>JtapiPeerFactory.getJtapiPeer()</em> method. </p> 
  <p><br> <br> </p> 
  <h2><a name="SECURITY">Security in the Java Telephony API </a></h2> 
  <p>JTAPI peer implementations use the Java "sandbox" model for controlling access to sensitive operations. Callers of JTAPI methods are categorized as "trusted" or "untrusted", using criteria determined by the runtime system. Trusted callers are allowed full access to JTAPI functionality. Untrusted callers are limited to operations that cannot compromise the system's integrity. </p> 
  <p>JTAPI may be used to access telephony servers or implementations that provide their own security mechanisms. These mechanisms remain in place; parameters such as user name and password are provided through parameters on the JtapiPeer.getProvider() method. </p> 
  <p> </p>
  <hr> 
  <!-- ========== START OF NAVBAR ========== --> 
  <a name="navbar_bottom">
   <!-- --></a> 
  <table border="0" width="100%" cellpadding="1" cellspacing="0"> 
   <tbody>
    <tr> 
     <td colspan="2" bgcolor="#EEEEFF" class="NavBarCell1"> <a name="navbar_bottom_firstrow">
       <!-- --></a> 
      <table border="0" cellpadding="0" cellspacing="3"> 
       <tbody>
        <tr align="center" valign="top"> 
         <td bgcolor="#EEEEFF" class="NavBarCell1"> <a href="../../overview-summary.html"><font class="NavBarFont1"><b>Overview</b></font></a>&nbsp;</td> 
         <td bgcolor="#FFFFFF" class="NavBarCell1Rev"> &nbsp;<font class="NavBarFont1Rev"><b>Package</b></font>&nbsp;</td> 
         <td bgcolor="#EEEEFF" class="NavBarCell1"> <font class="NavBarFont1">Class</font>&nbsp;</td> 
         <td bgcolor="#EEEEFF" class="NavBarCell1"> <a href="package-tree.html"><font class="NavBarFont1"><b>Tree</b></font></a>&nbsp;</td> 
         <td bgcolor="#EEEEFF" class="NavBarCell1"> <a href="../../deprecated-list.html"><font class="NavBarFont1"><b>Deprecated</b></font></a>&nbsp;</td> 
         <td bgcolor="#EEEEFF" class="NavBarCell1"> <a href="../../index-all.html"><font class="NavBarFont1"><b>Index</b></font></a>&nbsp;</td> 
         <td bgcolor="#EEEEFF" class="NavBarCell1"> <a href="../../help-doc.html"><font class="NavBarFont1"><b>Help</b></font></a>&nbsp;</td> 
        </tr> 
       </tbody>
      </table> </td> 
     <td align="right" valign="top" rowspan="3"><em> JSR-043: JTAPI-1.4</em> </td> 
    </tr> 
    <tr> 
     <td bgcolor="white" class="NavBarCell2"><font size="-2"> &nbsp;PREV PACKAGE&nbsp; &nbsp;<a href="../../javax/telephony/callcenter/package-summary.html"><b>NEXT PACKAGE</b></a></font></td> 
     <td bgcolor="white" class="NavBarCell2"><font size="-2"> <a href="../../index.html" target="_top"><b>FRAMES</b></a> &nbsp; &nbsp;<a href="package-summary.html" target="_top"><b>NO FRAMES</b></a></font></td> 
    </tr> 
   </tbody>
  </table> 
  <!-- =========== END OF NAVBAR =========== --> 
  <hr> Send comments to: 
  <a href="mailto:JSR-43@ectf.org">JSR-43@ectf.org</a>   
 </body>
</html>