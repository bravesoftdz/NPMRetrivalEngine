<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
 <head> 
  <script src="/jslibs/swapstyle.js" type="text/javascript"></script> 
  <script src="/styles/managestyles.js" type="text/javascript"></script> 
  <link rel="shortcut icon" href="/favicon.ico"> 
  <link rel="stylesheet" type="text/css" href="/styles/moosified.css" title="Moosified"> 
  <link rel="alternate stylesheet" type="text/css" href="/styles/nostalgic.css" title="Nostalgic"> 
  <link rel="alternate stylesheet" type="text/css" href="/styles/gentleblue.css" title="Gentle Blue"> 
  <link rel="alternate stylesheet" type="text/css" href="/styles/blueframe.css" title="Blue Frame"> 
  <link rel="alternate" href="/howtocreate.xml" type="application/rss+xml" title="HowToCreate site updates"> 
  <link rel="author" title="Author information" href="/bio.html"> 
  <link rel="copyright" title="Script license and terms of use" href="/jslibs/termsOfUse.html"> 
  <link rel="home" title="How To Create home" href="/"> 
  <link rel="search" title="Search this site" href="/tutorials/"> 
  <link rel="bookmark" href="#content" title="Skip navigation"> 
  <link rel="bookmark" href="#index" title="Navigation"> 
  <link rel="prev" title="Event information" href="eventinfo">
  <link rel="next" title="Creating time delays" href="timers">
  <link rel="start" title="Important guidelines" href="important">
  <link rel="first" title="Important guidelines" href="important">
  <link rel="last" title="DOM objects and methods" href="domstructure"> 
  <link rel="stylesheet" type="text/css" href="/styles/demostyles.css"> 
  <title>JavaScript tutorial - Creating objects</title> 
 </head> 
 <body> 
  <h1 title="Part 18 of 31">JavaScript tutorial - Creating objects</h1> 
  <!-- DO NOT follow this link - anti spider abuse --> 
  <div style="display:none;speak:none;">
   <a href="/spdrwarn.html" onclick="return false;"></a>
  </div> 
  <div id="index"> 
   <h2 class="accessible">Navigation</h2> 
   <p class="accessible"><a href="#content" title="See inside the CSS file for why I had to do it this way">Skip navigation</a>.</p> 
   <h3>Site search</h3> 
   <form method="get" action="/tutorials/"> 
    <p> <input type="text" name="searchstring" value="" class="searchbybut"> <input type="submit" value="Search" class="searchbut"> <input type="hidden" name="searchIn[javascript]" value="1"> </p> 
   </form> 
   <h3>Site navigation</h3> 
   <ul> 
    <li><a href="/">How To Create home</a></li> 
   </ul>
   <h3>JavaScript tutorial</h3>
   <ul>
    <li><a href="/tutorials/javascript/important">Important guidelines</a></li> 
    <li><a href="/tutorials/javascript/introduction">Introduction to JavaScript</a></li> 
    <li><a href="/tutorials/javascript/examples">Examples</a></li> 
    <li><a href="/tutorials/javascript/incorporate">Adding JavaScript to a page</a></li> 
    <li><a href="/tutorials/javascript/objectoriented">Object oriented programming</a></li> 
    <li><a href="/tutorials/javascript/operators">Operators</a></li> 
    <li><a href="/tutorials/javascript/variables">Variables</a></li> 
    <li><a href="/tutorials/javascript/controls">Control structures</a></li> 
    <li><a href="/tutorials/javascript/writing">Writing with script</a></li> 
    <li><a href="/tutorials/javascript/functions">Writing functions</a></li> 
    <li><a href="/tutorials/javascript/referencing">Referencing</a></li> 
    <li><a href="/tutorials/javascript/browserinspecific">Browser inspecific referencing</a></li> 
    <li><a href="/tutorials/javascript/browserspecific">Browser specific referencing</a></li> 
    <li><a href="/tutorials/javascript/dhtml">DHTML</a></li> 
    <li><a href="/tutorials/javascript/elementcontents">Element contents</a></li> 
    <li><a href="/tutorials/javascript/browserwindow">Window size and scrolling</a></li> 
    <li><a href="/tutorials/javascript/eventinfo">Event information</a></li> 
    <li class="currentpage"><a href="/tutorials/javascript/objects">Creating objects</a></li> 
    <li><a href="/tutorials/javascript/timers">Creating time delays</a></li> 
    <li><a href="/tutorials/javascript/cookies">Using cookies</a></li> 
    <li><a href="/tutorials/javascript/security">Security</a></li> 
    <li><a href="/tutorials/javascript/semicolons">Semicolons</a></li> 
    <li><a href="/tutorials/javascript/javascriptobject">The JavaScript object</a></li> 
    <li><a href="/tutorials/javascript/domintroduction">W3C DOM introduction</a></li> 
    <li><a href="/tutorials/javascript/dombasics">DOM nodes and tree</a></li> 
    <li><a href="/tutorials/javascript/domtables">DOM tables</a></li> 
    <li><a href="/tutorials/javascript/domcss">DOM CSS</a></li> 
    <li><a href="/tutorials/javascript/domstylesheets">DOM Style Sheets</a></li> 
    <li><a href="/tutorials/javascript/domevents">DOM events</a></li> 
    <li><a href="/tutorials/javascript/domstructure">DOM objects and methods</a></li> 
   </ul>
   <h3>Printing</h3>
   <ul>
    <li><a href="/tutorials/javascript/combinedpage">View tutorial as a single document</a></li>
    <li><a href="/aboutsite.html#markupstyle">Print styling information</a></li>
    <li><a href="/aboutsite.html#saveprint">Printing policy</a></li>
   </ul> 
   <h3>Other tutorials</h3>
   <ul>
    <li><a href="/tutorials/css/introduction">CSS tutorial</a></li> 
    <li><a href="/tutorials/html/basics">HTML tutorial</a></li> 
    <li><a href="/tutorials/design/introduction">Site design</a></li> 
   </ul>
  </div> 
  <div id="content"> 
   <h2>Creating objects</h2>
   <ul class="browserbugs"> 
    <li>Netscape 4, IE 4 on Windows and Mac, and IE 5 on Mac do not support the <var>instanceof</var> operator.</li> 
   </ul> 
   <p>Any function in JavaScript can be used to create custom object classes, simply by calling it using the keyword <code>new</code>. When called in this way, the special variable <var>this</var> inside the function references the new object that is being constructed (it normally refers to the 'current' object, which is usually <var>window</var>, except inside methods). The function should not return a value. The following function can be used as demonstrated to create an object of class <var>myobject</var>:</p> 
   <pre><code>function myobject() {
  this.containedValue = 0;
  this.othercontainedValue = 0;
  this.anothercontainedValue = 0;
}

var mything = new myobject();</code></pre> 
   <p>And there you go, <var>mything</var> is now an instance of class <var>myobject</var>. It will have the following properties, all of which will be 0:</p> 
   <ul> 
    <li><var>mything.containedValue</var></li> 
    <li><var>mything.othercontainedValue</var></li> 
    <li><var>mything.anothercontainedValue</var></li> 
   </ul> 
   <p>You could also now write this:</p> 
   <pre><code>myobject.prototype.newContainedValue = someValue;</code></pre> 
   <p>This will cause all instances of class <var>myobject</var> will have the property <var>newContainedValue</var> with value <var>someValue</var>.</p> 
   <p>Use the instanceof operator to find out if your object is an instance of a given object class:</p> 
   <pre><code>if( myvar instanceof Array ) { ... }
if( myvar instanceof myobject ) { ... }</code></pre> 
   <h3>Creating an object with methods</h3> 
   <p>Now I will give you an example showing you how to create methods for your objects. As an example, I will create a circle as my object. The methods will be</p> 
   <dl> 
    <dt>
     <code>nameOfCircle.retArea()</code>
    </dt> 
    <dd>
     Returns the area of the circle (pi r
     <sup>2</sup>)
    </dd> 
    <dt>
     <code>nameOfCircle.retCirc()</code>
    </dt> 
    <dd>
     Returns the circumference of the circle (2 pi r)
    </dd> 
    <dt>
     <code>nameOfCircle.mvBy(xDis,yDis)</code>
    </dt> 
    <dd>
     Moves the circle by xDis in the x direction and yDis in the y direction
    </dd> 
   </dl> 
   <p>The following lines point the methods to functions that the object will use as the methods:</p> 
   <ul> 
    <li><code>this.retArea = getTheArea;</code></li> 
    <li><code>this.mvBy = mvCclBy;</code></li> 
    <li><code>this.retCirc = function () { ... };</code></li> 
   </ul> 
   <p>The third of these defines the method using an anonymous function in one line, and does not work in some early Netscape 4 releases. Note, it has a semicolon after the '}', and is one of the few places where this is correct practice.</p> 
   <pre><code>function mycircle(x,y,r) {
  this.xcoord = x;
  this.ycoord = y;
  this.radius = r;
  this.retArea = getTheArea;
  <span class="comment">//This next line uses an alternative syntax</span>
  this.retCirc = function () { return ( Math.PI * this.radius * 2 ); };
  this.mvBy = mvCclBy;
}
function getTheArea() {
  return ( Math.PI * this.radius * this.radius );
}
function mvCclBy(xDis,yDis) {
  this.xcoord += xDis;
  this.ycoord += yDis;
}

<span class="comment">/* create a mycircle called testcircle where testcircle.xcoord is 3 and testcircle.ycoord is 4 and testcircle.radius is 5 */</span>
var testcircle = new mycircle(3,4,5);
<span class="comment">/* use the mvBy method to displace the centre of testcircle. move it by 2 in the x direction and 3 in the y direction */</span>
testcircle.mvBy(2,3);
<span class="comment">//testcircle.xcoord is now 5 and testcircle.ycoord is now 7</span>

window.alert( 'The area of the circle is ' + testcircle.retArea() );
window.alert( 'The circumference is ' + testcircle.retCirc() );</code></pre> 
   <h4>The special 'toString' method</h4> 
   <p>All objects have the <var>'toString'</var> method, even if you do not define it yourself. The method returns a string representation of the object, and is automatically called whenever a string representation of an object is required, such as when you use <code>alert(myObject);</code></p> 
   <p>In most browsers, this returns <samp>'[object Object]'</samp>, although some more useful browsers return a string like this:</p> 
   <pre><samp>'{property1:value1,property2:value2,method1:function () { ... },etc.}'</samp></pre> 
   <p>However, for your own objects, you may wish to provide a special string that may provide more useful information. To do this, simply define the <var>'toString'</var> method:</p> 
   <pre><code>this.toString = function () {
  return 'Circle object; xcoord: ' + this.xcoord + ', ycoord: ' +
    this.ycoord + ', radius: ' + this.radius;
};</code></pre> 
   <h3 id="advobj">Advanced object techniques</h3> 
   <p>These deal with concepts that are rarely used in JavaScripting. JavaScript is a more powerful programming language than most people make use of, but that is because in normal scripting, these powerful features are not really necessary. If you are just learning, or if you are interested only in day-to-day scripting, I suggest you move on to the <a href="timers">next chapter</a>.</p> 
   <p>Some of these techniques may not work in older browsers like early Netscape 4 releases.</p> 
   <h4>Adding extra properties/methods using prototype</h4> 
   <ul class="browserbugs"> 
    <li>Internet Explorer 5.2-, Safari 1.3-, Konqueror 3.3-, Netscape 4, and WebTV do not implement the <var>hasOwnProperty</var> method.</li> 
   </ul> 
   <p>Take the <var>mycircle</var> example from the top of this section (creating new objects). We have already created an instance of the <var>mycircle</var> class called <var>'testcircle'</var>. And we can also assume that we have created a few other <var>mycircles</var>. Now, let us assume that we want to add another property to each circle. For example, we want each circle to have a <var>'texture'</var> property. We could use this:</p> 
   <pre><code>testcircle.texture = 'smooth';</code></pre> 
   <p>And we could do this for each individual <var>mycircle</var>. But since we want to do this for all of them, it would be much more easy to give all instances the property at the same time. So we can use the <var>'prototype'</var> property of the class constructor:</p> 
   <pre><code>mycircle.prototype.texture = 'smooth';</code></pre> 
   <p>Immediately, all of the <var>mycircles</var> that we have created will now inherit the new property:</p> 
   <pre><code>alert(testcircle.texture);
<span class="comment">//alerts 'smooth'</span></code></pre> 
   <p>We can add new methods the same way:</p> 
   <pre><code>mycircle.prototype.setArea = function (oArea) {
  this.radius = Math.sqrt( oArea / Math.PI );
};
mycircle.setArea(5);</code></pre> 
   <p>This is most useful with instrinsic (fundamental inbuilt) objects. For example, the regular expression construct <code>/a[0-9]b/g</code> is shorthand for <code>new RegExp('a[0-9]b','g');</code> and in fact the same is true for all intrinsic object classes, such as <var>String</var>, <var>Number</var> and <var>Boolean</var>. So if, for example, we wanted to create a new method on all strings called <var>'reverse'</var> that returned their contents in reverse order, we could do this:</p> 
   <pre><code>String.prototype.reverse = function() {
  for( var oStr = '', x = this.length - 1, oTmp; oTmp = this.charAt(x); x-- ) {
    oStr += oTmp;
  }
  return oStr;
};</code></pre> 
   <p>The use of <var>prototype</var> could have been applied to create all of the methods of the <var>mycircle</var> object, not just new ones. This gives a mixed response to performance. It will not have to store individual copies of the methods for each instance of the object, so it may require less memory, but it will require the browser to search the current and parent scopes to find the methods. This may cause a marginal delay. Generally, you should use what is appropriate for your code, and not base this decision on performance (unless you are dealing with a very specific controlled environment):</p> 
   <pre><code>function mycircle(x,y,r) {
  this.xcoord = x;
  this.ycoord = y;
  this.radius = r;
}
mycircle.prototype.retArea = function () {
  return ( Math.PI * this.radius * this.radius );
};
mycircle.prototype.retCirc = function () {
  return ( Math.PI * this.radius * 2 );
};
mycircle.prototype.mvBy = function (xDis,yDis) {
  this.xcoord += xDis;
  this.ycoord += yDis;
};</code></pre> 
   <p>In some cases, it may be desirable to work out if a property on an object is attached to the object instance itself, or somewhere in its prototype chain. In JavaScript, all objects have a method called <var>hasOwnProperty</var> that returns true if the given property is attached to the individual object instance. Of course, it is also possible to check if the object's constructor also has the same property with the same value as the object instance itself, but that can give the wrong result if separate properties exists with the same value on both the object instance and the prototype chain. The <var>hasOwnProperty</var> method accepts a single parameter; the name of the property as a string.</p> 
   <pre><code>function myclass() {
  this.propertytwo = 2;
  this.propertythree = 3;
}
myclass.prototype.propertyone = 1;
myclass.prototype.propertytwo = 2;

var myinstance = new myclass();
myinstance.propertyfour = 4;

alert(myinstance.hasOwnProperty('propertyone'));
<span class="comment">//alerts false</span>

alert(myinstance.hasOwnProperty('propertytwo'));
<span class="comment">//alerts true</span>

alert(myinstance.hasOwnProperty('propertythree'));
<span class="comment">//alerts true</span>

alert(myinstance.hasOwnProperty('propertyfour'));
<span class="comment">//alerts true</span>

alert(myinstance.hasOwnProperty('propertyfive'));
<span class="comment">//alerts false</span></code></pre> 
   <h4>Public and private properties</h4> 
   <p>This is a concept that is almost never used in JavaScript, and there is a good reason. It simply is not necessary. Even complicated scripts are almost never complex enough to require this level of control. However, many programmers familiar with other programming languages (such as Java or C++) often desire this behavior in JavaScript simply because it is a concept they are familiar with. This sort of concept is only really useful when putting together large projects from multiple pieces of code.</p> 
   <p>Say for example that I am producing a public functions library. A set of constructors and methods that people can include in their own projects (something that Java programmers use all of the time). Say for example that the mycircle constructor is included in it, so that you can create your own mycircles. Now say for example you try this:</p> 
   <pre><code>var aCircle = new mycircle(5,6,'about 3mm');</code></pre> 
   <p>That will work now (it's not a valid measurement, but my constructor will not argue), but later on when you try to use the methods that my class provides, it will fail. So I can check what you have provided, and make sure it is a valid number, and use a default value if it is not. But then you can say something like this:</p> 
   <pre><code>aCircle.radius = 'some text';</code></pre> 
   <p>Again, it would break (of course, it is your own fault, but in more complicated applications, it would be possible to make a mistake where this causes a real problem). So what I want to do is to not allow you to modify that property directly, and only allow you to change it using a method that I control:</p> 
   <pre><code>this.setRadius = function (oRad) {
  if( typeof(oRad) == 'number' &amp;&amp; oRad &gt;= 0 ) {
    this.radius = oRad;
  } else {
    this.radius = 0;
  }
};</code></pre> 
   <p>An alternative situation where this can be important is if I am storing the information in one set of properties. I then upgrade my libraries, maybe adding some extra functionality. But in order to do so, I have to change the properties that I am using. If your script was relying on them existing in a specific format, and I have now changed that format, your script would fail. If I could protect those properties, and force you to use only methods, then I could do whatever I needed with the properties, and as long as I then change the methods to use the new properties, your script would keep working, and you would not even need to know what I had changed or why. That way, we could each manage our own project, and not waste each other's time.</p> 
   <p>It would also help avoid possible conflicts between undisclosed properties, and your own scripting. For example, if you decide to temporarily assign a property to an object, but you were unaware that internally, my object constructor already used that property name, you would overwrite my object's property, and cause problems with the object.</p> 
   <p>This is what private properties are for. They do not allow scripts that use the contructor to use or modify the properties directly. They only allow the methods of the object itself to use and modify them. Unlike many other languages, JavaScript does not declare each variable type as 'public' or 'private'. It all depends on how you create them.</p> 
   <p>Saying '<code>this.propertyname</code>' as I did above will create a public property. Any script can create an object then use and modify its properties directly. Using <var>'var'</var> to define a variable in the constructor will create a private property. Note that unlike public properties, the private properties are then accessed, including from within methods, without the 'this.' prefix - just like a normal variable. This makes heavy use of JavaScript's scope functionality. Private variables can only be accessed from methods that are declared inline, and not externally referenced or created using the prototype construct. Methods of this kind are also known as privileged methods. An example of its use might be: <code>this.mymethod = function () { alert( propertyname ); };</code></p> 
   <pre><code>function myob() {
  this.property1 = 'value1'; <span class="comment">//this creates a public property</span>
  var property2 = 'value2';  <span class="comment">//this creates a private property</span>
  this.method1 = function () { alert( property2 ); };
}
var oneOb = new myob();
alert(oneOb.property1); <span class="comment">//alerts 'value1'</span>
alert(oneOb.property2); <span class="comment">//alerts undefined (private property)</span>
oneOb.method1();        <span class="comment">//alerts 'value2'</span></code></pre> 
   <p>Similarly, you can also create private methods. These are simply a function that you create inside the constructor function. This may look confusing, but it works. The private function can only be called by the constructor itself, or by methods that are defined inline. Private methods can be used as public methods, if they are assigned to a public method constructor, and accessed using the public method constructor (as with 'method2' below).</p> 
   <pre><code>function myob() {
  function cantBeSeen() {
    alert(secretValue);
  }
  var secretValue = '';
  this.method1 = function () {
    secretValue = 'no surprises';
    cantBeSeen();
  };
  this.method2 = cantBeSeen;
}
var oneOb = new myob();
oneOb.method1(); <span class="comment">//alerts 'no surprises'</span>
oneOb.method2(); <span class="comment">//alerts 'no surprises'</span></code></pre> 
   <p>For more information on private, public and privileged properties and methods in JavaScript, see <a href="http://www.crockford.com/javascript/private.html">Douglas Crockford's 'Private Members in JavaScript'</a> page.</p> 
   <h4>Sub-classes and class inheritance</h4> 
   <p>This is also hardly ever used in JavaScript, despite its popularity in other languages. Take this as an example. I want to make a new type of object, that will store the data to represent a sphere (a ball - in case you don't know). Since a sphere is just a three dimensional circle, I would probably want to include all the methods I created earlier for the circle object; <var>retArea</var> to get the cross-section area, <var>retCirc</var> to get the circumference, <var>mvBy</var> to move it by a certain amount. Aditionally, I would probably want <var>retVol</var> to get the volume, and <var>retSurf</var> to get the surface area. I would also need to provide a z coordinate when creating the object, and again when calling the <var>mvBy</var> property.</p> 
   <p>So, I want to create a new type of object, based on the <var>mycircle</var>, but with a few aditions and modifications. I will call this new type of object a <var>mysphere</var>. Now, I could just rewrite all the code I already wrote for the <var>mycircle</var> and change the bits I need. But in a real-world application, this might be a lot of wasteful duplication, for only one or two modifications. So what I want to do is make the <var>mysphere</var> inherit all the properties and methods of the <var>mycircle</var>, then overwrite only the ones I want.</p> 
   <p>This effectively makes <var>mysphere</var> a sub-class of <var>mycircle</var>, and making the <var>mysphere</var> class constructor inherit from the <var>mycircle</var> class constructor is as simple as this:</p> 
   <pre><code>function mysphere(x,y,z,r) { ... constructor code ... }
mysphere.prototype = new mycircle();</code></pre> 
   <p>In case you are wondering, the way it works is to actually create a <var>mycircle</var>, then assign that to the <var>mysphere</var> constructor prototype. As a result, the <var>mysphere</var> constructor has the <var>mycircle</var> object added to its prototype chain. What this means is that each time a <var>mysphere</var> is created, it will inherit the properties and methods of the <var>mycircle</var> object. It can then override any of these properties using its own prototype, or with properties and methods created within its own constructor. If any of these properties are subsequently removed (using the <var>'delete'</var> keyword), the inherited ones will become available again. That also means that if the <var>mycircle</var> prototype is changed (properties are added or deleted, etc.), these changes are replicated down the chain, so the <var>mysphere</var> also inherits these changes.</p> 
   <p>Note that the prototype chain is established for each object as the object is created. Once an object has been created, its prototype chain cannot be changed (though new properties and methods can still be added to its parent classes, and those changes will be reflected in the object). Changes to its prototype chain will have no effect; it will still see the old prototype chain. The new chain will only be used for new instances of that class. This is also the case for the assignment of a new <var>mycircle</var> to the prototype of <var>mysphere</var> (which, as stated, creates a new instance of the <var>mycircle</var> class); any subsequent changes to the prototype chain of the <var>mycircle</var> class will not be reflected in the <var>mysphere</var> class. For this reason, it is very important to ensure that the prototype chain is built in the correct order, with class constructors and their prototypes set up before any child class is made to inherit from them. Properties and methods can still be added to any class or parent class at any time after their own prototype chain has been set up.</p> 
   <p>The line that makes <var>mysphere</var> inherit from <var>mycircle</var> sounds simple enough. And at least, it would be, but you will remember that <var>mycircle</var> expected me to pass it some parameters that it would then use. Then I call my new constructor, and these parameters will not automatically be passed to the <var>mycircle</var> constructor function. I need to do this myself for each mysphere that I want to create. But since I am not passing these parameters when assigning the <var>mycircle</var> object to the <var>mysphere</var> prototype, I also need to ensure that the <var>mycircle</var> contructor stops before attempting to create its own properties. Instead of defining the public properties immediately, I will define them using a method (that I have decided to call getready), and if the required parameters have been passed (<var>arguments.length</var>), I will immediately call the method.</p> 
   <p>If the parameters are present, the <var>mycircle</var> constructor keeps working, and no-one needs to know that anything was changed at all. To make things easier later on, I will take all of the methods out of the constructor, and add them later using the prototype. That way, the <var>mycircle</var> prototype methods will always be available without me needing to create a new <var>mycircle</var>. Unfortunately, this also means that public and private properties are very hard (or impossible) to use. It's a trade off - one functionality for another.</p> 
   <pre><code>function mycircle(x,y,r) {
  if( arguments.length ) { this.getready(x,y,r); }
}
mycircle.prototype.getready = function (a,b,c) {
  this.xcoord = a;
  this.ycoord = b;
  this.radius = c;
};
mycircle.prototype.retArea = function () {
  return ( Math.PI * this.radius * this.radius );
};
mycircle.prototype.retCirc = function () {
  return ( Math.PI * this.radius * 2 );
};
mycircle.prototype.mvBy = function (xDis,yDis) {
  this.xcoord += xDis; this.ycoord += yDis;
};</code></pre> 
   <p>Now, back to the <var>mysphere</var> constructor. I have already said how to make it inherit, but it still needs to run the <var>mycircle.getready</var> method to initialise the properties. To do this, we will need to reference the parent class prototype, and run the method ourselves. This also ensures that even if each parent class uses the same method name (<var>getready</var>), the correct one is always referenced. Since we can almost never be sure how many sub-classes we will need, it is useful to do it this way, and simply use the same method name for each, knowing that we will not have problems with name conflicts.</p> 
   <p>When running the method, we need to tell JavaScript that even though we are referencing a method for a different prototype, we want to run it as if it were a method of the object we are creating (to make sure that any properties it creates are added to the object we are creating). This could be done using the <var>'call'</var> method or <var>'apply'</var> method, but unfortunately, Internet Explorer 5 does not understand these, so I will assign it to a temporary property of the new object, and run it from there.</p> 
   <p>To reference the method from the parent class prototype, it would be possible to use the constructor's prototype chain to locate it (the property that references the constructor will, at this point, refer to the parent class - more on that later):</p> 
   <pre><code>this.constructor.getready</code></pre> 
   <p>However, that will only work for one level of inheritance, due to the way it is run as a method of the current object for all child classes. As a result, it is best to reference it by name, which will work no matter how many levels of class inheritance are used:</p> 
   <pre><code>mycircle.prototype.getready</code></pre> 
   <p>Note that when assigning the <var>mycircle</var> object to the <var>mysphere</var> prototype, it also overwrites the <var>mysphere</var> prototype <var>constructor</var> property. This is not a major problem, but some scripts use it, so we will put the reference back where we want it:</p> 
   <pre><code>function mysphere(x,y,z,r) {
  if( arguments.length ) { this.getready(x,y,z,r); }
}
<span class="comment">//inherit from the mycircle prototype</span>
mysphere.prototype = new mycircle();
<span class="comment">//put the correct constructor reference back (not essential)</span>
mysphere.prototype.constructor = mysphere;

mysphere.prototype.getready = function (a,b,c,d) {
  <span class="comment">//reference the getready method from the parent class</span>
  this.tempReady = mycircle.prototype.getready;
  <span class="comment">//and run it as if it were part of this object</span>
  this.tempReady(a,b,d);
  <span class="comment">//now that all required properties have been inherited //from the parent class, define extra ones from this class</span>
  this.zcoord = c;
}
mysphere.prototype.mvBy = function (xDis,yDis,zDis) {
  <span class="comment">//override the existing method</span>
  this.xcoord += xDis;
  this.ycoord += yDis;
  this.zcoord += zDis;
};
mysphere.prototype.retVol = function () {
  return ( 4 / 3 ) * Math.PI * Math.pow( this.radius, 3 );
};
mysphere.prototype.retSurf = function () {
  return 4 * Math.PI * this.radius * this.radius;
};</code></pre> 
   <p>And finally, to use it:</p> 
   <pre><code>var testsphere = new mysphere(3,4,5,6);

alert( 'The cross-section area is ' + testsphere.retArea() );
alert( 'The circumference is ' + testsphere.retCirc() );
alert( 'The volume is ' + testsphere.retVol() );
alert( 'The surface area is ' + testsphere.retSurf() );</code></pre> 
   <script type="text/javascript">

function mycircle(x,y,r) {
  if( arguments.length ) { this.getready(x,y,r); }
}
mycircle.prototype.getready = function (a,b,c) {
  this.xcoord = a;
  this.ycoord = b;
  this.radius = c;
};
mycircle.prototype.retArea = function () {
  return ( Math.PI * this.radius * this.radius );
};
mycircle.prototype.retCirc = function () {
  return ( Math.PI * this.radius * 2 );
};
mycircle.prototype.mvBy = function (xDis,yDis) {
  this.xcoord += xDis; this.ycoord += yDis;
};

function mysphere(x,y,z,r) {
  if( arguments.length ) { this.getready(x,y,z,r); }
}
mysphere.prototype = new mycircle();
mysphere.prototype.constructor = mysphere;

mysphere.prototype.getready = function (a,b,c,d) {
  this.tempReady = mycircle.prototype.getready;
  this.tempReady(a,b,d);
  this.zcoord = c;
}
mysphere.prototype.mvBy = function (xDis,yDis,zDis) {
  //override the existing method
  this.xcoord += xDis;
  this.ycoord += yDis;
  this.zcoord += zDis;
};
mysphere.prototype.retVol = function () {
  return ( 4 / 3 ) * Math.PI * Math.pow( this.radius, 3 );
};
mysphere.prototype.retSurf = function () {
  return 4 * Math.PI * this.radius * this.radius;
};

function ball(x,y,z,r,m) {
  if( arguments.length ) { this.getready(x,y,z,r,m); }
}
ball.prototype = new mysphere();
ball.prototype.constructor = ball;

ball.prototype.getready = function (a,b,c,d,e) {
  this.tempReady = mysphere.prototype.getready;
  this.tempReady(a,b,c,d);
  this.mass = e;
}
ball.prototype.retDensity = function () {
  return this.mass / this.retVol();
};

function runObjCrTest() {
	var testsphere = new mysphere(3,4,5,6);
	window.alert( 'The cross-section area is ' + testsphere.retArea() );
	window.alert( 'The circumference is ' + testsphere.retCirc() );
	window.alert( 'The volume is ' + testsphere.retVol() );
	window.alert( 'The surface area is ' + testsphere.retSurf() );
}

function runObjBallTest() {
	var testball = new ball(3,4,5,6,7000);
	window.alert( 'The density for a ball with volume ' + testball.retVol() + ' and mass ' + testball.mass + ' is ' + testball.retDensity() );
}

</script> 
   <p><a href="#" onclick="if(window.runObjCrTest){runObjCrTest();}else{alert('Sorry, your browser\'s JavaScript implentation is not advanced enough to use this script');}return false;">Test this class inheritance script</a>.</p> 
   <p>There is no limit to how many sub-classes can inherit from a class, and there is also no limit to how many levels of sub-classes can be created. As an example, I will create a <var>ball</var> class that will inherit from the <var>mysphere</var> class:</p> 
   <pre><code>function ball(x,y,z,r,m) {
  if( arguments.length ) { this.getready(x,y,z,r,m); }
}
ball.prototype = new mysphere();
ball.prototype.constructor = ball;

ball.prototype.getready = function (a,b,c,d,e) {
  this.tempReady = mysphere.prototype.getready;
  this.tempReady(a,b,c,d);
  this.mass = e;
}
ball.prototype.retDensity = function () {
  return this.mass / this.retVol();
};</code></pre> 
   <p><a href="#" onclick="if(window.runObjBallTest){runObjBallTest();}else{alert('Sorry, your browser\'s JavaScript implentation is not advanced enough to use this script');}return false;">Test this class inheritance script</a>.</p> 
   <p>The <var>instanceof</var> operator returns true when testing an object against any class in its prototype chain, so it would say that an instance of the <var>ball</var> class was also an instance of the <var>mysphere</var> class, and also the <var>mycircle</var> class.</p> 
   <p>For more information on sub-classes and class inheritance in JavaScript, see <a href="http://www.kevlindev.com/tutorials/javascript/inheritance/">Kevin Lindsey's class inheritance</a> page.</p> 
   <h4>Static methods and properties</h4> 
   <p>A static property (or method) is a property of the class constructor, not an individual instance of that class. For example, <code>mycircle.myproperty</code> instead of <code>(new mycircle()).myproperty</code>. While not often used in JavaScript, they are often encountered in other programming languages, and are covered here for those who are familiar with them in other languages. As with most objects in JavaScript, the functions used as class constructors can have properties added to them, and these will be public static properties:</p> 
   <pre><code>function mycircle() { ... }
mycircle.aStaticProperty = true;
mycircle.aStaticMethod = function () { ... };</code></pre> 
   <p>Making a private static property is significantly harder, as it is a concept that JavaScript (at least in widely supported implementations) simply does not recognise. However, it is possible to provide an approximate equivalent to this functionality by using an anonymous wrapper function to create a scope where the private "properties" are created as normal variables, then having that return another function that will be used as the constructor. As long as the constructor function is declared inside the anonymous function, it will have access to the private variables from the anonymous function's local scope when it is executed. This structure is described in the section on <a href="functions">writing functions</a>.</p> 
   <pre><code>var mycircle = (function () {
  var privateStaticVariable = true;
  function privateStaticMethod() { ... }
  function publicConstructor() {
    this.normalInstanceProperty = 1;
    ...
    alert(privateStaticVariable);
  };
  publicConstructor.prototype.normalProperty = 2;
  return publicConstructor;
})();
mycircle.publicStaticProperty = true;
mycircle.publicStaticMethod = function () { ... };</code></pre> 
   <h4>Singletons</h4> 
   <p>The singleton is one of the design patterns that is commonly seen in other languages, and in a simplified format within JavaScript. The idea of a singleton is to have a class that can only have one object created from it. Every time a script tries to create another instance of that class, it returns the same copy as before, so if the properties are modified on one of them, then the other will also see the modifications. The use of singletons can be controversial, but I will not cover that here. This tutorial will only show you how to produce them.</p> 
   <p>In JavaScript, there is the ability to create a generic anonymous object to serve this purpose. It can either be created using <code>new Object()</code> or the shorthand <code>{ ... }</code> syntax, and can then be given any properties or methods that are needed. However, this does have limitations; using a generic object means that it is not possible to use private properties. In most cases, this is functionality that is not needed, and the majority of scripts simply use a generic object. Instead of trying to constuct new instances of the object, scripts will just create another variable that references the object:</p> 
   <pre><code>var mySingleton = { foo: 'bar', baz: 'qux', aMethod: function () { ... } };
...
var anotherReference = mySingleton;</code></pre> 
   <p>If you feel the need for private properties, read on. With other languages, the expectation is to create a class constructor that refuses to be instantiated by other scripts, and provides a public static method that constructs the object the first time it is called, and returns the same object for each subsequent call. JavaScript, however, does not provide a way to prevent a class from being instantiated (at least in widely supported JavaScript). If it exists as a function, it can be called as a constructor.</p> 
   <p>It is tempting (and sometimes used) to simply use an anonymous function as the class constructor, construct it once, and use its scope to keep variables private. This is limited to normal private properties, and cannot be used for private static properties. The theory is that this enforces the singleton principle by preventing another attempt to reference and use the class constructor. This pattern fails to produce a singleton, however, as other code can simply use the singleton's <var>constructor</var> property to reference it - although you could override the singleton's <var>constructor</var> property, this can cause other problems later on if code needs to be able to use that to add properties to the <var>constructor.prototype</var>.</p> 
   <pre><code>var mySingleton = new function () {
  var privateStaticVariable = true;
  function privateStaticMethod() { ... }
  ...
};
<del>var newInstance = new mySingleton.constructor();</del></code></pre> 
   <p>It is, however, possible to adapt the pattern used for private static properties, to create private properties for the singleton, while at the same time creating a proper singleton. Once again, an anonymous function is used to contain the private variables and functions. However, instead of returning a class contructor function, it just returns the single object:</p> 
   <pre><code>var mySingleton = (function () {
  var privateStaticVariable = true;
  function privateStaticMethod() { ... }
  return { ... };
})();</code></pre> 
   <p>That is, of course, a very simple pattern, but it shows something important; by returning a generic object, it is not possible to use <code>new mySingleton.constructor()</code> to create a separate instance, as that would just produce a generic object. This particular format is quite awkward, however, as the generic object prevents the prototype from being used to cleanly add more properties and methods. It is very simple to extend it to make that possible, however, just by creating the class contructor function inside the anonymous function:</p> 
   <pre><code>var mySingleton = (function () {
  var privateStaticVariable = true;
  function privateStaticMethod() { ... }
  function PrivateConstructor() {}
  PrivateConstructor.prototype.publicProperty = true;
  ...
  return new PrivateConstructor();
})();</code></pre> 
   <p>This now means that <code>new mySingleton.constructor()</code> will create a new instance of a <var>PrivateConstructor</var> object. However, the constructor function, when called in this way, is pulled out of the inner scope during that call, and as a result, it ends up with a relatively useless object that has none of the prototype's properties. Once again, the singleton principle is enforced. New properties can be created by modifying the <var>mySingleton.constructor.prototype</var>. The singleton can itself be used as the prototype for another constructor, to allow sub-classes to be created.</p> 
   <p>There are some reasons why this particular approach may not be favoured; specifically that it always creates the singleton even if it is never used. Some may also prefer to use a function call instead of having a global variable always created (though a function is still a global variable), as this may make it possible to change the implementation later to use a different design pattern instead of a singleton. It is possible to take care of both of these concerns, by returning a function instead of an object. That function can check if the singleton has been created yet, store it in a private variable, and return the instance. This has the small limitation that an instance of the object will need to be created by an external script in order to add properties or methods to the prototype, but this is a limitation that is unlikely to be a problem:</p> 
   <pre><code>var getSingleton = (function () {
  var privateStaticVariable = true;
  function privateStaticMethod() { ... }
  function PrivateConstructor() {}
  PrivateConstructor.prototype.publicProperty = true;
  ...
  var onlyInstance;
  return function () {
    if( !onlyInstance ) {
      onlyInstance = new PrivateConstructor();
    }
    return onlyInstance;
  };
})();
...
var mySingleton = getSingleton();</code></pre> 
   <p>Or an equivalent approach that assigns the function to a global variable instead of returning it (this may be preferred for clarity, or to allow you to put the class instantiation methods at the top of the anonymous function instead of the bottom of it):</p> 
   <pre><code>var getSingleton;
(function () {
  var onlyInstance;
  getSingleton = function () {
    if( !onlyInstance ) {
      onlyInstance = new PrivateConstructor();
    }
    return onlyInstance;
  };
  function PrivateConstructor() {}
  PrivateConstructor.prototype.publicProperty = true;
  ...
})();</code></pre> 
   <p>It is, however, possible to make the anonymous function return an object which can be used for prototyping directly, but this becomes quite messy. The <var>PrivateConstructor</var> can be made to inherit its prototype from the object that will be returned by the anonymous function. The singleton (when it is created) will then inherit any changes made to that object (in addition, it will inherit the <var>getInstance</var> method from the returned object, but this is harmless). I recommend that you avoid getting into a situation where you would need this functionality in a script.</p> 
   <pre><code>var singletonMaker = (function () {
  var privateStaticVariable = true;
  function privateStaticMethod() { ... }
  var onlyInstance;
  var returnedObject = {
    getInstance: function () {
      if( !onlyInstance ) {
        onlyInstance = new PrivateConstructor();
      }
      return onlyInstance;
    }
  };
  function PrivateConstructor() {}
  PrivateConstructor.prototype = returnedObject;
  PrivateConstructor.prototype.publicProperty = true;
  ...
  return returnedObject;
})();
...
singletonMaker.foo = true;
var mySingleton = singletonMaker.getInstance();
alert(mySingleton.foo); <span class="comment">//true</span></code></pre> 
   <p>For more information on this topic, see <a href="http://kaijaeger.com/articles/the-singleton-design-pattern-in-javascript.html">Kai Jäger's article about singletons in JavaScript</a>.</p> 
   <h4>ECMAScript 5</h4> 
   <p><a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">ECMAScript 5</a> adds several additional methods for custom objects, allowing you to control whether properties can be added, or obtain information about the object's prototype. ECMAScript 5 is not currently supported by enough browsers for it to be used in most practical applications. Even the parts that are supported by Internet Explorer 9+ are not available in quirks mode - the browser intentionally regresses to IE 6's scripting support. This means that generic scripts that are designed to work anywhere, will not be able to make use of the new functionality even once it becomes widely supported.</p> 
   <p class="lastmod">Last modified: 19 March 2011</p>
   <ol id="guide">
    <li><a href="eventinfo" title="Event information">Previous</a></li>
    <li><a href="timers" title="Creating time delays">Next</a></li>
   </ol>
  </div> 
  <address><a href="/aboutsite.html">This site</a> was created by <a href="/sendEmail.php">Mark "Tarquin" Wilton-Jones</a>.</address> 
  <!-- DO NOT follow this link - anti spider abuse --> 
  <div style="display:none;speak:none;">
   <a href="/spdrwarn.html" onclick="return false;">Don't click this link unless you want to be banned from our site.</a>
  </div>  
 </body>
</html>