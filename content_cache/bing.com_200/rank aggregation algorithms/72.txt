<html>
 <head> 
  <title>JUNG Manual</title> 
 </head> 
 <body> 
  <h1>JUNG (Java Universal Network/Graph) Framework Manual</h1> 
  <h2>Table of Contents</h2> 
  <ol> 
   <li></li>
   <h3><a href="#intro">Introduction</a></h3> 
   <ol> 
    <li></li>
    <h4><a href="#why">Why JUNG Exists</a></h4> 
    <li></li>
    <h4><a href="#what">What JUNG Is And Is Not</a></h4> 
    <li></li>
    <h4><a href="#use">Using This Manual</a></h4> 
    <ol> 
     <li></li>
     <h5><a href="#nomenclature">Nomenclature</a></h5> 
    </ol> 
    <li></li>
    <h4><a href="#how">How To Contact The JUNG Project</a></h4> 
   </ol> 
   <li></li>
   <h3><a href="#start">Getting Started</a></h3> 
   <li></li>
   <h3><a href="#gve">Graphs, Vertices, and Edges</a></h3> 
   <ol> 
    <li></li>
    <h4><a href="#properties">Basic Properties and Operations</a></h4> 
    <li></li>
    <h4><a href="#types">Types</a></h4> 
    <li></li>
    <h4><a href="#create">Creating and Adding</a></h4> 
    <li></li>
    <h4><a href="#copy">Copying and Equivalency</a></h4> 
    <li></li>
    <h4><a href="#remove">Removing Vertices and Edges</a></h4> 
   </ol> 
   <li></li>
   <h3><a href="#data">User Data</a></h3> 
   <ol> 
    <li></li>
    <h4><a href="#extension">Class Extension</a></h4> 
    <li></li>
    <h4><a href="#annotation">JUNG Annotation</a></h4> 
    <li></li>
    <h4><a href="#copyaction">Copying User Data</a></h4> 
    <li></li>
    <h4><a href="#deco">Decorators, Indexers, and Labellers</a></h4> 
   </ol> 
   <li></li>
   <h3><a href="#io">Input and Output</a></h3> 
   <li></li>
   <h3><a href="#algorithms">Algorithms</a></h3> 
   <ol> 
    <li></li>
    <h4><a href="#matrix">Graph/Matrix Operations</a></h4> 
    <li></li>
    <h4><a href="#clustering">Clustering</a></h4> 
    <li></li>
    <h4><a href="#topology">Topology, Paths, and Flows</a></h4> 
    <li></li>
    <h4><a href="#importance">Importance</a></h4> 
    <li></li>
    <h4><a href="#optimization">Optimization</a></h4> 
    <li></li>
    <h4><a href="#statistics">Statistics</a></h4> 
    <li></li>
    <h4><a href="#permuters">Permutations</a></h4> 
   </ol> 
   <li></li>
   <h3><a href="#filter">Filtering</a></h3> 
   <li></li>
   <h3><a href="#viz">Visualization</a></h3> 
   <li></li>
   <h3><a href="#util">Utilities</a></h3> 
   <li></li>
   <h3><a href="#samples">Sample Code</a></h3> 
  </ol> 
  <hr> 
  <h2><a name="intro">Introduction</a></h2> 
  <blockquote> 
   <h3><a name="overview">Overview</a></h3> 
   <blockquote> 
    <p>JUNG is an open-source software library that provides a common and extendible language for the modeling, analysis, and visualization of data that can be represented as a graph or network. It is written in Java, which allows JUNG-based applications to make use of the extensive built-in capabilities of the Java API, as well as those of other existing third-party Java libraries.</p> 
    <p>The JUNG architecture is designed to support a variety of representations of entities and their relations, such as directed and undirected graphs, multi-modal graphs, graphs with parallel edges, and hypergraphs. It provides a mechanism for annotating graphs, entities, and relations with metadata. This facilitates the creation of analytic tools for complex data sets that can examine the relations between entities as well as the metadata attached to each entity and relation.</p> 
    <p>The current distribution of JUNG includes implementations of a number of algorithms from graph theory, data mining, and social network analysis, such as routines for clustering, decomposition, optimization, random graph generation, statistical analysis, and calculation of network distances, flows, and importance measures (centrality, PageRank, HITS, etc.).</p> 
    <p>JUNG also provides a visualization framework that makes it easy to construct tools for the interactive exploration of network data. Users can use one of the layout algorithms provided, or use the framework to create their own custom layouts. In addition, filtering mechanisms are provided which allow users to focus their attention, or their algorithms, on specific portions of the graph.</p> 
    <p>We hope that JUNG will make it easier for those who work with graphs, networks, and relational data to make use of one another's development efforts.</p> 
   </blockquote> 
   <h3><a name="why">Why JUNG Exists</a></h3> 
   <blockquote> 
    <p>The JUNG Project was created because we perceived a need for a general, flexible, and powerful API for manipulating, analyzing, and visualizing graphs and networks in Java--and because none of the other tools/APIs that we found fit our specific requirements for the projects that we were working on at the time. However, there are other tools available for manipulating networks, which may be more appropriate for you, depending on your specific needs and abilities. The <a href="http://jung.sourceforge.net/faq.html">JUNG FAQ</a> summarizes some of the basic distinctions between JUNG and other tools for network analysis and visualization. </p>
   </blockquote> 
   <h3><a name="what">What JUNG Is And Is Not</a></h3> 
   <blockquote> 
    <p>JUNG is a framework on which applications and tools for handling and visualizing graph and network data can be built. It can be used in simple snippets of code to test ideas, or in the context of a sophisticated tool with a graphic user interface.</p> 
    <p>JUNG is not itself a finished tool (nor is it intended to be one). You can build a tool that uses JUNG, but this will require some Java programming. The JUNG distribution does provide some samples of small applications that use JUNG to accomplish certain tasks, but they are intended to be examples of how one might use JUNG, not tools in their own right.</p> 
    <p>If you are not an experienced Java programmer, but would like to learn to use Java, we recommend that you visit the website for <a href="http://java.sun.com/docs/books/tutorial/">The Java Tutorial</a>.</p> 
   </blockquote> 
   <h3><a name="use">Using This Manual</a></h3> 
   <blockquote> 
    <p>This manual is intended for people who intend to write programs using JUNG. You will get the most out of this manual (and out of JUNG) if you have some knowledge of Java, programming, and basic graph theoretic concepts and algorithms (graphs/networks, nodes/vertices, arcs/edges). This manual will not tell you how to write programs in Java, or tell you the details of how the algorithms work.</p> 
    <p>You may find it useful to have the Javadoc documentation handy when reading this manual, as it will provide specific details for how to use the methods that this manual will refer to.</p> 
    <p>This document is sometimes updated less frequently than the release notes and the Javadoc documentation. If there is a conflict between this manual and the release notes or source code documentation, the release notes/Javadoc are generally considered to be definitive.</p> 
    <h4><a name="nomenclature">Nomenclature</a></h4> 
    <blockquote> 
     <p>The JUNG Framework is organized in a number of different packages, all of which (except where otherwise noted) share the prefix <code>edu.uci.ics.jung</code>. To simplify the presentation, this prefix will be omitted except where necessary for clarity; thus, for example, the package <code>edu.uci.ics.jung.graph.impl</code> will be referred to as <code>graph.impl</code>.</p> 
     <p>We have attempted to use a consistent terminology in this manual, but the Javadoc documentation is more heterogenous in this regard. Thus, the JUNG Project considers the following pairs of terms to be essentially synonymous (although the first of each is generally preferred):</p> 
     <ul> 
      <li></li>
      <b>graph</b> and 
      <b>network</b> 
      <li></li>
      <b>vertex</b> and 
      <b>node</b> 
      <li></li>
      <b>edge</b> and 
      <b>arc</b> 
     </ul> 
    </blockquote> 
   </blockquote> 
   <h3><a name="how">How To Contact The JUNG Project</a></h3> 
   <blockquote> 
    <p>The JUNG Project can be contacted via information posted on <a href="http://jung.sourceforge.net">the JUNG website</a>. Please feel free to contact us with bug reports, feature requests, and information on related projects. Suggestions for how the manual and other documentation could be made more clear would be especially appreciated.</p> 
   </blockquote> 
  </blockquote> 
  <hr> 
  <h2><a name="start">Getting Started</a></h2> 
  <blockquote> 
   <p>In order to run a JUNG-based application, you will need all the packages listed on <a href="http://jung.sourceforge.net/download.html">the JUNG download page</a>. (As of this writing, this includes .jar files for JUNG, version 1.3 (or later) of a Java runtime environment (JRE), Apache Jakarta <code>commons-collections</code>, the CERN Colt scientific library, and Xerces.</p> 
   <p>Building JUNG-based applications will require all of the above, plus the Java SDK (version 1.3 or later).</p> For instructions on how to set up your computer to run (or develop) Java applications, (including downloading and installing the JRE or Java SDK), we recommend Sun's website: 
   <a href="http://developer.java.sun.com/developer/onlineTraining/new2java/gettingstartedjava.html">New-To-Java Programming Center: Getting Started</a>, and in particular the article called "Getting Started" which is linked to from that page. You may also find some of the other articles in the New-to-Java Programming Center to be of use. 
  </blockquote> 
  <hr> 
  <h2><a name="gve">Graphs, Vertices, and Edges</a></h2> 
  <blockquote> 
   <h3><a name="properties">Basic Properties and Operations</a></h3> 
   <blockquote> 
    <p>Graphs, vertices, and edges each have several properties that can be extracted from them, and operations that they can perform (or have performed upon them). The operations listed below are all guaranteed to be defined and to behave as specified for all JUNG graphs, vertices, and edges. Depending on the specific type of graph, vertex, or edge, and on the implementation used, a given graph, vertex, or edge object may have other available properties and/or operations. For specific details on the use and behavior of these operations, see the <a href="http://jung.sourceforge.net/doc/api/index.html">Javadoc documentation</a> for the appropriate class(es).</p> Graphs: 
    <ul> 
     <li></li>
     <code>newInstance()</code>: Returns a graph of the same type as the graph on which this method is invoked. 
     <li></li>
     <code>addVertex(v)</code>: Adds the vertex 
     <code>v</code> to this graph, and returns a reference to the added vertex. 
     <li></li>
     <code>addEdge(e)</code>: Adds the edge 
     <code>e</code> to this graph, and returns a reference to the added edge. 
     <li></li>
     <code>getVertices()</code>: Returns the set of all vertices in this graph. 
     <li></li>
     <code>getEdges()</code>: Returns the set of all edges in this graph. 
     <li></li>
     <code>numVertices()</code>: Returns the number of vertices in this graph. 
     <li></li>
     <code>numEdges()</code>: Returns the number of edges in this graph. 
     <li></li>
     <code>removeVertex(v)</code>: Removes the vertex 
     <code>v</code> from this graph. 
     <li></li>
     <code>removeEdge(e)</code>: Removes the edge 
     <code>e</code> from this graph. 
     <li></li>
     <code>removeVertices(s)</code>: Removes all vertices in the set 
     <code>s</code> from this graph. 
     <li></li>
     <code>removeEdges(s)</code>: Removes all edges in the set 
     <code>s</code> from this graph. 
     <li></li>
     <code>removeAllEdges()</code>: Removes all edges from this graph, leaving the vertices intact. 
     <li></li>
     <code>removeAllVertices()</code>: Removes all vertices (and, therefore, edges) from this graph. 
     <li></li>
     <code>copy()</code>: Performs a deep copy of the graph and its contents. 
    </ul> Vertices: 
    <ul> 
     <li></li>
     <code>getGraph()</code>: Returns a reference to the graph that contains this vertex. 
     <li></li>
     <code>getNeighbors()</code>: Returns the set of vertices which are connected to this vertex (by edges). 
     <li></li>
     <code>getIncidentEdges()</code>: Returns the set of edges which are incident to this vertex. 
     <li></li>
     <code>degree()</code>: Returns the number of edges incident to this vertex. 
     <li></li>
     <code>getEquivalentVertex(g)</code>: Returns the vertex in the specified graph 
     <code>g</code>, if any, that is equivalent to this vertex. 
     <li></li>
     <code>isNeighbor(v)</code>: Returns 
     <code>true</code> if the specified vertex 
     <code>v</code> and this vertex are both incident to at least one edge, and 
     <code>false</code> otherwise. 
     <li></li>
     <code>isIncident(e)</code>: Returns 
     <code>true</code> if the specified edge 
     <code>e</code> is incident to this vertex, and 
     <code>false</code> otherwise. 
     <li></li>
     <code>removeAllIncidentEdges()</code>: Removes all edges that are incident to this vertex from the graph. 
     <li></li>
     <code>copy(g)</code>: Creates a copy of this vertex in the specified graph 
     <code>g</code>. 
    </ul> Edges: 
    <ul> 
     <li></li>
     <code>getGraph()</code>: Returns a reference to the graph that contains this edge. 
     <li></li>
     <code>getIncidentVertices()</code>: Returns the set of vertices that are incident to this edge. 
     <li></li>
     <code>getEquivalentEdge(g)</code>: Returns the edge in graph 
     <code>g</code>, if any, that is equivalent to this edge. 
     <li></li>
     <code>numVertices()</code>: Returns the number of vertices that are incident to this edge. 
     <li></li>
     <code>isIncident(v)</code>: Returns 
     <code>true</code> if the specified vertex 
     <code>v</code> is incident to this edge, and 
     <code>false</code> otherwise. 
     <li></li>
     <code>copy(g)</code>: Creates a copy of this edge in the specified graph 
     <code>g</code>. 
    </ul> 
   </blockquote> 
   <h3><a name="types">Types</a></h3> 
   <blockquote> 
    <p>The <code>graph</code> package contains specifications (in the form of Java interfaces), at various levels of abstraction, for graphs, vertices, and edges. </p> 
    <h4><code>ArchetypeGraph</code>, <code>ArchetypeVertex</code>, and <code>ArchetypeEdge</code></h4> 
    <blockquote> 
     <p>The <code>Archetype</code> interfaces specify the behavior of generalized graphs, vertices, and edges; they are designed to encompass all types of graphs, including directed and undirected graphs, graphs with attached data (e.g., weighted edges), hypergraphs, and graphs with parallel edges. All graph, vertex, and edge implementations should implement the appropriate one of these interfaces (or an interface which inherits from these interfaces). The methods listed above are those available to objects which implement one of these interfaces.</p> 
    </blockquote> 
    <h4><code>Graph</code>, <code>Vertex</code>, and <code>Edge</code></h4> 
    <blockquote> 
     <p>These interfaces inherit from the <code>Archetype</code> interfaces, and specify the behavior for (binary) graphs in which each edge connects exactly two vertices; this limitation allows a number of new methods to be defined.</p> 
    </blockquote> 
    <h4><code>DirectedGraph</code> and <code>DirectedEdge</code></h4> 
    <blockquote> 
     <p>A <code>DirectedEdge</code> is a type of <code>Edge</code> which imposes an ordering on its incident vertices. <code>DirectedGraph</code> is a tagging interface for implementations of <code>Graph</code> whose edge set consists of implementations of <code>DirectedEdge</code>. Thus, for example, the author of a method which is designed to operate only on directed graphs should specify that the graph argument to the method could be <code>DirectedGraph</code>.</p> 
    </blockquote> 
    <h4><code>UndirectedGraph</code> and <code>UndirectedEdge</code></h4> 
    <blockquote> 
     <p>These interfaces are exactly analogous to the corresponding interfaces for directed graphs and edges (mentioned above), but for undirected graphs and edges (which do not impose an ordering on their incident vertices), instead.</p> 
    </blockquote> The 
    <code>graph.impl</code> package contains several implementations of these specifications in the 
    <code>graph</code> package. Currently all the code in this package is designed to support binary graphs. 
    <h4><code>AbstractSparseGraph</code>, <code>AbstractSparseVertex</code>, and <code>AbstractSparseEdge</code></h4> 
    <blockquote> 
     <p>These classes are skeletal implementations of the <code>Graph</code>, <code>Vertex</code>, and <code>Edge</code> interfaces. Their intent is to minimize the effort required to implement these interfaces, while not committing to details such as whether the graph is directed or not.</p> 
     <p>These classes, and those that inherit from them, are designed for sparse graphs (ones in which the number of edges is only a few times as large as the number of vertices). They may not be the best implementations for representing and manipulating dense graphs (ones in which most vertices are connected to most other vertices).</p> 
     <p>Since these are abstract classes, users cannot create instances of them.</p> 
    </blockquote> 
    <h4><code>DirectedSparseGraph</code>, <code>DirectedSparseVertex</code>, and <code>DirectedSparseEdge</code></h4> 
    <blockquote> 
     <p>These classes extend the <code>Abstract</code> graph, vertex, and edge classes for directed graphs; the graph and edge classes implement the <code>DirectedGraph</code> and DirectedEdge interfaces, respectively.</p> 
    </blockquote> 
    <h4><code>UndirectedSparseGraph</code>, <code>UndirectedSparseVertex</code>, and <code>UndirectedSparseEdge</code></h4> 
    <blockquote> 
     <p>These classes extend the <code>Abstract</code> graph, vertex, and edge classes for undirected graphs; the graph and edge classes implement the <code>UndirectedGraph</code> and UndirectedEdge interfaces, respectively.</p> 
    </blockquote> 
   </blockquote> 
   <h3><a name="create">Creating and Adding</a></h3> 
   <blockquote> 
    <p>Creating a graph is straightforward: just call the constructor for the type of graph that you want. For example:</p> 
    <pre>
	Graph g = new DirectedSparseGraph();
</pre> 
    <p>creates a new directed sparse graph and assigns it to a variable of type <code>Graph</code>. (See the Javadoc documentation for details on the <code>Graph</code> type and the <code>DirectedSparseGraph</code> implementation.)</p> 
    <p>You can also create a graph by reading it in from a file (covered in the <a href="#io">Input and Output</a> section) or by generating a random graph (covered in the <a href="#algorithms">Algorithms</a> section).</p> 
    <p>Once you have created a graph, you can create vertices and add them to this graph:</p> 
    <pre>
	Vertex v1 = (Vertex) g.addVertex(new DirectedSparseVertex());
	Vertex v2 = (Vertex) g.addVertex(new DirectedSparseVertex());
</pre> 
    <p>and once you have vertices, you can connect them with edges:</p> 
    <pre>
	DirectedEdge e = (DirectedEdge) g.addEdge(new DirectedSparseEdge(v1, v2));
</pre> 
    <p>Note that creating vertices/edges and adding them to a graph are actually two different operations, which we combine here into a single line of code. The two-stage nature of this process makes it possible to create "orphaned" vertices/edges that are not part of a graph. This was done as a compromise between common practices in Java APIs regarding the side effects of constructors, and the semantics of graphs. However, the behavior of the JUNG edge and vertex methods, with the exception of <code>getGraph()</code>, is unspecified on orphaned vertices/edges. The JUNG Project implementations will never create orphaned vertices/edges, and we strongly recommend that users follow this practice by nesting the call to the vertex/edge constructor inside the call to the graph method that adds its argument to the graph (as in the examples above).</p> 
    <p>Some constraints to keep in mind:</p> 
    <ul> 
     <li></li>A vertex/edge may only be in one graph at a time. 
     <li></li>A vertex/edge may only be added to a given graph once. 
     <li></li>An edge may not be created incident to "orphaned" vertices. 
     <li></li>An edge may not be created which joins vertices in different graphs. 
     <li></li>The directionality of a vertex must match that of the graph to which it is being added. (Thus, for example, you may not add a 
     <code>DirectedSparseVertex</code> to an implementation of 
     <code>UndirectedGraph</code>.) 
     <li></li>The directionality of an edge must match that of the vertices that it is connecting, and that of the graph to which it is being added. 
    </ul> 
   </blockquote> If any of these constraints are violated, the error will be caught at runtime, and a 
   <code>FatalExcecption</code> will be thrown. Note that while most of these constraints are fail-fast (that is, they will be caught as soon as the error is encountered), some of them will not be so indicative, and will fail more subtly. 
   <h3><a name="copy">Copying and Equivalency</a></h3> 
   <blockquote> 
    <p>You can make a copy of a graph, or copy a vertex or edge from one graph (the <i>original</i> graph) to another graph (the <i>target</i> graph).</p> 
    <p>Copying a vertex or edge does three things:</p> 
    <ul> 
     <li></li>A new vertex or edge is created in the target graph, of the same type as the original vertex or edge. 
     <li></li>Any user data which is preserved by copying will be copied from the original vertex/edge to the copy. (The behavior of user data when its host is copied is discussed in the section called 
     <a href="#data">"User Data"</a>.) 
     <li></li>An equivalence relation is created between the original vertex/edge (and any vertices/edges to which the original vertex is equivalent) and the copy. 
    </ul> 
    <p>Copying a graph does three things:</p> 
    <ul> 
     <li></li>A new graph is created, of the same type as the original graph. 
     <li></li>Any user data which is preserved by copying will be copied from the original vertex/edge to the copy. (The behavior of user data when its host is copied is discussed in the section called 
     <a href="#data">"User Data"</a>.) 
     <li></li>Each vertex and edge of the original graph is copied (as defined above) to the target graph. 
    </ul> 
    <p>The following code creates a graph, creates two vertices and an edge and adds them to this graph, then copies each vertex and edge from the original graph to a new target graph.</p> 
    <pre>
	Graph original = new DirectedSparseGraph();
	Vertex v1_orig = original.addVertex(new DirectedSparseVertex());
	Vertex v2_orig = original.addVertex(new DirectedSparseVertex());
	DirectedEdge e_orig = original.addEdge(new DirectedSparseEdge(v1, v2));

	Graph target = new DirectedSparseGraph();
	Vertex v1_copy = v1_orig.copy(target);
	Vertex v2_copy = v2_orig.copy(target);
	DirectedEdge e_copy = e_orig.copy(target);
</pre> 
    <p>The vertices <code>v1_copy</code> and <code>v2_copy</code> are equivalent to the vertices <code>v1_orig</code> and <code>v2_orig</code>, respectively, and the edge <code>e_copy</code> is equivalent to the edge <code>e_orig</code>. That is, each of the following statements evaluates to <code>true</code>:</p> 
    <pre>
	v1_orig == v1_copy.getEquivalentVertex(original);
	v2_orig == v2_copy.getEquivalentVertex(original);
	v1_copy == v1_orig.getEquivalentVertex(target);
	v2_copy == v2_orig.getEquivalentVertex(target);
	e_orig == e_copy.getEquivalentEdge(original);
	e_copy == e_orig.getEquivalentEdge(target);
</pre> 
    <p>As a convenience, the Java <code>equals</code> method has been implemented to respect this equivalence relation, so the following statements also each evaluate to <code>true</code>:</p> 
    <pre>
	v1_orig.equals(v1_copy);
	v1_copy.equals(v1_orig);
	v2_orig.equals(v2_copy);
	v2_copy.equals(v2_orig);
	e_orig.equals(e_copy);
	e_copy.equals(e_orig);
</pre> 
    <p>There are some restrictions that govern when and where vertices and edges may be copied:</p> 
    <ul> 
     <li></li>The original graph and the target graph may not be the same. 
     <li></li>The vertices incident to an edge must have equivalents in the target graph before the edge can be copied into that graph. (Thus, in the example above, we could not have copied the edge 
     <code>e_orig</code> until its incident vertices 
     <code>v1_orig</code> and 
     <code>v2_orig</code> had been copied.) 
     <li></li>Two equivalent vertices (or two equivalent edges) may not exist in the same graph. Thus, a vertex or edge cannot be copied into a graph if it already has an equivalent in that graph. 
    </ul> 
   </blockquote> 
   <h3><a name="remove">Removing Vertices and Edges</a></h3> 
   <blockquote> 
    <p>To remove a vertex or edge from a graph, call the appropriate removal method:</p> 
    <pre>
	g.removeEdge(e);
	g.removeVertex(v1);
</pre> 
    <p>Removing an edge from a graph will not affect any other part of the graph. Removing a vertex from a graph may cause the edges that are incident to that vertex to be removed if these edges would otherwise become ill-formed. (An ill-formed edge is one that is incident to the wrong number of vertices. In graphs where edges are defined to connect exactly two vertices, removing a vertex will result in the removal of all of its incident edges.)</p> 
    <p>Removing an element from a graph does not free the memory used by that object. (In fact, you can remove an element from a graph and then re-insert it in that graph or in a different graph). As with all Java programs, the Java garbage collector is responsible for freeing the memory for an object once it is no longer being used. Removing an element from a graph also does not remove it from any user data structures (discussed in the section entitled <a href="#data">"User Data"</a>); users are responsible for updating the user data as necessary.</p> 
   </blockquote> 
  </blockquote> 
  <hr> 
  <h2><a name="data">User Data</a></h2> 
  <blockquote> 
   <p>Users can associate data with graphs, edges, or vertices in two ways: class extension and the built-in JUNG annotation mechanism.</p> 
   <h3><a name="extension">Class Extension</a></h3> 
   <blockquote> 
    <p>Users can extend the classes provided so that they include the variables/properties (and methods for manipulating those fields) that the user desires. This mechanism is most appropriate for applications which are designed to operate on a specific data set, each of whose elements have known properties. For instance, a network representing a highway system might store, for each segment of highway between interchanges (i.e., edge), the length of that segment.</p> 
    <p>The ability to extend the JUNG classes is a feature of the Java language, and is not specific to JUNG. However, class extenders should note that the AbstractSparse classes use the Object.clone() method to copy Vertices, Edges, and Graphs; therefore, copies of objects will be "shallow" copies. (For more information on cloning objects, and on "deep" and "shallow" copies, see the Java Tutorial). </p> 
    <p>This sample code creates a class that extends <code>DirectedSparseVertex</code> and carries with it some of its own sample data. Note that the routine looks exactly like a standard Java extension of the class. </p> 
    <pre>
class PersonVertex extends DirectedSparseVertex {
    private String name;
    private List publications;     

    public PersonVertex( String name, List publications ) {
       this.name = name;
       this.publications = publications;
    }

    public List getPublications() { return publications; }
}
</pre> 
    <p>There may be circumstances under which it is better to store information through the annotation mechansims discussed below, or the class extension system. In particular, the annotation mechanisms are substantially more flexible than class extension.</p> 
   </blockquote> 
   <h3><a name="annotation">JUNG Annotation</a></h3> 
   <blockquote> 
    <p>The JUNG <code>utils</code> package provides a built-in mechanism, the <code>UserData</code> class, for annotating graph elements with data. This mechanism is most appropriate for handling data which is either temporary or idiosyncratic (i.e., data which not every graph element of that type will have or need).</p> 
    <p>Each of the JUNG graph, vertex, and edge implementations extends <code>UserData</code>, which provides the following operations:</p> 
    <ul> 
     <li></li>
     <code>addUserDatum(key, datum, copyaction)</code>: Adds the specified object 
     <code>datum</code> with the specified retrieval 
     <code>key</code> to this object's user data repository, with the specified 
     <code>copyaction</code>. 
     <li></li>
     <code>getUserDatum(key)</code>: Retrieves the object that has the specified retrieval 
     <code>key</code> from this object's user data repository. 
     <li></li>
     <code>removeUserDatum(key)</code>: Removes the object that has the specified retrieval 
     <code>key</code> from this object's user data repository. 
     <li></li>
     <code>setUserDatum(key, datum, copyaction)</code>: Replaces the object (if any) which has the specified retrieval 
     <code>key</code> with the specified object 
     <code>datum</code> and 
     <code>copyaction</code>. If there is no such object, then this method is equivalent to 
     <code>addUserDatum(key, datum, copyaction)</code>. 
     <li></li>
     <code>importUserData(udc)</code>: Takes the user data stored in 
     <code>udc</code> (the user data repository of another graph element) and copies it to this object's user data repository, according to the constraints of each datum's copy action. 
     <li></li>
     <code>getUserDatumKeyIterator()</code>: Provides an iterator over this object's user data repository key set; this allows a user to examine the contents of the user data repository of this object. 
     <li></li>
     <code>getUserDatumCopyAction(key)</code>: Retrieves the copy action for the datum with the specified retrieval 
     <code>key</code> from this object's user data repository. 
    </ul> 
    <p>(The purpose and semantics of copy actions are discussed in the section below entitled <a href="#copyaction">Copying User Data</a>.)</p> 
    <p>Here is a simple example of how this user data may be stored, accessed, modified, and removed:</p> 
    <pre>
	Vertex v = (Vertex) g.addVertex(new DirectedSparseVertex());
	Vertex w = (Vertex) g.addVertex(new DirectedSparseVertex());
	String name_key = "name";
	String current_address_key = "address";
	String current_student_key = "student";
	v.addUserDatum(name_key, "Carl Jung", UserData.SHARED);
	w.addUserDatum(name_key, "Sigmund Freud", UserData.SHARED);
	v.addUserDatum(current_address_key, "Vienna, Austria", UserData.SHARED);
	v.addUserDatum(current_student_key, w, UserData.REMOVE);  // Freud is a student of Jung!
	...
	String v_name = v.getUserDatum(namekey);
	v.setUserDatum(current_address_key, "Basel, Switzerland", UserData.SHARED);
	v.removeUserDatum(current_student_key);
</pre> 
    <p>This example shows that userdata can contain any java object, including other vertices.</p> 
   </blockquote> 
   <h3><a name="copyaction">Copying User Data</a></h3> 
   <blockquote> 
    <p>When a graph element <code>a</code> is copied (with the <code>copy</code> method), the newly created element <code>b</code> calls <code>importUserData(a)</code>, which attempts to copy each of the objects in <code>a</code>'s user data repository to <code>b</code>'s user data repository. The behavior of each such copy attempt will depend on the copy action that was specified when the corresponding user data element was created.</p> 
    <p>The interface <code>UserDataContainer</code> contains an interface called <code>CopyAction</code>, which consists of a single method signature, <code>onCopy(value, source, target)</code>. <code>importUserData(a)</code> retrieves the copy action (which is an implementation of <code>CopyAction</code>) for each element in <code>a</code>'s user data repository. This copy action then calls <code>onCopy(datum, a, b)</code>, and based on the result, decides what to do with the specified <code>datum</code>.</p> 
    <p>JUNG provides three different implementations of <code>CopyAction</code>: <code>UserData.CLONE</code>, <code>UserData.REMOVE</code>, and <code>UserData.SHARED</code>.</p> 
    <p><code>UserData.CLONE</code>'s version of <code>onCopy()</code> returns a copy of the user datum, as defined by the Java <code>clone()</code> method; <code>importUserData</code> then places this copy in the target graph element's user data repository. This clone is completely independent of the original. (If the user datum does not support the <code>clone()</code> method, <code>onCopy</code> will throw the Java <code>CloneNotSupportedException</code>.)</p> 
    <p><code>UserData.SHARED</code>'s version of <code>onCopy()</code> returns a reference to the original user datum; <code>importUserData</code> then places this reference in the target graph element's user data repository. Thus, any changes to this user datum that are made by one of the graph elements that share this user datum will be reflected in all such graph elements.</p> 
    <p><code>UserData.REMOVE</code>'s version of <code>onCopy()</code> returns null; that is, user data that is created with this copy action will not be copied by the <code>copy()</code> method.</p> 
   </blockquote> 
   <h3><a name="deco">Decorators, Indexers, and Labellers</a></h3> 
   <blockquote> 
    <p>JUNG includes a few convenience classes that provide examples of structured uses of the user data repositories; these may be found in the package <code>graph.decorators</code>. We will briefly discuss two of these classes here; for more details and to see what other examples are available, see the <a href="http://jung.sourceforge.net/doc/api/index.html">Javadoc documentation</a>.</p> 
    <h4>Indexer</h4> 
    <blockquote> 
     <p>An <code>Indexer</code> contains methods that create a mapping between the vertices of a graph and the integers <code>{0, 1, ... n-1}</code> (where <code>n</code> is the number of vertices in the graph). It provides mechanisms to get the index of a given vertex (<code>getIndex(v)</code>) and to get the vertex with a specified index (<code>getVertex(i)</code>). Among other things, <code>Indexer</code> thus makes it convenient to arrange a set of vertices in an array, using each vertex's index as an index into the array.</p> 
     <p>Note: if a graph that has been indexed is modified, the user must call <code>updateIndex</code> in order to make sure that all vertices are indexed properly.</p> 
    </blockquote> 
    <h4>StringLabeller</h4> 
    <blockquote> 
     <p>A <code>StringLabeller</code> is similar to an <code>Indexer</code>; it provides facilities for fetching vertices given strings (labels) and vice versa. However, the labels are user-defined and thus need not follow any particular pattern. Vertices that have not been labelled simply will not be accessible by the indexer.</p> 
    </blockquote> 
   </blockquote> 
  </blockquote> 
  <hr> 
  <h2><a name="io">Input and Output</a></h2> 
  <blockquote> 
   <p>JUNG currently provides partial support for two different formats: the <a href="http://vlado.fmf.uni-lj.si/pub/networks/pajek/">Pajek</a> format (reading and writing) and the <a href="http://graphml.graphdrawing.org/">GraphML</a> file format (reading only). The relevant classes and methods may be found in the <code>io</code> package.</p> 
   <p>Note: Check the <a href="http://jung.sourceforge.net/doc/api/index.html"> Javadoc documentation</a> for a list of the commands and tags that are currently supported by the JUNG readers and writers.</p> 
   <p>The JUNG Project does not have a native file format for graph representation.</p> 
  </blockquote> 
  <hr> 
  <h2><a name="algorithms">Algorithms</a></h2> 
  <blockquote> 
   <p>JUNG provides a number of different graph and network algorithms. Generally speaking, each type of algorithm has its own package. </p> 
   <p>This is one of the most complex and rapidly evolving aspects of JUNG; make sure that you check the <a href="http://jung.sourceforge.net/doc/">Javadoc documentation and release notes</a> to make sure that you have the latest information available on the operations available, and how to use them.</p> 
   <h3><a name="matrix">Graph/Matrix Operations</a></h3> 
   <blockquote> 
    <p>These algorithms reside in the main <code>algorithms</code> package (in the class <code>GraphMatrixOperations</code> and the interface <code>MatrixElementOperations</code>).</p> 
    <p>Matrices are one common representation for network data. <code>GraphMatrixOperations</code> is comprised of two classes of operations: those that are typically cast as matrix operations, but can be efficiently implemented by taking advantage of the structure of the graph; and operations that use the <a href="http://dsd.lbl.gov/~hoschek/colt/">CERN Colt package</a> for numerical matrix manipulation.</p> 
    <p>Some of the operations in <code>GraphMatrixOperations</code> require an implementation of <code>MatrixElementOperations</code>, to specify the behavior of the operation for a particular element type. Essentially, the methods of <code>MatrixElementOperations</code> specify how the equivalent of the vector inner (dot) product is to proceed. For example, implementations of this interface will specify whether the elements of the graph should be treated as numeric or Boolean values.</p> 
    <p>Currently, <code>GraphMatrixOperations</code> consists of the following operations:</p> 
    <ul> 
     <li></li>
     <code>square(g, meo)</code>: Returns the graph that corresponds to the square of the (weighted) adjacency matrix that the specified graph 
     <code>g</code> encodes, where the element manipulations are defined by 
     <code>meo</code>, an implementation of 
     <code>MatrixElementOperations</code>. 
     <li></li>
     <code>computeMeanFirstPassageMatrix(g, edgeWeightKey, dist)</code>: Computes the all-pairs mean-first passage time for the specified graph 
     <code>g</code> whose edge weights have user data key 
     <code>edgeWeightKey</code>, given an existing stationary probability distribution 
     <code>dist</code>. 
     <li></li>
     <code>graphToSparseMatrix(g, edgeWeightKey)</code>: returns a Colt 
     <code>SparseDoubleMatrix2D</code> that represents the edge weights (whose user data key is 
     <code>edgeWeightKey</code>) of the specified graph 
     <code>g</code>. 
     <li></li>
     <code>mapTo1DMatrix(m)</code>: Returns the Colt 
     <code>DoubleMatrix1D</code> that corresponds to the specified map 
     <code>m</code> of vertices to Java 
     <code>Double</code>s. 
    </ul> 
    <p>The matrix types that are returned by <code>graphToSparseMatrix</code> and <code>mapTo1DMatrix</code> can be passed to the CERN Colt libraries, which allows users to make use of the tools provided by those libraries on their JUNG graphs.</p> 
   </blockquote> 
   <h3><a name="clustering">Clustering</a></h3> 
   <blockquote> 
    <p>These algorithms reside in the <code>algorithms.cluster</code> package.</p> 
    <p>A cluster is a collection of objects that are all similar to each other in some way. In a network, similarity is often based on topological properties such as connectivity, but can also be based on the properties of vertices or edges in the network.</p> 
    <p>Currently, this package provides the following classes:</p> 
    <ul> 
     <li></li>
     <code>BicomponentClusterer</code>: Finds all bicomponents (or blocks) in an undirected graph 
     <code>g</code>, where a bicomponent is defined as a maximal induced biconnected subgraph of 
     <code>g</code>. 
     <li></li>
     <code>EdgeBetweennessClusterer</code>: Computes clusters for a graph based on the betweenness property of the edges. (Related algorithm: 
     <code>BetweennessCentrality</code>, in the 
     <a href="#importance">Importance</a> algorithms section.) 
     <li></li>
     <code>WeakComponentClusterer</code>: Finds all weak components in a graph 
     <code>g</code>, where a weak component is defined as a maximal weakly connected subgraph of 
     <code>g</code>. 
    </ul> 
   </blockquote> 
   <h3><a name="topology">Topology, Paths, and Flows</a></h3> 
   <blockquote> 
    <p>These algorithms perform operations on (and calculate properties of) graphs that relate to the graph's topology (that is, the structures and substructures formed by the ways that the vertices are linked together by edges).</p> 
    <p>This category of algorithms includes the following classes:</p> 
    <ul> 
     <li></li>package 
     <code>algorithms.connectivity</code>: 
     <ul> 
      <li></li>
      <code>BFSDistanceLabeler</code>: Labels each vertex in a graph with the length of the shortest unweighted path from a specified vertex in that graph. 
      <li></li>
      <code>KNeighborhoodExtractor</code>: Returns the subgraph from a graph whose vertices are separated by no more than 
      <code>k</code> edges from a specified vertex in that graph. 
     </ul> 
     <li></li>package 
     <code>algorithms.flows</code>: 
     <ul> 
      <li></li>
      <code>EdmondsKarpMaxFlow</code>: Labels each edge in a directed, edge-weighted graph with the flow along that edge which is consistent with the maximum flow for the graph. 
     </ul> 
     <li></li>package 
     <code>algorithms.shortestpath</code>: 
     <ul> 
      <li></li>
      <code>DijkstraShortestPath</code>: Labels each vertex in a graph with the length of the shortest weighted path from a specified vertex in that graph. 
      <li></li>
      <code>UnweightedShortestPath</code>: Computes the shortest path distances for an unweighted graph. 
     </ul> 
    </ul> 
   </blockquote> 
   <h3><a name="importance">Importance</a></h3> 
   <blockquote> 
    <p>These algorithms reside in the <code>algorithms.importance</code> package.</p> 
    <p>Network importance algorithms measure the importance of each vertex (or edge) according to a set of criteria that is usually based on the positioning of the vertex/edge relative to the rest of the graph.</p> 
    <p>Some of the following algorithms assume that they are given a Markov network: a directed weighted graph in which the vertices represent states, the edges represent possible state transitions, and the edge weights represent transition probabilities. The stationary probability for a vertex <code>v</code> in such a network is the limiting probability that, given an arbitrary starting state and a large number of transitions, the current state will be that of <code>v</code>.</p> 
    <p>This category of algorithms includes the following classes (in addition to other classes that provide a structural relationship between these classes):</p> 
    <ul> 
     <li></li>
     <code>BetweennessCentrality</code>: Labels each vertex and edge in a graph with a value that is derived from the number of shortest paths that pass through them. 
     <li></li>
     <code>DegreeDistributionRanker</code>: Ranks each node according to its degree. 
     <li></li>
     <code>PageRank</code>: Ranks each vertex in a modified Markov network according to its stationary probability. 
     <li></li>
     <code>PageRankWithPriors</code>: Ranks each vertex in a modified Markov network according to its stationary probability, relative to a specified set of root vertices. 
     <li></li>
     <code>HITS</code>: Ranks each vertex in a graph according to the "hubs-and-authorities" importance measures. 
     <li></li>
     <code>HITSWithPriors</code>: Ranks each vertex in a graph according to the "hubs-and-authorities" importance measures, relative to a specified set of root vertices. 
     <li></li>
     <code>KStepMarkov</code>: Ranks each vertex according to a fast approximation of the 
     <code>PageRankWithPriors</code> algorithm. 
     <li></li>
     <code>MarkovCentrality</code>: Ranks each vertex in a Markov network according to an aggregation of the mean first passage times from the other vertices. 
     <li></li>
     <code>WeightedNIPaths</code>: Ranks each vertex in a graph according to the number and length of the disjoint paths that terminate at that vertex, relative to a specified set of root vertices. 
    </ul> 
   </blockquote> 
   <h3><a name="optimization">Optimization</a></h3> 
   <blockquote> 
    <p><b>[under construction]</b></p> 
    <ul> 
     <li></li>
     <code></code> 
    </ul> 
   </blockquote> 
   <h3><a name="statistics">Statistics</a></h3> 
   <blockquote> 
    <p>These algorithms reside in the <code>statistics</code> package, and include the following classes:</p> 
    <p></p> 
    <ul> 
     <li></li>
     <code>DegreeDistributions</code>: A class of functions for analyzing the degree distribution of a set of vertices. 
     <li></li>
     <code>GraphStatistics</code>: A set of statistical measures for the structural properties of a graph. 
     <li></li>
     <code>Histogram</code>: A general-purpose class for representing distributions as histograms. 
    </ul> 
   </blockquote> 
   <h3><a name="permuters">Permutations</a></h3> 
   <blockquote> 
    <p><b>[under construction]</b></p> 
    <ul> 
     <li></li>
     <code></code> 
    </ul> 
   </blockquote> 
  </blockquote> 
  <hr> 
  <h2><a name="filter">Filtering</a></h2> 
  <blockquote> 
   <p> The JUNG filtering mechanism removes selected vertices and edges from input graphs, and returns new graphs. These new graphs are copies of the original, containing all the same vertices and edges except for those that have been removed. A <code>Filter</code> takes in a <code>Graph</code>, and returns an <code>UnassembledGraph</code>.</p> 
   <p>An <code>UnassembledGraph</code> is a temporary storage mechanism for nodes and edges: it holds all the vertices (and at least all the edges) that will be placed into the final, filtered graph. In some circumstances, just knowing which vertices pass the filter is sufficient; this information can be accessed directly from the <code>UnassembledGraph</code> with the calls <code>getUntouchedEdges()</code> and <code>getUntouchedVertices()</code>, which return the set of edges that passed the filter, and the set of vertices that passed the filter, respectively. However, most of the time, one wants to access the new graph that passes the filter; this is done with the <code>UnassembledGraph</code> method called <code>assemble()</code>, which builds the new graph. <code>assemble()</code> copies every vertex that passed the filter into the new graph, and then copies each edge that passed the original filter into the new graph if both of its incident vertices also passed the filter (thus ensuring that the resulting graph is well-formed). Note that this means that some edges returned by <code>getUntouchedEdges()</code> will not be copied into the new graph.</p> 
   <p><code>assemble()</code> can be slow, so it is sometimes desirable to string together several filters in a row, and not call <code>assemble</code> until the last <code>Filter</code> has been run. This is done by creating a filter that implements the <code>EfficientFilter</code> interface. An <code>EfficientFilter</code> is a type of <code>Filter</code> that can filter an <code>UnassembledGraph</code>, and return another <code>UnassembledGraph</code>. A filter which examines structural properties of graphs is probably not appropriate to implement as an <code>EfficientFilter</code>, because <code>UnassembledGraph</code>s may contain incorrect topology information (in particular, as noted above, the edge set may include some ill-formed edges). It is the responsibility of the user to determine whether a given filtering mechanism can be implemented as an <code>EfficientFilter</code>.</p> 
   <p> While a user can write a custom filter merely by implementing the interface, it is often easiest to extend one of the two provided base <code>Filter</code> classes, <code>VertexAcceptFilter</code> and <code>EdgeAcceptFilter</code>. Both of these require the user to write a method--<code>boolean acceptVertex(vertex)</code> or <code>boolean acceptEdge(edge)</code>, respectively. By default, these are not declared to be <code>EfficientFilter</code>s; however, users may certainly create extensions of these filters that are <code>EfficientFilter</code>s. </p> 
   <p> The <code>SerialFilter</code> mechanism applies a series of filters sequentially to a specified graph, in the order in which they were added to the <code>SerialFilter</code>. As the filters are applied, it checks to see whether each one is an <code>EfficientFilter</code>, and calls <code>assemble</code> as necessary. </p> 
   <p>The <code>LevelFilter</code> interface was designed to be used in conjunction with the <code>GraphDraw</code> mechanism. <code>LevelFilter</code>s are filters that take an integer parameter, which is used to determine the operation of the filter (for instance, filtering all edges with weight less than the value of this parameter). With a <code>LevelFilter</code>, a slider on a visualization can be tied directly into the <code>Filter</code>, and thus can allow the user to control this parameter directly, and generate a dynamically changing graph. </p>
   <p> Detailed documentation and sample filtering code can be found within the <a href="http://jung.sourceforge.net/doc/api/index.html">Javadoc</a> for those classes. In particular, look at the package-level Javadoc for the class. </p> 
  </blockquote> 
  <hr> 
  <h2><a name="viz">Visualization</a></h2> 
  <blockquote> 
   <p>The JUNG <code>visualization</code> package provides mechanisms for laying out and rendering graphs. The current renderer implementations use the <a href="http://java.sun.com/docs/books/tutorial/uiswing/">Java Swing</a> API to display graphs, but these may be implemented using other toolkits.</p> 
   <p>In general, a visualization is accomplished with</p> 
   <ul> 
    <li></li>A 
    <code>Layout</code>, which takes a graph and determines the location at which each of its vertices will be drawn. 
    <li></li>A (Swing) Component, into which the data is rendered. (Current implementations use a 
    <code>VisualizationViewer</code>, which is an extension of the Swing 
    <code>JPanel</code> class.) 
    <li></li>A 
    <code>Renderer</code>, which takes the data provided by the 
    <code>Layout</code> and paints the vertices and edges into the provided Component. 
   </ul> 
   <p></p>Thus, by selecting one of each of these three, it is possible to coordinate drawing. The default implementation traverses the 
   <code>Layout</code>, asking it for locations of vertices, and then paints them individually with the 
   <code>Renderer</code> inside the Swing component. In addition, the 
   <code>GraphDraw</code> infrastructure simplifies many of these transformations by packaging the VisualizationViewer, the Renderer, and the 
   <code>Layout</code> together. Users may then customize this viewer as appropriate. (Sample code is available in the 
   <code>GraphDraw</code> documentation.)
   <p> </p>
   <p>The current implementation supports only 2D layout algorithms of (binary) <code>Graph</code>s; it does not support visualization of other graph types (such as hypergraphs).</p> 
   <p>This package, and the <code>visualization.graphdraw</code> package, also includes utilities and support classes that facilitate customization of a graph visualization. For instance, see the notes at <code>FadingVertexLayout</code> for a mechanism that can be used to create fading effects when vertices are filtered out and subsequently restored.</p> 
  </blockquote> 
  <hr> 
  <h2><a name="util">Utilities</a></h2> 
  <blockquote> 
   <p>JUNG includes a number of utility convenience classes, including:</p> 
   <ul> 
    <li></li>package 
    <code>util</code>: 
    <ul> 
     <li></li>
     <code>GraphUtils</code>: Contains convenience methods for operations such as creating graphs based on specified edge or vertex sets. Some specific methods include: 
     <ul> 
      <li><code>addEdge(graph, vertex1, vertex)</code> Adds an edge to a graph consisting of an appropriately-directed sparse edge between the two vertices.</li> 
      <li><code>addUndirectedVertices(graph, n), addVertices( graph, n )</code> Adds <i>n</i> undirected (or directed, respectively) vertices to the input graph.</li> 
      <li><code>getLabel(StringLabeller, vertex)</code> returns the label for the input vertex stored by the StringLabeller. If the vertex is not a member of the graph that StringLabeller has labelled, and if that graph does contain some vertex equivalent to the input, returns the equivalent label. This is useful for getting the label of a vertex once it's been run through a filter.</li> 
      <li><code>translateAll(vertices, graph), translateAllEdges( edges, graph)</code> returns subsets of vertices (or edges, respectively) from the input graph that correspond to the elements of the input set. This is a good way of finding the original vertices in a Graph after some parts have been filtered out. </li>
     </ul> 
     <li></li>
     <code>MutableDouble</code>: Wraps a value of the primitive type 
     <code>double</code> in a mutable object. 
     <li></li>
     <code>MutableInteger</code>: Wraps a value of the primitive type 
     <code>int</code> in a mutable object. 
    </ul> 
    <li></li>package 
    <code>random.generator</code>: 
    <ul> 
     <li></li>
     <code>EppsteinPowerLawGenerator</code>: Returns an undirected graph such that the degrees of the vertices are distributed according to the power law. 
     <li></li>
     <code>KleinbergSmallWorldGenerator</code>: Returns a graph with small-world connectivity. 
    </ul> 
   </ul> 
  </blockquote> 
  <hr> 
  <h2><a name="samples">Sample Code</a></h2> 
  <p>The JUNG distribution includes several examples of code whose purpose is to show users how to perform a few simple tasks using JUNG. These examples include:</p> 
  <ul> 
   <li></li>
   <code>SimpleGraphDraw</code>: Illustrates the simplest possible program for visualizing a graph using JUNG. 
   <li></li>
   <code>ClusteringDemo</code>: A simple GUI application that demonstrates the use of filters, the 
   <code>EdgeBetweennessClusterer</code> algorithm, and rendering using 
   <code>VertexColorFunction</code> and 
   <code>EdgeColorFunctions</code> to create contrast between visual elements. Can also be run as a Java web applet. 
  </ul>   
 </body>
</html>