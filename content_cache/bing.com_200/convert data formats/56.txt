<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 TRANSITIONAL//EN">
<html>
 <head> 
  <title>Développons en Java - L'utilisation des dates</title> 
  <meta http-equiv="Content-type" content="text/html; charset=ISO-8859-1"> 
  <meta name="description" content=""> 
  <meta name="keywords" content="java tutoriel tutorial cours didacticiel dej date"> 
  <meta name="robots" content="all"> 
  <meta name="revisit-after" content="2 months"> 
  <meta http-equiv="Content-Language" content="fr-FX"> 
  <meta name="author" content="Jean Michel DOUDOUX"> 
  <meta http-equiv="Reply-to" content="jean-michel.doudoux@wanadoo.fr"> 
  <link rev="made" href="mailto:jean-michel.doudoux@wanadoo.fr">
  <link href="dej_style.css" rel="stylesheet" type="text/css"> 
  <link type="text/css" rel="stylesheet" href="styles/shCore.css"> 
  <link type="text/css" rel="stylesheet" href="styles/shThemeDefault.css"> 
  <script language="javascript" src="shCore.js"></script> 
  <script language="javascript" src="shBrushJava.js"></script> 
  <script language="javascript" src="shBrushPlain.js"></script> 
  <script type="text/javascript" src="https://apis.google.com/js/plusone.js">
  {lang: 'fr'}
</script> 
 </head> 
 <body> 
  <!--ENTETE-->
  <table border="0" cellpadding="2" cellspacing="0" width="100%" bgcolor="#7B7BC2"> 
   <tbody> 
    <tr> 
     <td rowspan="2" align="center" width="50">&nbsp;</td>
     <td rowspan="2" align="center" width="50"> <a href="chap-validation_donnees.htm" alt="101. La validation des données"> <img src="FlecheG.gif" alt="101. La validation des données" align="left" border="0" hspace="0" width="31" height="31"> </a> </td> 
     <td rowspan="2" align="center" width="50"> <a href="chap-planification_taches.htm" alt="103. La planification de tâches"> <img src="FlecheD.gif" alt="103. La planification de tâches" align="left" border="0" hspace="0" width="31" height="31"> </a> </td> 
     <td rowspan="2" align="center"> <a href="javascript:window.print()"> <img src="imprimer.gif" width="46" height="40" align="middle" alt="Imprimer" border="0"> </a> </td> 
     <td rowspan="2" align="center"> <a href="index.htm"> <img src="index.gif" alt="Sommaire" align="middle" border="0" hspace="0" width="34" height="31"> </a> </td> 
     <td rowspan="2" align="center"> <a href="indexavecframes.htm" target="_top"> <img src="frame.png" alt="Consulter avec table des matières" align="middle" border="0" hspace="0" width="46" height="40"> </a> </td> 
     <td rowspan="2" align="left" valign="middle" style="vertical-align:middle"> 
      <form method="get" action="http://www.google.com/search" target="_blank"> 
       <div style="border:0px dotted black;padding:4px;width:380px;"> 
        <input type="text" name="q" size="35" style="color:#808080;" maxlength="255" value="Recherche dans DEJ avec Google" onfocus="if(this.value==this.defaultValue) this.value=''; this.style.color='black';" onblur="if(this.value=='') this.value=this.defaultValue;this.style.color='#808080'; "> 
        <input type="submit" value="Rechercher"> 
        <input type="hidden" name="sitesearch" value="http://www.jmdoudoux.fr/java/dej"> 
       </div> 
      </form> </td> 
     <td rowspan="2" align="left" valign="middle" style="vertical-align:middle"> 
      <g:plusone></g:plusone> </td> 
     <td align="right"> <font color="#FFFFFF" size="5"><b><i>Développons en Java&nbsp;&nbsp;</i></b></font><font color="#FFFFFF" size="-1"> v 2.10&nbsp;&nbsp;</font></td> 
    </tr> 
    <tr> 
     <td align="right"><font color="#FFFFFF" size="-1">Copyright (C) 1999-2016 <a class="auteur" href="http://www.jmdoudoux.fr/presentation.htm" rel="author">Jean-Michel DOUDOUX</a>.&nbsp;&nbsp;</font></td> 
    </tr> 
   </tbody> 
  </table> 
  <hr> 
  <p>&nbsp;</p> 
  <h1 class="TITRESECTION0">
   <!--idrefpage value="utilisation_dates" -->
   <!--resumetitre value="ce chapitre d&eacute;taille l'utilisation des dates en Java" -->
   <!--nchpdeb--><a name="utilisation_dates">102. 
    <!--nchpfin-->L'utilisation des dates</a></h1> 
  <p>&nbsp;</p> 
  <!--chapitredeb--> 
  <div align="right"> 
   <table border="0" cellspacing="0" summary="titre"> 
    <tbody>
     <tr> 
      <td width="270"><img src="images/chapitre.gif" alt="chapitre" width="347" height="100" border="0"></td> 
      <td width="50" valign="top"><img src="images/1.gif" alt="1" width="62" height="83" border="0"></td> 
      <td width="50" valign="top"><img src="images/0.gif" alt="0" width="62" height="83" border="0"></td> 
      <td width="50" valign="top"><img src="images/2.gif" alt="2" width="62" height="83" border="0"></td> 
     </tr> 
    </tbody>
   </table> 
   <br> 
  </div> 
  <!--chapitrefin--> 
  <div align="justify"> 
   <!--resumedeb niveau="2" datecrea="" datemodif="" version=""--> 
   <p>&nbsp;</p> 
   <div align="right"> 
    <table border="0" cellspacing="0" cellpadding="0"> 
     <tbody>
      <tr>
       <td width="200">Niveau :</td>
       <td width="200">&nbsp;<img src="images/niveau2.png" width="80" height="12" alt="niveau 2">&nbsp;Elémentaire&nbsp;</td>
      </tr> 
     </tbody>
    </table> 
   </div> 
   <!--resumefin--> 
   <p>&nbsp;</p> 
   <p>La manipulation des dates n'est pas toujours facile à mettre en oeuvre :</p> 
   <ul> 
    <li>il existe plusieurs calendriers dont le plus usité est le calendrier Grégorien</li> 
    <li>le calendrier Grégorien comporte de nombreuses particularités : le nombre de jours d'un mois varie selon le mois, le nombre de jours d'une année varie selon l'année (année bissextile), ...</li> 
    <li>le format textuel de restitution des dates diffère selon la Locale utilisée</li> 
    <li>l'existence des fuseaux horaires qui donnent une date/heure différente d'un point dans le temps selon la localisation géographique</li> 
    <li>la possibilité de prendre en compte un décalage horaire lié aux heures d'été et d'hiver</li> 
    <li>...</li> 
   </ul> 
   <p>Pourtant le temps s'écoule de façon linéaire : c'est d'ailleurs de cette façon que les calculs de dates sont réalisés avec Java, en utilisant une représentation de la date qui indique le nombre de millisecondes écoulées depuis un point d'origine défini. Dans le cas de Java, ce point d'origine est le 1er janvier 1970. Ceci permet de définir un point dans le temps de façon unique.</p> 
   <p>L'utilisation de dates en Java est de surcroît plus compliquée à cause de l'API historique qui permet leur gestion car elle n'est pas toujours intuitive.</p> 
   <p>Il est intéressant de découpler l'obtention de la date/heure système par exemple en utilisant une fabrique. Cette fabrique renvoie la date/heure système en production mais elle est aussi capable de renvoyer une date/heure déterminée.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">Date aujourdhui = SystemClockFactory.getDatetime();</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>L'utilisation d'une telle fabrique peut être particulièrement utile lors de tests unitaires ou d'intégration pour faciliter la vérification des résultats par rapport à un type de données dont la valeur par définition évolue constamment.</p> 
   <p>Ceci évite entre autres d'avoir à modifier la date système sur la ou les machines sur lesquelles les tests sont exécutés.</p> 
   <p>La bibliothèque jFin propose aussi des fonctionnalités relatives au traitement des dates spécifiquement dédiées à la finance.</p> 
   <p>Ce chapitre contient plusieurs sections :</p> 
   <!--listesectiondeb--> 
   <ul type="square"> 
    <li><a href="#utilisation_dates-1">Les classes standard du JDK pour manipuler des dates</a></li> 
    <li><a href="#utilisation_dates-2">Des exemples de manipulations de dates</a></li> 
    <li><a href="#utilisation_dates-3">La classe SimpleDateFormat</a></li> 
    <li><a href="#utilisation_dates-4">Joda Time</a></li> 
    <li><a href="#utilisation_dates-5">La classe FastDateFormat du projet Apache commons.lang</a></li> 
    <li><a href="#utilisation_dates-6">L'API Date and Time</a></li> 
   </ul> 
   <!--listesectionfin--> 
   <p>&nbsp;</p> 
   <h2 class="TITRESECTION1">
    <!--nchpdeb--><a name="utilisation_dates-1">102.1. 
     <!--nchpfin-->Les classes standard du JDK pour manipuler des dates</a></h2> 
   <p>En Java 1.0, la classe java.util.Date était seule responsable de l'encapsulation et de la manipulation d'une date.</p> 
   <p>A partir de Java 1.1, la responsabilité de la gestion et des traitements sur les dates est répartie sur plusieurs classes :</p> 
   <ul> 
    <li>java.util.Date : elle encapsule un point dans le temps</li> 
    <li>java.util.Calendar et java.util.GregorianCalendar : elle permet la manipulation d'une date</li> 
    <li>java.util.TimeZone et java.util.SimpleTimeZone&nbsp;: elle encapsule un fuseau horaire à partir du méridien de Greenwich (GMT) et les informations relatives aux décalages concernant les heures d'été et d'hiver</li> 
    <li>java. text.DateFormat, java.text.SimpleDateFormat : elle permet de convertir une date en chaîne de caractères et vice versa</li> 
    <li>java.text.DateFormatSymbols : elle permet de traduire les différents éléments d'une date (jour, mois, ...)</li> 
   </ul> 
   <p>Les classes permettant la mise en oeuvre des dates sont dans le package java.util exceptées celles relatives à leur conversion de et vers une chaîne de caractères qui sont dans le package java.text.</p> 
   <p>Le package java.sql contient aussi des classes relatives aux dates et à leur utilisation dans une base de données&nbsp;:</p> 
   <ul> 
    <li>java.sql.Date : hérite de java.util.Date et n'encapsule que la date sans la partie horaire</li> 
    <li>java.sql.Time : hérite de java.util.Date et n'encapsule que la partie horaire sans la partie date</li> 
    <li>java.sgl.Timestamp : encapsule un point dans le temps avec une représentation particulière pour une utilisation avec SQL</li> 
   </ul> 
   <p>Les classes abstraites Calendar, TimeZone et DateFormat possèdent toutes une implémentation concrète respectivement GregorianCalendar, SimpleTimeZone et SimpleDateFormat.</p> 
   <p>La conception des classes qui encapsulent et manipulent des dates ne facilitent pas leur mise en oeuvre. C'est d'autant plus dommageable que l'utilisation de dates est courante notamment dans les applications de gestion.</p> 
   <p>Par exemple, l'API propose au moins quatre manières pour obtenir un point dans le temps depuis le 1 janvier 1970 :</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">  System.out.println(System.currentTimeMillis());
  System.out.println(new java.util.Date().getTime());
  System.out.println(Calendar.getlnstance().getTimelnMillis() );
  System.out.println(Calendar.getlnstance().getTime().getTime ())
</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>L'API de gestion des dates en Java est particulièrement propice à la confusion et à l'obtention d'erreurs potentielle :</p> 
   <ul> 
    <li>nommage de certaines méthodes (Date.getTime(), Date.getDate(), ...)</li> 
    <li>gestion des mois de 0 à 11 au lieu de 1 à 12</li> 
   </ul> 
   <p>&nbsp;</p> 
   <h3 class="TITRESECTION2">
    <!--nchpdeb--><a name="utilisation_dates-1-1">102.1.1. 
     <!--nchpfin-->La classe java.util.Date</a></h3> 
   <p>Cette classe encapsule, sous la forme d'une variable de type long, un point dans le temps qui est représenté par le nombre de millisecondes écoulées entre le 1 janvier 1970 à 00 heure 00 GMT et l'instant concerné.</p> 
   <p>Depuis la version 1.1, toutes les méthodes permettant de manipuler la date sont deprecated.</p> 
   <p>Par défaut, cette classe encapsule le point courant dans le temps obtenu en utilisant la méthode System.currentTimeMillis() ce qui rend sa précision dépendante du système d'exploitation.</p> 
   <p>&nbsp;</p> 
   <h3 class="TITRESECTION2">
    <!--nchpdeb--><a name="utilisation_dates-1-2">102.1.2. 
     <!--nchpfin-->La classe java.util.Calendar</a></h3> 
   <p>La classe Calendar encapsule un point dans le temps (une Date sous la forme d'une variable de type long) et permet une représentation et une manipulation dans un calendrier et un fuseau horaire.</p> 
   <p>La classe Calendar n'est pas stateless puisqu'elle encapsule un point dans le temps : il est donc nécessaire d'initialiser ce point avant de pouvoir utiliser l'instance de Calendar.</p> 
   <p>Une nouvelle instance de la classe est toujours initialisée avec le point dans le temps courant. Pour encapsuler un autre point, il faut obligatoirement après l'instanciation utiliser une des méthodes de la classe pour modifier le point encapsulé.</p> 
   <p>Pour accéder aux différentes propriétés de la date encapsulée dans l'instance de Calendar, il n'existe pas un getter pour chaque propriété mais une seule méthode get() qui attend en paramètre le nom de la propriété souhaitée et qui retourne toujours une valeur de type int.</p> 
   <p>La classe Calendar définit des constantes de type int pour le nom de ces propriétés.</p> 
   <p>La classe Calendar définit aussi plusieurs constantes qui contiennent les valeurs possibles pour certaines propriétés. Leur utilisation est fortement recommandée car certaines valeurs sont parfois surprenantes notamment celles qui encapsulent un mois. La valeur d'un mois varie de 0 à 11 correspondant aux constantes Calendar.JANUARY à Calendar.DECEMBER. Calendar définit aussi la constante UNDECIMBER qui représente le treizième mois de l'année requis par certains calendriers.</p> 
   <p>Attention : toutes ces constantes sont définies pêle-mêle dans la classe et ne sont donc pas groupées par une convention de nommage dans une interface dédiée par rôle. Elles sont toutes de types int, ce qui peut permettre d'utiliser n'importe quelle constante à la place d'une autre.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">Calendar calendar = Calendar.getInstance();
if ( calendar.get( Calendar.MONTH )==Calendar.JANUARY ) { 
  system.out.prinln("la date courante est en janvier"); }
</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>La classe Calendar propose trois façons de manipuler la date qu'elle encapsule en agissant sur les éléments qui la composent :</p> 
   <ul> 
    <li>set() : permet de modifier un élément de la date</li> 
    <li>add() : permet de modifier un élément de la date en tenant compte des impacts sur les autres éléments qui composent la date</li> 
    <li>roll() : identique à la méthode add() mais sans affecter les autres éléments de la date</li> 
   </ul> 
   <p>La date encapsulée dans Calendar peut être manipulée de deux façons :</p> 
   <ul> 
    <li>directement par un calcul sur le nombre de millisecondes écoulées depuis le 1er janvier 1970</li> 
    <li>en agissant sur les éléments qui composent la date en utilisant les méthodes dédiées</li> 
   </ul> 
   <p>&nbsp;</p> 
   <h3 class="TITRESECTION2">
    <!--nchpdeb--><a name="utilisation_dates-1-3">102.1.3. 
     <!--nchpfin-->La classe java.util.GregorianCalendar</a></h3> 
   <p>La classe java.util.GregorianCalendar est la seule implémentation concrète de la classe Calendar fournie en standard. Cette implémentation correspond au calendrier Grégorien.</p> 
   <p>La méthode isLeapYear() permet de savoir si l'année encapsulée par la classe est bissextile.</p> 
   <p>&nbsp;</p> 
   <h3 class="TITRESECTION2">
    <!--nchpdeb--><a name="utilisation_dates-1-4">102.1.4. 
     <!--nchpfin-->Les classes java.util.TimeZone et java.util.SimpleTimeZone</a></h3> 
   <p>La classe abstraite TimeZone et sa sous-classe SimpleTimeZone encapsulent un fuseau horaire.</p> 
   <p>Une instance de type TimeZone est utilisée par la classe Calendar pour déterminer la date correspondant au point dans le temps qu'elle encapsule. Un même point dans le temps correspond à des dates/heures différentes pour deux fuseaux horaires différents.</p> 
   <p>Un fuseau horaire correspond à un certain décalage vis à vis du méridien de référence, le méridien de Greenwich. Le fuseau horaire correspondant à ce méridien est désigné par GMT.</p> 
   <p>Ce décalage peut en plus être affecté par un second décalage induit par les heures d'été et d'hiver (daylight savings time (DST)) si ceux-ci sont mis en place dans le pays considéré.</p> 
   <p>La classe TimeZone encapsule un nom long et un nom court qui permet d'identifier le fuseau horaire qu'elle encapsule.</p> 
   <p>La méthode String[] getAvailableIDs() permet d'obtenir les noms des TimeZones définis en standard : par exemple avec Java 6, il y a 597 TimeZones fournis.</p> 
   <p>La classe est une fabrique qui permet d'obtenir une instance de TimeZone à partir de son identifiant en utilisant la méthode getTimeZone() ou celle correspondant à la Locale courante en utilisant la méthode getDefault().</p> 
   <p>&nbsp;</p> 
   <h3 class="TITRESECTION2">
    <!--nchpdeb--><a name="utilisation_dates-1-5">102.1.5. 
     <!--nchpfin-->La classe java.text.DateFormat</a></h3> 
   <p>La clase abstraite DateFormat propose les fonctionnalités de base pour interpréter et formater une date sous la forme d'une chaîne de caractères.</p> 
   <p>Ce formatage doit traduire certains éléments notamment le jour et le mois de la date selon la Locale. De nombreux formats de dates sont aussi utilisés généralement dépendant eux aussi de la Locale.</p> 
   <p>Quatre styles de formats sont définis par défaut : SHORT, MEDIUM, LONG, et FULL. Avec une Locale et un style, la classe DateFormat peut fournir un formatage standard de la date.</p> 
   <p>La classe DateFormat propose plusieurs méthodes statiques getXXXlnstance() qui sont des fabriques renvoyant des instances de type DateFormat.</p> 
   <p>La méthode format() permet de formater une date en chaîne de caractères.</p> 
   <p>La méthode parse() permet d'extraire une date à partir de sa représentation sous la forme d'une chaîne de caractères.</p> 
   <p>La Locale et le style de la classe DateFormat ne peuvent pas être modifiés après la création de son instance.</p> 
   <p>&nbsp;</p> 
   <h3 class="TITRESECTION2">
    <!--nchpdeb--><a name="utilisation_dates-1-6">102.1.6. 
     <!--nchpfin-->La classe java.util.SimpleDateFormat</a></h3> 
   <p>La classe SimpleDateFormat permet de formater et d'analyser une date en tenant compte d'une Locale. Elle hérite de la classe abstraite DateFormat.</p> 
   <p>Pour réaliser ces traitements, cette classe utilise un modèle (pattern) sous la forme d'une chaîne de caractères.</p> 
   <p>La classe DataFormat propose plusieurs méthodes pour obtenir le modèle par défaut de la Locale courante :</p> 
   <ul> 
    <li>getTimeInstance(style)</li> 
    <li>getDateInstance(style)</li> 
    <li>getDateTimeInstance(styleDate, styleHeure)</li> 
   </ul> 
   <p>Ces méthodes utilisent la Locale par défaut mais chacune de ces méthodes possède une surcharge qui permet de préciser une Locale.</p> 
   <p>Pour chacune de ces méthodes, quatre styles sont utilisables : SHORT, MEDIUM, LONG et FULL. Ils permettent de désigner la richesse des informations contenues dans le modèle pour la date et/ou l'heure.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmd.test.dej.date;

import java.text.DateFormat;
import java.util.Date;
import java.util.Locale;

public class TestFormaterDate2 {

  /**
   * @param args
   */
  public static void main(String[] args) {
    Date aujourdhui = new Date();

    DateFormat shortDateFormat = DateFormat.getDateTimeInstance(
        DateFormat.SHORT,
        DateFormat.SHORT);

    DateFormat shortDateFormatEN = DateFormat.getDateTimeInstance(
        DateFormat.SHORT,
        DateFormat.SHORT, new Locale("EN","en"));

    DateFormat mediumDateFormat = DateFormat.getDateTimeInstance(
        DateFormat.MEDIUM,
        DateFormat.MEDIUM);

    DateFormat mediumDateFormatEN = DateFormat.getDateTimeInstance(
        DateFormat.MEDIUM,
        DateFormat.MEDIUM, new Locale("EN","en"));

    DateFormat longDateFormat = DateFormat.getDateTimeInstance(
        DateFormat.LONG,
        DateFormat.LONG);

    DateFormat longDateFormatEN = DateFormat.getDateTimeInstance(
        DateFormat.LONG,
        DateFormat.LONG, new Locale("EN","en"));

    DateFormat fullDateFormat = DateFormat.getDateTimeInstance(
        DateFormat.FULL,
        DateFormat.FULL);

    DateFormat fullDateFormatEN = DateFormat.getDateTimeInstance(
        DateFormat.FULL,
        DateFormat.FULL, new Locale("EN","en"));

    System.out.println(shortDateFormat.format(aujourdhui));
    System.out.println(mediumDateFormat.format(aujourdhui));
    System.out.println(longDateFormat.format(aujourdhui));
    System.out.println(fullDateFormat.format(aujourdhui));
    System.out.println("");
    System.out.println(shortDateFormatEN.format(aujourdhui));
    System.out.println(mediumDateFormatEN.format(aujourdhui));
    System.out.println(longDateFormatEN.format(aujourdhui));
    System.out.println(fullDateFormatEN.format(aujourdhui));
  }

}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">27/06/06 21:36
27 juin 2006 21:36:30
27 juin 2006 21:36:30 CEST
mardi 27 juin 2006 21 h 36 CEST

6/27/06 9:36 PM
Jun 27, 2006 9:36:30 PM
June 27, 2006 9:36:30 PM CEST
Tuesday, June 27, 2006 9:36:30 PM CEST</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Il est aussi possible de définir son propre format en utilisant les éléments du tableau ci-dessous. Chaque lettre du tableau est interprétée de façon particulière. Pour utiliser les caractères sans qu'ils soient interprétés dans le modèle il faut les encadrer par de simples quotes. Pour utiliser une quote il faut en mettre deux consécutives dans le modèle.</p> 
   <table class="tableau" border="1" cellpadding="4" cellspacing="0" align="center"> 
    <tbody>
     <tr> 
      <td><p align="center" style="text-align:center;"><strong>Lettre </strong></p></td> 
      <td><p align="center" style="text-align:center;"><strong>Description </strong></p></td> 
      <td><p align="center" style="text-align:center;"><strong>Exemple </strong></p></td> 
     </tr> 
     <tr> 
      <td><p align="center" style="text-align:center;"><strong>G </strong></p></td> 
      <td><p>Era</p></td> 
      <td><p>AD (Anno Domini), BC (Before Christ)</p></td> 
     </tr> 
     <tr> 
      <td><p align="center" style="text-align:center;"><strong>y </strong></p></td> 
      <td><p>Année</p></td> 
      <td><p>06 ; 2006</p></td> 
     </tr> 
     <tr> 
      <td><p align="center" style="text-align:center;"><strong>M </strong></p></td> 
      <td><p>Mois dans l'année</p></td> 
      <td><p>Septembre; Sept.; 07</p></td> 
     </tr> 
     <tr> 
      <td><p align="center" style="text-align:center;"><strong>w </strong></p></td> 
      <td><p>Semaine dans l'année</p></td> 
      <td><p>34</p></td> 
     </tr> 
     <tr> 
      <td><p align="center" style="text-align:center;"><strong>W </strong></p></td> 
      <td><p>Semaine dans le mois</p></td> 
      <td><p>2</p></td> 
     </tr> 
     <tr> 
      <td><p align="center" style="text-align:center;"><strong>D </strong></p></td> 
      <td><p>Jour dans l'année</p></td> 
      <td><p>192</p></td> 
     </tr> 
     <tr> 
      <td><p align="center" style="text-align:center;"><strong>d </strong></p></td> 
      <td><p>jour dans le mois</p></td> 
      <td><p>23</p></td> 
     </tr> 
     <tr> 
      <td><p align="center" style="text-align:center;"><strong>F </strong></p></td> 
      <td><p>Jour de la semaine dans le mois</p></td> 
      <td><p>17</p></td> 
     </tr> 
     <tr> 
      <td><p align="center" style="text-align:center;"><strong>E </strong></p></td> 
      <td><p>Jour de la semaine</p></td> 
      <td><p>Mercredi; Mer.</p></td> 
     </tr> 
     <tr> 
      <td><p align="center" style="text-align:center;"><strong>a </strong></p></td> 
      <td><p>Marqueur AM/PM (Ante/Post Meridiem)</p></td> 
      <td><p>PM, AM</p></td> 
     </tr> 
     <tr> 
      <td><p align="center" style="text-align:center;"><strong>H </strong></p></td> 
      <td><p>Heure (0-23)</p></td> 
      <td><p>23</p></td> 
     </tr> 
     <tr> 
      <td><p align="center" style="text-align:center;"><strong>k </strong></p></td> 
      <td><p>Heure (1-24)</p></td> 
      <td><p>24</p></td> 
     </tr> 
     <tr> 
      <td><p align="center" style="text-align:center;"><strong>K </strong></p></td> 
      <td><p>Heure en AM/PM (0-11)</p></td> 
      <td><p>6</p></td> 
     </tr> 
     <tr> 
      <td><p align="center" style="text-align:center;"><strong>h </strong></p></td> 
      <td><p>Heure en AM/PM (1-12)</p></td> 
      <td><p>7</p></td> 
     </tr> 
     <tr> 
      <td><p align="center" style="text-align:center;"><strong>m </strong></p></td> 
      <td><p>Minutes</p></td> 
      <td><p>59</p></td> 
     </tr> 
     <tr> 
      <td><p align="center" style="text-align:center;"><strong>s </strong></p></td> 
      <td><p>Secondes</p></td> 
      <td><p>59</p></td> 
     </tr> 
     <tr> 
      <td><p align="center" style="text-align:center;"><strong>S </strong></p></td> 
      <td><p>Millisecondes</p></td> 
      <td><p>12564</p></td> 
     </tr> 
     <tr> 
      <td><p align="center" style="text-align:center;"><strong>z </strong></p></td> 
      <td><p>Zone horaire générale</p></td> 
      <td><p>CEST; Heure d'été d'Europe centrale</p></td> 
     </tr> 
     <tr> 
      <td><p align="center" style="text-align:center;"><strong>Z </strong></p></td> 
      <td><p>Zone horaire (RFC 822)</p></td> 
      <td><p>+0200</p></td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <p>Ces caractères peuvent être répétés pour préciser le format à utiliser :</p> 
   <ul> 
    <li>Pour les caractères de type Text : moins de 4 caractères consécutifs représentent la version abrégée sinon c'est la version longue qui est utilisée.</li> 
    <li>Pour les caractères de type Number : c'est le nombre de répétitions qui désigne le nombre de chiffres utilisés, complété si nécessaire par des 0 à gauche.</li> 
    <li>Pour les caractères de type Year : 2 caractères précisent que l'année est codée sur deux caractères.</li> 
    <li>Pour les caractères de type Month : 3 caractères ou plus représentent la forme littérale sinon c'est la forme numérique du mois.</li> 
   </ul> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmd.test.dej.date;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;

public class TestFormaterDate {

  public static void main(String[] args) {
    SimpleDateFormat formater = null;

    Date aujourdhui = new Date();

    formater = new SimpleDateFormat("dd-MM-yy");
    System.out.println(formater.format(aujourdhui));

    formater = new SimpleDateFormat("ddMMyy");
    System.out.println(formater.format(aujourdhui));

    formater = new SimpleDateFormat("yyMMdd");
    System.out.println(formater.format(aujourdhui));

    formater = new SimpleDateFormat("h:mm a");
    System.out.println(formater.format(aujourdhui));

    formater = new SimpleDateFormat("K:mm a, z");
    System.out.println(formater.format(aujourdhui));

    formater = new SimpleDateFormat("hh:mm a, zzzz");
    System.out.println(formater.format(aujourdhui));

    formater = new SimpleDateFormat("EEEE, d MMM yyyy");
    System.out.println(formater.format(aujourdhui));

    formater = new SimpleDateFormat("'le' dd/MM/yyyy 'à' hh:mm:ss");
    System.out.println(formater.format(aujourdhui));

    formater = new SimpleDateFormat("'le' dd MMMM yyyy 'à' hh:mm:ss");
    System.out.println(formater.format(aujourdhui));

    formater = new SimpleDateFormat("dd MMMMM yyyy GGG, hh:mm aaa");
    System.out.println(formater.format(aujourdhui));

    formater = new SimpleDateFormat("yyyyMMddHHmmss");
    System.out.println(formater.format(aujourdhui));

  }

}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">27-06-06
270606
060627
9:37 PM
9:37 PM, CEST
09:37 PM, Heure d'été d'Europe centrale
mardi, 27 juin 2006
le 27/06/2006 à 09:37:10
le 27 juin 2006 à 09:37:10
27 juin 2006 ap. J.-C., 09:37 PM
20060627213710</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Il existe plusieurs constructeurs de la classe SimpleDateFormat :</p> 
   <table class="tableau" border="1" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td><p>Constructeur</p></td> 
      <td><p>Rôle</p></td> 
     </tr> 
     <tr> 
      <td><p>SimpleDateFormat()</p></td> 
      <td><p>Constructeur par défaut utilisant le modèle par défaut et les symboles de formatage de dates de la Locale par défaut</p></td> 
     </tr> 
     <tr> 
      <td><p>SimpleDateFormat(String)</p></td> 
      <td><p>Constructeur utilisant le modèle fourni et les symboles de formatage de dates de la Locale par défaut</p></td> 
     </tr> 
     <tr> 
      <td><p>SimpleDateFormat(String, DateFormatSymbols)</p></td> 
      <td><p>Constructeur utilisant le modèle et les symboles de formatage de dates fournis</p></td> 
     </tr> 
     <tr> 
      <td><p>SimpleDateFormat(String, Locale)</p></td> 
      <td><p>Constructeur utilisant le modèle fourni et les symboles de formatage de dates de la Locale fournie</p></td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <p>La classe DateFormatSymbols encapsule les différents éléments textuels qui peuvent entrer dans la composition d'une date pour une Locale donnée (les jours, les libellés courts des mois, les libellés des mois, ...).</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmd.test.dej.date;

import java.text.DateFormatSymbols;
import java.util.Locale;

public class TestFormaterDate3 {

  public static void main(String[] args) {
    DateFormatSymbols dfsFR = new DateFormatSymbols(Locale.FRENCH);
    DateFormatSymbols dfsEN = new DateFormatSymbols(Locale.ENGLISH);

    String[] joursSemaineFR = dfsFR.getWeekdays();
    String[] joursSemaineEN = dfsEN.getWeekdays();

    StringBuffer texteFR = new StringBuffer("Jours FR ");
    StringBuffer texteEN = new StringBuffer("Jours EN ");

    for (int i = 1; i &lt; joursSemaineFR.length; i++) {
      texteFR.append(" : ");
      texteFR.append(joursSemaineFR[i]);
      texteEN.append(" : ");
      texteEN.append(joursSemaineEN[i]);
    }
    System.out.println(texteFR);
    System.out.println(texteEN);

    texteFR = new StringBuffer("Mois courts FR ");
    texteEN = new StringBuffer("Mois courts EN ");
    String[] moisCourtsFR = dfsFR.getShortMonths();
    String[] moisCourtsEN = dfsEN.getShortMonths();

    for (int i = 0; i &lt; moisCourtsFR.length - 1; i++) {
      texteFR.append(" : ");
      texteFR.append(moisCourtsFR[i]);
      texteEN.append(" : ");
      texteEN.append(moisCourtsEN[i]);
    }

    System.out.println(texteFR);
    System.out.println(texteEN);

    texteFR = new StringBuffer("Mois FR ");
    texteEN = new StringBuffer("Mois EN ");
    String[] moisFR = dfsFR.getMonths();
    String[] moisEN = dfsEN.getMonths();

    for (int i = 0; i &lt; moisFR.length - 1; i++) {
      texteFR.append(" : ");
      texteFR.append(moisFR[i]);
      texteEN.append(" : ");
      texteEN.append(moisEN[i]);
    }

    System.out.println(texteFR);
    System.out.println(texteEN);

  }

}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">Jours FR  : dimanche : lundi : mardi : mercredi : jeudi : vendredi : samedi
Jours EN  : Sunday : Monday : Tuesday : Wednesday : Thursday : Friday : Saturday
Mois courts FR  : janv. : févr. : mars : avr. : mai : juin : juil. : août : sept. : oct.
 : nov. : déc.
Mois courts EN  : Jan : Feb : Mar : Apr : May : Jun : Jul : Aug : Sep : Oct : Nov : Dec
Mois FR  : janvier : février : mars : avril : mai : juin : juillet : août : septembre :
octobre : novembre : décembre
Mois EN  : January : February : March : April : May : June : July : August : September :
 October : November : December</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Il est possible de définir son propre objet DateFormatSymbols pour personnaliser les éléments textuels nécessaires au traitement des dates. La classe DateFormatSymbols propose à cet effet des setters sur chacun des éléments.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmd.test.dej.date;

import java.text.DateFormatSymbols;
import java.text.SimpleDateFormat;
import java.util.Date;

public class TestFormaterDate4 {

  public static void main(String[] args) {
    Date aujourdhui = new Date();
    DateFormatSymbols monDFS = new DateFormatSymbols();
    String[] joursCourts = new String[] {
        "",
        "Di",
        "Lu",
        "Ma",
        "Me",
        "Je",
        "Ve",
        "Sa" };
    monDFS.setShortWeekdays(joursCourts);
    SimpleDateFormat dateFormat = new SimpleDateFormat(
        "EEE dd MMM yyyy HH:mm:ss",
        monDFS);
    System.out.println(dateFormat.format(aujourdhui));
  }

}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">Ma 27 juin 2006 21:38:22</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Attention : il faut consulter la documentation de l'API pour connaître précisément le contenu et l'ordre des éléments fournis sous la forme de tableaux aux setters de la classe. Dans l'exemple, ci-dessus, les jours de la semaine commencent par Dimanche.</p> 
   <p>La méthode applyPattern() permet de modifier le modèle d'un objet SimpleDateFormat.</p> 
   <p>La classe SimpleDataFormat permet également d'analyser une date sous la forme d'une chaîne de caractères pour la transformer en objet de type Date en utilisant un modèle. Cette opération est réalisée grâce à la méthode parse(). Si elle échoue, elle lève une exception de type ParseException.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmd.test.dej.date;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class TestParserDate {

  public static void main(String[] args) {
    Date date = null;
    SimpleDateFormat simpleDateFormat = new SimpleDateFormat("dd/MM/yyyy");

    String date1 = "22/06/2006";
    String date2 = "22062006";

    try {
      date = simpleDateFormat.parse(date1);
      System.out.println(date);
      date = simpleDateFormat.parse(date2);
      System.out.println(date);
    } catch (ParseException e) {
      e.printStackTrace();
    }
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">Thu Jun 22 00:00:00 CEST 2006
java.text.ParseException: Unparseable date: "22062006"
	at java.text.DateFormat.parse(Unknown Source)
	at com.jmd.test.dej.date.TestParserDate.main(TestParserDate.java:19)</pre></td>
     </tr>
    </tbody>
   </table> 
   <p>&nbsp;</p> 
   <h3 class="TITRESECTION2">
    <!--nchpdeb--><a name="utilisation_dates-1-7">102.1.7. 
     <!--nchpfin-->Les classes java.sql.Date, java.sql.Time, java.sql.TimeStamp</a></h3> 
   <p>Ces trois classes héritent de la classe java.util.Date pour encapsuler des données correspondant aux types DATE, TIME et TIMESTAMP de la norme SQL 92.</p> 
   <p>La classe java.sql.Date n'encapsule que la partie date en ignorant la partie horaire du point dans le temps qu'elle encapsule.</p> 
   <p>La classe java.sql.Time, elle, n'encapsule que la partie horaire en ignorant la partie date du point dans le temps qu'elle encapsule.</p> 
   <p>La classe java.sql.TimeStamp encapsule encapsule un instant exprimé en millisecondes et des informations permettant une expression de cet instant avec une précision à la nanoseconde.</p> 
   <p>Ces trois méthodes redéfinissent la méthode toString() pour permettre une représentation respectant le standard SQL 92.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">final java.sql.Date dateSQL = new java.sql.Date(new Date().getTime()) ;
System.out.println(dateSQL);
</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Remarque : ces trois classes ne permettent pas de prendre en compte un TimeZone explicite puisque généralement c'est celui de la base de données qui est toujours utilisé par défaut.</p> 
   <p>&nbsp;</p> 
   <h2 class="TITRESECTION1">
    <!--nchpdeb--><a name="utilisation_dates-2">102.2. 
     <!--nchpfin-->Des exemples de manipulations de dates</a></h2> 
   <p>Cette section présente des portions de code pour répondre à des besoins courants de manipulations de dates.</p> 
   <p>Formater une date :</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">protected static final SimpleDateFormat dateFormat = 
  new SimpleDateFormat("dd/MM/yyyy");
protected static final SimpleDateFormat dateHeureFormat = 
  new SimpleDateFormat("dd/MM/yyyy hh:mm:ss");

public static String formatterDate(Date date) {
  return dateFormat.format(date);
}
public static String formatterDateHeure(Date date) {
  return dateFormatHeure.format(date);
}
</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Extraire une date d'une chaîne de caractères :</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">DateFormat df = new SimpleDateFormat("dd-MM-yyyy"); 
Date date=null;
try
{
  date= df.parse("25-12-2010");
} catch (ParseException e){
  e.printstacktrace();
} 
</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Ajouter/retrancher des jours à une date :</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">public static Date ajouterJour(Date date, int nbJour) { 
  Calendar cal = Calendar.getInstance(); 
  cal.setTime(date.getTime();
  cal.add(Calendar.DATE, nbJour);
  return cal.getTime();
}
</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>ou</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">public static Date ajouterJour(Date date, int nbJour) { 
  Calendar cal = Calendar.getlnstance(); 
  cal.setTime(date.getTime();
  cal.add(Calendar.DAY_OF_MONTH, nbJour);
  return cal.getTime();
}
</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Pour retrancher des jours, il faut fournir un paramètre négatif au nombre de jours.</p> 
   <p>Ajouter/retrancher des mois à une date :</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">public static Date ajouterMois(Date date, int nbMois) {
  Calendar cal = Calendar.getInstance();
  cal.setTime(date.getTime();
  cal.add(Calendar.MONTH, nbMois);
  return cal.getTime(); 
}
</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Pour retrancher des mois, il faut fournir un paramètre négatif au nombre de mois.</p> 
   <p>Ajouter/retrancher des années à une date :</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">public static Date ajouterAnnee(Date date, int nbAnnee) {
  Calendar cal = Calendar.getInstance();
  cal.setTime(date.getTime());
  cal.add(Calendar.YEAR, nbAnnee);
  return cal.getTime();
}
</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Pour retrancher des années, il faut fournir un paramètre négatif au nombre d'années.</p> 
   <p>Ajouter/retrancher des heures à une date :</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">public static Date ajouterHeure(Date date, int nbHeure) {
  Calendar cal = Calendar.getInstance();
  cal.setTime(date.getTime());
  cal.add(Calendar.HOUR, nbHeure);
  return cal.getTime();
}
</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Pour retrancher des heures, il faut fournir un paramètre négatif au nombre d'heures.</p> 
   <p>Ajouter/retrancher des minutes à une date :</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">public static Date ajouterMinute(Date date, int nbMinute) { 
  Calendar cal = Calendar.getInstance(); 
  cal.setTime(date.getTime());
  cal.add(Calendar.MINUTE, nbMinute);
  return cal.getTime();
}
</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Pour retrancher des minutes, il faut fournir un paramètre négatif au nombre de minutes.</p> 
   <p>Ajouter/retrancher des secondes à une date :</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">public static Date ajouterSeconde(Date date, int nbSeconde) {
  Calendar cal = Calendar.getlnstance(); 
  cal.setTime(date.getTime());
  cal.add(Calendar.SECOND, nbSeconde); 
  return cal.getTime();
}
</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Pour retrancher des secondes, il faut fournir un paramètre négatif au nombre de secondes.</p> 
   <p>&nbsp;</p> 
   <h2 class="TITRESECTION1">
    <!--nchpdeb--><a name="utilisation_dates-3">102.3. 
     <!--nchpfin-->La classe SimpleDateFormat</a></h2> 
   <p>La classe SimpleDateFormat permet de formater une date pour lui donner une représentation textuelle dans un format donné ou de parser une chaîne de caractères pour extraire une date dans un format donné.</p> 
   <p>&nbsp;</p> 
   <h3 class="TITRESECTION2">
    <!--nchpdeb--><a name="utilisation_dates-3-1">102.3.1. 
     <!--nchpfin-->L'utilisation de la classe SimpleDateFormat</a></h3> 
   <p>Le constructeur de la classe SimpleDateFormat attend en paramètre une chaîne de caractères qui précise le format à utiliser durant les traitements de formatage et de parsing.</p> 
   <p>La méthode format() permet de formater la date fournie en paramètre.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">SimpleDateFormat simpleDateFormat = new SimpleDateFormat("dd/MM/yyyy");
String dateStr = simpleDateFormat.format(new Date()); 
System.out.println(dateStr);
</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Le format comporte de nombreuses options et peut même contenir du texte brut qui doit être échappé avec des quotes simples.</p> 
   <p>Par défaut, la classe SimpleDateFormat travail avec la Locale courante. Il est possible de préciser une autre Locale en tant que paramètre du constructeur.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">SimpleDateFormat simpleDateFormat = new SimpleDateFormat("dd MMMM yyyy zzzz G", Locale.FRENCH);
String dateStr = simpleDateFormat.format(new Date()); 
System.out.println(dateStr);
</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>La méthode parse() permet de déterminer une date extraite d'une chaîne de caractères en utilisant un format donné.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">SimpleDateFormat simpleDateFormat = new SimpleDateFormat("dd/MM/yyyy");
Date date = simpleDateFormat.parse("25/12/2010"); 
System.out.println(date);
</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Par défaut, SimpleDateFormat travaille avec la Locale par défaut qui contient le fuseau horaire (time zone).</p> 
   <p>Si la chaîne de caractères ne contient pas explicitement le fuseau horaire, il peut être nécessaire de le préciser en utilisant la méthode setTimeZone() :</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">SimpleDateFormat simpleDateFormat = new SimpleDateFormat("dd/MM/yyyy");
simpleDateFormat.setTimeZone(TimeZone.getTimeZone("PST"));
Date date = simpleDateFormat.parse("25/12/2010"); 
System.out.println(date);
</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Il est possible de préciser le siècle si la date à parser ne contient que deux chiffres : par exemple "01/01/02" peut correspondre à une date de l'année 1902 ou 2002. La méthode set2DigitYearStart() permet de préciser la date de début de la plage de 100 ans dans laquelle l'année sera traitée. Par défaut, cette plage de 100 ans correspond à la date du jour - 80 ans jusqu'à la date du jour + 20 ans.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">SimpleDateFormat simpleDateFormat = new SimpleDateFormat("dd MMMM yy", Locale.FRENCH);
Date date = simpleDateFormat.parse("25-12-02");
System.out.println(date);
Date debut20emeSiecle = new GregorianCalendar(1901,1,1).getTime();
simpleDateFormat.set2DigitYearStart(debut20emeSiecle);
date = simpleDateFormat.parse("25-12-02");
System.out.println(date);
</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Par défaut, le parsing de la date est très permissif : le format de la date n'a pas à respecter strictement le format fourni à SimpleDateFormat. Dans ce cas, sans générer d'erreur, SimpleDateFormat va tenter d'extraire une date qui potentiellement ne correspond pas du tout.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">SimpleDateFormat simpleDateFormat = new SimpleDateFormat("dd-MM-yyyy", Locale.FRENCH); 
Date date = simpleDateFormat.parse("31-04-10"); 
System.out.println(date);
</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Dans l'exemple ci-dessus, le mois d'avril ne possède que 30 jours. La classe SimpleDateFormat en déduit que l'on veut le jour suivant le 30 avril soit le 1er mai. Ce comportement est rarement celui souhaité.</p> 
   <p>Pour demander un respect strict du format, il faut passer la valeur false à la méthode setLenient(). Si le format de la date à traiter ne correspond pas, une exception est levée.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">SimpleDateFormat simpleDateFormat =
new SimpleDateFormat("dd-MM-yyyy", Locale.FRENCH);
simpleDateFormat.setLenient(false);
Date date = simpleDateFormat.parse("31-04-10"); 
System.out.println(date);
</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>La classe SimpleDateFormat n'est pas thread-safe car elle maintient son état, entre autre, avec deux objets de type Calendar et NumberFormat. Si deux threads utilisent la même instance pour manipuler deux dates en même temps, le résultat des traitements est aléatoire : généralement il est erroné par rapport à la date traitée ce qui conduit à une corruption des données qui n'est pas facilement détectable ou, plus rarement, une exception est levée.</p> 
   <p>L'utilisation d'une même instance de SimpleDateFormat dans un contexte multithreads implique donc qu'il est nécessaire de prendre des précautions : le résultat peut être aléatoire lors du parsing et du formatage d'une date :</p> 
   <ul> 
    <li>tout peut bien se passer</li> 
    <li>le résultat peut être erroné</li> 
    <li>une exception peut être levée</li> 
   </ul> 
   <p>&nbsp;</p> 
   <h3 class="TITRESECTION2">
    <!--nchpdeb--><a name="utilisation_dates-3-2">102.3.2. 
     <!--nchpfin-->Les points faibles de la classe SimpleDateFormat</a></h3> 
   <p>La classe SimpleDateFormat présente deux faiblesses lors de sa mise en oeuvre :</p> 
   <ul> 
    <li>son instanciation est très coûteuse</li> 
    <li>ses traitements ne sont pas threadsafe</li> 
   </ul> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">import java.text.ParseException; 
import java.text.SimpleDateFormat;
import java.util.Date;

public class DateUtil {

  public static final Date parse(String date) throws ParseException{
    SimpleDateFormat simpleDateFormat = new SimpleDateFormat("dd-MM-yyyy");
    return simpleDateFormat.parse(date);
  }

  public static final String format(Date date) throws ParseException{
    SimpleDateFormat simpleDateFormat = new SimpleDateFormat("dd-MM-yyyy");
    return simpleDateFormat.format(date); }
  } 
</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Cette solution est threadsafe mais son inconvénient est qu'elle peut requérir de nombreuses ressources si le nombre d'invocations est important.</p> 
   <p>Pour pallier ce premier souci, il est possible de créer une instance de classe statique qui permettra de n'avoir qu'un seul objet.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">import java.text.ParseException; 
import java.text.SimpleDateFormat; 
import java.util.Date;

public class DateUtil {

  public static final SimpleDateFormat simpleDateFormat = new SimpleDateFormat("dd-MM-yyyy");

  public static final Date parse(String date) throws ParseException{
    return simpleDateFormat.parse(date);
  }

  public static final String format(Date date) throws ParseException{
    return simpleDateFormat.format(date);
  }
}
</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Cette solution fréquemment utilisée permet de réduire le nombre d'instances créées. Malheureusement, comme indiqué dans la JavaDoc, elle ne fonctionne pas dans un environnement multithread puisque la classe SimpleDateFormat n'est pas threadsafe. L'utilisation de la classe ci-dessus dans un contexte multithread peut donner des résultats aléatoires.</p> 
   <p>Cependant ces résultats aléatoires ne sont pas faciles à détecter dans une application car il faut que plusieurs threads sollicitent en même temps l'instance de SimpleDateFormat.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">import java.text.ParseException;

public class TestSimpleDateFormat {

  public static void main(String[] args) { 
    final String[] dates = new String[] {"15-01-2000", "28-02-2005", "20-04-2005", 
      "31-07-2015" };

    Runnable runnable = new Runnable() { public void run() {
    try {
      for (int j = 0; j &lt; 1000; j++) {
        for (int i = 0; i &lt; 2; i++) {
          String date = DateUtil.format(DateUtil.parse(dates[i]));
          if (!(dates[i].equals(date))) {
            throw new ParseException(dates[i] + " =&gt;"+ date, 0);
          }
        }
      }
    } catch (ParseException e) { 
      e.printStackTrace();
    }

    new Thread(runnable).start();

    Runnable runnable2 = new Runnable() { 
      public void run() {
        try {
          for (int j = 0; j &lt; 1000; j++) {
            for (int i = 0; i &lt; 2; i++) {
              String date = DateUtil.format(DateUtil.parse(dates[i]));
              if (!(dates[i].equals(date))) {
                throw new ParseException(dates[i] + " =&gt;"+ date, 0);
              }
            }
          }
        } catch (ParseException e) { 
          e.printStackTrace();
        }
      }
    }; 
    new Thread(runnable2).start();
  }
}
</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Dans cet exemple, le nombre d'exceptions et d'anomalies de traitement est important car les threads utilisent en permanence le même objet. Dans la réalité, par exemple dans une application web, les exceptions et les dates erronées sont très rares. L'ennui avec les erreurs de formatage et de parsing c'est qu'elles sont difficiles à détecter.</p> 
   <p>Il est possible de sécuriser l'utilisation de l'instance de SimpleDateFormat en l'entourant d'un bloc synchronized dont le moniteur est l'instance de la classe SimpleDateFormat ou en définissant les méthodes utilisant l'instance synchronized. Ainsi, un seul thread pourra accéder à l'instance à la fois.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">import java.text.ParseException; 
import java.text.SimpleDateFormat; 
import java.util.Date;

public class DateUtil {

  public static final SimpleDateFormat simpleDateFormat = new SimpleDateFormat("dd-MM-yyyy");

  public synchronized static final Date parse(String date) throws ParseException{
    return simpleDateFormat.parse(date);
  }

  public synchronized static final String format(Date date) throws ParseException{
    return simpleDateFormat.format(date);
  }
}
</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Cette solution simple est thread-safe mais elle peut impliquer de la contention liée au verrou posé lors de l'exécution de la méthode qui bloque l'invocation par d'autres threads.</p> 
   <p>Une autre solution est d'utiliser la classe ThreadLocal qui est capable de fournir une instance pour le thread en cours, ainsi chaque thread peut avoir sa propre instance.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">import java.text.ParseException; 
import java.text.SimpleDateFormat; 
import java.util.Date;

public class DateUtil {

  private static ThreadLocal&lt;SimpleDateFormat&gt; format = new ThreadLocal&lt;SimpleDateFormat&gt;() {
    protected synchronized SimpleDateFormat initialValue() {
      return new SimpleDateFormat("dd-MM-yyyy");
    }
  };

  public static final Date parse(String date) throws ParseException{
    return format.get().parse(date);
  }

  public static final String format(Date date) throws ParseException{
    return format.get().format(date); }
  } 
</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Remarque : selon l'implémentation fournie de la classe ThreadLocal par le JRE, il peut y avoir des fuites de mémoire lors du redéploiement de l'application dans un conteneur web.</p> 
   <p>Il peut être intéressant d'utiliser une SoftReference en paramètre du ThreadLocal pour améliorer la gestion de la mémoire par la JVM.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">import java.lang.ref.SoftReference; 
import java.text.DateFormat;
import java.text.ParseException; 
import java.text.SimpleDateFormat; 
import java.util.Date;

public class DateUtil {

  private static final ThreadLocal&lt;SoftReference&lt;DateFormat» format = 
    new ThreadLocal&lt;SoftReference&lt;DateFormat&gt;&gt;();

  private static DateFormat getDateFormat() { 
    SoftReference&lt;DateFormat&gt;      softRef = format.get();
    if (softRef != null) {
      final DateFormat result = softRef.get(); 
      if (result != null) {
        return result;
      }
    }
    final DateFormat result = new SimpleDateFormat("dd-MM-yyyy");
    softRef = new SoftReference&lt;DateFormat&gt;(result); 
    format.set(softRef);
    return result;
  }

  public static final Date parse(final String date) throws ParseException {
    return getDateFormat().parse(date);
  }

  public static final String format(final Date date) throws ParseException {
    return getDateFormat().format(date);
  }
}
</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Cette approche nécessite de recréer l'instance locale de SimpleDateFormat dans le cas où le ramasse-miettes aurait détruit la précédente.</p> 
   <p>Une autre solution peut être d'utiliser une API tierce telle que&nbsp;:</p> 
   <ul> 
    <li>Joda Time : en remplaçant java.text.SimpleDateFormat par org.joda.time.format.DateTimeFormatter</li> 
    <li>Apache Jakarta Common Lang : utiliser la classe FastDateFormat. Malheureusement cette classe ne permet que de formater mais pas de parser une date.</li> 
   </ul> 
   <p>Lors de la mise en oeuvre de la classe SimpleDateFormat, il faut aussi être vigilent car par défaut, la classe SimpleDateFormat est très permissive : elle tente au mieux de faire correspondre la date selon le format fourni, ce qui peut conduire à un comportement non souhaité et surtout à des résultats indésirables.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">import java.text.DateFormat;
import java.text.ParseException; 
import java.text.SimpleDateFormat; 
import java.util.Date;

public class TestDate {

  public static void main(final String[] args) {
    final DateFormat df = new SimpleDateFormat("yyyyMMddHHmmss"); 
    Date d;
    try {
      d = df.parse("2010-01-15 07:23:30");
      System.out.println(d); 
    } catch (final ParseException e) {
      e.printStackTrace(); 
    }
  }
}
</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">Mon Nov 30 23:05:07 CET 2009</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Pour que la classe SimpleDateFormat respecte strictement le format fourni et lève une exception de type java.text.ParseException, il faut invoquer la méthode setLenient() en lui passant la valeur false en paramètre.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat; 
import java.util.Date;

public class TestDate {

  public static void main(final String[] args) {
    final DateFormat df = new SimpleDateFormat("yyyyMMddHHmmss"); 
    df.setLenient(false); 
    Date d;
    try {
      d = df.parse("2010-01-15 07:23:30"); 
      System.out.println(d);
    } catch (final ParseException e) { 
      e.printStackTrace();
    } 
  }
}
</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">java.text.ParseException: Unparseable date: "2010-01-15 07:23:30"
at java.text.DateFormat.parse(DateFormat.java:337) at TestDate.main(TestDate.java:39)</pre></td>
     </tr>
    </tbody>
   </table> 
   <p>&nbsp;</p> 
   <h2 class="TITRESECTION1">
    <!--nchpdeb--><a name="utilisation_dates-4">102.4. 
     <!--nchpfin-->Joda Time</a></h2> 
   <p>La plupart des applications ont besoin à un moment ou à un autre de manipuler des données de type date ou heure. Le JDK fournit des classes pour permettre ces manipulations, notamment les classes Date et Calendar, mais leur utilisation n'est pas simple et généralement source d'erreurs.</p> 
   <p>Joda Time est une bibliothèque open source dont le but est de fournir une solution simple et complète pour manipuler des données de types date/heure.</p> 
   <p>Joda Time propose&nbsp;au travers de son API :</p> 
   <ul> 
    <li>Le support de plusieurs systèmes calendaires dont celui par défaut est celui définit par le standard ISO8601 (utilisé par XML)&nbsp;: Grégorien, Julien, Bouddhiste, Islamique, ...</li> 
    <li>Le parsing et le formatage de dates</li> 
    <li>Le support des fuseaux horaires</li> 
    <li>Le support de plusieurs classes temporelles&nbsp;: date/heure locale, durée, période, intervalle, ...</li> 
   </ul> 
   <p>Le but de Joda Time est de proposer une solution de remplacement aux classes de gestion des dates du JDK qui présentent plusieurs inconvénients :</p> 
   <ul> 
    <li>Il n'est pas facile à utiliser pour manipuler des données courantes</li> 
    <li>La conception des classes Date et Calendar</li> 
    <li>Les performances de certaines fonctionnalités sont plutôt mauvaises</li> 
   </ul> 
   <p>Par exemple, Joda Time gère les mois de 1 à 12 dans son implémentation du calendrier Grégorien alors que la classe GregorianCalendar du JDK gère les mois de 0 à 11.</p> 
   <p>Joda Time a été développé pour améliorer la manière d'utiliser des données de type date/heure en mettant l'accent sur :</p> 
   <ul> 
    <li>la faciliter d'utilisation</li> 
    <li>la fourniture d'un ensemble complet de fonctionnalités relatives aux traitements de données de type dates/heures</li> 
    <li>l'extensibilité : Joda Time propose le support de plusieurs calendriers qui reposent sur la classe Chronology</li> 
    <li>l'interopérabilité avec les classes correspondantes du JDK</li> 
    <li>la performance</li> 
    <li>la maturité</li> 
   </ul> 
   <p>La version couverte dans cette section est la 2.1. Elle nécessite une version 1.5 ou supérieure du JDK.</p> 
   <p>La partie publique de l'API est contenue dans les packages org.joda.time et org.joda.time.format.</p> 
   <p>Joda Time utilise plusieurs concepts&nbsp;:</p> 
   <ul> 
    <li>instant&nbsp;(un point unique dans le temps)</li> 
    <li>temps partiel&nbsp;(points multiples dans le temps)</li> 
    <li>intervalle et durée</li> 
    <li>système calendaire</li> 
    <li>fuseau horaire</li> 
   </ul> 
   <p>La classe JodaTimePermission peut être utilisée dans le mécanisme standard de sécurité de la JVM pour restreindre l'utilisation à certaines fonctionnalités globales de JodaTime.</p> 
   <p>L'API Joda Time a été utilisée comme une grande source d'inspiration pour la JSR 310.</p> 
   <p>&nbsp;</p> 
   <h3 class="TITRESECTION2">
    <!--nchpdeb--><a name="utilisation_dates-4-1">102.4.1. 
     <!--nchpfin-->Les principales classes de JodaTime</a></h3> 
   <p>La plupart des classes de Joda Time sont immuables : les méthodes qui permettent d'effectuer des modifications les font sur une copie de l'objet qu'elles retournent.</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Classe</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime</p> </td> 
      <td> <p>Equivalent de la classe Calendar</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateMidnight</p> </td> 
      <td> <p>Classe immuable qui encapsule une date dont l'heure est forcée à minuit</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDate</p> </td> 
      <td> <p>Classe immuable qui encapsule une date locale (sans fuseau horaire)</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalTime</p> </td> 
      <td> <p>Classe immuable qui encapsule une heure locale (sans fuseau horaire)</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDateTime</p> </td> 
      <td> <p>Classe immuable qui encapsule une date/heure locale (sans fuseau horaire)</p> </td> 
     </tr> 
    </tbody>
   </table> 
   <p>&nbsp;</p> 
   <h3 class="TITRESECTION2">
    <!--nchpdeb--><a name="utilisation_dates-4-2">102.4.2. 
     <!--nchpfin-->Le concept d'Instant</a></h3> 
   <p>Un instant est un point unique dans le temps dont la représentation est le nombre de millisecondes depuis le 1<sup>er</sup> janvier 1970 00 heure 00. Ceci rend un Instant compatible avec les classes Calendar et Date du JDK.</p> 
   <p>La représentation d'un instant en une date est dépendante du calendrier et du fuseau horaire utilisés pour représenter cet instant.</p> 
   <p>Un instant est défini par l'interface ReadableInstant.</p> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-4-2-1">102.4.2.1. 
     <!--nchpfin-->L'interface ReadableInstant</a></h4> 
   <p>L'interface ReadableInstant décrit les fonctionnalités d'un objet qui encapsule un instant.</p> 
   <p>Les implémentations de cette interface peuvent être immuables ou non.</p> 
   <p>Joda Time propose plusieurs classes qui implémentent l'interface ReadableInstant&nbsp;dont :</p> 
   <ul> 
    <li>Instant&nbsp;: une implémentation immuable qui encapsule un instant dans le temps sans utiliser de système calendaire ou de fuseau horaire particulier. Elle stocke en interne une valeur de type long qui contient le nombre de millisecondes écoulées depuis le 1<sup>er</sup> janvier 1970 à 00 heure 00.</li> 
    <li>DateTime&nbsp;: encapsule une date/heure selon un système calendaire et un fuseau horaire donnés. C'est l'implémentation la plus fréquemment utilisée.</li> 
    <li>DateMidnight&nbsp;: cette classe agit comme la classe DateTime excepté le fait que l'heure encapsulée est toujours minuit.</li> 
    <li>MutableDateTime&nbsp;: cette classe agit comme la classe DateTime excepté le fait qu'elle ne soit pas immuable.</li> 
   </ul> 
   <p>Attention&nbsp;: l'interface ReadableInstant n'est qu'un sous-ensemble des fonctionnalités des classes qui l'implémentent. Il est généralement préférable de typer les variables avec leur implémentation plutôt que de les typer avec l'interface ReadableInstant sauf si les fonctionnalités requises de l'instance sont définies dans l'interface.</p> 
   <p>Il est généralement recommandé d'utiliser dans la mesure du possible des implémentations qui soient immuables. L'objet ne peut ainsi pas être modifié sans créer une nouvelle instance, ce qui lui permet d'être thread safe.</p> 
   <p>Important&nbsp;: Joda Time considère qu'un instant null correspond à l'instant présent. Ainsi lorsqu'une méthode attend en paramètre un objet de ReadableInstant et que la valeur reçue en paramètre est null, alors cela revient à passer en paramètre un instant qui correspond à l'instant présent.</p> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-4-2-2">102.4.2.2. 
     <!--nchpfin-->La classe DateTime</a></h4> 
   <p>La classe DateTime encapsule un instant dans le temps pour un système calendaire et un fuseau horaire donné&nbsp;: ceux-ci lui permettent de restituer l'instant encapsulé sous la forme d'une date et d'une heure.</p> 
   <p>Par défaut, une instance de type DataTime utilise le système calendaire ISOChronology et le fuseau horaire obtenu du système. De nombreux constructeurs attendent en paramètre un objet de type Chronology et/ou DateTimeZone qui permettent de préciser le système calendaire et /ou le fuseau horaire à utiliser.</p> 
   <p>Le constructeur sans paramètre crée une instance qui encapsule l'instant courant représenté dans le système calendaire ISO et le fuseau horaire par défaut.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    DateTime datetime = new DateTime();</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Plusieurs constructeurs permettent de préciser les éléments de la date/heure encapsulée&nbsp;: année, mois, jour, heure, minute, seconde.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    DateTime datetime = new DateTime(2012,12,25,0,0,0);</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>La classe DateTime propose plusieurs autres constructeurs qui acceptent une instance de type Object comme valeur pour représenter la date/heure. Ces surcharges permettent à Joda Time d'être extensible mais en sacrifiant le typage fort.</p> 
   <p>Par défaut, la classe ConverterManager permet de gérer les différents types supportés&nbsp;:</p> 
   <ul> 
    <li>ReadableInstant</li> 
    <li>String&nbsp;: une chaîne de caractères qui contient la date au format ISO-8601</li> 
    <li>java.util.Calendar&nbsp;: dans ce cas, le système calendaire encapsulé est utilisé</li> 
    <li>java.util.Date et javax.sql.Date</li> 
    <li>Long&nbsp;: un nombre de millisecondes</li> 
    <li>null&nbsp;: est interprété par Joda Time comme l'instant présent</li> 
   </ul> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    java.util.Date date = new Date();
    long timeEnMs = date.getTime();
    DateTime dateTime = new DateTime(timeEnMs);</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    java.util.Date date = new Date();
    DateTime dateTime = new DateTime(date);</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    java.util.Calendar calendar = Calendar.getInstance();
    calendar.setTime(new Date());
    DateTime dateTime = new DateTime(calendar);</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    String timeString = "2012-12-25";
    DateTime dateTime = new DateTime(timeString);</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    DateTime dt = new DateTime("2012-10-28T16:23:13.324+01:00");</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Il est ainsi facile de convertir une instance de type java.util.Date ou java.util.Calendar en un objet de type DateTime simplement en passant l'instance au constructeur de la classe DateTime.</p> 
   <p>A l'exécution de l'exemple ci-dessous une exception de type IllegalArgumentException est levée avec le message &nbsp;No instant converter found for type: java.util.ArrayList car Joda Time ne peut pas convertir l'instance de type Object fournie en paramètre en un instant.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    List liste = new ArrayList();
    DateTime dateCourante = new DateTime(liste);</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Plusieurs méthodes statiques permettent d'obtenir une instance de type DateTime.</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Méthode</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static DateTime now()</p> </td> 
      <td> <p>Obtenir une instance de type DateTime qui encapsule la date/heure système courante en utilisant le système calendaire ISO et le fuseau horaire par défaut</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static DateTime now(Chronology chronology)</p> </td> 
      <td> <p>Obtenir une instance de type DateTime qui encapsule la date/heure système courante en utilisant le système calendaire fourni en paramètre et le fuseau horaire par défaut</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static DateTime now(DateTimeZone zone)</p> </td> 
      <td> <p>Obtenir une instance de type DateTime qui encapsule la date/heure système courante en utilisant le système calendaire ISO et le fuseau horaire fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static DateTime parse(String str)</p> </td> 
      <td> <p>Extraire une date/heure de la chaîne de caractères fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static DateTime parse(String str, DateTimeFormatter formatter)</p> </td> 
      <td> <p>Extraire une date/heure de la chaîne de caractères fournie en utilisant le formateur passé en paramètre</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <p>Les opérations de manipulations de date/heure encapsulées dans un objet de type DateTime peuvent être réalisées en invoquant des méthodes de DateTime ou en invoquant des méthodes sur les propriétés de l'objet DateTime. Cela rend ces opérations particulièrement pratiques et flexibles.</p> 
   <p>La classe DateTime encapsule une date/heure de manière immuable. Les méthodes qui permettent de modifier un élément de la date/heure encapsulée renvoie une nouvelle instance de type DateTime encapsulant le résultat de l'opération.</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Méthode</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime minus(long duration)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont la durée fournie a été soustraite</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime minus(ReadableDuration duration)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont la durée fournie a été soustraite</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime minus(ReadablePeriod period)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont la période fournie a été soustraite</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime minusDays(int days)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont le nombre de jours fourni a été soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime minusHours(int hours)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont le nombre d'heures fourni a été soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime minusMillis(int millis)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont le nombre de millisecondes fourni a été soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime minusMinutes(int minutes)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont le nombre de minutes fourni a été soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime minusMonths(int months)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont le nombre de mois fourni a été soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime minusSeconds(int seconds)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont le nombre de secondes fourni a été soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime minusWeeks(int weeks)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont le nombre de semaines fourni a été soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime minusYears(int years)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont le nombre d'années fourni a été soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime plus(long duration)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont la durée fournie a été ajoutée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime plus(ReadableDuration duration)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont la durée fournie a été ajoutée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime plus(ReadablePeriod period)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont la période fournie a été ajoutée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime plusDays(int days)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont le nombre de jours fourni a été ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime plusHours(int hours)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont le nombre d'heures fourni a été ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime plusMillis(int millis)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont le nombre de millisecondes fourni a été ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime plusMinutes(int minutes)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont le nombre de minutes fourni a été ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime plusMonths(int months)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont le nombre de mois fourni a été ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime plusSeconds(int seconds)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont le nombre de secondes fourni a été ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime plusWeeks(int weeks)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont le nombre de semaines fourni a été ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime plusYears(int years)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont le nombre d'années fourni a été ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateMidnight toDateMidnight()</p> </td> 
      <td> <p>Convertir en une instance de type DateMidnight en utilisant le même système calendaire</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDate toLocalDate()</p> </td> 
      <td> <p>Convertir en une instance de type LocalDate en utilisant le même système calendaire</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDateTime toLocalDateTime()</p> </td> 
      <td> <p>Convertir en une instance de type LocalDateTime en utilisant le même système calendaire</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime withCenturyOfEra(int centuryOfEra)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont le siècle a été modifié</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime withChronology(Chronology newChronology)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime qui utilise le système calendaire fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime withDate(int year, int monthOfYear, int dayOfMonth)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont l'année, le mois et le jour ont été modifié</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime withDayOfMonth(int dayOfMonth)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont le jour du mois a été modifié</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime withDayOfWeek(int dayOfWeek)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont le jour de la semaine a été modifié</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime withDayOfYear(int dayOfYear)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont le jour de l'année a été modifié</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime withDurationAdded(long durationToAdd, int scalar)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime à la laquelle la durée a été ajoutée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime withDurationAdded(ReadableDuration durationToAdd, int scalar)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime à la laquelle la durée a été ajoutée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime withEra(int era)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont l'ère a été modifiée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime withField(DateTimeFieldType fieldType, int value)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont la propriété fournie a été modifiée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime withFieldAdded(DurationFieldType fieldType, int amount)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont la propriété fournie a été ajoutée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime withHourOfDay(int hour)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont l'heure du jour a été modifiée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime withMillis(long newMillis)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont le nombre de millisecondes a été modifié</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime withMillisOfDay(int millis)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont le nombre de millisecondes du jour a été modifié</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime withMillisOfSecond(int millis)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont le nombre de millisecondes courant a été modifié</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime withMinuteOfHour(int minute)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont le nombre de minutes a été modifié</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime withMonthOfYear(int monthOfYear)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont le mois a été modifié</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime withPeriodAdded(ReadablePeriod period, int scalar)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime à laquelle la période a été ajoutée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime withSecondOfMinute(int second)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont le nombre de secondes a été modifié</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime withTime(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont les heures, les minutes, les secondes et les millisecondes ont été modifiées</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime withYear(int year)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime dont l'année a été modifiée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime withZone(DateTimeZone newZone)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime qui utilise le fuseau horaire fourni en paramètre sans modifier l'instant encapsulé</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime withZoneRetainFields(DateTimeZone newZone)</p> </td> 
      <td> <p>Renvoyer une nouvelle instance de DateTime qui utilise le fuseau horaire fourni en paramètre sans modifier les champs encapsulés</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    DateTime dateCourante = new DateTime();
    DateTime dateLimite = dateCourante.plusDays(2);</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>La classe DateTime propose plusieurs solutions pour obtenir individuellement chacun des champs de la date/heure encapsulée&nbsp;:</p> 
   <ul> 
    <li>un getter pour chaque champs</li> 
    <li>une méthode qui renvoie un objet de type DateTime.Property pour chaque champs</li> 
    <li>la méthode property() qui attend en paramètre et renvoie un objet de type DateTime.Property</li> 
   </ul> 
   <p>Les propriétés contenues dans un DateTime sont&nbsp;:</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Propriété&nbsp;</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>centuryOfEra</p> </td> 
      <td> <p>Le siècle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>dayOfMonth</p> </td> 
      <td> <p>Le jour du mois</p> </td> 
     </tr> 
     <tr> 
      <td> <p>dayOfWeek</p> </td> 
      <td> <p>Le jour de la semaine</p> </td> 
     </tr> 
     <tr> 
      <td> <p>dayOfYear</p> </td> 
      <td> <p>Le jour de l'année</p> </td> 
     </tr> 
     <tr> 
      <td> <p>era</p> </td> 
      <td> <p>L'ère comme défini par le système calendaire</p> </td> 
     </tr> 
     <tr> 
      <td> <p>hourOfDay</p> </td> 
      <td> <p>L'heure</p> </td> 
     </tr> 
     <tr> 
      <td> <p>millisOfDay</p> </td> 
      <td> <p>Le nombre de millisecondes du jour</p> </td> 
     </tr> 
     <tr> 
      <td> <p>millisOfSecond</p> </td> 
      <td> <p>Le nombre de millisecondes de l'heure</p> </td> 
     </tr> 
     <tr> 
      <td> <p>minuteOfDay</p> </td> 
      <td> <p>Le nombre de minutes du jour</p> </td> 
     </tr> 
     <tr> 
      <td> <p>minuteOfHour</p> </td> 
      <td> <p>Le nombre de minutes</p> </td> 
     </tr> 
     <tr> 
      <td> <p>monthOfYear</p> </td> 
      <td> <p>Le mois</p> </td> 
     </tr> 
     <tr> 
      <td> <p>secondOfDay</p> </td> 
      <td> <p>Le nombre de secondes du jour</p> </td> 
     </tr> 
     <tr> 
      <td> <p>secondOfMinute</p> </td> 
      <td> <p>Le nombre de secondes</p> </td> 
     </tr> 
     <tr> 
      <td> <p>weekOfWeekyear</p> </td> 
      <td> <p>La semaine de l'année</p> </td> 
     </tr> 
     <tr> 
      <td> <p>weekYear</p> </td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr> 
      <td> <p>Year</p> </td> 
      <td> <p>L'année</p> </td> 
     </tr> 
     <tr> 
      <td> <p>yearOfCentury</p> </td> 
      <td> <p>L'année du siècle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>yearOfEra</p> </td> 
      <td>&nbsp;</td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    DateTime dateTime = new DateTime();
    System.out.println(dateTime.getYear());
    System.out.println(dateTime.year().get());
    System.out.println(dateTime.property(DateTimeFieldType.year()).get());</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>La classe DateTime.Property encapsule la valeur d'un champ qui est un élément d'une DateTime.La classe DateTime.Property propose quelques getters&nbsp;:</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Méthode</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Chronology getChronology()</p> </td> 
      <td> <p>Retourne le système calendaire du DateTime correspondant au champ</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime getDateTime()</p> </td> 
      <td> <p>Retourne l'instance de type DateTime correspondant au champ</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTimeField getField()</p> </td> 
      <td> <p>Retourne le champ encapsulé</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long getMillis()</p> </td> 
      <td> <p>Retourne le nombre de millisecondes du DateTime correspondant au champ</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <p>La classe DateTime propose plusieurs méthodes qui permettent de modifier la valeur du champ et de retourner une nouvelle instance de type DateTime encapsulant le résultat de la mise à jour.</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Méthode</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime addToCopy(int value)</p> </td> 
      <td> <p>Ajouter une valeur à la valeur de ce champ dans l'instance retournée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime addToCopy(long value)</p> </td> 
      <td> <p>Ajouter une valeur à la valeur de ce champ dans l'instance retournée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime setCopy(int value)</p> </td> 
      <td> <p>Modifier la valeur de ce champ dans l'instance retournée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime setCopy(String text)</p> </td> 
      <td> <p>Modifier la valeur de ce champ dans l'instance retournée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime setCopy(String text, Locale locale)</p> </td> 
      <td> <p>Modifier la valeur de ce champ dans l'instance retournée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime withMaximumValue()</p> </td> 
      <td> <p>Forcer la valeur de ce champ à sa valeur maximale dans l'instance retournée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTime withMinimumValue()</p> </td> 
      <td> <p>Forcer la valeur de ce champ à sa valeur minimale dans l'instance retournée</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    DateTime dateTime = new DateTime(new Date());
    System.out.println(dateTime);
    System.out.println("dayOfMonth     " + dateTime.dayOfMonth().get());
    System.out.println("dayOfWeek      " + dateTime.dayOfWeek().get());
    System.out.println("dayOfYear      " + dateTime.dayOfYear().get());
    System.out.println("ear            " + dateTime.era().get());
    System.out.println("hourOfDay      " + dateTime.hourOfDay().get());
    System.out.println("millisOfDay    " + dateTime.millisOfDay().get());
    System.out.println("millisOfSecond " + dateTime.millisOfSecond().get());
    System.out.println("minuteOfDay    " + dateTime.minuteOfDay().get());
    System.out.println("minuteOfHour   " + dateTime.minuteOfHour().get());
    System.out.println("monthOfYear    " + dateTime.monthOfYear().get());
    System.out.println("secondOfDay    " + dateTime.secondOfDay().get());
    System.out.println("secondOfMinute " + dateTime.secondOfMinute().get());
    System.out.println("weekOfWeekyear " + dateTime.weekOfWeekyear().get());
    System.out.println("weekyear       " + dateTime.weekyear().get());
    System.out.println("year           " + dateTime.year().get());
    System.out.println("yearOfCentury  " + dateTime.yearOfCentury().get());
    System.out.println("yearOfEra      " + dateTime.yearOfEra().get());</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">2012-11-08T06:56:46.781+01:00
dayOfMonth     8
dayOfWeek      4
dayOfYear      313
ear            1
hourOfDay      6
millisOfDay    25006781
millisOfSecond 781
minuteOfDay    416
minuteOfHour   56
monthOfYear    11
secondOfDay    25006
secondOfMinute 46
weekOfWeekyear 45
weekyear       2012
year           2012
yearOfCentury  12
yearOfEra      2012</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Elle possède aussi de nombreuses méthodes héritées de la classe AbstractReadableInstantField.</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Méthode</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int compareTo(ReadableInstant instant)</p> </td> 
      <td> <p>Comparer ce champ au champ correspondant de l'instant</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int compareTo(ReadablePartial partial)</p> </td> 
      <td> <p>Comparer ce champ au champ correspondant de l'instant partiel</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean equals(Object object)</p> </td> 
      <td> <p>Comparer ce champ à un autre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int get()</p> </td> 
      <td> <p>Obtenir la valeur du champ</p> </td> 
     </tr> 
     <tr> 
      <td> <p>String getAsShortText()</p> </td> 
      <td> <p>Obtenir la valeur textuelle courte du champ dans la locale par défaut.</p> </td> 
     </tr> 
     <tr> 
      <td> <p>String getAsShortText(Locale locale)</p> </td> 
      <td> <p>Obtenir la valeur textuelle du champ dans la locale fournie.</p> </td> 
     </tr> 
     <tr> 
      <td> <p>String getAsString()</p> </td> 
      <td> <p>Obtenir la valeur du champ sous la forme d'une chaîne de caractères</p> </td> 
     </tr> 
     <tr> 
      <td> <p>String getAsText()</p> </td> 
      <td> <p>Obtenir la valeur textuelle du champ dans la locale par défaut.</p> </td> 
     </tr> 
     <tr> 
      <td> <p>String getAsText(Locale locale)</p> </td> 
      <td> <p>Obtenir la valeur textuelle du champ dans la locale fournie.</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getDifference(ReadableInstant instant)</p> </td> 
      <td> <p>Obtenir la différence entre la valeur de champ et celle correspondante dans l'instant passé en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long getDifferenceAsLong(ReadableInstant instant)</p> </td> 
      <td> <p>Obtenir la différence entre la valeur de champ et celle correspondante dans l'instant passé en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTimeFieldType getFieldType()</p> </td> 
      <td> <p>Obtenir le type du champ</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getMaximumShortTextLength(Locale locale)</p> </td> 
      <td> <p>Obtenir la taille maximale de valeur textuelle courte pour ce champ</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getMaximumTextLength(Locale locale)</p> </td> 
      <td> <p>Obtenir la taille maximale de valeur textuelle pour ce champ</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getMaximumValue()</p> </td> 
      <td> <p>Obtenir la valeur maximale pour ce champ</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getMaximumValueOverall()</p> </td> 
      <td> <p>Obtenir la valeur maximale pour ce champ sans tenir compte de l'instant</p> </td> 
     </tr> 
     <tr> 
      <td> <p>protected abstract long getMillis()</p> </td> 
      <td> <p>Obtenir le nombre de millisecondes du DateTime</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getMinimumValue()</p> </td> 
      <td> <p>Obtenir la valeur minimale pour ce champ</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getMinimumValueOverall()</p> </td> 
      <td> <p>Obtenir la valeur minimale pour ce champ sans tenir compte de l'instant</p> </td> 
     </tr> 
     <tr> 
      <td> <p>String getName()</p> </td> 
      <td> <p>Obtenir le nom du champ</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isLeap()</p> </td> 
      <td> <p>Retourner un booléen qui indique si la valeur du champ est bissextile</p> </td> 
     </tr> 
     <tr> 
      <td> <p>String toString()</p> </td> 
      <td> <p>Obtenir une représentation textuelle orientée debug du champ</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    DateTime dateTime = new DateTime(new Date());
    System.out.println("date = "+dateTime);
    System.out.println("nom du champ = "+dateTime.year().getName());
    System.out.println("mois EN = "+dateTime.monthOfYear().getAsText(Locale.ENGLISH));
    System.out.println("mois court = "+dateTime.monthOfYear().getAsShortText());
    System.out.println("est bissextile = "+dateTime.year().isLeap());
    System.out.println("jour rounded = "+dateTime.dayOfMonth().roundFloorCopy());
    System.out.println("mois rounded = "+dateTime.monthOfYear().roundFloorCopy());
    System.out.println("dayofWeek = "+dateTime.dayOfWeek().toString());</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">date = 2012-11-08T07:04:03.265+01:00
nom du champ = year
mois EN = November
mois court = nov.
est bissextile = true
jour rounded = 2012-11-08T00:00:00.000+01:00
mois rounded = 2012-11-01T00:00:00.000+01:00
dayofWeek = Property[dayOfWeek]</pre></td>
     </tr>
    </tbody>
   </table> 
   <p>&nbsp;</p> 
   <h3 class="TITRESECTION2">
    <!--nchpdeb--><a name="utilisation_dates-4-3">102.4.3. 
     <!--nchpfin-->Le concept de Partial</a></h3> 
   <p>Un instant partiel peut représenter plusieurs points dans le temps. Par exemple, le premier janvier existe chaque année dans le calendrier Grégorien. Un instant partiel est aussi pratique pour gérer des dates/heures locales (sans fuseau horaire) ou pour gérer uniquement des dates ou des heures.</p> 
   <p>L'interface ReadablePartial définit les fonctionnalités d'un objet qui encapsule une date partielle locale (pas de fuseau horaire). Il est possible de définir tout ou partie des champs de la date/heure encapsulée.</p> 
   <p>Il est parfois nécessaire de manipuler une partie d'une date et/ou d'une heure&nbsp;: par exemple uniquement le jour, le mois ou l'heure. Ce besoin est défini par l'interface ReadablePartial qui représente un instant partiellement défini.</p> 
   <p>Joda Time propose plusieurs classes qui implémentent l'interface ReadablePartial&nbsp;dont :</p> 
   <ul> 
    <li>Partial</li> 
    <li>LocalDate</li> 
    <li>LocalTime</li> 
    <li>LocalDateTime</li> 
   </ul> 
   <p>Il est possible de convertir une instance de type ReadablePartial en une instance de type ReadableInstant en utilisant la méthode toDateTime().</p> 
   <p>La classe LocalDate encapsule une date (année, mois, jour), sans heure et sans fuseau horaire de manière immuable.</p> 
   <p>La classe LocalDate propose plusieurs constructeurs.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    LocalDate localDate = new LocalDate(2012, 12, 25);</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>A partir de la version 1.3 de Joda Time, la classe LocalDate doit être utilisée à la place de la classe YearMonthDay qui est deprecated.</p> 
   <p>La classe LocalTime encapsule une heure (heure, minutes, secondes, millisecondes) sans fuseau horaire de manière immuable.</p> 
   <p>La classe LocalTime propose plusieurs constructeurs.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    LocalTime localTime = new LocalTime(17, 30, 45);</pre></td>
     </tr>
    </tbody>
   </table> 
   <p>&nbsp;</p> 
   <h3 class="TITRESECTION2">
    <!--nchpdeb--><a name="utilisation_dates-4-4">102.4.4. 
     <!--nchpfin-->Les concepts d'intervalle, de durée et de période</a></h3> 
   <p>Joda Time propose un support pour la gestion d'intervalles qui correspondent à une plage entre deux dates et de périodes de temps qui sont une durée grâce à trois classes&nbsp;: Interval, Period et Duration.</p> 
   <p>Les classes Interval et MutableInterval implémentent l'interface ReadableInterval.</p> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-4-4-1">102.4.4.1. 
     <!--nchpfin-->La classe Interval</a></h4> 
   <p>La classe Interval encapsule un intervalle entre deux instants de manière immuable. L'instant de début est inclus et l'instant de fin est exclu de l'intervalle. L'instant de fin doit donc être supérieur ou égal à l'instant de début.</p> 
   <p>Les deux instants doivent obligatoirement utiliser le même système calendaire et le même fuseau horaire.</p> 
   <p>La classe Interval propose plusieurs constructeurs.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    Interval interval = new Interval(
        new DateTime("2012-12-10"),
        new DateTime("2012-12-15"));</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>La méthode getStart() renvoie l'instant de début de l'intervalle. La méthode getEnd() renvoie l'instant de fin de l'intervalle.</p> 
   <p>La classe Interval propose plusieurs autres méthodes pour manipuler le contenu de l'intervalle.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    DateTime debut = new DateTime("2012-01-01");
    DateTime fin = debut.plus(Months.months(1));
    Interval interval = new Interval(debut, fin);
    System.out.println("Interval = " + interval);
    interval = interval.withEnd(interval.getEnd().plusMonths(1));
    System.out.println("Interval = " + interval);</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">Interval =
2012-01-01T00:00:00.000+01:00/2012-02-01T00:00:00.000+01:00
Interval = 2012-01-01T00:00:00.000+01:00/2012-03-01T00:00:00.000+01:00</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>La méthode contains() permet de déterminer si un Instant est inclus dans l'intervalle ou pas.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    Interval interval = new Interval(
        new DateTime("2012-12-10"),
        new DateTime("2012-12-15"));
    System.out.println(interval.contains(
        new DateTime(2012, 12, 9, 23, 59, 59, 999)));
    System.out.println(interval.contains(
        new DateTime(2012, 12, 10, 0, 0, 0, 0)));
    System.out.println(interval.contains(
        new DateTime(2012, 12, 14, 23, 59, 59, 999)));
    System.out.println(interval.contains(
        new DateTime(2012, 12, 15, 0, 0, 0, 0)));</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">false
true
true
false</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>La méthode toDuration() permet d'obtenir une instance de type Duration à partir de l'instance de type Interval.</p> 
   <p>Pour comparer deux instances de type Interval, il faut comparer leur durée.</p> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-4-4-2">102.4.4.2. 
     <!--nchpfin-->La classe Period</a></h4> 
   <p>Une période ne possède ni système calendaire ni fuseau horaire. Elle ne possède donc pas de représentation en millisecondes&nbsp;: il est nécessaire d'utiliser un Instant qui servira de référence et qui précisera le système calendaire et le fuseau horaire à utiliser pour y associer la période.</p> 
   <p>Par exemple, une période d'un mois ne correspond pas au même nombre de millisecondes si on l'ajoute au premier janvier ou au premier février. C'est aussi le cas si l'on ajoute une heure&nbsp;: ce ne sont pas forcément 60 minutes qui sont ajoutées selon le fuseau horaire et l'utilisation de l'heure d'été/d'hiver.</p> 
   <p>La classe Period encapsule une durée dont la valeur est constituée de champs qui expriment ses différentes unités.</p> 
   <p>Par défaut, les champs utilisables dans une Period (années, mois, semaines, jours, heures, minutes, secondes, millisecondes) sont définis dans une instance de la classe PeriodType. Il est possible de restreindre les champs utilisables en utilisant la classe PeriodType. La classe PeriodType propose plusieurs fabriques qui renvoient des instances de type PeriodType&nbsp;:</p> 
   <ul> 
    <li>Standard&nbsp;: années, mois, semaine, jours, heures, minutes, secondes, millisecondes (c'est l'instance par défaut)</li> 
    <li>YearMonthDayTime&nbsp;: années, mois, jours, heures, minutes, secondes, millisecondes</li> 
    <li>YearMonthDay&nbsp;: années, mois, jours</li> 
    <li>YearWeekDayTime&nbsp;: années, semaines, jours, heures, minutes, secondes, millisecondes</li> 
    <li>YearWeekDay&nbsp;: années, semaines, jours</li> 
    <li>YearDayTime&nbsp;: années, jours, heures, minutes, secondes, millisecondes</li> 
    <li>YearDay&nbsp;: années, jours, heures</li> 
    <li>DayTime&nbsp;: jours, heures, minutes, secondes, millisecondes</li> 
    <li>Time&nbsp;: heures, minutes, secondes, millisecondes</li> 
    <li>et une fabrique pour chaque champ</li> 
   </ul> 
   <p>JodaTime propose plusieurs classes qui encapsulent une valeur pour un des champs de manière immuable&nbsp;: Years, Weeks, Months, Days, Hours, Minutes, Seconds.</p> 
   <p>Ces classes implémentent l'interface Comparable et proposent quelques méthodes permettant de réaliser des opérations mathématiques de base sur les valeurs qu'elles encapsulent (plus(), multipliedBy(), dividedBy(), negated(), ...) et des opérations de comparaison (isGreaterThan(), isLesserThan()).</p> 
   <p>La classe Days encapsule un nombre de jours. Elle ne possède pas de constructeur public&nbsp;: pour obtenir une instance, il faut utiliser une des méthodes statiques qui sont des fabriques.</p> 
   <p>La méthode days() est une fabrique qui retourne une constante de type Days ou un instance selon le valeur fournie en paramètre.</p> 
   <p>La méthode daysBetween() permet d'obtenir une instance qui encapsule le nombre de jours entre deux Instant ou deux Partial.</p> 
   <p>La méthode daysIn() permet d'obtenir une instance qui encapsule le nombre de jours d'un Interval.</p> 
   <p>La classe Hours encapsule un nombre d'heures. Elle ne possède pas de constructeur public&nbsp;: pour obtenir une instance, il faut utiliser la méthode hours() qui est une fabrique retournant une constante ou une instance de type Hours selon la valeur fournie en paramètre.</p> 
   <p>La méthode hoursBetween() permet d'obtenir une instance qui encapsule le nombre d'heures entre deux Instant ou deux Partial.</p> 
   <p>La méthode hoursIn() permet d'obtenir une instance qui encapsule le nombre d'heures d'un Interval.</p> 
   <p>La classe Minutes encapsule un nombre de minutes. Elle ne possède pas de constructeur public&nbsp;: pour obtenir une instance, il faut utiliser la méthode minutes() qui est une fabrique retournant une constante ou une instance de type Minutes selon la valeur fournie en paramètre.</p> 
   <p>La méthode minutesBetween() permet d'obtenir une instance qui encapsule le nombre de minutes entre deux Instant ou deux Partial.</p> 
   <p>La méthode minutesIn() permet d'obtenir une instance qui encapsule le nombre de minutes d'un Interval.</p> 
   <p>La classe Seconds encapsule un nombre de secondes. Elle ne possède pas de constructeur public&nbsp;: pour obtenir une instance, il faut utiliser la méthode seconds() qui est une fabrique retournant une constante ou une instance de type Seconds selon la valeur fournie en paramètre.</p> 
   <p>La méthode secondsBetween() permet d'obtenir une instance qui encapsule le nombre de secondes entre deux Instant ou deux Partial.</p> 
   <p>La méthode secondsIn() permet d'obtenir une instance qui encapsule le nombre de secondes d'un Interval.</p> 
   <p>La classe Weeks encapsule un nombre de semaines. Elle ne possède pas de constructeur public&nbsp;: pour obtenir une instance, il faut utiliser la méthode weeks() qui est une fabrique retournant une constante ou une instance de type Weeks selon la valeur fournie en paramètre.</p> 
   <p>La méthode weeksBetween() permet d'obtenir une instance qui encapsule le nombre de semaines entre deux Instant ou deux Partial.</p> 
   <p>La méthode weeksIn() permet d'obtenir une instance qui encapsule le nombre de semaines d'un Interval.</p> 
   <p>La classe Years encapsule un nombre d'années. Elle ne possède pas de constructeur public&nbsp;: pour obtenir une instance, il faut utiliser la méthode years() qui est une fabrique retournant une constante ou une instance de type Years selon la valeur fournie en paramètre.</p> 
   <p>La méthode yearsBetween() permet d'obtenir une instance qui encapsule le nombre d'années entre deux Instant ou deux Partial.</p> 
   <p>La méthode yearsIn() permet d'obtenir une instance qui encapsule le nombre d'années d'un Interval.</p> 
   <p>La classe Period propose de nombreux constructeurs.</p> 
   <p>Une instance de type Period peut s'utiliser avec une instance de type Instant pour obtenir une nouvelle instance de type Instant.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    DateTime noel = new DateTime("2012-12-25");
    DateTime nouvelAn = noel.plus(Period.days(7));
    System.out.println(nouvelAn);</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Les classes Period et MutablePeriod implémentent l'interface ReadablePeriod.</p> 
   <p>La conversion d'une période peut être complexe&nbsp;: par exemple, une journée ne vaut pas forcément 24 heures&nbsp;: elle peut aussi valoir 23 ou 25 heures en fonction de l'heure d'été/d'hiver. Cependant une journée est généralement considérée comme composée de 24 heures&nbsp;: la classe Days possède la méthode toStandardHours() qui permet de convertir la valeur en heures sur la base d'une journée de 24 heures.</p> 
   <p>La classe Period propose des méthodes pour obtenir et pour modifier les valeurs des différents champs. Comme la classe Period est immuable, les opérations de modifications renvoient une nouvelle instance.</p> 
   <p>Il est possible de créer une instance de type Period qui encapsule la durée entre deux instants. Il suffit simplement de passer les deux instants en paramètres du constructeur de la classe Period.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    DateTime noel12 = new DateTime("2012-12-25");
    DateTime noel13 = new DateTime("2013-12-25");
    Period period = new Period(noel12, noel13);
    System.out.println(period.getYears() + " an entre les deux dates");</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Le même calcul peut se faire en utilisant la classe Years :</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    DateTime noel12 = new DateTime("2012-12-25");
    DateTime noel13 = new DateTime("2013-12-25");
    Years year = Years.yearsBetween(noel12, noel13);
    System.out.println(year.getYears() + " an entre les deux dates");</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Attention&nbsp;: Joda Time considère une instance de type Period qui est null comme une période dont tous les champs sont à zéro.</p> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-4-4-3">102.4.4.3. 
     <!--nchpfin-->La classe Duration</a></h4> 
   <p>La classe Duration encapsule une durée mesurée en millisecondes de manière immuable. Un objet de type Duration ne possède aucun système calendaire ni fuseau horaire.</p> 
   <p>La classe Duration implémente l'interface ReadableDuration. L'interface ReadableDuration est un sous-ensemble des opérations du type Duration, il est donc généralement préférable de définir une variable de type Duration plutôt que du type ReadableDuration.</p> 
   <p>La classe Duration possède plusieurs constructeurs qui attendent en paramètres la durée ou deux instants qui seront utilisés pour déterminer la durée encapsulée.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    DateTime noel = new DateTime("2012-12-25");
    DateTime nouvelAn = new DateTime("2013-01-01");
    Duration duree = new Duration(noel, nouvelAn);</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Un objet de type Duration peut être ajouté à un objet de type Instant pour obtenir une nouvelle instance de type Instant.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    DateTime noel = new DateTime("2012-12-25");
    DateTime nouvelAn = noel.plus(new Duration(24L * 60L * 60L * 1000L * 7));
    System.out.println(nouvelAn);</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Une instance de type ReadableDuration à null est considérée par Joda Time comme une instance de type ReadableDurantion ayant pour durée la valeur zéro.</p> 
   <p>&nbsp;</p> 
   <h3 class="TITRESECTION2">
    <!--nchpdeb--><a name="utilisation_dates-4-5">102.4.5. 
     <!--nchpfin-->Les calendriers et les fuseaux horaires</a></h3> 
   <p>Joda Time propose le support de plusieurs systèmes calendaires et la gestion des fuseaux horaires.</p> 
   <p>La classe abstraite Chronology est la classe de base pour encapsuler un système calendaire. La classe DateTimeZone encapsule un fuseau horaire.</p> 
   <p>Joda Time utilise par défaut le système calendaire ISO et le fuseau horaire par défaut du système.</p> 
   <p>En interne, Joda Time utilise des fabriques pour créer des instances de type Chronology et DateTimeZone qui sont des singletons.</p> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-4-5-1">102.4.5.1. 
     <!--nchpfin-->La classe Chronology</a></h4> 
   <p>Un système calendaire est une manière particulière de représenter le temps et de permettre de réaliser des calculs temporels. Joda Time propose en standard le support de plusieurs systèmes calendaires.</p> 
   <p>La classe abstraite Chronology est la classe mère de toutes les classes qui encapsulent un système calendaire. Une instance de type Chronology encapsule un moteur de calcul pour appliquer les règles d'un système calendaire.</p> 
   <p>Joda Time propose un système extensible pour supporter différents systèmes calendaires. Joda Time propose plusieurs classes filles, chacune encapsulant une implémentation d'un système calendaire&nbsp;:</p> 
   <ul> 
    <li>ISOChronology&nbsp;: calendrier définit par le standard ISO8601 (calendrier par défaut)</li> 
    <li>GJChronology&nbsp;: permet une utilisation du calendrier Julien et du calendrier Grégorien</li> 
    <li>GregorianChronology&nbsp;: le calendrier Gregorien</li> 
    <li>IslamicChronology&nbsp;: le calendrier Islamique</li> 
    <li>JulianChronology&nbsp;: le calendrier Julien</li> 
    <li>CopticChronology&nbsp;: le calendrier Copte</li> 
    <li>BuddhistChronology&nbsp;: le calendrier Bouddhiste</li> 
    <li>EthiopicChronology&nbsp;: le calendrier Ethiopien</li> 
   </ul> 
   <p>Pour obtenir une instance dédiée à un système calendaire, il faut utiliser la fabrique correspondante en invoquant la méthode getInstance() de la classe qui encapsule le système calendaire souhaité.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">  Chronology calendrierCopte = CopticChronology.getInstance()
  DateTime dt = new DateTime(calendrierCopte);</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Le système de calendrier par défaut de Joda Time est le calendrier ISO. Ce calendrier est couramment utilisé mais ne convient pas pour des dates antérieures à 1583.</p> 
   <p>Il est possible de fournir une instance de type DateTimeZone qui encapsule un fuseau horaire en paramètre de la fabrique pour préciser le fuseau horaire à utiliser.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">  DateTimeZone zone = DateTimeZone.forID("Europe/Paris");
  Chronology calendrierCopte = CopticChronology.getInstance(zone)
  DateTime dt = new DateTime(calendrierCopte);</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Attention&nbsp;: une instance de type Chonology à null est toujours considérée par l'API Joda Time comme une instance de type Chronology par défaut (système calendaire ISO8601 et fuseau horaire par défaut).</p> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-4-5-2">102.4.5.2. 
     <!--nchpfin-->La classe DateTimeZone</a></h4> 
   <p>Un fuseau horaire correspond à un découpage géographique de la surface de la Terre relatif au méridien de Greenwich&nbsp;: le fuseau horaire de ce méridien est nommé GMT (Greenwich Mean Time). Le concept d'UTC (Universal Coordonated Time) est similaire mais pas tout à fait identique.</p> 
   <p>Le fuseau horaire permet de préciser un décalage, positif ou négatif, par rapport à l'UTC. La valeur de ce décalage peut varier en fonction de l'utilisation de l'heure d'été/d'hiver (DST en anglais&nbsp;: Daylight Saving Time).</p> 
   <p>Un fuseau horaire est utilisé pour calculer une heure par rapport à une position géographique.</p> 
   <p>La classe DateTimeZone encapsule un fuseau horaire de manière immuable.</p> 
   <p>Lors du calcul de certaines données temporelles, il peut être important de connaître le lieu où un point dans le temps doit être représenté. Cela se fait avec un fuseau horaire car selon celui-ci, la représentation du point dans un calendrier peut être différente.</p> 
   <p>C'est la raison pour laquelle une instance de type Chronology encapsule une instance de type DateTimeZone. Si aucun fuseau horaire n'est précisé, alors c'est le fuseau horaire par défaut qui est utilisé&nbsp;: c'est celui de la machine hôte.</p> 
   <p>La méthode forId() de la classe DateTimeZone est une fabrique qui permet de créer une instance en passant en paramètre l'identifiant de la zone concernée.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    DateTimeZone zone = DateTimeZone.forID("Europe/Paris");</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>La classe DateTimeZone définit la constante UTC qui correspond à l'instance de DateTimeZone pour l'UTC.</p> 
   <p>La méthode getDefault() permet d'obtenir une instance de type DateTimeZone encapsulant le fuseau horaire par défaut qui correspond à celui du système hôte.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    DateTimeZone zone = DateTimeZone.getDefault();
    System.out.println(zone);</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>C'est ce fuseau horaire qui sera utilisé par défaut par l'API Joda Time si aucun fuseau horaire n'est explicitement précisé.</p> 
   <p>La méthode statique setDefault() peut être utilisée pour modifier le fuseau horaire qui doit être utilisé par défaut.</p> 
   <p>Les fuseaux horaires sont des concepts qui évoluent fréquemment en fonction du contexte politique du pays concerné. Le JDK et Joda Time utilise la TZ Database. Comme le JDK peut ne pas être mis à jour, il est possible de mettre à jour la base incluse dans Joda Time et de recompiler la bibliothèque pour tenir compte des mises à jour dans la définition des fuseaux horaires.</p> 
   <p>La dernière version de la base peut être téléchargée à l'url&nbsp;: <a href="http://www.twinsun.com/tz/tz-link.htm">http://www.twinsun.com/tz/tz-link.htm</a></p> 
   <p>Il faut télécharger les sources de l'API Joda Time à l'url <a href="http://sourceforge.net/projects/joda-time/files/joda-time/">http://sourceforge.net/projects/joda-time/files/joda-time/</a></p> 
   <p>Il faut décompresser les sources et remplacer les fichiers dans le sous-répertoire src/java/org/joda/time/tz/src par les fichiers téléchargés.</p> 
   <p>La recompilation du code source se fait en utilisant la commande ant jar dans le répertoire racine des sources. Il est recommandé dans ce cas de renommer le fichier jar généré pour indiquer que cette version à été modifiée par rapport à l'originale.</p> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-4-5-3">102.4.5.3. 
     <!--nchpfin-->Le système calendaire ISO8601</a></h4> 
   <p>Le système calendaire ISO8601 est une normalisation basée sur le calendrier Grégorien afin de faciliter les échanges de date/heures entre applications, systèmes et pays.</p> 
   <p>Ce système calendaire est implémenté dans la classe ISOChronology qui est immuable.</p> 
   <p>Ce standard définit&nbsp;:</p> 
   <ul> 
    <li>12 mois&nbsp;: de janvier à décembre, numérotés de 1 à 12</li> 
    <li>7 jours&nbsp;: de lundi à dimanche, numérotés de 1 à 7</li> 
    <li>plusieurs formats pour restituer la date dont le plus commun est YYYY-MM-DDTHH:MM:SS.SSSZ&nbsp;: il est notamment utilisé dans le standard XML.</li> 
   </ul> 
   <p>La classe ISOChronology est l'implémentation utilisée par défaut par Joda Time&nbsp;: si une instance de type Chronology fournie à l'API est null, alors c'est une instance de type ISOChronology qui sera utilisée.</p> 
   <p>Pour obtenir une instance de type ISOChronology, il faut invoquer sa méthode getInstance().</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">Chronology chrono = ISOChronology.getInstance();
DateTime dt = new DateTime(2012, 12, 25, 0, 0, 0, 0, chrono);</pre></td>
     </tr>
    </tbody>
   </table> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-4-5-4">102.4.5.4. 
     <!--nchpfin-->La calendrier Bouddhiste</a></h4> 
   <p>Le calendrier Bouddhiste ne possède qu'une seule ère et ses années possèdent un décalage de 543 ans par rapport au calendrier Grégorien.</p> 
   <p>La classe BuddhistChronology est l'implémentation du calendrier Bouddhiste. Pour obtenir une instance, il faut invoquer la méthode getInstance() de la classe BuddhistChronology.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    DateTime noel12 = new DateTime("2012-12-25");
    DateTime dt = noel12.withChronology(BuddhistChronology.getInstance());
    System.out.println(dt);</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">2555-12-25T00:00:00.000+01:00</pre></td>
     </tr>
    </tbody>
   </table> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-4-5-5">102.4.5.5. 
     <!--nchpfin-->Le calendrier Copte</a></h4> 
   <p>Le calendrier copte est basé sur le calendrier utilisé dans l'Ancien Egypte. Il est utilisé par l'Eglise Orthodoxe Copte.</p> 
   <p>Le calendrier Copte repose sur 12 mois de 30 jours chacun suivi d'une période de 5 ou 6 jours. L'année contient donc 365 ou 366 jours. Les années bissextiles sont celles qui durent 366 jours&nbsp;: elles surviennent tous les 4 ans.</p> 
   <p>La classe CopticChronology implémente le calendrier Copte. Dans cette implémentation, les 5 ou 6 jours complémentaires sont stockées dans un treizième mois.</p> 
   <p>Pour obtenir une instance, il faut invoquer sa méthode getInstance().</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    DateTime noel12 = new DateTime("2012-12-25");
    DateTime dt = noel12.withChronology(CopticChronology.getInstance());
    System.out.println(dt);</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">1729-04-16T00:00:00.000+01:00</pre></td>
     </tr>
    </tbody>
   </table> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-4-5-6">102.4.5.6. 
     <!--nchpfin-->Le calendrier Ethiopien</a></h4> 
   <p>Le calendrier Ethiopien est similaire au calendrier Copte.</p> 
   <p>La classe EthiopicChronology implémente le calendrier Ethiopien. Pour obtenir une instance, il faut invoquer sa méthode getInstance().</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    DateTime noel12 = new DateTime("2012-12-25");
    DateTime dt = noel12.withChronology(EthiopicChronology.getInstance());
    System.out.println(dt);</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">2005-04-16T00:00:00.000+01:00</pre></td>
     </tr>
    </tbody>
   </table> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-4-5-7">102.4.5.7. 
     <!--nchpfin-->Le calendrier Grégorien</a></h4> 
   <p>Le calendrier Grégorien est le calendrier majoritairement utilisé pour les traitements métiers. Ce calendrier a remplacé le calendrier Julien. Le calendrier Grégorien définit une année bissextile tous les quatre ans avec deux exceptions&nbsp;: les années divisibles par 100 ne sont pas bissextiles sauf celles divisibles par 400.</p> 
   <p>Ce système calendaire est compatible avec le système calendaire ISO même si la gestion du siècle est légèrement différente. Il n'est utilisable que pour des dates postérieures à 1583.</p> 
   <p>La classe GregorianChronology implémente le calendrier Grégorien. Pour obtenir une instance, il faut invoquer sa méthode getInstance().</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    DateTime noel12 = new DateTime("2012-12-25");
    DateTime dt = noel12.withChronology(GregorianChronology.getInstance());
    System.out.println(dt);</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">2012-12-25T00:00:00.000+01:00</pre></td>
     </tr>
    </tbody>
   </table> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-4-5-8">102.4.5.8. 
     <!--nchpfin-->Le système calendaire Grégorien/Julien</a></h4> 
   <p>Le système calendaire Grégorien/Julien est la combinaison des systèmes calendaires utilisés par les Chrétiens et les Romains. Ce système calendaire est utilisé pour des traitements de dates historiques puisqu'il permet de gérer les dates du calendrier Julien puis celles du calendrier Grégorien. La date de basculement de calendriers est configurable&nbsp;: elle est par défaut au 15/10/1582 comme l'a défini le pape Grégoire XIII.</p> 
   <p>La classe GJChronology implémente le calendrier Grégorien/Julien. Cette classe est similaire à la classe java.util.GregorianCalendar du JDK.</p> 
   <p>Pour obtenir une instance, il faut invoquer sa méthode getInstance().</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    DateTime noel12 = new DateTime("2012-12-25");
    DateTime dt = noel12.withChronology(GJChronology.getInstance());
    System.out.println(dt);</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">2012-12-25T00:00:00.000+01:00</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Une des surcharge de la méthode getInstance() permet de préciser le point dans le temps où le calendrier Grégorien doit être utilisé.</p> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-4-5-9">102.4.5.9. 
     <!--nchpfin-->Le calendrier Islamique</a></h4> 
   <p>Le calendrier Islamique est basé sur les cycles de la Lune&nbsp;: il est utilisé dans de nombreux pays musulmans.</p> 
   <p>La classe IslamicChronology implémente le système calendaire Islamique. Pour obtenir une instance, il faut invoquer sa méthode getInstance().</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    DateTime noel12 = new DateTime("2012-12-25");
    DateTime dt = noel12.withChronology(IslamicChronology.getInstance());
    System.out.println(dt);</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">1434-02-11T00:00:00.000+01:00</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>La classe IslamicChronology.LeapYearPatternType permet de définir la façon dont les années bissextiles sont définies.</p> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-4-5-10">102.4.5.10. 
     <!--nchpfin-->Le calendrier Julien</a></h4> 
   <p>Le calendrier Julien est utilisé jusqu'au 15 octobre 1582 où il a été remplacé par le calendrier Grégorien.</p> 
   <p>La classe JulianChronology implémente le système calendaire Julien. Pour obtenir une instance, il faut invoquer sa méthode getInstance().</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    DateTime noel12 = new DateTime("1012-12-25");
    DateTime dt = noel12.withChronology(JulianChronology.getInstance());
    System.out.println(dt);</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">1012-12-19T00:00:00.000+00:09:21</pre></td>
     </tr>
    </tbody>
   </table> 
   <p>&nbsp;</p> 
   <h3 class="TITRESECTION2">
    <!--nchpdeb--><a name="utilisation_dates-4-6">102.4.6. 
     <!--nchpfin-->La manipulation des dates</a></h3> 
   <p>Les fonctionnalités de manipulation de dates sont le point fort de l'API Joda Time de part leur richesse et leur facilité d'utilisation par rapport aux classes fournies par le JDK.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.jodatime;
      
import org.joda.time.DateTime;

public class TestJodaTime {
  public static void main(String[] args) {
    DateTime dateTime = new DateTime(2012, 1, 1, 0, 0, 0, 0);
    System.out.println(dateTime.plusDays(30) 
        .toString("dd/MM/yyyy HH:mm:ss.SSS"));
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Le code équivalent en utilisant les classes du JDK est le suivant :</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.jodatime;
      
import java.text.SimpleDateFormat;
import java.util.Calendar;

public class TestJodaTime {

  public static void main(String[]args) {
    Calendar calendar = Calendar.getInstance();
    calendar.setTimeInMillis(0);
    calendar.set(2012, Calendar.JANUARY, 1, 0, 0, 0);
    SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss.SSS");
    calendar.add(Calendar.DAY_OF_MONTH, 30);
    System.out.println(sdf.format(calendar.getTime()));
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Cette section propose plusieurs exemples pour illustrer certaines fonctionnalités de manipulation de dates proposées par Joda Time.</p> 
   <p>Exemple&nbsp;: obtenir la date/heure courante plus une heure et demi.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    DateTime now = new DateTime();
    DateTime limite = now.plusHours(1).plusMinutes(30);
    System.out.println(limite);</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Exemple&nbsp;: obtenir le dernier jour du mois précédent.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    LocalDate dernierJourduMoisPrecedent = LocalDate.now() // aujourd'hui
        .minusMonths(1) // on retire un mois
        .dayOfMonth() // on récupère le jour du mois
        .withMaximumValue(); // on lui affecte sa valeur maximale
    System.out.println(dernierJourduMoisPrecedent);</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Exemple&nbsp;: obtenir le lundi de la semaine de Noël.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    DateTime dateTime = new DateTime("2012-12-25");
    DateTime result = dateTime.dayOfWeek().setCopy(DateTimeConstants.MONDAY);
    System.out.println(result);</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">2012-12-24T00:00:00.000+01:00</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Exemple&nbsp;: Obtenir la date de paiement à 90 jours fin de mois.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    LocalDate datePaiement = LocalDate.now() // aujourd'hui
        .plusDays(90) // on ajoute 90 jours
        .dayOfMonth() // on récupère le jour du mois
        .withMaximumValue(); // on lui affecte sa valeur maximale
    System.out.println(datePaiement);</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Pour calculer le nombre de jours entre deux dates, il est possible d'utiliser la méthode daysBetween() de la classe Days.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    DateTime dateTimeDeb = new DateTime("2012-12-25");
    DateTime dateTimeFin = new DateTime("2012-12-31");
    Days d = Days.daysBetween(dateTimeDeb, dateTimeFin);
    int days = d.getDays();
    System.out.println(days);</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">6</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Pour obtenir le nombre des différents éléments qui composent l'écart entre deux dates, il est possible d'utiliser la classe Period.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    DateTime dateTimeDeb = new DateTime("2011-11-25");
    DateTime dateTimeFin = new DateTime("2012-12-31");
    Period p = new Period(dateTimeDeb, dateTimeFin, PeriodType.yearWeekDay());
    System.out.println("annees   " + p.getYears());
    System.out.println("semaines " + p.getWeeks());
    System.out.println("jours    " + p.getDays());</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">annees   1
semaines 5
jours    1</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Exemple&nbsp;: Obtenir le nombre de jours avant la nouvelle année.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    LocalDate aujourdhui = LocalDate.now();
    LocalDate nouvelAn = aujourdhui.plusYears(1).withDayOfYear(1);
    Days nbJours = Days.daysBetween(aujourdhui, nouvelAn);
    System.out.println(nbJours.getDays());</pre></td>
     </tr>
    </tbody>
   </table> 
   <p>&nbsp;</p> 
   <h3 class="TITRESECTION2">
    <!--nchpdeb--><a name="utilisation_dates-4-7">102.4.7. 
     <!--nchpfin-->L'intéropabilité avec les classes du JDK</a></h3> 
   <p>Joda Time offre une grande facilité pour l'interopérabilité avec les classes du JDK relatives aux traitements des données de type date/heure (notamment les classes Date et Calendar).</p> 
   <p>Il est possible de convertir des classes du JDK vers leur équivalent et vice versa tout en profitant de la facilité et de la richesse des fonctionnalités de manipulation de dates/heures offertes par Joda Time.</p> 
   <p>Les classes de Joda Time qui encapsulent une date/heure acceptent comme paramètre dans une surcharge de leur constructeur un objet de type java.util.Date ou java.util.Calendar.</p> 
   <p>La méthode toCalendar() de la classe AbstractDateTime permet de convertir l'objet Joda Time en une instance de type java.util.Calendar.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    DateTime dateTime = new DateTime("2012-12-25");
    Calendar calendar = dateTime.toCalendar(Locale.getDefault());
    System.out.println(calendar);</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>La méthode toGregorianCalendar() de la classe AbstractDateTime permet de convertir l'objet Joda Time en une instance de type java.util.GregorianCalendar.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    DateTime dateTime = new DateTime("2012-12-25");
    GregorianCalendar calendar = dateTime.toGregorianCalendar();
    System.out.println(calendar);</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>La méthode toDate() de la classe AbstractInstant permet de convertir l'objet Joda Time en une instance de type java.util.Date.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    DateTime dateTime = new DateTime("2012-12-25");
    Date date = dateTime.toDate();
    System.out.println(date);</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Pour convertir un objet de type LocalDate en un objet de type Date ou Calender, il est nécessaire de le convertir au préalable en une instance de type DateMidnight en invoquant la méthode toDateMidnight().</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    LocalDate localDate = new LocalDate("2012-12-25");
    Date date = localDate.toDateMidnight().toDate();
    System.out.println(date);</pre></td>
     </tr>
    </tbody>
   </table> 
   <p>&nbsp;</p> 
   <h3 class="TITRESECTION2">
    <!--nchpdeb--><a name="utilisation_dates-4-8">102.4.8. 
     <!--nchpfin-->Le formattage des dates</a></h3> 
   <p>L'obtention d'une date à partir d'une ressource externe (fichiers, services web, ...) ou d'une zone de saisie de l'utilisateur, le formattage d'une date sont fréquents dans une application. Le format de ces dates n'est pas toujours le même&nbsp;: Joda Time propose plusieurs solutions pour définir ce format de manière simple ou personnalisée.</p> 
   <p>Le plus simple pour formater un objet de type DateTime est d'invoquer sa méthode toString().</p> 
   <p>Il est possible de fournir en paramètre de la méthode toString() une chaîne de caractères qui contient le format désiré. Le format à utiliser est quasiment le même que la classe SimpleDateFormat du JDK.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    DateTime dateTime = new DateTime("2012-12-25");
    System.out.println(dateTime.toString("dd-MM-yyyy HH:mm:ss"));
    System.out.println(dateTime.toString("EEEE dd MMMM yyyy HH:mm:ss"));
    System.out.println(dateTime.toString("MM/dd/yyyy HH:mm ZZZZ"));
    System.out.println(dateTime.toString("MM/dd/yyyy HH:mm Z"));</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">25-12-2012 00:00:00
mardi 25 décembre 2012 00:00:00
12/25/2012 00:00 Europe/Paris
12/25/2012 00:00 +0100</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>La classe ISODateTimeFormat est une fabrique pour obtenir des instances de type DateTimeFormatter pour différent format de dates respectant la norme ISO8601.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    DateTime dateTime = new DateTime("2012-12-25");
    System.out.println(dateTime.toString(ISODateTimeFormat.basicDateTime()));
    System.out.println(dateTime.toString(ISODateTimeFormat
        .basicDateTimeNoMillis()));
    System.out.println(dateTime.toString(ISODateTimeFormat
        .basicOrdinalDateTime()));
    System.out
        .println(dateTime.toString(ISODateTimeFormat.basicWeekDateTime()));</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">20121225T000000.000+0100
20121225T000000+0100
2012360T000000.000+0100
2012W522T000000.000+0100</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>La classe DateTimeFormatter est utilisée pour formater et extraire une date d'une chaîne de caractères.</p> 
   <p>La classe DateTimeFormatter est thread-safe et immuable. Elle contient un cache en interne qui maintient des instances ce qui évite d'avoir à créer une instance à chaque utilisation.</p> 
   <p>La classe DateTimeFormat propose plusieurs méthodes qui sont des fabriques pour obtenir des instances de type DateTimeFormatter. La plupart de ces méthodes proposent des formats standard. La méthode forPattern() permet de préciser explicitement le format de la date/heure à utiliser.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    DateTimeFormatter formatter = DateTimeFormat
        .forPattern("dd-MM-yyyy HH:mm:ss");
    DateTime dateTime = formatter.parseDateTime("25-12-2012 00:00:00");
    System.out.println(dateTime);</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">2012-12-25T00:00:00.000+01:00</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>La méthode withLocale() permet de préciser la locale à utiliser et renvoie une nouvelle instance.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    DateTime dateTime = new DateTime("2012-12-25");
    DateTimeFormatter formatter = DateTimeFormat
      .forPattern("EEEE dd MMMM yyyy HH:mm:ss");
    DateTimeFormatter frenchFmt = formatter.withLocale(Locale.FRENCH);
    System.out.println(frenchFmt.print(dateTime));
    DateTimeFormatter englishFmt = formatter.withLocale(Locale.ENGLISH);
    System.out.println(englishFmt.print(dateTime));</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">mardi 25 décembre 2012 00:00:00
Tuesday 25 December 2012 00:00:00</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Pour des formats très spécifiques, Joda Time propose la classe DateTimeFormatterBuilder qui implémente le motif de conception builder pour créer une instance de type DateTimeFormatter.</p> 
   <p>La classe DateTimeFormatterBuilder propose de nombreuses méthodes appendXXX() qui permet de préciser chaque élément qui devra être ajouté pour définir le format de la date.</p> 
   <p>La méthode toFormatter() permet de demander l'instance de type DateTimeFormatter selon la configuration définie.</p> 
   <p>L'exemple ci-dessous va demander le formatage de l'année sur deux caractères.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    DateTime dateTime = new DateTime("2012-12-25");
    DateTimeFormatter fmt = new DateTimeFormatterBuilder().appendDayOfMonth(2)
        .appendLiteral(' ').appendMonthOfYearShortText().appendLiteral(' ')
        .appendTwoDigitYear(1949).toFormatter();
    System.out.println(fmt.print(dateTime));</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">25 déc. 12</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>La méthode clear() permet de réinitialiser la configuration.</p> 
   <p>&nbsp;</p> 
   <h3 class="TITRESECTION2">
    <!--nchpdeb--><a name="utilisation_dates-4-9">102.4.9. 
     <!--nchpfin-->D'autres fonctionnalités de Joda Time</a></h3> 
   <p>Joda Time propose aussi des fonctionnalités pour modifier la date/heure par défaut ou utiliser des objets mutables.</p> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-4-9-1">102.4.9.1. 
     <!--nchpfin-->La modification de l'heure de la JVM</a></h4> 
   <p>La classe DateTimeUtils propose plusieurs méthodes qui permettent de modifier la date/heure obtenue par l'API Joda Time.</p> 
   <p>La méthode setCurrentMillisFixed() permet de modifier la date/heure de Joda Time avec celle correspondant au nombre de millisecondes fourni en paramètre.</p> 
   <p>La méthode setCurrentMillisOffset() permet de modifier la date/heure de Joda Time en effectuant un décalage avec le nombre de millisecondes fourni en paramètre.</p> 
   <p>La méthode setCurrentMillisSystem() permet d'accorder la date/heure de Joda Time avec celle du système.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    DateTime noel13 = new DateTime("2013-12-25");
    DateTimeUtils.setCurrentMillisFixed(noel13.getMillis());
    System.out.println(new Date());
    System.out.println(LocalDateTime.now());
    
    // remettre la date de Joda Time à la date systeme
    DateTimeUtils.setCurrentMillisSystem();
    System.out.println(LocalDateTime.now());
    
    // modifier la date de Joda Time à la veille
    DateTimeUtils.setCurrentMillisOffset(1000 * 60 * 60 * 24);
    System.out.println(LocalDateTime.now());</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>L'utilisation de ces méthodes peut être pratique pour des tests.</p> 
   <p>Attention&nbsp;: la date/heure de la JVM obtenue avec les API du JDK n'est pas modifiée.</p> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-4-9-2">102.4.9.2. 
     <!--nchpfin-->Les objets mutables</a></h4> 
   <p>Comme la plupart des objets Joda Time sont immuables, leur modification implique la création d'une nouvelle instance à chaque méthode invoquée. Si plusieurs champs doivent être modifiés, il peut être intéressant d'utiliser une version mutable afin de limiter le nombre d'instances créées.</p> 
   <p>Joda Time propose les classes MutableDateTime, MutableInterval et MutablePeriod.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">    DateTime noel13 = new DateTime("2013-12-25");
    MutableDateTime mdt = noel13.toMutableDateTime();
    mdt.setDayOfMonth(1);
    mdt.setYear(2012);
    mdt.setMonthOfYear(1);
    DateTime result = mdt.toDateTime();
    System.out.println(result);</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>La classe MutableDateTime possède de nombreux constructeurs pour indiquer la date/heure encapsulée.</p> 
   <p>La classe DateTime propose aussi la méthode toMutableDateTime() qui renvoie une instance de type MutableDateTime encapsulant la date/heure de l'objet.</p> 
   <p>La classe MutableDateTime propose de nombreuses méthodes qui ne renvoient rien pour modifier un champ de la date/heure encapsulée.</p> 
   <p>La méthode toDateTime() permet de renvoyer une instance de type DateTime qui encapsule la date/heure de l'objet.</p> 
   <p>&nbsp;</p> 
   <h2 class="TITRESECTION1">
    <!--nchpdeb--><a name="utilisation_dates-5">102.5. 
     <!--nchpfin-->La classe FastDateFormat du projet Apache commons.lang</a></h2> 
   <p>La classe org.apache.commons.lang.time.FastDateFormat permet le formatage d'une date comme SimpleDateFormat mais elle est plus performante et surtout thread-safe.</p> 
   <p>La classe FastDateFormat offre des fonctionnalités de formatage d'une date similaires à celles de la classe SimpleDateFormat : elle propose cependant un support du timezone différent dans le formatage.</p> 
   <p>FastDateFormat ne permet que le formatage d'une date. Contrairement à la classe SimpleDateFormat, elle ne permet pas d'extraire une date d'une chaine de caractères.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">import java.text.SimpleDateFormat; import java.util.Date;

import org.apache.commons.lang.time.FastDateFormat;

public class TestSdf {

  public static void main(final String[] args) {
    final String format = "dd-MM-yyyy HH:mm:ss.SSS"; 
    SimpleDateFormat sdf = new SimpleDateFormat(format); 
    FastDateFormat fdf = FastDateFormat.getlnstance(format);
    final Date d = new Date();
    final int nblteration = 1000000;
    long start = 0; 
    long tempsTrt = 0;

    start = System.currentTimeMillis();
    for (int i = 0; i &lt; nblteration; i++) {
      fdf = FastDateFormat.getlnstance(format);
      d.setTime(System.currentTimeMillis()); 
      fdf.format(d);
    }
    tempsTrt = System.currentTimeMillis() - start;
    System.out.println("FastDateFormat : " + tempsTrt + " ms");

    start = System.currentTimeMillis();
    for (int i = 0; i &lt; nblteration; i++) {
      sdf = new SimpleDateFormat(format);
      d.setTime(System.currentTimeMillis()); 
      sdf.format(d);
    }
    tempsTrt = System.currentTimeMillis() - start;
    System.out.println("SimpleDateFormat : " + tempsTrt + " ms");
  }

} 
</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">FastDateFormat : 2041 ms
SimpleDateFormat : 5360 ms</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>La classe org.apache.commons.lang.time.DateFormatUtils est une classe utilitaire pour le formatage de dates et d'heures en utilisant la classe FastDateFormat.</p> 
   <p>Elle propose des constantes pour des instances de FastDateFormat avec des motifs de formatage courants en ISO08601 et SMTP :</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>ISO_DATETIME_FORMAT</p> </td> 
      <td> <p>formatage d'une date/heure en ISO860 sans timezone : yyyy-MM-dd'T'HH:mm:ss</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ISO_DATETIME_TIMEZONE_FORMAT</p> </td> 
      <td> <p>formatage d'une date/heure en ISO8601 avec timezone : yyyy-MM-dd'T'HH:mm:ssZZ</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ISO_DATE_FORMAT</p> </td> 
      <td> <p>formatage d'une date enISO8601 sans timezone : yyyy-MM-dd</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ISO_TIME_FORMAT</p> </td> 
      <td> <p>formatage d'une heure en pseudo ISO8601 sans time zone (la spécification ne permet pas d'avoir une heure sans timezone) : 'T'HH:mm:ss</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ISO_DATE_TIME_ZONE_FORMAT</p> </td> 
      <td> <p>formatage d'une date enISO8601 sans timezone (la spécification ne permet pas d'avoir une heure sans timezone) : yyyy-MM-ddZZ</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ISO_TIME_TIMEZONE_FORMAT</p> </td> 
      <td> <p>formatage d'une heure en ISO8601 avec time zone : 'T'HH:mm:ssZZ.</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ISO_TIME_NOT_FORMAT</p> </td> 
      <td> <p>formatage d'une heure en pseudo ISO8601 sans time zone (la spécification requiert que l'heure soit préfixée par le caractère T) : HH:mm:ss.</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ISO_TIME_NOTTIMEZONE_FORMAT</p> </td> 
      <td> <p>formatage d'une heure en pseudo ISO8601 avec time zone (la spécification requiert que l'heure soit préfixée par le caractère T) : HH:mm:ssZZ.</p> </td> 
     </tr> 
     <tr> 
      <td> <p>SMTP_DATETIME_FORMAT</p> </td> 
      <td> <p>formatage d'une date heure au format requis par SMTP : EEE, dd MMM yyyy EH:mm:ss Z in US locale.</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <p>Il n'est pas recommandé d'utiliser son constructeur par défaut.</p> 
   <p>Elle propose de nombreuses méthodes notamment plusieurs surcharges des méthodes format() et formatUTC() acceptant la date à formater en plusieurs formats (long, Date, Calendar) et permettant de préciser le format et la Locale à utiliser.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">public static void main(final String[] args) { 
  final Date today = new Date();

  /*
   *    formatage en ISO8601 sans timezone : yyyy-MM-dd'T'HH:mm:ss.
   */
  String timestamp = DateFormatUtils.ISO_DATETIME_FORMAT.format(today);    
  System.out.println("timestamp = " + timestamp);

  /*
   *    formatage en ISO8601 avec timezone : yyyy-MM-dd' T'HH:mm:ssZZ.
   */
  timestamp = DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.format(today)
  System.out.println("timestamp = " + timestamp);

  /*
   *    formatage au format SMTP : EEE, dd MMM yyyy HH:mm:ss Z (Locale US).
   */
  timestamp = DateFormatUtils.SMTP_DATETIME_FORMAT.format(today);
  System.out.println("timestamp = " + timestamp); }
</pre></td>
     </tr>
    </tbody>
   </table> 
   <p>&nbsp;</p> 
   <h2 class="TITRESECTION1">
    <!--nchpdeb--><a name="utilisation_dates-6">102.6. 
     <!--nchpfin-->L'API Date and Time</a></h2> 
   <p>Malgré les nombreux intérêts de la plate-forme Java, celle-ci a toujours manqué d'un support correct pour la gestion des données temporelles jusqu'à Java 8. Pourtant un bon support de ce type de fonctionnalités est important car l'utilisation de données temporelles est omniprésente notamment dans les applications de gestion.</p> 
   <p>Il y a 3 API différentes pour manipuler le temps dans le JDK8 :</p> 
   <ul> 
    <li>java.util.Date depuis Java 1.0</li> 
    <li>java.util.Calendar depuis Java 1.1</li> 
    <li>java.time.* depuis Java 1.8</li> 
   </ul> 
   <p>&nbsp;</p> 
   <h3 class="TITRESECTION2">
    <!--nchpdeb--><a name="utilisation_dates-6-1">102.6.1. 
     <!--nchpfin-->Le besoin d'une nouvelle API</a></h3> 
   <p>Java 1.0 ne propose que la classe java.util.Date concernant le support de données temporelles. Elle encapsule un point dans le temps avec une précision à la milliseconde.</p> 
   <p>Elle présente de nombreuses lacunes dont les principales sont :</p> 
   <ul> 
    <li>elle n'encapsule pas une date mais une date et une heure</li> 
    <li>le mois est numéroté de 0 à 11</li> 
    <li>l'année commence en 1900 : elle doit être précisée en utilisant un décalage</li> 
    <li>elle n'est pas immuable donc pas thread-safe</li> 
    <li>elle ne propose aucun support pour l'internationalisation</li> 
    <li>elle supporte uniquement du fuseau horaire de la machine</li> 
    <li>le formatage de la date grâce à la méthode toString() est particulier</li> 
   </ul> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;

import java.util.Date;

public class TestDate {
  public static void main(String[] args) {
    Date date = new Date(114, 11, 25);
    System.out.println(date);
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">Thu Dec 25 00:00:00 CET 2014</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Pour combler une partie de ces lacunes et conserver la compatibilité, Java 1.1 a rendu deprecated une grande partie des méthodes et constructeurs de la classe Date et a introduit la classe java.util.Calendar. Celle-ci n'a pas résolu tous les problèmes car elle a aussi certains inconvénients de la classe Date mais aussi des inconvénients qui lui sont propres :</p> 
   <ul> 
    <li>son nom n'est pas très représentatif de ce qu'elle fait</li> 
    <li>le mois est numéroté de 0 à 11</li> 
    <li>pour obtenir une des valeurs encapsulées, il faut invoquer la méthode get() en lui passant en paramètre un entier : des constantes sont définies pour chacun des éléments</li> 
    <li>elle encapsule ses données de deux manières : un entier long qui représente le nombre de millisecondes écoulées depuis un instant donné et leur équivalent sous la forme de champs années, mois, jours, heures, minutes, secondes, ... se qui requiert des conversions pour maintenir leur cohérence</li> 
    <li>elle n'est pas immuable donc pas thread-safe</li> 
    <li>il n'est pas possible de formater un objet de type Calendar</li> 
    <li>elle a introduit une confusion avec son utilisation vis-à-vis de la classe Date</li> 
   </ul> 
   <p>De plus, certaines fonctionnalités requièrent uniquement un objet de type Date ce qui oblige à faire des conversions.</p> 
   <p>Pour analyser et formater une date, la classe abstraite DateFormat et la classe SimpleDateFormat ont été ajoutées. Elles présentent aussi des inconvénients :</p> 
   <ul> 
    <li>SimpleDateFormat n'est pas thread-safe</li> 
    <li>ses performances sont médiocres</li> 
   </ul> 
   <p>La classe java.util.TimeZone encapsule un fuseau horaire.</p> 
   <p>Pour pallier ces inconvénients, plusieurs API open source ont été développées : la plus populaire est Joda-Time. Cependant Joda-Time n'est pas exempt de défauts :</p> 
   <ul> 
    <li>la représentation interne des données temporelles rend les calculs encore plus complexes</li> 
    <li>de nombreuses méthodes permettent de recevoir null comme paramètre ce qui peut induire des bugs</li> 
    <li>les objets temporels peuvent utiliser différents calendriers</li> 
   </ul> 
   <p>Ces points expliquent en grande partie pourquoi Joda-Time n'est pas et ne peut pas être l'implémentation de référence de la JSR 310.</p> 
   <p>&nbsp;</p> 
   <h3 class="TITRESECTION2">
    <!--nchpdeb--><a name="utilisation_dates-6-2">102.6.2. 
     <!--nchpfin-->La JSR 310</a></h3> 
   <p>L'API Date-Time offre un support pour utiliser et manipuler des données temporelles de manière la plus complète possible : date, heure, intervalle de temps, calendrier, fuseau et décalage horaire, ...</p> 
   <p>Les spécifications de l'API Date-Time sont définies dans la JSR 310 dont l'implémentation de référence est le projet ThreeTen. Celle-ci s'est largement inspirée de l'API Joda-Time pour proposer une API riche permettant le support de données temporelles dans l'API du JDK. Elle est intégrée à Java SE version 8.</p> 
   <p>L'API propose une meilleure modélisation des classes et interfaces permettant la gestion de dates/heures qui est riche, puissante et extensible.</p> 
   <p>L'API possède plusieurs avantages :</p> 
   <ul> 
    <li>simplicité : les nombreuses classes de l'API permettent une meilleure séparation des rôles. Par exemple, elle définit les classes Date, Time et DateTime. Plusieurs énumérations pour différentes données sont définies pour limiter les risques d'erreurs</li> 
    <li>richesse des fonctionnalités</li> 
    <li>clarté des opérations notamment celles qui concernent des calculs</li> 
    <li>immutabilité donc thread-safe : la plupart des principaux objets sont immuables</li> 
    <li>création d'instances grâce à des fabriques</li> 
    <li>l'utilisation d'interfaces de type fluent permet de simplifier l'utilisation de l'API en chaînant l'invocation des méthodes</li> 
    <li>extensible en utilisant le motif de conception Stratégie</li> 
   </ul> 
   <p>L'API Date-Time utilise :</p> 
   <ul> 
    <li> par défaut, le calendrier utilisé est celui défini par l'International Organization for Standardization dans les spécifications ISO-8601 : c'est le calendrier utilisé de facto dans le monde et qui repose sur le calendrier Grégorien. Il est possible d'utiliser un autre calendrier. Plusieurs implémentations sont proposées dans le package java.util.chrono</li> 
    <li>l'Unicode Common Locale Data Repository (CLRD) pour tenir compte de la Locale lorsque la manipulation d'une donnée temporelle le requiert</li> 
    <li>le Time-Zone Database (TZDB) pour obtenir des informations sur chacun des fuseaux horaires</li> 
   </ul> 
   <p>La représentation du temps peut se faire selon deux grands modèles :</p> 
   <ul> 
    <li>le temps machine : c'est un entier long dont la valeur est une quantité de temps, dans une unité définie, écoulée depuis un point dans le temps. Cette représentation est facilement exploitable par une machine</li> 
    <li>le temps humain : le temps est représenté par différentes valeurs dans différents champs qui permettent de préciser différentes unités (siècle, année, mois, jour, heure, minute, seconde, ...). La définition et les règles de gestion de ces champs sont définies dans un calendrier. D'autres concepts peuvent compléter ces règles notamment les fuseaux horaires, l'heure d'été/hiver, ...</li> 
   </ul> 
   <p>L'API propose plusieurs classes qui encapsulent différentes données temporelles sous ces deux formes :</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Classe</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDate</p> </td> 
      <td> <p>Encapsule une date sans heure ni fuseau horaire ni offset. Cette classe peut par exemple être utile pour stocker une date d'anniversaire</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDateTime</p> </td> 
      <td> <p>Encapsule une date et une heure sans fuseau horaire</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Localtime</p> </td> 
      <td> <p>Encapsule une heure sans date, ni fuseau horaire ni offset</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Period</p> </td> 
      <td> <p>Encapsule une période de temps exprimée dans des unités compréhensibles par un humain, par exemple 1 mois et 12 jours. Les valeurs exprimées dans une unité peuvent être négatives</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Duration</p> </td> 
      <td> <p>Encapsule une durée entre deux instants stockée avec une précision de la nanoseconde. La durée peut être négative</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Instant</p> </td> 
      <td> <p>Encapsule un point dans le temps avec une précision de la nanoseconde. Elle permet de représenter un point dans la ligne du temps. La classe Instant est la classe la plus proche de la classe java.util.Date</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime</p> </td> 
      <td> <p>Encapsule une date et une heure avec un fuseau horaire et son offset correspondant. La classe ZonedDateTime est la classe la plus proche de la classe GregorianCalendar</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZoneId</p> </td> 
      <td> <p>Encapsule un fuseau horaire précisé par son identifiant, par exemple «Europe/Paris»</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZoneOffset</p> </td> 
      <td> <p>Encapsule un fuseau horaire précisé par un décalage à partir du méridien de Greenwich/UTC, par exemple +01:00</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <p>Il y a plusieurs classes qui permettent de gérer une date mais seulement quelques-unes pour gérer l'heure. Par exemple, aucune classe ne propose d'encapsuler une combinaison heures-minutes ou minutes-secondes. Les heures sont toujours gérées sous la forme des quatre champs (heures, minutes, secondes, nanosecondes) pour simplifier l'API. Si un de ces champs n'est pas utile, il suffit de mettre sa valeur à zéro.</p> 
   <p>De la même façon pour rester pragmatique, le nombre de classes qui encapsulent une combinaison de champs d'une date est limité : YearMonth et MonthDay.</p> 
   <p>Les classes de l'API qui permettent d'obtenir ou de manipuler une donnée temporelle telles que Instant, LocalDateTime, LocalDate, LocalTime, ZonedDateTime, ... sont désignées par objets temporels dans les sections suivantes.</p> 
   <p>Elle propose aussi des classes utilitaires pour réaliser des opérations sur des données temporelles :</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Classe</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ChronoUnit</p> </td> 
      <td> <p>Une énumération des différentes unités temporelles. Elle permet aussi de réaliser des opérations de calcul en utilisant ces unités</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTimeFormatter</p> </td> 
      <td> <p>Analyser et formater une date/heure sous une forme textuelle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Clock</p> </td> 
      <td> <p>Obtenir la date/heure courante dans le fuseau horaire par défaut.<br>Son but est de permettre de pouvoir être remplacée par une autre implémentation notamment pour faciliter les tests unitaires</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <p>Les interfaces et les classes de l'API Date-Time sont contenues dans le package java.time et ses quatre sous-packages :</p> 
   <ul> 
    <li>java.time : contient les classes de bases, immuables qui encapsulent des données temporelles</li> 
    <li>java.time.chrono : contient les implémentations de quelques calendriers (Hijrah, Japanese, Minguo, ThaiBuddhist) et des classes et interfaces pour implémenter son propre calendrier</li> 
    <li>java.time.format : contient les classes pour analyser et formater des dates/heures</li> 
    <li>java.time.temporal : contient des interfaces et des classes pour permettre l'accès aux informations sur des données temporelles et développer de nouvelles fonctionnalités</li> 
    <li>java.time.zone : contient des classes pour le support des fuseaux horaires et leurs règles d'application incluant par exemple la prise en compte de l'heure d'été/hiver.</li> 
   </ul> 
   <p>La conception de cette API repose sur plusieurs principes :</p> 
   <ul> 
    <li>les principales classes sont immuables</li> 
    <li>assurer une bonne séparation des rôles de chaque classe : par exemple, il existe des classes pour encapsuler une date et des classes pour encapsuler une heure</li> 
    <li>permettre une extensibilité</li> 
   </ul> 
   <p>L'API Date-Time est composée de nombreuses classes et méthodes. Elle utilise de préférence une convention de nommage pour certaines méthodes ayant le même rôle dans différentes classes afin de renforcer la cohérence et faciliter son utilisation.</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Nom ou préfixe</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>format</p> </td> 
      <td> <p>Formater l'objet pour obtenir une chaîne de caractères</p> </td> 
     </tr> 
     <tr> 
      <td> <p>get</p> </td> 
      <td> <p>Obtenir la valeur d'un élément</p> </td> 
     </tr> 
     <tr> 
      <td> <p>is</p> </td> 
      <td> <p>Obtenir la valeur booléenne d'un élément</p> </td> 
     </tr> 
     <tr> 
      <td> <p>with</p> </td> 
      <td> <p>Renvoyer une copie de l'objet avec un élément modifié</p> </td> 
     </tr> 
     <tr> 
      <td> <p>plus</p> </td> 
      <td> <p>Renvoyer une copie de l'objet avec une portion de temps ajoutée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>minus</p> </td> 
      <td> <p>Renvoyer une copie de l'objet avec une portion de temps soustraite</p> </td> 
     </tr> 
     <tr> 
      <td> <p>to</p> </td> 
      <td> <p>Convertir l'objet dans un autre type</p> </td> 
     </tr> 
     <tr> 
      <td> <p>at</p> </td> 
      <td> <p>Combiner l'objet avec une autre instance</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <p>De nombreuses classes de base sont immuables : elles ne proposent donc pas de setter mais des fabriques pour faciliter la création de nouvelles instances. Le nom des fabriques utilise au mieux quelques conventions :</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Nom ou préfix</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>of</p> </td> 
      <td> <p>Créer une nouvelle instance à partir des données passées en paramètres : les valeurs sont validées mais ne sont pas converties</p> </td> 
     </tr> 
     <tr> 
      <td> <p>from</p> </td> 
      <td> <p>Créer une nouvelle instance en opérant une conversion des données fournies en paramètres</p> </td> 
     </tr> 
     <tr> 
      <td> <p>now</p> </td> 
      <td> <p>Créer une nouvelle instance en utilisant les données utiles de la date-heure courante</p> </td> 
     </tr> 
     <tr> 
      <td> <p>parse</p> </td> 
      <td> <p>Analyser la chaîne de caractères fournie en paramètre pour créer une nouvelle instance</p> </td> 
     </tr> 
    </tbody>
   </table> 
   <p>&nbsp;</p> 
   <h3 class="TITRESECTION2">
    <!--nchpdeb--><a name="utilisation_dates-6-3">102.6.3. 
     <!--nchpfin-->Les interfaces et classes de bas niveau de l'API</a></h3> 
   <p>Le package java.time.temporal contient des interfaces, des classes et des énumérations permettant d'obtenir des informations à partir de données temporelles et de réaliser des opérations basiques sur celles-ci.</p> 
   <p>Ces interfaces sont de bas niveaux : elles ne devraient pas être utilisées pour déclarer des objets dans le code d'une application. Il est préférable d'utiliser le type d'une classe concrète pour déclarer un objet temporel essentiellement car les interfaces sont indépendantes de tout calendrier.</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Interface</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>TemporalAccessor</p> </td> 
      <td> <p>Accès en lecture seule aux informations d'une donnée temporelle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Temporal</p> </td> 
      <td> <p>Opérations de base de manipulation de données temporelles</p> </td> 
     </tr> 
     <tr> 
      <td> <p>TemporalAmount</p> </td> 
      <td> <p>Une quantité temporelle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>TemporalField</p> </td> 
      <td> <p>Un champ d'une donnée temporelle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>TemporalUnit</p> </td> 
      <td> <p>Une unité temporelle</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <p>Les dates et les heures sont exprimées sous la forme de champs. Ces champs possèdent :</p> 
   <ul> 
    <li>un type</li> 
    <li>une valeur</li> 
    <li>une unité qui définit la mesure de la quantité de temps</li> 
   </ul>
   <p>Un objet temporel qui implémente l'interface TemporalAccessor encapsule ses données sous la forme de champs de type TemporalField.</p> 
   <p>L'énumération ChronoField qui implémente l'interface TemporalField définit ces différents champs.</p> 
   <p>La valeur de ces champs est exprimée dans une unité définie par l'interface TemporalUnit.</p> 
   <p>L'énumération ChronoUnit qui implémente l'interface TemporalUnit définit différentes unités couramment utilisées. Certains calendriers peuvent requérir des unités qui leur sont particulières.</p> 
   <p>Les quantités passées en paramètre des opérations arithmétiques de l'interface Temporal sont définies par l'interface TemporalAmount. Les classes Period et Duration implémentent cette interface.</p> 
   <p>Il existe différentes définitions de la notion de semaines en fonction de la Locale : par exemple en Europe elle commence le lundi, aux Etats Unis elle commence le dimanche. La classe WeekFields encapsule ces définitions en proposant des constantes pour les plus courantes d'entre-elles.</p> 
   <p>L'interface Temporal propose des opérations de base de manipulation de données temporelles telles que l'ajout ou le retrait d'une quantité temporelle.</p> 
   <p>Il est fréquent d'avoir à ajuster une date pour en obtenir une nouvelle : par exemple, le prochain lundi, le dernier jour du mois, ... Généralement, ces opérations sont plus ou moins complexes et sont définies par l'interface TemporalAdjuster.</p> 
   <p>L'interface TemporalQuery définit les fonctionnalités qui permettent d'obtenir des informations d'un objet temporel sous la forme d'une requête. <i></i></p> 
   <p><i>&nbsp;</i></p> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-6-3-1">102.6.3.1. 
     <!--nchpfin-->L'interface TemporalAccessor</a></h4> 
   <p>L'interface TemporalAccessor définit des fonctionnalités permettant un accès en lecture seule à certains éléments d'un objet temporel en accédant directement à un champ ou en exécutant une requête.</p> 
   <p>C'est l'interface de base pour les objets qui encapsulent des dates, des heures et des offsets.</p> 
   <p>La plupart des champs qui composent un objet temporel peuvent être représentés sous la forme d'un entier. Ces champs implémentent l'interface TemporalField. Deux informations d'un objet temporel ne peuvent pas être représentées sous la forme d'un entier : le calendrier et le fuseau horaire. Ces informations peuvent être accédées en utilisant une requête de type TemporalQuery.</p> 
   <p>Elle définit plusieurs méthodes :</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Méthode</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>default int get(TemporalField field)</p> </td> 
      <td> <p>Obtenir la valeur du champ précisé en paramètre sous la forme d'un entier</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long getLong(TemporalField field)</p> </td> 
      <td> <p>Obtenir la valeur du champ précisé en paramètre sous la forme d'un entier long</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isSupported(TemporalField field)</p> </td> 
      <td> <p>Vérifier si le champ fourni en paramètre est supporté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>default &lt;R&gt; R query(TemporalQuery&lt;R&gt; query)</p> </td> 
      <td> <p>Exécuter la requête passée en paramètre sur l'instance courante</p> </td> 
     </tr> 
     <tr> 
      <td> <p>default ValueRange range(TemporalField field)</p> </td> 
      <td> <p>Obtenir la plage des valeurs possibles pour le champ fourni en paramètre</p> </td> 
     </tr> 
    </tbody>
   </table> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-6-3-2">102.6.3.2. 
     <!--nchpfin-->L'interface Temporal</a></h4> 
   <p>L'interface Temporal hérite de l'interface TemporalAccessor pour définir des opérations de base de manipulations sur des objets temporels.</p> 
   <p>Elle définit plusieurs méthodes :</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Méthode</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isSupported(TemporalUnit unit)</p> </td> 
      <td> <p>Vérifier si l'unité passée en paramètre est supportée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>default Temporal minus(long amountToSubtract, TemporalUnit unit)</p> <p>default Temporal minus(TemporalAmount amount)</p> </td> 
      <td> <p>Renvoyer une instance du même type minorée de la quantité temporelle fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Temporal plus(long amountToAdd, TemporalUnit unit)</p> <p>default Temporal plus(TemporalAmount amount)</p> </td> 
      <td> <p>Renvoyer une instance du même type majorée de la quantité temporelle fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long until(Temporal endExclusive, TemporalUnit unit)</p> </td> 
      <td> <p>Calculer la quantité de temps jusqu'à l'objet temporel fourni en paramètre. La valeur retournée est exprimée dans l'unité temporelle précisée en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>default Temporal with(TemporalAdjuster adjuster)</p> </td> 
      <td> <p>Renvoyer une copie dont la valeur est ajustée grâce à l'objet qui encapsule les traitements fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Temporal with(TemporalField field, long newValue)</p> </td> 
      <td> <p>Renvoyer un objet du même type dont la valeur du champ fourni en paramètre est modifiée</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <p>Plusieurs classes de l'API implémentent l'interface Temporal : HijrahDate, Instant, JapaneseDate, LocalDate, LocalDateTime, LocalTime, MinguoDate, OffsetDateTime, OffsetTime, ThaiBuddhistDate, Year, YearMonth et ZonedDateTime.</p> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-6-3-3">102.6.3.3. 
     <!--nchpfin-->L'interface TemporalAmount</a></h4> 
   <p>L'interface TemporalAmount définit les fonctionnalités d'un objet qui encapsule une quantité temporelle telle qu'une heure et 30 minutes, trois jours, un an et un jour, ...</p> 
   <p>Une quantité temporelle n'est pas liée à un point dans le temps. Cette quantité est exprimée au moyen d'une ou plusieurs paires de valeur-unité.</p> 
   <p>Elle définit plusieurs méthodes :</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Méthode</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Temporal addTo(Temporal temporal)</p> </td> 
      <td> <p>Renvoyer une copie de l'objet temporel fourni en paramètre auquel est ajoutée la quantité encapsulée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long get(TemporalUnit unit)</p> </td> 
      <td> <p>Obtenir la valeur dans l'unité précisée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>List&lt;TemporalUnit&gt; getUnits()</p> </td> 
      <td> <p>Retourner une liste des unités temporelles utilisables pour exprimer la quantité. La collection est triée dans l'ordre décroissant de durée de l'unité (de la plus longue à la plus courte)</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Temporal subtractFrom(Temporal temporal)</p> </td> 
      <td> <p>Renvoyer une copie de l'objet temporel fourni en paramètre duquel est soustrait la quantité encapsulée</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <p>La quantité est le cumul des différentes valeurs de chacune des unités : pour chaque unité obtenue en invoquant la méthode getUnits(), cela revient à invoquer la méthode get() en lui passant l'unité en paramètre.</p> 
   <p>L'API fournit deux classes qui implémentent cette interface :</p> 
   <ul> 
    <li>Period : encapsule une période en années, mois et jours</li> 
    <li>Duration : encapsule une durée en secondes et nanosecondes</li> 
   </ul> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-6-3-4">102.6.3.4. 
     <!--nchpfin-->L'interface TemporalField</a></h4> 
   <p>L'interface TemporalField définit les fonctionnalités d'un champ d'un objet temporel dont il encapsule une représentation humaine.</p> 
   <p>Elle définit plusieurs méthodes, notamment :</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Méthode</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>&lt;R extends Temporal&gt; R adjustInto(R temporal, long newValue)</p> </td> 
      <td> <p>Renvoyer une copie de l'objet temporel fourni en paramètre dans lequel la valeur du champ encapsulé est remplacée par celle passée en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>TemporalUnit getBaseUnit()</p> </td> 
      <td> <p>Renvoyer l'unité temporelle dans laquelle la valeur du champ est exprimée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>default String getDisplayName(Locale locale)</p> </td> 
      <td> <p>Renvoyer le nom du champ dans la Locale fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long getFrom(TemporalAccessor temporal)</p> </td> 
      <td> <p>Obtenir la valeur du champ encapsulée dans l'objet temporel fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isDateBased()</p> </td> 
      <td> <p>Renvoyer un booléen qui précise si le champ entre dans la composition d'une date</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isSupportedBy(TemporalAccessor temporal)</p> </td> 
      <td> <p>Renvoyer un booléen qui précise si le champ est supporté par l'objet temporel fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isTimeBased()</p> </td> 
      <td> <p>Renvoyer un booléen qui précise si le champ entre dans la composition d'une heure</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ValueRange range()</p> </td> 
      <td> <p>Obtenir la plage des valeurs valides pour le champ</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ValueRange rangeRefinedBy(TemporalAccessor temporal)</p> </td> 
      <td> <p>Obtenir la plage des valeurs valides pour le champ dans le contexte de l'objet temporel fourni en paramètre.</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <p>Il est possible pour certains champs que les méthodes isDateBased() et isTimeBased() renvoient toutes les deux false.</p> 
   <p>L'énumération ChronoField implémente l'interface TemporalField. D'autres classes contiennent des objets de type TemporalField : IsoFields, WeekFields et JulienFields.</p> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-6-3-5">102.6.3.5. 
     <!--nchpfin-->L'énumération ChronoField</a></h4> 
   <p>L'énumération ChronoField propose des constantes de type TemporalField pour les champs standard utilisés dans la composition de dates et/ou d'heures. Ces champs peuvent être utilisés dans différents calendriers.</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Valeur</p> </td> 
      <td> <p>Description</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ALIGNED_DAY_OF_WEEK_IN_MONTH</p> </td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr> 
      <td> <p>ALIGNED_DAY_OF_WEEK_IN_YEAR</p> </td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr> 
      <td> <p>ALIGNED_WEEK_OF_MONTH</p> </td> 
      <td> <p>La semaine du mois</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ALIGNED_WEEK_OF_YEAR</p> </td> 
      <td> <p>La semaine de l'année</p> </td> 
     </tr> 
     <tr> 
      <td> <p>AMPM_OF_DAY</p> </td> 
      <td> <p>La demi-journée (0 AM, 1 PM)</p> </td> 
     </tr> 
     <tr> 
      <td> <p>CLOCK_HOUR_OF_AMPM</p> </td> 
      <td> <p>L'heure de la demi-journée (1-12)</p> </td> 
     </tr> 
     <tr> 
      <td> <p>CLOCK_HOUR_OF_DAY</p> </td> 
      <td> <p>L'heure de la journée (0-24)</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DAY_OF_MONTH</p> </td> 
      <td> <p>Le jour du mois (1-31)</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DAY_OF_WEEK</p> </td> 
      <td> <p>Le jour de la semaine (1-7)</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DAY_OF_YEAR</p> </td> 
      <td> <p>Le jour de l'année (1-366)</p> </td> 
     </tr> 
     <tr> 
      <td> <p>EPOCH_DAY</p> </td> 
      <td> <p>Le Neme jour depuis l'EPOCH (01/01/1970 dans le calendrier ISO)</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ERA</p> </td> 
      <td> <p>L'ère : dans le calendrier ISO (0 BCE, 1 CE)</p> </td> 
     </tr> 
     <tr> 
      <td> <p>HOUR_OF_AMPM</p> </td> 
      <td> <p>L'heure de la demi-journée (0-11)</p> </td> 
     </tr> 
     <tr> 
      <td> <p>HOUR_OF_DAY</p> </td> 
      <td> <p>L'heure de la journée (0-23)</p> </td> 
     </tr> 
     <tr> 
      <td> <p>INSTANT_SECONDS</p> </td> 
      <td>Représente le nombre de secondes comptées à partir du 1er janvier 1970 à 0000z</td> 
     </tr> 
     <tr> 
      <td> <p>MICRO_OF_DAY</p> </td> 
      <td> <p>La microseconde de la journée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>MICRO_OF_SECOND</p> </td> 
      <td> <p>La microseconde de la seconde</p> </td> 
     </tr> 
     <tr> 
      <td> <p>MILLI_OF_DAY</p> </td> 
      <td> <p>La milliseconde de la journée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>MILLI_OF_SECOND</p> </td> 
      <td> <p>La milliseconde de la seconde</p> </td> 
     </tr> 
     <tr> 
      <td> <p>MINUTE_OF_DAY</p> </td> 
      <td> <p>La minute de la journée (0-1440)</p> </td> 
     </tr> 
     <tr> 
      <td> <p>MINUTE_OF_HOUR</p> </td> 
      <td> <p>La minute de l'heure (0-59)</p> </td> 
     </tr> 
     <tr> 
      <td> <p>MONTH_OF_YEAR</p> </td> 
      <td> <p>Le mois de l'année</p> </td> 
     </tr> 
     <tr> 
      <td> <p>NANO_OF_DAY</p> </td> 
      <td> <p>La nanoseconde de la journée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>NANO_OF_SECOND</p> </td> 
      <td> <p>La nanoseconde de la seconde</p> </td> 
     </tr> 
     <tr> 
      <td> <p>OFFSET_SECONDS</p> </td> 
      <td> <p>Le décalage depuis le méridien de Greenwich</p> </td> 
     </tr> 
     <tr> 
      <td> <p>PROLEPTIC_MONTH</p> </td> 
      <td> <p>Le mois depuis l'année 0</p> </td> 
     </tr> 
     <tr> 
      <td> <p>SECOND_OF_DAY</p> </td> 
      <td> <p>La seconde de la journée (0-86400)</p> </td> 
     </tr> 
     <tr> 
      <td> <p>SECOND_OF_MINUTE</p> </td> 
      <td> <p>La seconde de la minute (0-59)</p> </td> 
     </tr> 
     <tr> 
      <td> <p>YEAR</p> </td> 
      <td> <p>L'année</p> </td> 
     </tr> 
     <tr> 
      <td> <p>YEAR_OF_ERA</p> </td> 
      <td> <p>L'année de l'ère</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <p>La méthode isSupported() de la classe TemporalAccessor qui attend en paramètre un objet de type TemporalField permet de déterminer si l'objet temporel supporte le champ passé en paramètre.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;
      
import java.time.LocalDate;
import java.time.temporal.ChronoField;
import java.time.temporal.IsoFields;

public class TestTemporalField {
  public static void main(String[] args) {
    LocalDate date = LocalDate .now();
    int mois = date.get(ChronoField.MONTH_OF_YEAR);
    System.out.println("Mois="+mois);
    boolean supporte = date.isSupported(ChronoField.HOUR_OF_DAY);
    System.out.println("Supporte="+supporte);    
    int trimestre = date.get(IsoFields.QUARTER_OF_YEAR);
    System.out.println("Trimestre="+trimestre);
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">Mois=2
Supporte=false
Trimestre=1</pre></td>
     </tr>
    </tbody>
   </table> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-6-3-6">102.6.3.6. 
     <!--nchpfin-->L'interface TemporalUnit</a></h4> 
   <p>L'interface TemporalUnit définit les fonctionnalités d'une unité temporelle. Une unité temporelle permet de mesurer le temps en exprimant une quantité temporelle telle qu'une heure, un jour, une année, ...</p> 
   <p>Elle définit plusieurs méthodes :</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Méthode</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>&lt;R extends Temporal&gt; R addTo(R temporal, long amount)</p> </td> 
      <td> <p>Renvoyer une copie de l'objet temporel fourni en paramètre dans lequel la quantité précisée est ajoutée. La quantité est exprimée dans l'unité encapsulée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long between(Temporal temporal1Inclusive, Temporal temporal2Exclusive)</p> </td> 
      <td> <p>Calculer la quantité de temps entre les deux objets temporels fournis en paramètres exprimée dans l'unité précisée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Duration getDuration()</p> </td> 
      <td> <p>Renvoyer une durée de l'unité qui peut être estimée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isDateBased()</p> </td> 
      <td> <p>Indiquer si l'unité peut être utilisée sur un champ composant une date</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isDurationEstimated()</p> </td> 
      <td> <p>Indiquer si la durée de l'unité est estimée. Par exemple, à cause de la gestion de l'heure d'été/hiver la durée d'une journée est estimée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>default boolean isSupportedBy(Temporal temporal)</p> </td> 
      <td> <p>Vérifier si l'unité est supportée par l'objet temporel fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isTimeBased()</p> </td> 
      <td> <p>Indiquer si l'unité peut être utilisée sur un champ composant une heure</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <p>L'énumération ChronoUnit implémente cette interface. Quelques unités sont définies dans la classe IsoFields.</p> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-6-3-7">102.6.3.7. 
     <!--nchpfin-->L 'énumération ChronoUnit</a></h4> 
   <p>L'énumération ChronoUnit propose des constantes de type TemporalUnit pour les unités temporelles standard utilisées dans la composition de dates et/ou d'heures. Ces unités pour mesurer le temps peuvent être utilisées dans différents calendriers.</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Valeur</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>CENTURIES</p> </td> 
      <td> <p>Un siècle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DAYS</p> </td> 
      <td> <p>Un jour</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DECADES</p> </td> 
      <td> <p>Une décade</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ERAS</p> </td> 
      <td> <p>Une ère</p> </td> 
     </tr> 
     <tr> 
      <td> <p>FOREVER</p> </td> 
      <td> <p>Le concept de pour toujours (sans fin)</p> </td> 
     </tr> 
     <tr> 
      <td> <p>HALF_DAYS</p> </td> 
      <td> <p>Une demi-journée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>HOURS</p> </td> 
      <td> <p>Une heure</p> </td> 
     </tr> 
     <tr> 
      <td> <p>MICROS</p> </td> 
      <td> <p>Une microseconde</p> </td> 
     </tr> 
     <tr> 
      <td> <p>MILLENNIA</p> </td> 
      <td> <p>Un millénaire</p> </td> 
     </tr> 
     <tr> 
      <td> <p>MILLIS</p> </td> 
      <td> <p>Une milliseconde</p> </td> 
     </tr> 
     <tr> 
      <td> <p>MINUTES</p> </td> 
      <td> <p>Une minute</p> </td> 
     </tr> 
     <tr> 
      <td> <p>MONTH</p> </td> 
      <td> <p>Un mois</p> </td> 
     </tr> 
     <tr> 
      <td> <p>NANOS</p> </td> 
      <td> <p>Une nanoseconde</p> </td> 
     </tr> 
     <tr> 
      <td> <p>SECONDS</p> </td> 
      <td> <p>Une seconde</p> </td> 
     </tr> 
     <tr> 
      <td> <p>WEEKS</p> </td> 
      <td> <p>Une semaine</p> </td> 
     </tr> 
     <tr> 
      <td> <p>YEARS</p> </td> 
      <td> <p>Une année</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <p>La méthode isSupported() de la classe TemporalAccessor qui attend en paramètre un objet de type TemporalUnit permet de vérifier si l'unité passée en paramètre est supportée par l'objet Temporal.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;

import java.time.LocalDate;
import java.time.LocalTime;
import java.time.temporal.ChronoUnit;

public class TestTemporalUnit {
  public static void main(String[] args) {
    LocalDate dateDebut = LocalDate.of(2014, 12, 25);
    LocalDate dateFin = LocalDate.of(2015, 12, 25);
    System.out.println("Duree="+ChronoUnit.DAYS.between(dateDebut, dateFin));
    LocalTime heure = LocalTime.now();
    boolean supporte = heure.isSupported(ChronoUnit.YEARS);
    System.out.println("Supporte="+supporte);    
    System.out.println("ToString="+ChronoUnit.DAYS.toString());
  }  
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">Duree=365
Supporte=false
ToString=Days</pre></td>
     </tr>
    </tbody>
   </table> 
   <p>&nbsp;</p> 
   <h3 class="TITRESECTION2">
    <!--nchpdeb--><a name="utilisation_dates-6-4">102.6.4. 
     <!--nchpfin-->Les classes spécifiques aux dates</a></h3> 
   <p>L'API Date-Time propose des énumérations spécifiques :</p> 
   <ul> 
    <li>DayOfWeek : les jours de la semaine</li> 
    <li>Month : les mois d'une année</li> 
   </ul> 
   <p>L'API Date-Time propose quatre classes qui encapsulent tout ou partie d'une date sans tenir compte de l'heure et du fuseau horaire :</p> 
   <ul> 
    <li>LocalDate : encapsule une année, un mois et un jour</li> 
    <li>MonthDay : encapsule un jour et un mois</li> 
    <li>Year : encapsule une année</li> 
    <li>YearMonth : encapsule un mois d'une année</li> 
   </ul> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-6-4-1">102.6.4.1. 
     <!--nchpfin-->L'énumération DayOfWeek</a></h4> 
   <p>L'énumération java.time.DayOfWeek définit des constantes pour les 7 jours de la semaine tels que définit dans le calendrier ISO-8601 : FRIDAY, MONDAY, SATURDAY, SUNDAY, THURSDAY, TUESDAY et WEDNESDAY.</p> 
   <p>Chaque élément de l'énumération est associé à une valeur numérique tel que définie dans le calendrier ISO-8601 : 1 pour MONDAY à 7 pour SUNDAY.</p> 
   <p>Il est recommandé d'utiliser les éléments de l'énumération plutôt que leur valeur numérique.</p> 
   <p>Elle propose aussi plusieurs méthodes :</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Méthode</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Temporal adjustInto(Temporal temporal)</p> </td> 
      <td> <p>Renvoyer une copie de l'objet temporel fourni en paramètre dans laquelle le jour est remplacé par celui encapsulé</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static DayOfWeek from(TemporalAccessor temporal)</p> </td> 
      <td> <p>Obtenir une instance à partir des données encapsulées dans l'objet fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int get(TemporalField field)</p> </td> 
      <td> <p>Obtenir la valeur du champ fourni en paramètre sous la forme d'un entier</p> </td> 
     </tr> 
     <tr> 
      <td> <p>String getDisplayName(TextStyle style, Locale locale)</p> </td> 
      <td> <p>Renvoyer une représentation textuelle selon le format et la Locale fournis en paramètres</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long getLong(TemporalField field)</p> </td> 
      <td> <p>Obtenir la valeur du champ fourni en paramètre sous la forme d'un entier long</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getValue()</p> </td> 
      <td> <p>Renvoyer la valeur numérique associée au jour de la semaine</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isSupported(TemporalField field)</p> </td> 
      <td> <p>Vérifier si le champ fourni en paramètre est supporté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DayOfWeek minus(long days)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dont le nombre de jours est minoré de la valeur fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static DayOfWeek of(int dayOfWeek)</p> </td> 
      <td> <p>Renvoyer le jour de la semaine associé à la valeur fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DayOfWeek plus(long days)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dont le nombre de jours fourni en paramètre est ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>&lt;R&gt; R query(TemporalQuery&lt;R&gt; query)</p> </td> 
      <td> <p>Exécuter la requête passée en paramètre sur l'instance courante</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ValueRange range(TemporalField field)</p> </td> 
      <td> <p>Obtenir la plage des valeurs valides pour le champ fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static DayOfWeek valueOf(String name)</p> </td> 
      <td> <p>Renvoyer l'élément de l'énumération dont le nom est fourni paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static DayOfWeek[] values()</p> </td> 
      <td> <p>Renvoyer un tableau des éléments de l'énumération dans leur ordre de déclaration</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;
      
import java.time.DayOfWeek;

public class TestDayOfWeek {
    
  public static void main(String[] args) {
    DayOfWeek dow = DayOfWeek.MONDAY;
    System.out.println(dow.getValue());
    System.out.println(dow.plus(4));
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">1
FRIDAY</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>La méthode getDisplayName() permet d'obtenir le nom du jour dans le format et la Locale précisés.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;

import java.time.DayOfWeek;
import java.time.format.TextStyle;
import java.util.Locale;

public class TestDayOfWeek {
    
  public static void main(String[] args) {
    DayOfWeek dow = DayOfWeek.MONDAY;
    Locale locale = Locale.getDefault();
    System.out.println(dow.getDisplayName(TextStyle.FULL, locale));
    System.out.println(dow.getDisplayName(TextStyle.SHORT, locale));
    System.out.println(dow.getDisplayName(TextStyle.NARROW, locale));
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">lundi
lun.
L</pre></td>
     </tr>
    </tbody>
   </table> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-6-4-2">102.6.4.2. 
     <!--nchpfin-->L'énumération Month</a></h4> 
   <p>L'énumération java.time.Month définit des constantes pour les 12 mois de l'année telles que définies dans le calendrier ISO-8601 : JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER et DECEMBER.</p> 
   <p>Chaque élément de l'énumération est associé à une valeur numérique. Il est recommandé d'utiliser les éléments de l'énumération plutôt que leur valeur numérique.</p> 
   <p>Elle propose aussi plusieurs méthodes :</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Méthode</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Temporal adjustInto(Temporal temporal)</p> </td> 
      <td> <p>Renvoyer une copie de l'objet temporel fourni en paramètre dont le mois est ajusté avec celui encapsulé</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int firstDayOfYear(boolean leapYear)</p> </td> 
      <td> <p>Renvoyer le jour de l'année correspondant au premier jour du mois. Le paramètre booléen permet de préciser si cela concerne une année bissextile</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Month firstMonthOfQuarter()</p> </td> 
      <td> <p>Obtenir le premier mois du trimestre auquel appartient le mois encapsulé</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Month from(TemporalAccessor temporal)</p> </td> 
      <td> <p>Renvoyer une instance de type Month qui correspond au mois encapsulé dans l'objet fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int get(TemporalField field)</p> </td> 
      <td> <p>Obtenir la valeur du champ fourni en paramètre sous la forme d'un entier</p> </td> 
     </tr> 
     <tr> 
      <td> <p>String getDisplayName(TextStyle style, Locale locale)</p> </td> 
      <td> <p>Obtenir une représentation textuelle selon le style et la Locale fournis en paramètres</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long getLong(TemporalField field)</p> </td> 
      <td> <p>Obtenir la valeur du champ fourni en paramètre sous la forme d'un entier long</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getValue()</p> </td> 
      <td> <p>Renvoyer la valeur numérique associée au mois</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isSupported(TemporalField field)</p> </td> 
      <td> <p>Vérifier si le champ fourni en paramètre est supporté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int length(boolean leapYear)</p> </td> 
      <td> <p>Renvoyer le nombre de jours du mois. Le paramètre booléen permet de préciser si cette valeur est celle d'une année bissextile</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int maxLength()</p> </td> 
      <td> <p>Renvoyer le nombre maximum de jours du mois</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int minLength()</p> </td> 
      <td> <p>Renvoyer le nombre minimum de jours du mois</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Month minus(long months)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance minorée du nombre de mois fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Month of(int month)</p> </td> 
      <td> <p>Renvoyer l'instance de type Month associée à la valeur numérique fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Month plus(long months)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance majorée du nombre de mois fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>&lt;R&gt; R query(TemporalQuery&lt;R&gt; query)</p> </td> 
      <td> <p>Exécuter la requête passée en paramètre sur l'instance courante</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ValueRange range(TemporalField field)</p> </td> 
      <td> <p>Obtenir la plage des valeurs valides pour le champ fourni en paramètre. Seul MONTH_OF_YEAR renvoie une valeur comprise entre 1 et 12. Les autres champs renvoient une exception de type UnsupportedTemporalTypeException</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Month valueOf(String name)</p> </td> 
      <td> <p>Renvoyer la constante associée au nom fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Month[] values()</p> </td> 
      <td> <p>Renvoyer un tableau des constantes dans l'ordre dans lequel elles sont déclarées</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <p>Il ne faut pas utiliser la méthode ordinal() pour obtenir la valeur numérique mais utiliser la méthode getValue().</p> 
   <p>La méthode getDisplayName() permet d'obtenir le libellé en différente taille pour la Locale fournie en paramètre. La taille est fournie en paramètre grâce à un objet de type java.time.format.TextStyle qui est une énumération (FULL, FULL_STANDALONE, NARROW, NARROW_STANDALONE, SHORT, SHORT_STANDALONE).</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;

import java.time.Month;
import java.time.format.TextStyle;
import java.util.Locale;

public class TestMonth {
  public static void main(String[] args) {
    Month month = Month.NOVEMBER;
    Locale locale = Locale.getDefault();
    System.out.println(month.getDisplayName(TextStyle.FULL, locale));
    System.out.println(month.getDisplayName(TextStyle.SHORT, locale));
    System.out.println(month.getDisplayName(TextStyle.NARROW, locale));
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">novembre
N
nov.</pre></td>
     </tr>
    </tbody>
   </table> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-6-4-3">102.6.4.3. 
     <!--nchpfin-->La classe YearMonth</a></h4> 
   <p>La classe YearMonth encapsule un mois d'une année donnée, par exemple octobre 2014. Elle permet d'encapsuler une date partielle pour laquelle le jour n'est pas important. Par exemple, un cas d'utilisation est la date d'expiration d'une carte de crédit. Cette classe est immuable et thread-safe.</p> 
   <p>Elle possède plusieurs méthodes :</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Méthode</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Temporal adjustInto(Temporal temporal)</p> </td> 
      <td> <p>Renvoyer une copie de l'objet temporel fourni en paramètre dont le mois et l'année sont ajustés avec ceux encapsulés</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDate atDay(int dayOfMonth)</p> </td> 
      <td> <p>Combiner les données de l'instance avec le jour du mois fourni en paramètre pour créer une instance de type LocalDate.</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDate atEndOfMonth()</p> </td> 
      <td> <p>Renvoyer une instance de type LocalDate qui encapsule la date du dernier jour du mois</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int compareTo(YearMonth other)</p> </td> 
      <td> <p>Comparer l'instance avec celle fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean equals(Object obj)</p> </td> 
      <td> <p>Tester l'égalité de l'instance avec l'objet fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>String format(DateTimeFormatter formatter)</p> </td> 
      <td> <p>Formater l'instance en utilisant le Formatter fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static YearMonth from(TemporalAccessor temporal)</p> </td> 
      <td> <p>Obtenir une instance de type YearMonth à partir des champs encapsulés dans l'objet fourni en paramètre.</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int get(TemporalField field)</p> </td> 
      <td> <p>Obtenir la valeur du champ demandé en paramètre sous la forme d'un entier</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long getLong(TemporalField field)</p> </td> 
      <td> <p>Obtenir la valeur du champ demandé en paramètre sous la forme d'un entier long</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Month getMonth()</p> </td> 
      <td> <p>Renvoyer le mois encapsulé sous la forme d'une instance de type Month</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getMonthValue()</p> </td> 
      <td> <p>Obtenir le mois de l'année sous la forme d'un entier compris entre 1 et 12</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getYear()</p> </td> 
      <td> <p>Renvoyer l'année encapsulée dans l'instance</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isAfter(YearMonth other)</p> </td> 
      <td> <p>Comparer si l'instance est postérieure à celle fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isBefore(YearMonth other)</p> </td> 
      <td> <p>Comparer si l'instance est antérieure à celle fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isLeapYear()</p> </td> 
      <td> <p>Indiquer si l'année encapsulée est bissextile</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isSupported(TemporalField field)</p> </td> 
      <td> <p>Préciser si le champ fourni en paramètre est supporté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isSupported(TemporalUnit unit)</p> </td> 
      <td> <p>Préciser si l'unité de temps fournie en paramètre est supportée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isValidDay(int dayOfMonth)</p> </td> 
      <td> <p>Vérifier si le jour du mois fourni en paramètre est valide pour cette instance</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int lengthOfMonth()</p> </td> 
      <td> <p>Renvoyer le nombre de jours du mois encapsulé</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int lengthOfYear()</p> </td> 
      <td> <p>Renvoyer le nombre de jours de l'année encapsulée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>YearMonth minus(long amountToSubtract, TemporalUnit unit)YearMonth minus(TemporalAmount amountToSubtract)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance pour laquelle la valeur temporelle fournie en paramètre est soustraite</p> </td> 
     </tr> 
     <tr> 
      <td> <p>YearMonth minusMonths(long monthsToSubtract)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance pour laquelle le nombre de mois fourni en paramètre est soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>YearMonth minusYears(long yearsToSubtract)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance pour laquelle le nombre d'années fourni en paramètre est soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static YearMonth now()</p> </td> 
      <td> <p>Obtenir une instance encapsulant le mois et l'année de l'horloge système dans le fuseau horaire par défaut</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static YearMonth now(Clock clock)</p> </td> 
      <td> <p>Obtenir une instance encapsulant le mois et l'année de l'horloge fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static YearMonth now(ZoneId zone)</p> </td> 
      <td> <p>Obtenir une instance encapsulant le mois et l'année de l'horloge système dans le fuseau horaire fourni par défaut</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static YearMonth of(int year, int month)</p> <p>static YearMonth of(int year, Month month)</p> </td> 
      <td> <p>Obtenir une instance encapsulant le mois et l'année fournis en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static YearMonth parse(CharSequence text)</p> </td> 
      <td> <p>Obtenir une instance à partir de l'analyse utilisant le DateTimeFormatter par défaut de la représentation textuelle fournie en paramètre (exemple : 2014-12)</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static YearMonth parse(CharSequence text, DateTimeFormatter formatter)</p> </td> 
      <td> <p>Obtenir une instance à partir de l'analyse utilisant le DateTimeFormatter et la représentation textuelle fournis en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>YearMonth plus(long amountToAdd, TemporalUnit unit)</p> <p>YearMonth plus(TemporalAmount amountToAdd)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance à laquelle la valeur temporelle fournie en paramètre est ajoutée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>YearMonth plusMonths(long monthsToAdd)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance à laquelle le nombre de mois fourni en paramètre est ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>YearMonth plusYears(long yearsToAdd)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance à laquelle le nombre d'années fourni en paramètre est ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>&lt;R&gt; R query(TemporalQuery&lt;R&gt; query)</p> </td> 
      <td> <p>Exécuter la requête passée en paramètre sur l'instance courante</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ValueRange range(TemporalField field)</p> </td> 
      <td> <p>Obtenir la plage de valeurs valides pour le champ fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>String toString()</p> </td> 
      <td> <p>Obtenir une représentation textuelle de l'instance (exemple : 2014-12)</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long until(Temporal endExclusive, TemporalUnit unit)</p> </td> 
      <td> <p>Calculer la quantité de temps entre l'instance et l'objet temporel fourni en paramètre. Le résultat est obtenu dans l'unité précisé en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>YearMonth with(TemporalAdjuster adjuster)</p> </td> 
      <td> <p>Renvoyer une copie dont la valeur est ajustée grâce à l'objet fourni en paramètre qui encapsule les traitements</p> </td> 
     </tr> 
     <tr> 
      <td> <p>YearMonth with(TemporalField field, long newValue)</p> </td> 
      <td> <p>Obtenir une instance dans laquelle la valeur du champ fournie en paramètre est remplacée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>YearMonth withMonth(int month)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance encapsulant le mois précisé</p> </td> 
     </tr> 
     <tr> 
      <td> <p>YearMonth withYear(int year)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance encapsulant l'année précisée</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;

import java.time.Month;
import java.time.YearMonth;

public class TestYearMonth {
  public static void main(String[] args) {
    YearMonth yearMonth = YearMonth.of(2012, Month.FEBRUARY);
    System.out.println(yearMonth+" : " + yearMonth.lengthOfMonth()+" jours");
    yearMonth = YearMonth.of(2014, Month.FEBRUARY);
    System.out.println(yearMonth+" : " + yearMonth.lengthOfMonth()+" jours");
    yearMonth = YearMonth.parse("2014-12");
    yearMonth = yearMonth.plusYears(2);
    System.out.println(yearMonth);
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">2012-02 : 29 jours
2014-02 : 28 jours
2016-12</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Il ne faut pas utiliser d'opérations sur une instance de type YearMonth requérant l'identité de l'objet : opérateur ==, hashCode ou synchronisation. La comparaison de deux instances doit se faire en utilisant la méthode equals().</p> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-6-4-4">102.6.4.4. 
     <!--nchpfin-->La classe MonthDay</a></h4> 
   <p>La classe MonthDay encapsule de manière immuable un mois et un jour dans ce mois comme par exemple le jour de l'an, le premier janvier ou un anniversaire. Cette classe est immuable et thread-safe.</p> 
   <p>Elle possède plusieurs méthodes :</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Méthode</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Temporal adjustInto(Temporal temporal)</p> </td> 
      <td> <p>Renvoyer une copie de l'objet temporel fourni en paramètre dans laquelle les champs jour et mois sont remplacés par ceux encapsulés</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDate atYear(int year)</p> </td> 
      <td> <p>Combiner le jour et le mois encapsulé avec l'année fournie en paramètre pour obtenir une instance de type LocalDate</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int compareTo(MonthDay other)</p> </td> 
      <td> <p>Comparer l'instance avec celle fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean equals(Object obj)</p> </td> 
      <td> <p>Tester l'égalité de l'instance avec celle fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>String format(DateTimeFormatter formatter)</p> </td> 
      <td> <p>Formater l'instance en utilisant le Formatter fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static MonthDay from(TemporalAccessor temporal)</p> </td> 
      <td> <p>Obtenir une instance de type MonthDay à partir des champs encapsulés dans l'objet fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int get(TemporalField field)</p> </td> 
      <td> <p>Obtenir la valeur du champ fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getDayOfMonth()</p> </td> 
      <td> <p>Obtenir la valeur du champ day-of-month encapsulé</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long getLong(TemporalField field)</p> </td> 
      <td> <p>Obtenir la valeur du champ fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Month getMonth()</p> </td> 
      <td> <p>Obtenir le mois encapsulé correspondant au champ month-of-year sous la forme d'un objet de type Month</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getMonthValue()</p> </td> 
      <td> <p>Obtenir le mois encapsulé correspondant au champ month-of-year sous la forme d'un entier de 1 à 12</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isAfter(MonthDay other)</p> </td> 
      <td> <p>Comparer si l'instance est postérieure à celle fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isBefore(MonthDay other)</p> </td> 
      <td> <p>Comparer si l'instance est antérieure à celle fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isSupported(TemporalField field)</p> </td> 
      <td> <p>Vérifier si le champ fourni en paramètre est supporté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isValidYear(int year)</p> </td> 
      <td> <p>Vérifier si le jour et le mois encapsulés sont valides pour l'année fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static MonthDay now()</p> </td> 
      <td> <p>Obtenir une instance de type MonthDay à partir de la date courante du système dans le fuseau horaire par défaut</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static MonthDay now(Clock clock)</p> </td> 
      <td> <p>Obtenir une instance de type MonthDay à partir de l'instance de type Clock fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static MonthDay now(ZoneId zone)</p> </td> 
      <td> <p>Obtenir une instance de type MonthDay à partir de la date courante du système dans le fuseau horaire fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static MonthDay of(int month, int dayOfMonth)</p> </td> 
      <td> <p>Obtenir une instance de type MonthDay encapsulant le jour et le mois fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static MonthDay of(Month month, int dayOfMonth)</p> </td> 
      <td> <p>Obtenir une instance de type MonthDay encapsulant le jour et le mois fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static MonthDay parse(CharSequence text)</p> </td> 
      <td> <p>Obtenir une instance à partir de l'analyse utilisant le DateTimeFormatter par défaut de la représentation textuelle fournie en paramètre (par exemple --02-29)</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static MonthDay parse(CharSequence text, DateTimeFormatter formatter)</p> </td> 
      <td> <p>Obtenir une instance de type MonthDay encapsulant le jour et le mois extraits du texte en utilisant le Formatter fournis en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>&lt;R&gt; R query(TemporalQuery&lt;R&gt; query)</p> </td> 
      <td> <p>Exécuter la requête passée en paramètre sur l'instance courante</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ValueRange range(TemporalField field)</p> </td> 
      <td> <p>Obtenir la plage des valeurs valides pour le champ fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>String toString()</p> </td> 
      <td> <p>Obtenir une représentation textuelle de l'instance en utilisant le DateTimeFormatter par défaut (par exemple --02-29)</p> </td> 
     </tr> 
     <tr> 
      <td> <p>MonthDay with(Month month)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dont le mois encapsulé est celui fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>MonthDay withDayOfMonth(int dayOfMonth)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dont le jour encapsulé est celui fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>MonthDay withMonth(int month)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dont le mois encapsulé est celui fourni en paramètre</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <p>La méthode isValidYear() permet de vérifier si le jour du mois encapsulé est valide pour l'année fournie en paramètre. Attention, elle n'encapsule pas l'année : elle ne peut donc pas déterminer si l'année est bissextile et considère donc toujours comme valide le 29 février.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;

import java.time.Month;
import java.time.MonthDay;

public class TestMonthDay {
  public static void main(String[] args) {
    MonthDay date = MonthDay.of(Month.FEBRUARY, 29);
    System.out.println(date.isValidYear(2014));
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">false</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Elle implémente l'interface TemporalAccessor mais elle ne permet que l'accès aux champs MONTH_OF_YEAR et DAY_OF_MONTH.</p> 
   <p>Il ne faut pas utiliser d'opérations sur une instance de type YearMonth requérant l'identité de l'objet : opérateur ==, hashCode ou synchronisation. La comparaison de deux instances doit se faire en utilisant la méthode equals().</p> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-6-4-5">102.6.4.5. 
     <!--nchpfin-->La classe Year</a></h4> 
   <p>La classe Year encapsule de manière immuable une année du calendrier ISO-8601.</p> 
   <p>Elle possède plusieurs méthodes :</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Méthode</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Temporal adjustInto(Temporal temporal)</p> </td> 
      <td> <p>Renvoyer une copie de l'objet temporel fourni en paramètre dans laquelle le champ année est remplacé par celui encapsulé</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDate atDay(int dayOfYear)</p> </td> 
      <td> <p>Combiner le jour de l'année fourni en paramètre avec l'année encapsulée pour obtenir une instance de type LocalDate</p> </td> 
     </tr> 
     <tr> 
      <td> <p>YearMonth atMonth(int month)</p> </td> 
      <td> <p>Combiner le mois fourni en paramètre avec l'année encapsulée pour obtenir une instance de type YearMonth</p> </td> 
     </tr> 
     <tr> 
      <td> <p>YearMonth atMonth(Month month)</p> </td> 
      <td> <p>Combiner le mois fourni en paramètre avec l'année encapsulée pour obtenir une instance de type YearMonth</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDate atMonthDay(MonthDay monthDay)</p> </td> 
      <td> <p>Combiner le jour et le mois fournis en paramètre avec l'année encapsulée pour obtenir une instance de type LocalDate</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int compareTo(Year other)</p> </td> 
      <td> <p>Comparer l'instance avec l'année fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean equals(Object obj)</p> </td> 
      <td> <p>Vérifier l'égalité avec l'instance fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>String format(DateTimeFormatter formatter)</p> </td> 
      <td> <p>Obtenir une représentation textuelle en utilisant le Formatter fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Year from(TemporalAccessor temporal)</p> </td> 
      <td> <p>Obtenir une instance à partir de l'objet fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int get(TemporalField field)</p> </td> 
      <td> <p>Obtenir la valeur du champ fourni en paramètre sous la forme d'un entier</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long getLong(TemporalField field)</p> </td> 
      <td> <p>Obtenir la valeur du champ fourni en paramètre sous la forme d'un entier long</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getValue()</p> </td> 
      <td> <p>Obtenir la valeur de l'année encapsulée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isAfter(Year other)</p> </td> 
      <td> <p>Vérifier si l'année encapsulée est postérieure à celle fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isBefore(Year other)</p> </td> 
      <td> <p>Vérifier si l'année encapsulée est antérieure à celle fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isLeap()</p> </td> 
      <td> <p>Vérifier si l'année encapsulée est bissextile selon le calendrier ISO</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static boolean isLeap(long year)</p> </td> 
      <td> <p>Vérifier si l'année est bissextile selon le calendrier ISO</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isSupported(TemporalField field)</p> </td> 
      <td> <p>Vérifier si le champ fourni en paramètre est supporté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isSupported(TemporalUnit unit)</p> </td> 
      <td> <p>Vérifier si l'unité de temps est supportée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isValidMonthDay(MonthDay monthDay)</p> </td> 
      <td> <p>Vérifier si le jour et le mois encapsulés dans le MonthDay fourni en paramètre est valide</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int length()</p> </td> 
      <td> <p>Obtenir le nombre de jours de l'année encapsulée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Year minus(long amountToSubtract, TemporalUnit unit)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance pour laquelle la quantité de temps fournie en paramètre a été soustraite</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Year minus(TemporalAmount amountToSubtract)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance pour laquelle le nombre d'années fourni en paramètre a été soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Year minusYears(long yearsToSubtract)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance pour laquelle le nombre d'années fourni en paramètre a été soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Year now()</p> </td> 
      <td> <p>Obtenir une instance de type Year encapsulant l'année de la date courante en utilisant le fuseau horaire par défaut</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Year now(Clock clock)</p> </td> 
      <td> <p>Obtenir une instance de type Year encapsulant l'année obtenue de l'instance de type Clock passée en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Year now(ZoneId zone)</p> </td> 
      <td> <p>Obtenir une instance de type Year encapsulant l'année de la date courante en utilisant le fuseau horaire passé en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Year of(int isoYear)</p> </td> 
      <td> <p>Obtenir une instance de type Year encapsulant l'année passée en paramètre.</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Year parse(CharSequence text)</p> </td> 
      <td> <p>Obtenir une instance de type Year encapsulant l'année passée en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Year parse(CharSequence text, DateTimeFormatter formatter)</p> </td> 
      <td> <p>Obtenir une instance de type Year encapsulant l'année extraite du texte en utilisant le Formatter fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Year plus(long amountToAdd, TemporalUnit unit)<br>Year plus(TemporalAmount amountToAdd)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance encapsulant une année à laquelle la valeur passée en paramètre a été ajoutée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Year plus(TemporalAmount amountToAdd)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance encapsulant une année à laquelle la valeur passée en paramètre a été ajoutée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Year plusYears(long yearsToAdd)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance à laquelle le nombre d'années fourni en paramètre est ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>&lt;R&gt; R query(TemporalQuery&lt;R&gt; query)</p> </td> 
      <td> <p>Exécuter la requête passée en paramètre sur l'instance courante</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ValueRange range(TemporalField field)</p> </td> 
      <td> <p>Obtenir la plage des valeurs valides pour le champ fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>String toString()</p> </td> 
      <td> <p>Obtenir une représentation textuelle qui utilise le Formatter par défaut</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long until(Temporal endExclusive, TemporalUnit unit)</p> </td> 
      <td> <p>Calculer la quantité de temps entre l'instance et l'objet temporel fourni en paramètre. Le résultat est obtenu dans l'unité précisée en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Year with(TemporalAdjuster adjuster)</p> </td> 
      <td> <p>Renvoyer une copie dont la valeur est ajustée grâce à l'objet qui encapsule les traitements fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Year with(TemporalField field, long newValue)</p> </td> 
      <td> <p>Obtenir une instance dans laquelle la valeur du champ fourni en paramètre est remplacée</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;

import java.time.Year;

public class TestYear {
  public static void main(String[] args) {
    boolean estBissextile = Year.of(2016).isLeap();  
    System.out.println(estBissextile);
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Elle implémente l'interface TemporalAccessor mais elle ne permet que l'accès aux champs YEAR_OF_ERA, YEAR et ERA.</p> 
   <p>Il ne faut pas utiliser d'opérations sur une instance de type Year requérant l'identité de l'objet : opérateur ==, hashCode ou synchronisation. La comparaison de deux instances doit se faire en utilisant la méthode equals().</p> 
   <p>&nbsp;</p> 
   <h3 class="TITRESECTION2">
    <!--nchpdeb--><a name="utilisation_dates-6-5">102.6.5. 
     <!--nchpfin-->La gestion du temps machine</a></h3> 
   <p>Le temps machine représente une quantité de temps depuis un point d'origine : l'API Date-Time le gère sous la forme d'un entier long représentant le nombre de millisecondes écoulées depuis le 1er janvier 1970 à 00:00:00 désigné par le terme epoch.</p> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-6-5-1">102.6.5.1. 
     <!--nchpfin-->La classe Instant</a></h4> 
   <p>La classe java.time.Instant est une des principales classes de l'API Date-Time : elle encapsule un point sur la ligne du temps.</p> 
   <p>La classe Instant définit plusieurs constantes :</p> 
   <ul> 
    <li>MIN : représente l'instant minimum (dans le passé) qui peut être encapsulé</li> 
    <li>MAX : représente l'instant maximum (dans le futur) qui peut être encapsulé</li> 
   </ul> 
   <p>Elle possède de nombreuses méthodes pour obtenir une instance ou réaliser des opérations dessus :</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Méthode</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Temporal adjustInto(Temporal temporal)</p> </td> 
      <td> <p>Renvoyer une copie du même type de l'objet temporel fourni en paramètre encapsulant une représentation de l'instance courante</p> </td> 
     </tr> 
     <tr> 
      <td> <p>OffsetDateTime atOffset(ZoneOffset offset)</p> </td> 
      <td> <p>Obtenir une instance de type OffsetDateTime qui combine l'instance courante et l'objet fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime atZone(ZoneId zone)</p> </td> 
      <td> <p>Obtenir une instance de type ZonedDateTime qui combine l'instance courante et l'objet fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int compareTo(Instant otherInstant)</p> </td> 
      <td> <p>Comparer l'instance courante avec celle fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean equals(Object otherInstant)</p> </td> 
      <td> <p>Vérifier l'égalité de l'instance courante avec celle fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Instant from(TemporalAccessor temporal)</p> </td> 
      <td> <p>Obtenir une instance à partir des données de l'objet fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int get(TemporalField field)</p> </td> 
      <td> <p>Obtenir la valeur du champ fourni en paramètre sous la forme d'un entier</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long getEpochSecond()</p> </td> 
      <td> <p>Obtenir le nombre de secondes écoulées depuis l'EPOCH</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long getLong(TemporalField field)</p> </td> 
      <td> <p>Obtenir la valeur du champ fourni en paramètre sous la forme d'un entier long</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getNano()</p> </td> 
      <td> <p>Obtenir le nombre de nanosecondes écoulées depuis le début de la seconde</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isAfter(Instant otherInstant)</p> </td> 
      <td> <p>Vérifier si l'instance courante est après l'Instant fourni en paramètre dans la ligne du temps</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isBefore(Instant otherInstant)</p> </td> 
      <td> <p>Vérifier si l'instance courante est avant l'Instant fourni en paramètre dans la ligne du temps</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isSupported(TemporalField field)</p> </td> 
      <td> <p>Vérifier si le champ précisé en paramètre est supporté par l'objet</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isSupported(TemporalUnit unit)</p> </td> 
      <td> <p>Vérifier si l'unité temporelle précisée en paramètre est supportée par l'objet</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Instant minus(long amountToSubtract, TemporalUnit unit)</p> <p>Instant minus(TemporalAmount amountToSubtract)</p> </td> 
      <td> <p>Obtenir une copie de l'instance minorée de la quantité temporelle fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Instant minusMillis(long millisToSubtract)</p> </td> 
      <td> <p>Obtenir une copie de l'instance minorée du nombre de millisecondes fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Instant minusNanos(long nanosToSubtract)</p> </td> 
      <td> <p>Obtenir une copie de l'instance minorée du nombre de nanosecondes fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Instant minusSeconds(long secondsToSubtract)</p> </td> 
      <td> <p>Obtenir une copie de l'instance minorée du nombre de secondes fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Instant now()</p> </td> 
      <td> <p>Obtenir une instance qui encapsule le moment présent de l'horloge système</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Instant now(Clock clock)</p> </td> 
      <td> <p>Obtenir une instance qui encapsule le moment présent de l'horloge fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Instant ofEpochMilli(long epochMilli)</p> </td> 
      <td> <p>Obtenir une instance qui encapsule le moment correspondant au nombre de millisecondes depuis l'EPOCH</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Instant ofEpochSecond(long epochSecond)</p> </td> 
      <td> <p>Obtenir une instance qui encapsule le moment correspondant au nombre de secondes depuis l'EPOCH</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Instant parse(CharSequence text)</p> </td> 
      <td> <p>Analyser, avec le DateTimeFormatter par défaut, la chaîne de caractères fournie en paramètre pour créer une instance (Exemple : 2014-12-25T23:59:59Z)</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Instant plus(long amountToAdd, TemporalUnit unit)</p> <p>Instant plus(TemporalAmount amountToAdd)</p> </td> 
      <td> <p>Obtenir une copie de l'instance majorée de la quantité temporelle fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Instant plusMillis(long millisToAdd)</p> </td> 
      <td> <p>Obtenir une copie de l'instance majorée du nombre de millisecondes fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Instant plusNanos(long nanosToAdd)</p> </td> 
      <td> <p>Obtenir une copie de l'instance majorée du nombre de nanosecondes fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Instant plusSeconds(long secondsToAdd)</p> </td> 
      <td> <p>Obtenir une copie de l'instance majorée du nombre de secondes fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>&lt;R&gt; R query(TemporalQuery&lt;R&gt; query)</p> </td> 
      <td> <p>Exécuter la requête passée en paramètre sur l'instance courante</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ValueRange range(TemporalField field)</p> </td> 
      <td> <p>Obtenir la plage de valeurs valides pour le champ précisé en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long toEpochMilli()</p> </td> 
      <td> <p>Obtenir le nombre de millisecondes écoulées entre l'instant encapsulé et l'EPOCH</p> </td> 
     </tr> 
     <tr> 
      <td> <p>String toString()</p> </td> 
      <td> <p>Obtenir une représentation textuelle au format ISO-8601 de l'instance</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Instant truncatedTo(TemporalUnit unit)</p> </td> 
      <td> <p>Obtenir une copie de l'instance tronquée à l'unité fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long until(Temporal endExclusive, TemporalUnit unit)</p> </td> 
      <td> <p>Calculer la quantité de temps entre l'instance et l'objet temporel fourni en paramètre. Le résultat est obtenu dans l'unité précisée en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Instant with(TemporalAdjuster adjuster)</p> </td> 
      <td> <p>Renvoyer une copie dont la valeur est ajustée grâce à l'objet qui encapsule les traitements fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Instant with(TemporalField field, long newValue)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dont la valeur du champ précisé est remplacée par la valeur fournie</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <p>La classe Instant encapsule le nombre de secondes écoulées depuis le 1er janvier 1970 (1970-01-01T00:00:00Z) désigné par la constante EPOCH sous la forme d'un entier long avec une précision à la nanoseconde sous la forme d'un second entier de type int. Si l'instant encapsulé est antérieure à l'EPOCH alors la valeur est négative sinon elle est positive.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;
      
import java.time.Instant;

public class TestInstant {
  public static void main(String[] args) {
    System.out.println(Instant.EPOCH);
    Instant instant = Instant.now();  
    System.out.println(instant);
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">1970-01-01T00:00:00Z
2014-12-14T14:21:38.031Z</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>La classe Instant permet de gérer un temps machine mais ne permet pas de gérer un temps humain. Dans ce cas, il faut convertir l'Instant en une classe qui encapsule le temps de manière humaine : LocalDateTime ou ZonedDateTime par exemple.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;

import java.time.Instant;
import java.time.LocalDateTime;

public class TestInstant {
  public static void main(String[] args) {
    Instant instant = Instant.now();  
    LocalDateTime localDateTime = LocalDateTime.ofInstant(instant, 
      ZoneId.systemDefault());
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Un objet de type ZonedDateTime ou OffsetTimeZone peut être converti en une instance de type Instant mais pas l'inverse sans préciser respectivement le fuseau ou le décalage horaire.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;

import java.time.Instant;
import java.time.ZonedDateTime;

public class TestInstant {
  public static void main(String[] args) {
      
    ZonedDateTime zonedDateTime = ZonedDateTime.now();
    System.out.println(zonedDateTime);
    Instant instant1 = zonedDateTime.toInstant();
    System.out.println(instant1);
    Instant instant2 = Instant.from(zonedDateTime);
    System.out.println(instant2);
  }
}</pre></td>
     </tr>
    </tbody>
   </table> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-6-5-2">102.6.5.2. 
     <!--nchpfin-->La classe Duration</a></h4> 
   <p>La classe java.time.Duration encapsule une durée (la distance entre deux points dans le temps) sous la forme d'une quantité temporelle. Elle encapsule une durée temporelle stockée en interne sous la forme de valeurs exprimées en secondes et nanosecondes. Elle est donc utile lors de l'utilisation de temps machine.</p> 
   <p>Remarque : la classe Period permet aussi d'encapsuler une durée mais exprimée de façon humaine sous la forme de différentes valeurs temporelles (année, mois, jours).</p> 
   <p>Attention : le JDK contient deux classes Duration respectivement dans les packages javax.xml.datatype et java.time. JavaFx possède aussi une classe Duration dans le package javafx.util.</p> 
   <p>La valeur encapsulée peut être négative si l'instant de début est plus récent que l'instant de fin.</p> 
   <p>Elle définit une constante Duration.ZERO qui correspond à une durée nulle d'un point de vue fonctionnelle.</p> 
   <p>Elle possède de nombreuses méthodes pour créer une nouvelle instance ou obtenir une instance qui soit une copie modifiée de l'instance courante :</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Méthode</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Duration abs()</p> </td> 
      <td> <p>Obtenir une copie dont la quantité encapsulée est toujours positive</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Temporal addTo(Temporal temporal)</p> </td> 
      <td> <p>Renvoyer une copie de l'objet temporel fourni en paramètre en lui ajoutant la durée encapsulée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Duration between(Temporal startInclusive, Temporal endExclusive)</p> </td> 
      <td> <p>Obtenir une instance qui encapsule la durée entre les deux représentations temporelles fournies en paramètres incluses</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int compareTo(Duration otherDuration)</p> </td> 
      <td> <p>Comparer l'instance courante avec celle fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Duration dividedBy(long divisor)</p> </td> 
      <td> <p>Obtenir une copie dont la quantité encapsulée est divisée par la quantité fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean equals(Object otherDuration)</p> </td> 
      <td> <p>Vérifier l'égalité de l'instance courante avec celle fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Duration from(TemporalAmount amount)</p> </td> 
      <td> <p>Obtenir une instance qui encapsule la durée correspondant à la quantité temporelle fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long get(TemporalUnit unit)</p> </td> 
      <td> <p>Obtenir la valeur dans l'unité demandée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getNano()</p> </td> 
      <td> <p>Obtenir le nombre de nanosecondes de la durée encapsulée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long getSeconds()</p> </td> 
      <td> <p>Obtenir le nombre de secondes de la durée encapsulée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>List&lt;TemporalUnit&gt; getUnits()</p> </td> 
      <td> <p>Obtenir la liste des unités temporelles supportées</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isNegative()</p> </td> 
      <td> <p>Vérifier si la valeur encapsulée est strictement inférieure à zéro</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isZero()</p> </td> 
      <td> <p>Vérifier si la durée est égale à zéro</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Duration minus(Duration duration)</p> <p>Duration minus(long amountToSubtract, TemporalUnit unit)</p> </td> 
      <td> <p>Obtenir une copie pour laquelle la durée est retirée de celle fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Duration minusDays(long daysToSubtract)</p> </td> 
      <td> <p>Obtenir une copie dont la durée est minorée du nombre de jours fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Duration minusHours(long hoursToSubtract)</p> </td> 
      <td> <p>Obtenir une copie dont la durée est minorée du nombre d'heures fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Duration minusMillis(long millisToSubtract)</p> </td> 
      <td> <p>Obtenir une copie dont la durée est minorée du nombre de millisecondes fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Duration minusMinutes(long minutesToSubtract)</p> </td> 
      <td> <p>Obtenir une copie dont la durée est minorée du nombre de minutes fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Duration minusNanos(long nanosToSubtract)</p> </td> 
      <td> <p>Obtenir une copie dont la durée est minorée du nombre de nanosecondes fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Duration minusSeconds(long secondsToSubtract)</p> </td> 
      <td> <p>Obtenir une copie dont la durée est minorée du nombre de secondes fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Duration multipliedBy(long multiplicand)</p> </td> 
      <td> <p>Obtenir une copie dont la durée est multipliée par la valeur fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Duration negated()</p> </td> 
      <td> <p>Obtenir une copie dont la valeur est multipliée par -1 (inversion de la valeur positive/négative)</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Duration of(long amount, TemporalUnit unit)</p> </td> 
      <td> <p>Obtenir une instance qui encapsule la durée correspondant à la quantité temporelle fournie en paramètre sous la forme d'une quantité et de son unité</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Duration ofDays(long days)</p> </td> 
      <td> <p>Obtenir une durée qui correspond au nombre de jours fournis en paramètre (une journée correspond toujours à 24 heures)</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Duration ofHours(long hours)</p> </td> 
      <td> <p>Obtenir une durée qui correspond au nombre d'heures fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Duration ofMillis(long millis)</p> </td> 
      <td> <p>Obtenir une durée qui correspond au nombre de millisecondes fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Duration ofMinutes(long minutes)</p> </td> 
      <td> <p>Obtenir une durée qui correspond au nombre de minutes fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Duration ofNanos(long nanos)</p> </td> 
      <td> <p>Obtenir une durée qui correspond au nombre de nanosecondes fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Duration ofSeconds(long seconds)</p> </td> 
      <td> <p>Obtenir une durée qui correspond au nombre de secondes fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Duration ofSeconds(long seconds, long nanoAdjustment)</p> </td> 
      <td> <p>Obtenir une durée qui correspond au nombre de secondes et nanosecondes fournis en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Duration parse(CharSequence text)</p> </td> 
      <td> <p>Obtenir une instance en analysant la chaîne de caractères fournie en paramètre. Le format doit respecter le format PnDTnHnMn.nS.ou n correspond à la valeur d'un champ</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Duration plus(Duration duration)</p> </td> 
      <td> <p>Obtenir une copie qui encapsule la durée majorée de la durée fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Duration plus(long amountToAdd, TemporalUnit unit)</p> </td> 
      <td> <p>Obtenir une copie qui encapsule la durée majorée de la quantité temporelle fournie en paramètre sous la forme d'une quantité et de son unité</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Duration plusDays(long daysToAdd)</p> </td> 
      <td> <p>Obtenir une copie qui encapsule la durée majorée du nombre de jours fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Duration plusHours(long hoursToAdd)</p> </td> 
      <td> <p>Obtenir une copie qui encapsule la durée majorée du nombre d'heures fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Duration plusMillis(long millisToAdd)</p> </td> 
      <td> <p>Obtenir une copie qui encapsule la durée majorée du nombre de millisecondes fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Duration plusMinutes(long minutesToAdd)</p> </td> 
      <td> <p>Obtenir une copie qui encapsule la durée majorée du nombre de minutes fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Duration plusNanos(long nanosToAdd)</p> </td> 
      <td> <p>Obtenir une copie qui encapsule la durée majorée du nombre de nanosecondes fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Duration plusSeconds(long secondsToAdd)</p> </td> 
      <td> <p>Obtenir une copie qui encapsule la durée majorée du nombre secondes fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Temporal subtractFrom(Temporal temporal)</p> </td> 
      <td> <p>Renvoyer une copie de l'objet temporel fourni en paramètre dont la durée a été soustraite</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long toDays()</p> </td> 
      <td> <p>Obtenir le nombre de jours de la durée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long toHours()</p> </td> 
      <td> <p>Obtenir le nombre d'heures de la durée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long toMillis()</p> </td> 
      <td> <p>Obtenir le nombre de millisecondes de la durée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long toMinutes()</p> </td> 
      <td> <p>Obtenir le nombre de minutes de la durée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long toNanos()</p> </td> 
      <td> <p>Obtenir le nombre de nanosecondes de la durée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>String toString()</p> </td> 
      <td> <p>Obtenir une représentation textuelle de la durée respectant le format ISO-8601</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Duration withNanos(int nanoOfSecond)</p> </td> 
      <td> <p>Obtenir une copie de l'instance avec le nombre de nanosecondes fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Duration withSeconds(long seconds)</p> </td> 
      <td> <p>Obtenir une copie de l'instance avec le nombre de secondes fourni en paramètre</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;

import java.time.Duration;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.time.temporal.TemporalUnit;

public class TestDuration {
  public static void main(String[] args) {
        
    Duration uneHeure = Duration.ofHours(1L);
    System.out.println("uneHeure = "+uneHeure);
    uneHeure = Duration.ofMinutes(60L);
    System.out.println("uneHeure = "+uneHeure);
    uneHeure = Duration.ofSeconds(3600L);
    System.out.println("uneHeure = "+uneHeure);
        
    System.out.println("uneHeure = " +
      uneHeure.get(ChronoUnit.SECONDS) + " secondes");
        
    System.out.print("TemporalUnit supportees : ");
    for (TemporalUnit tu : uneHeure.getUnits()) {
      System.out.print(tu+" ");
    }
    System.out.println();
                
    Instant instant1 = Instant.parse("2014-12-25T23:59:59Z");
    Instant instant2 = instant1.plus(1L, ChronoUnit.DAYS);
    Duration duree = Duration.between(instant1, instant2);
    System.out.println("duree = "+duree);
    instant1 = Instant.parse("2014-12-25T23:59:59Z");
    instant2 = Instant.parse("2011-12-25T23:59:59Z");
    duree = Duration.between(instant1, instant2);
    System.out.println("duree = "+duree);
        
    Duration dureeN = uneHeure.negated();
    System.out.println("uneHeure = "+uneHeure + "
      "+dureeN.isNegative());
    dureeN = dureeN.negated();
    System.out.println("uneHeure = "+uneHeure + "
      "+dureeN.isNegative());
        
    boolean estEgal = Duration.ofHours(1L).equals(Duration.ofSeconds(3600L));
    System.out.println("est egal = " +estEgal);
                
    duree = Duration.ofDays(1L);
    Instant instant = instant1.plus(duree);
    System.out.println("instant = "+instant);
        
    duree = Duration.parse("P2DT8H30M12S");
    System.out.println("duree = "+duree);
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">uneHeure = PT1H
uneHeure = PT1H
uneHeure = PT1H
uneHeure = 3600 secondes
TemporalUnit supportees : Seconds Nanos 
duree = PT24H
duree = PT-26304H
uneHeure = PT1H true
uneHeure = PT1H false
est egal = true
instant = 2014-12-26T23:59:59Z
duree = PT56H30M12S</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Remarque : une journée correspond à une Duration de 24 heures. L'ajout d'une Duration correspondant à une journée à une instance de type ZonedDateTime va ajouter 24 heures quelque soit la situation : cette opération ne tiendra pas compte d'un décalage horaire comme l'heure d'été/hiver.</p> 
   <p>Le standard ISO-8601 définit le format textuel d'une durée : PTnHnMn.nS</p> 
   <ul> 
    <li>il commence par P</li> 
    <li>le nombre de jours suivi par D (optionnel)</li> 
    <li>la lettre T (Time) permet d'indiquer que la suite correspond à une heure</li> 
    <li>le nombre d'heures suivi par H (optionnel)</li> 
    <li>le nombre de minutes suivi par M (optionnel)</li> 
    <li>le nombre de secondes suivi par S (optionnel)</li> 
   </ul> 
   <p>Si le format ne peut pas être correctement analysé par la méthode parse(), celle-ci lève une exception de type DataTimeParseException avec le message « Text cannot be parsed to a Duration ».</p> 
   <p>&nbsp;</p> 
   <h3 class="TITRESECTION2">
    <!--nchpdeb--><a name="utilisation_dates-6-6">102.6.6. 
     <!--nchpfin-->La gestion du temps humain</a></h3> 
   <p>Le temps humain est représenté sous la forme de champs entiers dans un calendrier pour la date ( année, mois, jour) et d'heures, minutes, secondes, millisecondes et nanosecondes</p> 
   <p>Les classes java.time.LocalDate, java.time.LocalTime et java.time.LocalDateTime représentent des dates et/ou des heures sans fuseau horaire. Ce sont des objets temporels locaux dans le sens où ils ne sont valides que dans un contexte particulier et ne sont pas utilisables en dehors de ce contexte : ce contexte est généralement la machine sur laquelle le code s'exécute. Le préfixe Local fait référence à local par rapport au système dans lequel le code s'exécute : elles ne prennent pas en compte de fuseau ou de décalage horaire.</p> 
   <p>Les classes LocalDate, LocalTime et LocalDateTime ont différentes méthodes permettant de récupérer une partie de la date, de la tester et d'effectuer des opérations dessus qui renvoient une copie altérée de l'instance.</p> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-6-6-1">102.6.6.1. 
     <!--nchpfin-->La classe LocalDate</a></h4> 
   <p>La classe LocalDate encapsule de manière immuable une date sous la forme d'une année, d'un mois et d'un jour dans le calendrier ISO sans fuseau horaire. Elle est utile pour encapsuler une date sans heure, par exemple une date d'anniversaire.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;
      
import java.time.LocalDate;
import java.time.Month;

public class TestLocalDate {
  public static void main(String[] args) {
    LocalDate date = LocalDate.of(2014, Month.DECEMBER, 25);
    System.out.println(date);
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">2014-12-25</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Comme elle ne possède pas de fuseau horaire, elle ne représente pas un point dans le temps.</p> 
   <p>Elle possède plusieurs méthodes :</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Méthode</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Temporal adjustInto(Temporal temporal)</p> </td> 
      <td> <p>Renvoyer une copie du même type de l'objet temporel fourni en paramètre encapsulant une représentation de l'instance courante (année, mois, jour)</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDateTime atStartOfDay()</p> </td> 
      <td> <p>Renvoyer une instance de type LocalDatetime qui combine la date encapsulée et minuit comme heure</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime atStartOfDay(ZoneId zone)</p> </td> 
      <td> <p>Renvoyer une instance de type ZonedDateTime qui combine la date encapsulée et l'heure à minuit en tenant compte du fuseau horaire passé en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDateTime atTime(int hour, int minute)<br> LocalDateTime atTime(int hour, int minute, int second)<br> LocalDateTime atTime(int hour, int minute, int second, int nanoOfSecond)<br> LocalDateTime atTime(LocalTime time)</p> </td> 
      <td> <p>Renvoyer une instance de type LocalDatetime qui combine la date encapsulée et l'heure passée en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>OffsetDateTime atTime(OffsetTime time)</p> </td> 
      <td> <p>Renvoyer une instance de type OffsetDateTime qui combine la date encapsulée et l'OffsetTime passé en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int compareTo(ChronoLocalDate other)</p> </td> 
      <td> <p>Comparer la date encapsulée avec celle fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean equals(Object obj)</p> </td> 
      <td> <p>Vérifier l'égalité entre la date encapsulée et l'objet fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>String format(DateTimeFormatter formatter)</p> </td> 
      <td> <p>Formater la date encapsulée en utilisant le Formatter passé en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static LocalDate from(TemporalAccessor temporal)</p> </td> 
      <td> <p>Obtenir une instance à partir de l'objet fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int get(TemporalField field)</p> </td> 
      <td> <p>Obtenir un entier qui est la valeur du champ passé en paramètre de la date encapsulée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>IsoChronology getChronology()</p> </td> 
      <td> <p>Obtenir le système calendaire (calendrier ISO)</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getDayOfMonth()</p> </td> 
      <td> <p>Obtenir un entier qui représente le jour du mois de la date encapsulée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DayOfWeek getDayOfWeek()</p> </td> 
      <td> <p>Renvoyer le jour de la semaine de la date encapsulée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getDayOfYear()</p> </td> 
      <td> <p>Renvoyer un entier qui représente le numéro du jour dans l'année</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Era getEra()</p> </td> 
      <td> <p>Renvoyer l'ère du système calendaire à laquelle la date encapsulée appartient</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long getLong(TemporalField field)</p> </td> 
      <td> <p>Obtenir un entier long qui représente le jour du mois de la date encapsulée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Month getMonth()</p> </td> 
      <td> <p>Renvoyer le mois de l'année de la date encapsulée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getMonthValue()</p> </td> 
      <td> <p>Renvoyer le mois de l'année de la date encapsulée sous la forme d'un entier (de 1 à 12)</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getYear()</p> </td> 
      <td> <p>Renvoyer l'année</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isAfter(ChronoLocalDate other)</p> </td> 
      <td> <p>Vérifier si la date encapsulée est postérieure à celle fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isBefore(ChronoLocalDate other)</p> </td> 
      <td> <p>Vérifier si la date encapsulée est antérieure à celle fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isEqual(ChronoLocalDate other)</p> </td> 
      <td> <p>Vérifier si la date encapsulée est égale à celle fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isLeapYear()</p> </td> 
      <td> <p>Vérifier si l'année de la date encapsulée est bissextile selon les règles du calendrier ISO</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isSupported(TemporalField field)</p> </td> 
      <td> <p>Vérifier si le champ temporel passé en paramètre est supporté par cette classe</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isSupported(TemporalUnit unit)</p> </td> 
      <td> <p>Vérifier si l'unité temporelle passée en paramètre est supportée par cette classe</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int lengthOfMonth()</p> </td> 
      <td> <p>Renvoyer le nombre de jours du mois de la date encapsulée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int lengthOfYear()</p> </td> 
      <td> <p>Renvoyer le nombre de jours de l'année de la date encapsulée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDate minus(long amountToSubtract, TemporalUnit unit)</p> <p>LocalDate minus(TemporalAmount amountToSubtract)</p> </td> 
      <td> <p>Renvoyer une copie de l'objet avec une portion de temps soustraite</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDate minusDays(long daysToSubtract)</p> </td> 
      <td> <p>Renvoyer une copie de l'objet avec le nombre de jours fourni soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDate minusMonths(long monthsToSubtract)</p> </td> 
      <td> <p>Renvoyer une copie de l'objet avec le nombre de mois fourni soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDate minusWeeks(long weeksToSubtract)</p> </td> 
      <td> <p>Renvoyer une copie de l'objet avec le nombre de semaines fourni soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDate minusYears(long yearsToSubtract)</p> </td> 
      <td> <p>Renvoyer une copie de l'objet avec le nombre d'années fourni soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static LocalDate now()</p> </td> 
      <td> <p>Renvoyer une instance encapsulant la date courante de l'horloge système en utilisant le fuseau horaire par défaut</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static LocalDate now(Clock clock)</p> </td> 
      <td> <p>Renvoyer une instance encapsulant la date courante de l'horloge fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static LocalDate now(ZoneId zone)</p> </td> 
      <td> <p>Renvoyer une instance encapsulant la date courante de l'horloge système en utilisant le fuseau horaire fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static LocalDate of(int year, int month, int dayOfMonth)<br> static LocalDate of(int year, Month month, int dayOfMonth)<br> static LocalDate ofEpochDay(long epochDay)<br> static LocalDate ofYearDay(int year, int dayOfYear)</p> </td> 
      <td> <p>Obtenir une instance à partir des éléments temporels fournis en paramètres</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static LocalDate parse(CharSequence text)</p> </td> 
      <td> <p>Obtenir une instance à partir de l'analyse de la date fournie en paramètre sous la forme d'une chaîne de caractères en utilisant le Formatter par défaut (exemple : 2014-12-25)</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static LocalDate parse(CharSequence text, DateTimeFormatter formatter)</p> </td> 
      <td> <p>Obtenir une instance à partir de l'analyse de la date fournie en paramètre sous la forme d'une chaîne de caractères en utilisant le Formatter fourni</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDate plus(long amountToAdd, TemporalUnit unit)<br> LocalDate plus(TemporalAmount amountToAdd)</p> </td> 
      <td> <p>Renvoyer une copie de l'objet avec une portion de temps ajoutée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDate plusDays(long daysToAdd)</p> </td> 
      <td> <p>Renvoyer une copie de l'objet avec le nombre de jours fourni ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDate plusMonths(long monthsToAdd)</p> </td> 
      <td> <p>Renvoyer une copie de l'objet avec le nombre de mois fourni ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDate plusWeeks(long weeksToAdd)</p> </td> 
      <td> <p>Renvoyer une copie de l'objet avec le nombre de semaines fourni ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDate plusYears(long yearsToAdd)</p> </td> 
      <td> <p>Renvoyer une copie de l'objet avec le nombre d'années fourni ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>&lt;R&gt; R query(TemporalQuery&lt;R&gt; query)</p> </td> 
      <td> <p>Exécuter la requête passée en paramètre sur l'instance courante</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ValueRange range(TemporalField field)</p> </td> 
      <td> <p>Obtenir la plage de valeurs valides pour le champ fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long toEpochDay()</p> </td> 
      <td> <p>Renvoyer le nombre de jours entre le 01/01/1970 et la date encapsulée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>String toString()</p> </td> 
      <td> <p>Renvoyer une représentation textuelle de la date encapsulée en utilisant le formateur par défaut (exemple : 2014-12-25)</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Period until(ChronoLocalDate endDateExclusive)</p> </td> 
      <td> <p>Calculer la période entre la date encapsulée et celle fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long until(Temporal endExclusive, TemporalUnit unit)</p> </td> 
      <td> <p>Calculer la quantité exprimée dans l'unité demandée entre la date encapsulée et l'objet temporel fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDate with(TemporalAdjuster adjuster)</p> </td> 
      <td> <p>Renvoyer une copie dont la valeur est ajustée grâce à l'objet qui encapsule les traitements fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDate with(TemporalField field, long newValue)</p> </td> 
      <td> <p>Renvoyer une copie modifiée de la date en prenant en compte le jour de l'année fourni</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDate withDayOfMonth(int dayOfMonth)</p> </td> 
      <td> <p>Renvoyer une copie modifiée de la date en prenant en compte le jour du mois fourni</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDate withDayOfYear(int dayOfYear)</p> </td> 
      <td> <p>Renvoyer une copie modifiée de la date en prenant en compte le jour de l'année fourni</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDate withMonth(int month)</p> </td> 
      <td> <p>Renvoyer une copie modifiée de la date en prenant en compte le mois fourni</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDate withYear(int year)</p> </td> 
      <td> <p>Renvoyer une copie modifiée de la date en prenant en compte l'année fournie</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;
      
import java.time.LocalDate;
import java.time.Month;
import java.time.ZoneId;
import java.time.temporal.ChronoField;
import java.time.temporal.ChronoUnit;

public class TestLocalDate {
  public static void main(String[] args) {
    LocalDate date = LocalDate.now();
    System.out.println("date = "+date);
    date = LocalDate.now(ZoneId.of("America/Los_Angeles"));
    System.out.println("date = "+date);
    date = LocalDate.ofEpochDay(16428);
    System.out.println("date = "+date);
    date = LocalDate.of(2014, Month.DECEMBER, 25);
    System.out.println("date = "+date);
        
    System.out.println("Calendrier = "+date.getChronology());
    System.out.println("startOfDay = " + date.atStartOfDay(ZoneId.systemDefault()));
    System.out.println("dayOfMonth = "+date.getDayOfMonth());
    System.out.println("dayOfWeek = "+date.getDayOfWeek());
    System.out.println("dayOfYear = "+date.getDayOfYear());
    System.out.println("ere = "+date.getEra());
    System.out.println("support HOURS = "+date.isSupported(ChronoUnit.HOURS));        
    System.out.println("support HOUR_Of_DAY =
      "+date.isSupported(ChronoField.HOUR_OF_DAY));        
    System.out.println("lengthOfMonth = "+date.lengthOfMonth());        
    System.out.println("lengthOfYear = "+date.lengthOfYear());        
    System.out.println("2 semaines avant = "+date.minusWeeks(2));        
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">date = 2015-02-19
date = 2015-02-19
date = 2014-12-24
date = 2014-12-25
Calendrier = ISO
startOfDay = 2014-12-25T00:00+01:00[Europe/Paris]
dayOfMonth = 25
dayOfWeek = THURSDAY
dayOfYear = 359
ere = CE
support HOURS = false
support HOUR_Of_DAY = false
lengthOfMonth = 31
lengthOfYear = 365
2 semaines avant = 2014-12-11</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>La classe LocalDate permet aussi un accès aux champs : day-of-year, day-of-week et week-of-year.</p> 
   <p>Il ne faut pas utiliser d'opérations sur une instance de type LocalDate requérant l'identité de l'objet : opérateur ==, hashCode ou synchronisation. La comparaison de deux instances doit se faire en utilisant la méthode equals().</p> 
   <p>Remarque : il n'est pas possible de convertir une instance de type LocalDate en Instant car elle ne contient pas de données relatives à l'heure qui permettrait de déterminer le point dans le temps avec une précision à la seconde.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;

import java.time.DateTimeException;
import java.time.Instant;
import java.time.LocalDate;

public class TestLocalDate {
  public static void main(String[] args) {
    try {
      LocalDate date = LocalDate.of(2014, 12, 25);
      Instant instant = Instant.from(date);
    } catch (DateTimeException dte) {
      dte.printStackTrace();
    }
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">java.time.DateTimeException: Unable to obtain Instant from
TemporalAccessor: 2014-12-25 of type java.time.LocalDate
            at java.time.Instant.from(Instant.java:383)
            at com.jmdoudoux.test.java8.datetime.TestLocalDate.main(TestLocalDate.java:13)</pre></td>
     </tr>
    </tbody>
   </table> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-6-6-2">102.6.6.2. 
     <!--nchpfin-->La classe LocalDateTime</a></h4> 
   <p>La classe LocalDateTime encapsule une date (année, mois, jour) et une heure (heure, minute, seconde, nanoseconde) sans fuseau horaire.</p> 
   <p>Cette classe est immuable et thread-safe.</p> 
   <p>Elle possède plusieurs méthodes :</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Méthode</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Temporal adjustInto(Temporal temporal)</p> </td> 
      <td> <p>Renvoyer une copie de l'objet temporel fourni en paramètre dans lequel les champs sont remplacés par ceux encapsulés</p> </td> 
     </tr> 
     <tr> 
      <td> <p>OffsetDateTime atOffset(ZoneOffset offset)</p> </td> 
      <td> <p>Obtenir une instance qui combine l'instance courante avec le décalage horaire passé en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime atZone(ZoneId zone)</p> </td> 
      <td> <p>Obtenir une instance qui combine l'instance courante avec le fuseau horaire passé en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int compareTo(ChronoLocalDateTime&lt;?&gt; other)</p> </td> 
      <td> <p>Comparer l'instance avec l'objet temporel passé en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean equals(Object obj)</p> </td> 
      <td> <p>Vérifier l'égalité de l'instance avec l'objet passé en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>String format(DateTimeFormatter formatter)</p> </td> 
      <td> <p>Formater l'instance pour obtenir une représentation textuelle dans le format précisé par l'objet passé en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static LocalDateTime from(TemporalAccessor temporal)</p> </td> 
      <td> <p>Obtenir une instance à partir de l'objet temporel fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int get(TemporalField field)</p> </td> 
      <td> <p>Obtenir la valeur du champ passé en paramètre sous la forme d'un entier</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getDayOfMonth()</p> </td> 
      <td> <p>Obtenir la valeur du champ jour du mois</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DayOfWeek getDayOfWeek()</p> </td> 
      <td> <p>Obtenir la valeur du champ jour de la semaine encapsulé dans une instance de type DayOfWeek</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getDayOfYear()</p> </td> 
      <td> <p>Obtenir la valeur du champ jour de l'année</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getHour()</p> </td> 
      <td> <p>Obtenir la valeur du champ heures</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long getLong(TemporalField field)</p> </td> 
      <td> <p>Obtenir la valeur du champ fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getMinute()</p> </td> 
      <td> <p>Obtenir la valeur du champ minutes</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Month getMonth()</p> </td> 
      <td> <p>Obtenir la valeur du champ mois encapsulé dans une instance de type Month</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getMonthValue()</p> </td> 
      <td> <p>Obtenir la valeur du champ mois (1-12)</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getNano()</p> </td> 
      <td> <p>Obtenir la valeur du champ nanosecondes</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getSecond()</p> </td> 
      <td> <p>Obtenir la valeur du champ secondes</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getYear()</p> </td> 
      <td> <p>Obtenir la valeur du champ année</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isAfter(ChronoLocalDateTime&lt;?&gt; other)</p> </td> 
      <td> <p>Vérifier si l'instance courante est postérieure à l'objet temporel fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isBefore(ChronoLocalDateTime&lt;?&gt; other)</p> </td> 
      <td> <p>Vérifier si l'instance courante est antérieure à l'objet temporel fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isEqual(ChronoLocalDateTime&lt;?&gt; other)</p> </td> 
      <td> <p>Vérifier si l'instance est égale à l'objet temporel fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isSupported(TemporalField field)</p> </td> 
      <td> <p>Vérifier si le champ passé en paramètre est supporté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isSupported(TemporalUnit unit)</p> </td> 
      <td> <p>Vérifier si l'unité temporel fournie en paramètre est supportée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDateTime minus(long amountToSubtract, TemporalUnit unit)</p> <p>LocalDateTime minus(TemporalAmount amountToSubtract)</p> </td> 
      <td> <p>Renvoyer une copie pour laquelle la quantité temporelle passé en paramètre est soustraite</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDateTime minusDays(long days)</p> </td> 
      <td> <p>Renvoyer une copie pour laquelle le nombre de jours passé en paramètre est soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDateTime minusHours(long hours)</p> </td> 
      <td> <p>Renvoyer une copie pour laquelle le nombre d'heures passé en paramètre est soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDateTime minusMinutes(long minutes)</p> </td> 
      <td> <p>Renvoyer une copie pour laquelle le nombre de minutes passé en paramètre est soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDateTime minusMonths(long months)</p> </td> 
      <td> <p>Renvoyer une copie pour laquelle le nombre de mois passé en paramètre est soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDateTime minusNanos(long nanos)</p> </td> 
      <td> <p>Renvoyer une copie pour laquelle le nombre de nanosecondes passé en paramètre est soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDateTime minusSeconds(long seconds)</p> </td> 
      <td> <p>Renvoyer une copie pour laquelle le nombre de secondes passé en paramètre est soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDateTime minusWeeks(long weeks)</p> </td> 
      <td> <p>Renvoyer une copie pour laquelle le nombre de semaines passé en paramètre est soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDateTime minusYears(long years)</p> </td> 
      <td> <p>Renvoyer une copie pour laquelle le nombre d'années passé en paramètre est soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static LocalDateTime now()</p> </td> 
      <td> <p>Obtenir une instance à partir de la date/heure système et du fuseau horaire par défaut</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static LocalDateTime now(Clock clock)</p> </td> 
      <td> <p>Obtenir une instance à partir de la date/heure donné par l'objet en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static LocalDateTime now(ZoneId zone)</p> </td> 
      <td> <p>Obtenir une instance à partir de la date/heure système et du fuseau horaire passé en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute)<br> static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second)<br> static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond)<br> static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute)<br> static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second)<br> static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond)</p> </td> 
      <td> <p>Obtenir une instance à partir des différentes valeurs des champs passées en paramètres</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static LocalDateTime of(LocalDate date, LocalTime time)</p> </td> 
      <td> <p>Obtenir une instance à partir de la date et de l'heure passées en paramètres</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static LocalDateTime ofEpochSecond(long epochSecond, int nanoOfSecond, ZoneOffset offset)</p> </td> 
      <td> <p>Obtenir une instance qui encapsulera la date-heure issue du calcul de l'ajout du nombre de secondes à l'EPOCH et de la prise en compte du décalage horaire passé en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static LocalDateTime ofInstant(Instant instant, ZoneId zone)</p> </td> 
      <td> <p>Obtenir une instance à partir d'un point dans le temps et d'un fuseau horaire fournis en paramètres</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static LocalDateTime parse(CharSequence text)</p> </td> 
      <td> <p>Obtenir une instance à partir de l'analyse de la chaîne de caractères passée en paramètre. Exemple 2014-12-25T23:59:59</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static LocalDateTime parse(CharSequence text, DateTimeFormatter formatter)</p> </td> 
      <td> <p>Obtenir une instance à partir de l'analyse de la date fournie en paramètre sous la forme d'une chaîne de caractères en utilisant le Formatter fourni</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDateTime plus(long amountToAdd, TemporalUnit unit)</p> <p>LocalDateTime plus(TemporalAmount amountToAdd)</p> </td> 
      <td> <p>Renvoyer une copie à laquelle la quantité temporelle passée en paramètre est ajoutée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDateTime plusDays(long days)</p> </td> 
      <td> <p>Renvoyer une copie à laquelle le nombre de jours passé en paramètre est ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDateTime plusHours(long hours)</p> </td> 
      <td> <p>Renvoyer une copie à laquelle le nombre d'heures passé en paramètre est ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDateTime plusMinutes(long minutes)</p> </td> 
      <td> <p>Renvoyer une copie à laquelle le nombre de minutes passé en paramètre est ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDateTime plusMonths(long months)</p> </td> 
      <td> <p>Renvoyer une copie à laquelle le nombre de mois passé en paramètre est ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDateTime plusNanos(long nanos)</p> </td> 
      <td> <p>Renvoyer une copie à laquelle le nombre de nanosecondes passé en paramètre est ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDateTime plusSeconds(long seconds)</p> </td> 
      <td> <p>Renvoyer une copie à laquelle le nombre de secondes passé en paramètre est ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDateTime plusWeeks(long weeks)</p> </td> 
      <td> <p>Renvoyer une copie à laquelle le nombre de semaine passé en paramètre est ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDateTime plusYears(long years)</p> </td> 
      <td> <p>Renvoyer une copie à laquelle le nombre d'année passé en paramètre est ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>&lt;R&gt; R query(TemporalQuery&lt;R&gt; query)</p> </td> 
      <td> <p>Exécuter la requête passée en paramètre sur l'instance courante</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ValueRange range(TemporalField field)</p> </td> 
      <td> <p>Obtenir la plage des valeurs acceptables pour le champ fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDate toLocalDate()</p> </td> 
      <td> <p>Obtenir une instance de type LocalDate qui contient l'heure encapsulée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalTime toLocalTime()</p> </td> 
      <td> <p>Obtenir une instance de type LocalTime qui contient l'heure encapsulée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>String toString()</p> </td> 
      <td> <p>Obtenir une représentation textuelle de l'instance</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDateTime truncatedTo(TemporalUnit unit)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dont les valeurs encapsulées sont tronquées à l'unité précisée en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long until(Temporal endExclusive, TemporalUnit unit)</p> </td> 
      <td> <p>Calculer la quantité de temps entre l'instance et l'objet temporel fourni en paramètre. Le résultat est obtenu dans l'unité précisée en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDateTime with(TemporalAdjuster adjuster)</p> </td> 
      <td> <p>Renvoyer une copie dont la valeur est ajustée grâce à l'objet qui encapsule les traitements fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDateTime with(TemporalField field, long newValue)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dont la valeur du champ précisé en paramètre est celle fournie</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDateTime withDayOfMonth(int dayOfMonth)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dont le jour du mois est celui fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDateTime withDayOfYear(int dayOfYear)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dont le jour de l'année est celui fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDateTime withHour(int hour)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dont l'heure est celle fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDateTime withMinute(int minute)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dont les minutes sont celles fournies en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDateTime withMonth(int month)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dont le mois est celui fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDateTime withNano(int nanoOfSecond)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dont les nanosecondes sont celles fournies en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDateTime withSecond(int second)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dont les secondes de la minute sont celles fournies en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDateTime withYear(int year)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dont l'année est celle fournie en paramètre</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;
      
import java.time.LocalDateTime;
import java.time.Month;
import java.time.ZoneId;
import java.time.temporal.ChronoField;
import java.time.temporal.ChronoUnit;

public class TestLocalDateTime {
  public static void main(String[] args) {
    LocalDateTime date = LocalDateTime.now();
    System.out.println("dateTime = "+date);
    date = LocalDateTime.now(ZoneId.of("America/Los_Angeles"));
    System.out.println("dateTime = "+date);
    date = LocalDateTime.of(2014, Month.DECEMBER, 25,23,59,59);
    System.out.println("dateTime = "+date);
    System.out.println("date = "+date.toLocalDate());
    System.out.println("time = "+date.toLocalTime());
        
    System.out.println("Calendrier = "+date.getChronology());
    System.out.println("dayOfMonth = "+date.getDayOfMonth());
    System.out.println("dayOfWeek = "+date.getDayOfWeek());
    System.out.println("dayOfYear = "+date.getDayOfYear());
    System.out.println("support HOURS = "+date.isSupported(ChronoUnit.HOURS));        
    System.out.println("support HOUR_Of_DAY = "
      +date.isSupported(ChronoField.HOUR_OF_DAY));        
    System.out.println("support INSTANT_SECONDS =
      "+date.isSupported(ChronoField.INSTANT_SECONDS));        
    System.out.println("hour = "+date.getHour());        
    System.out.println("2 semaines avant = "+date.minusWeeks(2));        
    System.out.println("1 heure avant = "+date.minusHours(1));        
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">dateTime = 2015-02-20T21:07:48.406
dateTime = 2015-02-20T12:07:48.437
dateTime = 2014-12-25T23:59:59
date = 2014-12-25
time = 23:59:59
Calendrier = ISO
dayOfMonth = 25
dayOfWeek = THURSDAY
dayOfYear = 359
support HOURS = true
support HOUR_Of_DAY = true
support INSTANT_SECONDS = false
hour = 23
2 semaines avant = 2014-12-11T23:59:59
1 heure avant = 2014-12-25T22:59:59</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Il ne faut pas utiliser d'opérations sur une instance de type LocalDateTime requérant l'identité de l'objet : opérateur ==, hashCode ou synchronisation. La comparaison de deux instances doit se faire en utilisant la méthode equals().</p> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-6-6-3">102.6.6.3. 
     <!--nchpfin-->La classe LocalTime</a></h4> 
   <p>La classe LocalTime encapsule une heure (heure, minute, seconde, nanoseconde) sans fuseau horaire. Cette classe est immuable et thread-safe.</p> 
   <p>Elle définit plusieurs constantes :</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Valeur</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static LocalTime MAX</p> </td> 
      <td> <p>la plus grande valeur encapsulée, '23:59:59.999999999'</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static LocalTime MIDNIGHT</p> </td> 
      <td> <p>Minuit au début de la journée, '00:00'</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static LocalTime MIN</p> </td> 
      <td> <p>la plus petite valeur encapsulée, '00:00'</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static LocalTime NOON</p> </td> 
      <td> <p>Midi au milieu de la journée, '12:00'</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <p>Elle possède de nombreuses méthodes :</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Méthode</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Temporal adjustInto(Temporal temporal)</p> </td> 
      <td> <p>Renvoyer une copie de l'objet temporel fourni en paramètre dans lequel les champs sont remplacés par ceux encapsulés</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalTime atDate(LocalDate date)</p> </td> 
      <td> <p>Obtenir une instance qui combine l'instance courante et la date fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>OffsetTime atOffset(ZoneOffset offset)</p> </td> 
      <td> <p>Obtenir une instance qui combine l'instance courante avec le décalage horaire passé en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int compareTo(LocalTime other)</p> </td> 
      <td> <p>Comparer l'instance avec l'instance passée en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean equals(Object obj)</p> </td> 
      <td> <p>Vérifier l'égalité de l'instance avec l'objet passé en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>String format(DateTimeFormatter formatter)</p> </td> 
      <td> <p>Formater l'instance pour obtenir une représentation textuelle dans le format précisé par l'objet passé en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static LocalTime from(TemporalAccessor temporal)</p> </td> 
      <td> <p>Obtenir une instance à partir de l'objet temporel fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int get(TemporalField field)</p> </td> 
      <td> <p>Obtenir la valeur du champ passé en paramètre sous la forme d'un entier</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getDayOfMonth()</p> </td> 
      <td> <p>Obtenir la valeur du champ jour du mois</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long getLong(TemporalField field)</p> </td> 
      <td> <p>Obtenir la valeur du champ fourni en paramètre sous la forme d'un entier long</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getMinute()</p> </td> 
      <td> <p>Obtenir la valeur du champ minutes</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getNano()</p> </td> 
      <td> <p>Obtenir la valeur du champ nanosecondes</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getSecond()</p> </td> 
      <td> <p>Obtenir la valeur du champ secondes</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getYear()</p> </td> 
      <td> <p>Obtenir la valeur du champ année</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isAfter(LocalTime other)</p> </td> 
      <td> <p>Vérifier si l'instance courante est postérieure à l'objet temporel fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isBefore(LocalTime other)</p> </td> 
      <td> <p>Vérifier si l'instance courante est antérieure à l'objet temporel fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isSupported(TemporalField field)</p> </td> 
      <td> <p>Vérifier si le champ passé en paramètre est supporté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isSupported(TemporalUnit unit)</p> </td> 
      <td> <p>Vérifier si l'unité temporel fournie en paramètre est supportée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalTime minus(long amountToSubtract, TemporalUnit unit)<br> LocalTime minus(TemporalAmount amountToSubtract)</p> </td> 
      <td> <p>Renvoyer une copie pour laquelle la quantité temporelle passée en paramètre est soustraite</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalTime minusHours(long hours)</p> </td> 
      <td> <p>Renvoyer une copie pour laquelle le nombre d'heures passé en paramètre est soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalTime minusMinutes(long minutes)</p> </td> 
      <td> <p>Renvoyer une copie pour laquelle le nombre de minutes passé en paramètre est soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalTime minusNanos(long nanos)</p> </td> 
      <td> <p>Renvoyer une copie pour laquelle le nombre de nanosecondes passé en paramètre est soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalTime minusSeconds(long seconds)</p> </td> 
      <td> <p>Renvoyer une copie pour laquelle le nombre de secondes passé en paramètre est soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static LocalTime now()</p> </td> 
      <td> <p>Obtenir une instance à partir de la date/heure système et du fuseau horaire par défaut</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static LocalTime now(Clock clock)</p> </td> 
      <td> <p>Obtenir une instance à partir de la date/heure donnée par l'objet en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static LocalTime now(ZoneId zone)</p> </td> 
      <td> <p>Obtenir une instance à partir de la date/heure système et du fuseau horaire passé en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static LocalTime of(int hour, int minute)<br> static LocalTime of(int hour, int minute, int second)<br> static LocalTime of(int hour, int minute, int second, int nanoOfSecond)</p> </td> 
      <td> <p>Obtenir une instance à partir des différentes valeurs des champs passées en paramètres</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static LocalTime ofNanoOfDay(long nanoOfDay)</p> </td> 
      <td> <p>Obtenir une instance à partir des nanosecondes de la journée passées en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static LocalTime ofSecondOfDay(long secondOfDay)</p> </td> 
      <td> <p>Obtenir une instance à partir des secondes de la journée passées en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static LocalTime parse(CharSequence text)</p> </td> 
      <td> <p>Obtenir une instance à partir de l'analyse de la chaîne de caractères passée en paramètres avec le Formatter par défaut. Exemple 14:39:59</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static LocalTime parse(CharSequence text, DateTimeFormatter formatter)</p> </td> 
      <td> <p>Obtenir une instance à partir de l'analyse de la chaîne de caractères passée en paramètres avec le Formatter fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalTime plus(long amountToAdd, TemporalUnit unit)<br> LocalTime plus(TemporalAmount amountToAdd)</p> </td> 
      <td> <p>Renvoyer une copie à laquelle la quantité temporelle passée en paramètre est ajoutée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalTime plusHours(long hours)</p> </td> 
      <td> <p>Renvoyer une copie à laquelle le nombre d'heures passé en paramètre est ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalTime plusMinutes(long minutes)</p> </td> 
      <td> <p>Renvoyer une copie à laquelle le nombre de minutes passé en paramètre est ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalTime plusNanos(long nanos)</p> </td> 
      <td> <p>Renvoyer une copie à laquelle le nombre de nanosecondes passé en paramètre est ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalTime plusSeconds(long seconds)</p> </td> 
      <td> <p>Renvoyer une copie à laquelle le nombre de secondes passé en paramètre est ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>&lt;R&gt; R query(TemporalQuery&lt;R&gt; query)</p> </td> 
      <td> <p>Exécuter la requête passée en paramètre sur l'instance courante</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ValueRange range(TemporalField field)</p> </td> 
      <td> <p>Obtenir la plage des valeurs acceptables pour le champ fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long toNanoOfDay()</p> </td> 
      <td> <p>Obtenir le nombre de nanosecondes de la journée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int toSecondOfDay()</p> </td> 
      <td> <p>Obtenir le nombre de secondes de la journée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>String toString()</p> </td> 
      <td> <p>Obtenir une représentation textuelle de l'instance</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalTime truncatedTo(TemporalUnit unit)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dont les valeurs encapsulées sont tronquées à l'unité précisée en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long until(Temporal endExclusive, TemporalUnit unit)</p> </td> 
      <td> <p>Calculer la quantité de temps entre l'instance et l'objet temporel fourni en paramètre. Le résultat est obtenu dans l'unité précisé en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalTime with(TemporalAdjuster adjuster)</p> </td> 
      <td> <p>Renvoyer une copie dont la valeur est ajustée grâce à l'objet qui encapsule les traitements fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalTime with(TemporalField field, long newValue)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dont la valeur du champ précisé en paramètre est celle fournie</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalTime withHour(int hour)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dont l'heure est celle fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalTime withMinute(int minute)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dont les minutes sont celles fournies en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalTime withNano(int nanoOfSecond)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dont les nanosecondes sont celles fournies en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalTime withSecond(int second)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dont les secondes sont celles fournies en paramètre</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;
      
import java.time.LocalTime;
import java.time.temporal.ChronoField;
import java.time.temporal.ChronoUnit;

public class TestLocalTime {
  public static void main(String[] args) {
    LocalTime time = LocalTime.now();
    System.out.println("time = "+time);
    time = LocalTime.of(23,59,59,104534);
    System.out.println("time = "+time);
        
    System.out.println("support HOURS = " +time.isSupported(ChronoUnit.HOURS));        
    System.out.println("support HOUR_Of_DAY = " 
      +time.isSupported(ChronoField.HOUR_OF_DAY));        
    System.out.println("supportINSTANT_SECONDS = " 
      +time.isSupported(ChronoField.INSTANT_SECONDS));  
        
    System.out.println("hour = "+time.getHour());        
    System.out.println("1 heure avant = " +time.minusHours(1));        
  }  
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">time = 06:53:21.625
time = 23:59:59.000104534
support HOURS = true
support HOUR_Of_DAY = true
support INSTANT_SECONDS = false
hour = 23
1 heure avant = 22:59:59.000104534</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Il ne faut pas utiliser d'opérations sur une instance de type LocalTime requérant l'identité de l'objet : opérateur ==, hashCode ou synchronisation. La comparaison de deux instances doit se faire en utilisant la méthode equals().</p> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-6-6-4">102.6.6.4. 
     <!--nchpfin-->La classe Period</a></h4> 
   <p>La classe Period encapsule une période dans le temps : c'est une quantité de temps exprimée sous la forme des différents champs permettant de représenter une période de manière humaine, telle qu'un an, cinq mois et huit jours.</p> 
   <p>Les unités temporelles supportées sont année, mois et jour : chaque quantité encapsulée est représentée avec une quantité dans ces trois unités, leur valeur pouvant être égale à zéro. Ces valeurs peuvent aussi être négatives. Plusieurs méthodes permettent d'obtenir la quantité dans les différentes unités de temps requises pour représenter cette quantité.</p> 
   <p>Elle possède de nombreuses méthodes pour obtenir une instance ou renvoyer une copie modifiée :</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Méthode</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Temporal addTo(Temporal temporal)</p> </td> 
      <td> <p>Renvoyer une copie de l'objet temporel fourni en paramètre auquel la période a été ajoutée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Period between(LocalDate startDateInclusive, LocalDate endDateExclusive)</p> </td> 
      <td> <p>Calculer la période entre les deux dates fournies en paramètres</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean equals(Object obj)</p> </td> 
      <td> <p>Vérifier si l'instance courante est égale à l'objet fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Period from(TemporalAmount amount)</p> </td> 
      <td> <p>Obtenir une instance qui encapsule la période correspondant à la quantité temporelle fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long get(TemporalUnit unit)</p> </td> 
      <td> <p>Obtenir la durée de la période dans l'unité fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>IsoChronology getChronology()</p> </td> 
      <td> <p>Obtenir le calendrier de l'instance (ISO)</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getDays()</p> </td> 
      <td> <p>Obtenir le nombre de jours de l'instance</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getMonths()</p> </td> 
      <td> <p>Obtenir le nombre de mois de l'instance</p> </td> 
     </tr> 
     <tr> 
      <td> <p>List&lt;TemporalUnit&gt; getUnits()</p> </td> 
      <td> <p>Obtenir la liste des unités supportées</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getYears()</p> </td> 
      <td> <p>Obtenir le nombre d'années de l'instance</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isNegative()</p> </td> 
      <td> <p>Vérifier si la valeur d'au moins un des champs est négative</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isZero()</p> </td> 
      <td> <p>Vérifier que la valeur de tous les champs est zéro</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Period minus(TemporalAmount amountToSubtract)</p> </td> 
      <td> <p>Retourner une copie de l'instance pour laquelle la quantité temporelle fournie en paramètre est soustraite</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Period minusDays(long daysToSubtract)</p> </td> 
      <td> <p>Retourner une copie de l'instance pour laquelle le nombre de jours fourni en paramètre est soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Period minusMonths(long monthsToSubtract)</p> </td> 
      <td> <p>Retourner une copie de l'instance pour laquelle le nombre de mois fourni en paramètre est soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Period minusYears(long yearsToSubtract)</p> </td> 
      <td> <p>Retourner une copie de l'instance pour laquelle le nombre d'année fourni en paramètre est soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Period multipliedBy(int scalar)</p> </td> 
      <td> <p>Retourner une copie de l'instance pour laquelle la valeur de tous les champs est multipliée par la valeur fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Period negated()</p> </td> 
      <td> <p>Renvoyer une nouvelle instance dans laquelle toutes les valeurs des champs sont négatives</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Period normalized()</p> </td> 
      <td>Retourner une copie de la période avec les années et les mois normalisés</td> 
     </tr> 
     <tr> 
      <td> <p>static Period of(int years, int months, int days)</p> </td> 
      <td> <p>Obtenir une instance encapsulant le nombre d'années, mois et jours fournis en paramètres</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Period ofDays(int days)</p> </td> 
      <td> <p>Obtenir une instance encapsulant le nombre de jours fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Period ofMonths(int months)</p> </td> 
      <td> <p>Obtenir une instance encapsulant le nombre de mois fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Period ofWeeks(int weeks)</p> </td> 
      <td> <p>Obtenir une instance encapsulant le nombre de semaines fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Period ofYears(int years)</p> </td> 
      <td> <p>Obtenir une instance encapsulant le nombre d'années fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Period parse(CharSequence text)</p> </td> 
      <td> <p>Renvoyer une instance issue de l'analyse de la chaîne de caractères fournie en paramètre, exemple P1Y5M8D</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Period plus(TemporalAmount amountToAdd)</p> </td> 
      <td> <p>Retourner une copie à laquelle la quantité temporelle fournie en paramètre est ajoutée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Period plusDays(long daysToAdd)</p> </td> 
      <td> <p>Retourner une copie à laquelle le nombre de jours fourni en paramètre est ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Period plusMonths(long monthsToAdd)</p> </td> 
      <td> <p>Retourner une copie à laquelle le nombre de mois fourni en paramètre est ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Period plusYears(long yearsToAdd)</p> </td> 
      <td> <p>Retourner une copie à laquelle le nombre d'années fourni en paramètre est ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Temporal subtractFrom(Temporal temporal)</p> </td> 
      <td> <p>Renvoyer une copie de l'objet temporel fourni en paramètre pour laquelle la période est soustraite</p> </td> 
     </tr> 
     <tr> 
      <td> <p>String toString()</p> </td> 
      <td> <p>Obtenir une représentation textuelle de la période, exemple P1Y5M8D</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long toTotalMonths()</p> </td> 
      <td> <p>Obtenir le nombre total de mois de la période</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Period withDays(int days)</p> </td> 
      <td> <p>Renvoyer une copie de la période ajustée avec le nombre de jours fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Period withMonths(int months)</p> </td> 
      <td> <p>Renvoyer une copie de la période ajustée avec le nombre de mois fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Period withYears(int years)</p> </td> 
      <td> <p>Renvoyer une copie de la période ajustée avec le nombre d'années fourni en paramètre</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;
      
import java.time.LocalDate;
import java.time.Period;
import java.time.temporal.ChronoUnit;

public class TestPeriod {
  public static void main(String[] args) {
    Period period = Period.of(1, 2, 3);
    System.out.println("period=" + period);
    System.out.println("annees=" + period.getYears());
    System.out.println("mois  =" + period.getMonths());
    System.out.println("jours =" + period.getDays());
    
    System.out.println("annees=" + period.get(ChronoUnit.YEARS));
    System.out.println("mois  =" + period.get(ChronoUnit.MONTHS));
    System.out.println("jours =" + period.get(ChronoUnit.DAYS));
    
    System.out.println("-1 jour=" + period.minusDays(1));
    System.out.println("nb mois="+period.toTotalMonths());
    
    LocalDate debut = LocalDate.of(2015, 1, 1);
    LocalDate fin = LocalDate.of(2016, 3, 4);
    System.out.println("ecart deb fin ="+Period.between(debut, fin));
    System.out.println("ecart fin deb ="+Period.between(fin, debut));
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">period=P1Y2M3D
annees=1
mois  =2
jours =3
annees=1
mois  =2
jours =3
-1 jour=P1Y2M2D
nb mois=14
ecart deb fin =P1Y2M3D
ecart fin deb =P-1Y-2M-3D</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>La période encapsulée représente toujours la somme des valeurs des trois champs.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;
      
import java.time.LocalDate;
import java.time.Month;
import java.time.Period;

public class TestPeriod {
  public static void main(String[] args) {
    LocalDate dateNaissance = LocalDate.of(1972, Month.JUNE, 5);
    final LocalDate prochainAnniversaire = prochainAnniversaire(dateNaissance);
    System.out.println("prochain anniversaire="+prochainAnniversaire);
    
    Period period = Period.between(LocalDate.now(), prochainAnniversaire);
    System.out.println("aura lieu dans "+period.getYears()
      +" ans, "+ period.getMonths()+" mois et "
      +period.getDays()+" jours");
  }
  
  public static LocalDate prochainAnniversaire(LocalDate dateNaissance) {
    LocalDate aujourdhui = LocalDate.now();
    LocalDate resultat = dateNaissance.withYear(aujourdhui.getYear());
    if (resultat.isBefore(aujourdhui) || resultat.isEqual(aujourdhui)) {
      resultat = resultat.plusYears(1);
    }
    return resultat;
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">prochain anniversaire=2015-06-05
aura lieu dans 0 ans, 3 mois et 2 jours</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Remarque : pour obtenir une période sous la forme d'une seule unité temporelle, il faut utiliser la méthode between() de la classe ChronoUnit.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;
      
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;

public class TestChronoUnit {
  public static void main(String[] args) {
    LocalDate debut = LocalDate.of(2015, 1, 1);
    LocalDate fin = LocalDate.of(2015, 1, 2);
    long nbJour = ChronoUnit.DAYS.between(debut, fin);
    System.out.println("nbjour="+nbJour);
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">nbjour=1</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Remarque : la classe Duration encapsule aussi une quantité de temps mais sous une forme machine. Les classes Period et Duration gère le décalage horaire différemment lorsqu'elles sont ajoutées à un objet de type ZonedDateTime : Duration ajoute un nombre déterminé de secondes alors que Period tente d'être le plus proche possible de l'heure.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;
      
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.Period;
import java.time.ZoneId;
import java.time.ZonedDateTime;

public class TestPeriod {
  public static void main(String[] args) {
    Duration unJourD = Duration.ofDays(1);
    Period unJourP = Period.ofDays(1);
    
    ZonedDateTime dateTime = ZonedDateTime.of(
      LocalDateTime.of(2015, 3, 28, 17, 00), ZoneId.systemDefault());
    System.out.println("datetime         ="+dateTime);
    System.out.println("+ periode 1 jour ="+dateTime.plus(unJourP));
    System.out.println("+ duree 1 jour   ="+dateTime.plus(unJourD));
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">datetime =2015-03-28T17:00+01:00[Europe/Paris]
+ periode 1 jour =2015-03-29T17:00+02:00[Europe/Paris]
+ duree 1 jour   =2015-03-29T18:00+02:00[Europe/Paris]</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Period est une classe de type value-based : il ne faut pas utiliser d'opérations sur une instance de type Period requérant l'identité de l'objet : opérateur ==, hashCode ou synchronisation. La comparaison de deux instances doit se faire en utilisant la méthode equals().</p> 
   <p>&nbsp;</p> 
   <h3 class="TITRESECTION2">
    <!--nchpdeb--><a name="utilisation_dates-6-7">102.6.7. 
     <!--nchpfin-->Les fuseaux et les décalages horaires</a></h3> 
   <p>La gestion des fuseaux et des décalages horaires rend beaucoup plus complexe la gestion des objets temporaux.</p> 
   <p>La surface de la Terre est découpée virtuellement en portions appelées fuseaux horaires : dans chacune de ces portions des règles s'appliquent et l'heure communément utilisée est la même. Il existe une quarantaine de fuseaux horaires.</p> 
   <p>Chaque fuseau horaire possède :</p> 
   <ul> 
    <li>un identifiant court (exemple : CET)</li> 
    <li>un identifiant long généralement sous la forme région/ville (exemple : «Europe/Paris»)</li> 
    <li>des règles qui permettent de déterminer l'heure grâce à un décalage par rapport à l'heure du méridien de Greenwich, aussi désignée par UTC. Ces règles peuvent définir certaines spécificités comme l'utilisation de l'heure d'été/hiver.</li> 
   </ul> 
   <p>L'API Date-time propose deux classes pour encapsuler un fuseau horaire ou un décalage horaire :</p> 
   <ul> 
    <li>ZoneId : encapsule un fuseau horaire qui possède un décalage horaire et des règles pour déterminer l'heure utilisée dans ce fuseau</li> 
    <li>ZoneOffset : encapsule un décalage horaire</li> 
   </ul> 
   <p>Avant Java 8, la classe java.util.TimeZone encapsulait un fuseau horaire. C'est toujours le cas mais l'API Date-Time ne l'utilise pas et propose la nouvelle classe ZoneId car TimeZone est mutable.</p> 
   <p>L'API Date-Time propose plusieurs classes temporelles qui prennent en charge un fuseau horaire :</p> 
   <ul> 
    <li>ZonedDateTime : encapsule une date-heure avec un fuseau horaire</li> 
    <li>OffsetDateTime : encapsule une date-heure avec un décalage horaire</li> 
    <li>OffsetTime : encapsule une heure avec un décalage horaire</li> 
   </ul> 
   <p>Le plus simple est d'utiliser une ZonedDateTime qui gère le décalage horaire sur la base des règles encapsulées dans le ZoneId prenant par exemple en charge l'heure d'été/hiver. Les classes OffsetDatetime et OffsetTime gère un décalage fixe. Généralement les formats d'échanges tels que XML ou de stockage comme une base de données utilisent une OffsetDateTime ou OffsetTime.</p> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-6-7-1">102.6.7.1. 
     <!--nchpfin-->La classe ZoneId</a></h4> 
   <p>La classe abstraite ZoneId encapsule un fuseau horaire identifié par son id unique : exemple « Europe/Paris»</p> 
   <p>Elle contient les règles pour transformer un Instant en LocalDateTime.</p> 
   <p>Il existe deux types de fuseaux horaires chacun encapsulé dans une classe fille :</p> 
   <ul> 
    <li>décalage fixe (fixed offset) encapsulé dans le classe ZoneOffset : le décalage horaire par rapport à l'heure de Greenwich est le même pour tous les endroits du fuseau</li> 
    <li>régions géographiques encapsulés dans le classe ZoneRegion : des règles particulières s'appliquent sur le décalage horaire</li> 
   </ul> 
   <p>La classe ZoneRules contient pour chaque id les règles à appliquer : celles-ci changent fréquemment car elles sont définies par chaque pays.</p> 
   <p>Il existe trois types d'id :</p> 
   <ul> 
    <li>simple : correspond à celui encapsulé dans un ZoneOffset. Sa représentation commence par la lettre Z puis le signe + ou - et la valeur du décalage</li> 
    <li>offset-style : commence par un préfixe (UTC, GMT ou UT) puis le signe + ou - et la valeur du décalage</li> 
    <li>region-based : commence par au moins deux caractères différents des préfixes de l'offset-style et des caractères + et -,</li> 
   </ul> 
   <p>Plusieurs organismes collectent et diffusent régulièrement les changements sur les fuseaux horaires : IANA Time Zone Database (TZDB), IATA, ... Chaque organisme utilise son propre format : c'est celui du TZDB qui est prioritairement utilisé.</p> 
   <p>La classe ZoneId contient plusieurs méthodes :</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Méthode</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean equals(Object obj)</p> </td> 
      <td> <p>Vérifier l'égalité avec l'objet fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static ZoneId from(TemporalAccessor temporal)</p> </td> 
      <td> <p>Obtenir une instance à partir de l'objet temporel passé en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Set&lt;String&gt; getAvailableZoneIds()</p> </td> 
      <td> <p>Obtenir la liste des identifiants de zones utilisables</p> </td> 
     </tr> 
     <tr> 
      <td> <p>String getDisplayName(TextStyle style, Locale locale)</p> </td> 
      <td> <p>Obtenir une représentation textuelle de la zone sous la forme de son nom ou d'un décalage horaire</p> </td> 
     </tr> 
     <tr> 
      <td> <p>abstract String getId()</p> </td> 
      <td> <p>Obtenir l'identifiant unique de la zone</p> </td> 
     </tr> 
     <tr> 
      <td> <p>abstract ZoneRules getRules()</p> </td> 
      <td> <p>Obtenir les règles de calculs à utiliser pour la zone</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZoneId normalized()</p> </td> 
      <td> <p>Normaliser l'instance en tentant de renvoyer si possible une instance type ZoneOffset</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static ZoneId of(String zoneId)</p> </td> 
      <td> <p>Obtenir une instance à partir de son identifiant</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static ZoneId of(String zoneId, Map&lt;String, String&gt; aliasMap)</p> </td> 
      <td> <p>Obtenir une instance à partir de son identifiant en utilisant la collections d'alias en remplacement des ID standard</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static ZoneId ofOffset(String prefix, ZoneOffset offset)</p> </td> 
      <td> <p>Obtenir une instance qui encapsule la ZoneOffset passée en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static ZoneId systemDefault()</p> </td> 
      <td> <p>Obtenir la ZoneId du système</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <p>La classe ZoneId peut être sérialisée : dans ce cas c'est l'ID qui est stocké. Il est possible que l'ID n'existe pas dans la JVM où l'objet est dé-sérialisé. Dans ce cas, l'invocation de la méthode getRules() lève une exception de type ZoneRulesException.</p> 
   <p>ZoneId est une classe de type value-based : il ne faut pas utiliser d'opérations sur une instance de type Period requérant l'identité de l'objet : opérateur ==, hashCode ou synchronisation. La comparaison de deux instances doit se faire en utilisant la méthode equals().</p> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-6-7-2">102.6.7.2. 
     <!--nchpfin-->La classe ZoneOffset</a></h4> 
   <p>La classe ZoneOffset encapsule un décalage horaire.</p> 
   <p>Elle possède plusieurs méthodes :</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Constante</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static ZoneOffset MAX</p> </td> 
      <td> <p>Le décalage maximum : +18:00</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static ZoneOffset MIN</p> </td> 
      <td> <p>Le décalage minimum : -18:00</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static ZoneOffset UTC</p> </td> 
      <td> <p>Le décalage pour UTC : 00:00 avec l'ID «Z»</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <p>Elle possède plusieurs méthodes&nbsp;:</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Méthode</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Temporal adjustInto(Temporal temporal)</p> </td> 
      <td> <p>Renvoyer une copie de l'objet temporel fourni en paramètre ajustée avec l'instance de type ZoneOffset</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int compareTo(ZoneOffset other)</p> </td> 
      <td> <p>Comparer l'instance avec celle fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean equals(Object obj)</p> </td> 
      <td> <p>Vérifier l'égalité avec l'objet fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static ZoneOffset from(TemporalAccessor temporal)</p> </td> 
      <td> <p>Obtenir une instance à partir de l'objet temporel fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int get(TemporalField field)</p> </td> 
      <td> <p>Obtenir la valeur du champ passé en paramètre sous la forme d'un entier</p> </td> 
     </tr> 
     <tr> 
      <td> <p>String getId()</p> </td> 
      <td> <p>Obtenir l'ID de l'instance</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long getLong(TemporalField field)</p> </td> 
      <td> <p>Obtenir la valeur du champ passé en paramètre sous la forme d'un entier</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZoneRules getRules()</p> </td> 
      <td> <p>Obtenir les règles de calculs encapsulés dans une instance de type ZoneRules</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getTotalSeconds()</p> </td> 
      <td> <p>Obtenir le nombre de secondes correspondant au décalage</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isSupported(TemporalField field)</p> </td> 
      <td> <p>Vérifier si le champ passé en paramètre est supporté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static ZoneOffset of(String offsetId)</p> </td> 
      <td> <p>Obtenir une instance à partir de son ID</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static ZoneOffset ofHours(int hours)</p> </td> 
      <td> <p>Obtenir une instance à partir du nombre d'heures fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static ZoneOffset ofHoursMinutes(int hours, int minutes)</p> </td> 
      <td> <p>Obtenir une instance à partir du nombre d'heures et de minutes fournis en paramètres</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static ZoneOffset ofHoursMinutesSeconds(int hours, int minutes, int seconds)</p> </td> 
      <td> <p>Obtenir une instance à partir du nombre d'heures, de minutes et de secondes fournis en paramètres</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static ZoneOffset ofTotalSeconds(int totalSeconds)</p> </td> 
      <td> <p>Obtenir une instance à partir du nombre de secondes fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>&lt;R&gt; R query(TemporalQuery&lt;R&gt; query)</p> </td> 
      <td> <p>Exécuter la requête passée en paramètre sur l'instance</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ValueRange range(TemporalField field)</p> </td> 
      <td> <p>Obtenir la plage de valeurs utilisables pour le champ passé en paramètre</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <p>Le décalage horaire correspond à la différence de temps entre le fuseau horaire et celui de Greenwich : c'est généralement une quantité temporelle exprimée sous la forme d'heures et de minutes. Par exemple : +01:00 pour Paris en hiver et +02:00 en été.</p> 
   <p>Le fuseau horaire encapsulé dans une instance de type ZoneId possède une ou plusieurs instances de type ZoneOffset. Pour la ZoneId « Europe/Paris », il y a deux ZoneOffset : une pour l'heure d'été et une pour l'heure d'hiver.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;
      
import java.time.LocalDateTime;
import java.time.Month;
import java.time.ZoneId;
import java.time.zone.ZoneRules;

public class TestZoneOffset {
  public static void main(String[] args) {
    ZoneId zoneId = ZoneId.of("Europe/Paris");
    
    ZoneRules rules = zoneId.getRules();
    System.out.println(rules.getOffset(LocalDateTime.of(2015,
      Month.FEBRUARY, 10, 0, 0)));
    System.out.println(rules.getOffset(LocalDateTime.of(2015, 
      Month.JUNE,10, 0, 0)));
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">+01:00
+02:00</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Cette classe est conçue pour être utilisée avec le calendrier ISO.</p> 
   <p>ZoneOffset est une classe de type value-based : il ne faut pas utiliser d'opérations sur une instance de type Period requérant l'identité de l'objet : opérateur ==, hashCode ou synchronisation. La comparaison de deux instances doit se faire en utilisant la méthode equals().</p> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-6-7-3">102.6.7.3. 
     <!--nchpfin-->La classe ZonedDateTime</a></h4> 
   <p>La classe ZonedDateTime encapsule une date, une heure et un fuseau horaire : elle peut être vue comme une combinaison d'une LocalDateTime et d'une ZoneId. Il est nécessaire d'utiliser une instance de type ZonedDateTime pour fournir une donnée temporelle qui soit indépendante de la machine sur laquelle elle est créée.</p> 
   <p>Elle permet la conversion d'une LocalDateTime en une Instant. Cette conversion requiert le calcul du décalage horaire à appliquer en fonction des règles encapsulées dans la propriété rules de l'instance de type ZoneId.</p> 
   <p>Le décalage peut être simple en correspondant directement au décalage entre le fuseau horaire et celui de Greenwich. Ce décalage peut aussi être dans certains cas plus complexe notamment lors du passage :</p> 
   <ul> 
    <li>à l'heure d'été au printemps : dans ce cas, le décalage est incrémenté</li> 
    <li>à l'heure d'hiver en automne : dans ce cas, le décalage est décrémenté</li> 
   </ul> 
   <p>Elle possède de nombreuses méthodes :</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Méthode</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>String format(DateTimeFormatter formatter)</p> </td> 
      <td> <p>Formater l'instance avec le Formatter passé en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static ZonedDateTime from(TemporalAccessor temporal)</p> </td> 
      <td> <p>Obtenir une instance à partir de l'objet temporel passé en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int get(TemporalField field)</p> </td> 
      <td> <p>Obtenir la valeur du champ passé en paramètre sous la forme d'un entier</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getDayOfMonth()<br> DayOfWeek getDayOfWeek()</p> </td> 
      <td> <p>Obtenir le champ jour du mois</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getDayOfYear()</p> </td> 
      <td> <p>Obtenir le champ jour de l'année</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getHour()</p> </td> 
      <td> <p>Obtenir le champ heure</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long getLong(TemporalField field)</p> </td> 
      <td> <p>Obtenir la valeur du champ passé en paramètre sous la forme d'un entier long</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getMinute()</p> </td> 
      <td> <p>Obtenir les minutes</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Month getMonth()</p> </td> 
      <td> <p>Obtenir le mois de l'année</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getMonthValue()</p> </td> 
      <td> <p>Obtenir le mois de l'année (1 à 12)</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getNano()</p> </td> 
      <td> <p>Obtenir les nanosecondes</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZoneOffset getOffset()</p> </td> 
      <td> <p>Obtenir le décalage horaire. Exemple : «+01:00»</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getSecond()</p> </td> 
      <td> <p>Obtenir les secondes</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getYear()</p> </td> 
      <td> <p>Obtenir l'année</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZoneId getZone()</p> </td> 
      <td> <p>Obtenir le fuseau horaire. Exemple « Europe/Paris»</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isSupported(TemporalField field)</p> </td> 
      <td> <p>Vérifier si le champ passé en paramètre est supporté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isSupported(TemporalUnit unit)</p> </td> 
      <td> <p>Vérifier si l'unité passée en paramètre est supportée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime minus(long amountToSubtract, TemporalUnit unit)<br> ZonedDateTime minus(TemporalAmount amountToSubtract)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance pour laquelle la quantité temporelle a été soustraite</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime minusDays(long days)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance pour laquelle le nombre de jours a été soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime minusHours(long hours)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance pour laquelle le nombre d'heures a été soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime minusMinutes(long minutes)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance pour laquelle le nombre de minutes a été soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime minusMonths(long months)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance pour laquelle le nombre de mois a été soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime minusNanos(long nanos)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance pour laquelle le nombre de nanosecondes a été soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime minusSeconds(long seconds)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance pour laquelle le nombre de secondes a été soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime minusWeeks(long weeks)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance pour laquelle le nombre de semaines a été soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime minusYears(long years)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance pour laquelle le nombre d'années a été soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static ZonedDateTime now()</p> </td> 
      <td> <p>Obtenir une instance à partir de l'heure système et du fuseau horaire par défaut</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static ZonedDateTime now(Clock clock)</p> </td> 
      <td> <p>Obtenir une instance à partir de l'heure obtenue de l'objet passé en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static ZonedDateTime now(ZoneId zone)</p> </td> 
      <td> <p>Obtenir une instance à partir de l'heure système et fuseau horaire passé en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static ZonedDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond, ZoneId zone)</p> </td> 
      <td> <p>Obtenir une instance à partir de différents champs et du fuseau horaire passés en paramètres</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static ZonedDateTime of(LocalDate date, LocalTime time, ZoneId zone)<br> static ZonedDateTime of(LocalDateTime localDateTime, ZoneId zone)<br> static ZonedDateTime ofInstant(Instant instant, ZoneId zone)</p> </td> 
      <td> <p>Obtenir une instance à partir de l'objet temporel et du fuseau horaire passés en paramètres</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static ZonedDateTime ofInstant(LocalDateTime localDateTime, ZoneOffset offset, ZoneId zone)</p> </td> 
      <td> <p>Obtenir une instance à partir de l'objet temporel, du décalage horaire et du fuseau horaire fournis en paramètres</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static ZonedDateTime ofLocal(LocalDateTime localDateTime, ZoneId zone, ZoneOffset preferredOffset)</p> </td> 
      <td> <p>Obtenir une instance à partir de l'objet temporel et du fuseau horaire fournis en paramètres en utilisant le décalage horaire précisé si possible</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static ZonedDateTime ofStrict(LocalDateTime localDateTime, ZoneOffset offset, ZoneId zone)</p> </td> 
      <td>Obtenir une instance respectant strictement la combinaison de paramètres fournie</td> 
     </tr> 
     <tr> 
      <td> <p>static ZonedDateTime parse(CharSequence text)</p> </td> 
      <td> <p>Analyser le texte fourni en paramètre avec le Formatter par défaut pour obtenir une instance. Exemple «2014-12-25T23:59:59+01:00[Europe/Paris]»</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static ZonedDateTime parse(CharSequence text, DateTimeFormatter formatter)</p> </td> 
      <td> <p>Analyser le texte avec le Formatter fournis en paramètre pour obtenir une instance</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime plus(long amountToAdd, TemporalUnit unit)<br> ZonedDateTime plus(TemporalAmount amountToAdd)</p> </td> 
      <td> <p>Obtenir une copie à laquelle la quantité temporelle a été ajoutée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime plusDays(long days)</p> </td> 
      <td> <p>Obtenir une copie à laquelle le nombre de jours a été ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime plusHours(long hours)</p> </td> 
      <td> <p>Obtenir une copie à laquelle le nombre d'heures a été ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime plusMinutes(long minutes)</p> </td> 
      <td> <p>Obtenir une copie à laquelle le nombre de minutes a été ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime plusMonths(long months)</p> </td> 
      <td> <p>Obtenir une copie à laquelle le nombre de mois a été ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime plusNanos(long nanos)</p> </td> 
      <td> <p>Obtenir une copie à laquelle le nombre de nanosecondes a été ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime plusSeconds(long seconds)</p> </td> 
      <td> <p>Obtenir une copie à laquelle le nombre de secondes a été ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime plusWeeks(long weeks)</p> </td> 
      <td> <p>Obtenir une copie à laquelle le nombre de semaines a été ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime plusYears(long years)</p> </td> 
      <td> <p>Obtenir une copie à laquelle le nombre d'années a été ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>&lt;R&gt; R query(TemporalQuery&lt;R&gt; query)</p> </td> 
      <td> <p>Renvoyer le résultat de l'exécution de la requête fournie en paramètre sur l'instance</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ValueRange range(TemporalField field)</p> </td> 
      <td> <p>Obtenir la plage de valeurs valides pour le champ fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDate toLocalDate()</p> </td> 
      <td> <p>Obtenir une instance de type LocalDate à partir des champs encapsulés</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalDateTime toLocalDateTime()</p> </td> 
      <td> <p>Obtenir une instance de type LocalDateTime à partir des champs encapsulés</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalTime toLocalTime()</p> </td> 
      <td> <p>Obtenir une instance de type LocalTime à partir des champs encapsulés</p> </td> 
     </tr> 
     <tr> 
      <td> <p>OffsetDateTime toOffsetDateTime()</p> </td> 
      <td> <p>Obtenir une instance de type OffsetDateTime à partir des champs encapsulés</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime truncatedTo(TemporalUnit unit)</p> </td> 
      <td> <p>Obtenir une copie de l'instance tronquée à l'unité fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long until(Temporal endExclusive, TemporalUnit unit)</p> </td> 
      <td> <p>Calculer la quantité de temps exprimée dans l'unité fournie entre l'instance et l'objet temporel fourni en paramètres</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime with(TemporalAdjuster adjuster)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance ajustée grâce à l'objet fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime with(TemporalField field, long newValue)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dans la valeur du champ fournie en paramètre est remplacée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime withDayOfMonth(int dayOfMonth)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dont la valeur du champ jour du mois est remplacée avec celle fournie</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime withDayOfYear(int dayOfYear)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dont la valeur du champ jour de l'année est remplacée avec celle fournie</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime withEarlierOffsetAtOverlap()</p> </td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime withFixedOffsetZone()</p> </td> 
      <td>Retourne une copie de l'instance pour laquelle zone ID a la valeur de l'offset</td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime withHour(int hour)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dont la valeur du champ heure est remplacée avec celle fournie</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime withLaterOffsetAtOverlap()</p> </td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime withMinute(int minute)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dont la valeur du champ minute est remplacée avec celle fournie</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime withMonth(int month)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dont la valeur du champ mois est remplacée avec celle fournie</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime withNano(int nanoOfSecond)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dont la valeur du champ nanosecondes est remplacée avec celle fournie</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime withSecond(int second)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dont la valeur du champ seconde est remplacée avec celle fournie</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime withYear(int year)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dont la valeur du champ années est remplacée avec celle fournie</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime withZoneSameInstant(ZoneId zone)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance représentant le même instant mais dans le fuseau horaire fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime withZoneSameLocal(ZoneId zone)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance utilisant le fuseau horaire fourni en paramètre en tentant de conserver la même date/heure locale</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;
      
import java.time.LocalDateTime;
import java.time.Month;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.zone.ZoneRules;
import java.util.Set;

public class TestZonedDateTime {
  public static void main(String[] args) {
    LocalDateTime dateTime = LocalDateTime.of(2014,12,25,0,0,0);
    ZoneId zoneId = ZoneId.of("Europe/Paris");
    ZonedDateTime zoneDateTime = ZonedDateTime.of(dateTime, zoneId);
    System.out.println("zoneDateTime="+zoneDateTime);
    System.out.println(zoneId.getRules().isDaylightSavings(zoneDateTime.toInstant()));
      
    zoneId = ZoneId.of("America/Los_Angeles");
    zoneDateTime = ZonedDateTime.of(dateTime, zoneId);
    System.out.println("zoneDateTime L.A. ="+zoneDateTime);
    System.out.println("zoneDateTime Paris="
      +zoneDateTime.withZoneSameInstant(ZoneId.of("Europe/Paris")));
    // Calcul heure locale d'arrivee apres un vol de 12h30
    LocalDateTime dateTimeDepart = LocalDateTime.of(2015,3,11,8,0,0);
    System.out.println("depart Paris "+dateTimeDepart+" heure locale");
    ZoneId zoneIdDepart = ZoneId.of("Europe/Paris");
    ZonedDateTime zoneDateTimeDepart = ZonedDateTime.of(dateTimeDepart, zoneIdDepart);
    ZoneId zoneIdArrivee = ZoneId.of("America/Los_Angeles");
    ZonedDateTime zoneDateT imeArrivee = zoneDateTimeDepart
      .withZoneSameInstant(zoneIdArrivee).plusHours(12).plusMinutes(30);
    LocalDateTime dateTimeArrivee = zoneDateTimeArrivee.toLocalDateTime();
    System.out.println("Arrivee L.A. "+dateTimeArrivee+" heure locale");
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">zoneDateTime=2014-12-25T00:00+01:00[Europe/Paris]
false
zoneDateTime L.A. =2014-12-25T00:00-08:00[America/Los_Angeles]
zoneDateTime Paris=2014-12-25T09:00+01:00[Europe/Paris]
depart Paris 2015-03-11T08:00
heure locale
Arrivee L.A. 2015-03-11T12:30 heure locale</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>ZonedDateTime est une classe de type value-based : il ne faut pas utiliser d'opérations sur une instance de type ZonedDateTime requérant l'identité de l'objet : opérateur ==, hashCode ou synchronisation. La comparaison de deux instances doit se faire en utilisant la méthode equals().</p> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-6-7-4">102.6.7.4. 
     <!--nchpfin-->La classe OffsetDateTime</a></h4> 
   <p>La classe OffsetDateTime encapsule de manière immuable une date, une heure et un décalage horaire à partir de l'heure UTC (méridien de Greenwich) : elle combine une LocalDateTime et une ZoneOffset telles que 2014-12-25T00:00:00+01:00.</p> 
   <p>Cette classes est utile pour sérialiser une donnée temporelle en dehors de la JVM tel que le stockage dans une base de données, l'échange entre plusieurs serveurs, ...</p> 
   <p>Les classes ZonedDateTime et OffsetDateTime sont très proches. La différence majeure est que la classe OffsetDateTime applique simplement le décalage : elle ne tient, par exemple, pas compte de l'heure d'été/hiver.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;
      
import java.time.LocalDateTime;
import java.time.Month;
import java.time.OffsetDateTime;
import java.time.ZoneOffset;

public class TestOffsetDateTime {
  public static void main(String[] args) {
    LocalDateTime localDateTime = LocalDateTime.of(2014,Month.DECEMBER, 25, 4,00,0);
    final ZoneOffset zoneOffset = ZoneOffset.of("+05:00");
    OffsetDateTime offsetDateTime = OffsetDateTime.of(localDateTime, zoneOffset);
    System.out.println(offsetDateTime);
      
    offsetDateTime = OffsetDateTime.parse("2014-12-25T04:00+05:00");
    offsetDateTime =  offsetDateTime.withOffsetSameInstant(ZoneOffset.of("+01:00"));
    System.out.println(offsetDateTime);
    System.out.println(offsetDateTime.toLocalDateTime());
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">2014-12-25T04:00+05:00
2014-12-25T00:00+01:00
2014-12-25T00:00</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>OffsetDateTime est une classe de type value-based : il ne faut pas utiliser d'opérations sur une instance de type OffsetDateTime requérant l'identité de l'objet : opérateur ==, hashCode ou synchronisation. La comparaison de deux instances doit se faire en utilisant la méthode equals().</p> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-6-7-5">102.6.7.5. 
     <!--nchpfin-->La classe OffsetTime</a></h4> 
   <p>La classe OffsetTime encapsule une heure et un décalage horaire par rapport à l'heure UTC dans le calendrier ISO : elle combine une LocalTime et une ZoneOffset.</p> 
   <p>La précision de l'heure encapsulée est la nanoseconde. Elle est immuable et thread-safe.</p> 
   <p>Elle possède de nombreuses méthodes :</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Méthode</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Temporal adjustInto(Temporal temporal)</p> </td> 
      <td> <p>Renvoyer une copie de l'objet temporel fourni en paramètre dans lequel la valeur du champ encapsulé est remplacée par celle passée en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>OffsetDateTime atDate(LocalDate date)</p> </td> 
      <td> <p>Combiner l'instance courante avec l'objet temporal fourni en paramètre pour obtenir une instance de type OffsetDateTime</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int compareTo(OffsetTime other)</p> </td> 
      <td> <p>Comparer l'instance courante avec celle fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>String format(DateTimeFormatter formatter)</p> </td> 
      <td> <p>Formater l'instance avec le formateur passé en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static OffsetTime from(TemporalAccessor temporal)</p> </td> 
      <td> <p>Obtenir une instance à partir de l'objet temporel passé en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int get(TemporalField field)</p> </td> 
      <td> <p>Obtenir la valeur du champ passé en paramètre sous la forme d'un entier</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getHour()</p> </td> 
      <td> <p>Obtenir le champ heure</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long getLong(TemporalField field)</p> </td> 
      <td> <p>Obtenir la valeur du champ passé en paramètre sous la forme d'un entier long</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getMinute()</p> </td> 
      <td> <p>Obtenir les minutes</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getNano()</p> </td> 
      <td> <p>Obtenir les nanosecondes</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZoneOffset getOffset()</p> </td> 
      <td> <p>Obtenir le décalage horaire. Exemple : «+01:00»</p> </td> 
     </tr> 
     <tr> 
      <td> <p>int getSecond()</p> </td> 
      <td> <p>Obtenir les secondes</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isAfter(OffsetTime other)</p> </td> 
      <td> <p>Vérifier si l'instance courante est postérieure à celle fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isBefore(OffsetTime other)</p> </td> 
      <td> <p>Vérifier si l'instance courante est antéreure à celle fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isEqual(OffsetTime other)</p> </td> 
      <td> <p>Vérifier si l'instance est égale à celle fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isSupported(TemporalField field)</p> </td> 
      <td> <p>Vérifier si le champ passé en paramètre est supporté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean isSupported(TemporalUnit unit)</p> </td> 
      <td> <p>Vérifier si l'unité passée en paramètre est supportée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>OffsetTime minus(long amountToSubtract, TemporalUnit unit)</p> <p>OffsetTime minus(TemporalAmount amountToSubtract)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance à laquelle la quantité temporelle a été soustraite</p> </td> 
     </tr> 
     <tr> 
      <td> <p>OffsetTime minusHours(long hours)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance pour laquelle le nombre d'heures a été soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>OffsetTime minusMinutes(long minutes)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance pour laquelle le nombre de minutes a été soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>OffsetTime minusNanos(long nanos)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance pour laquelle le nombre de nanosecondes a été soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>OffsetTime minusSeconds(long seconds)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance pour laquelle le nombre de secondes a été soustrait</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static OffsetTime now()</p> </td> 
      <td> <p>Obtenir une instance à partir de l'heure système et fuseau horaire par défaut</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static OffsetTime now(Clock clock)</p> </td> 
      <td> <p>Obtenir une instance à partir de l'heure obtenue de l'objet passé en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static OffsetTime now(ZoneId zone)</p> </td> 
      <td> <p>Obtenir une instance à partir de l'heure système et du fuseau horaire passés en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static OffsetTime of(int hour, int minute, int second, int nanoOfSecond, ZoneOffset offset)</p> </td> 
      <td> <p>Obtenir une instance à partir de différents champs et du fuseau horaire passés en paramètres</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static OffsetTime of(LocalTime time, ZoneOffset offset)</p> </td> 
      <td> <p>Obtenir une instance à partir de l'objet temporel et du décalage horaire fournis en paramètres</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static OffsetTime ofInstant(Instant instant, ZoneId zone)</p> </td> 
      <td> <p>Obtenir une instance à partir de l'objet temporel, et du fuseau horaire fournis en paramètres</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static OffsetTime parse(CharSequence text)</p> </td> 
      <td> <p>Analyser le texte fourni en paramètre avec le Formatter par défaut pour obtenir une instance. Exemple «23:59:59+01:00»</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static OffsetTime parse(CharSequence text, DateTimeFormatter formatter)</p> </td> 
      <td> <p>Analyser le texte avec le Formatter fourni en paramètre pour obtenir une instance</p> </td> 
     </tr> 
     <tr> 
      <td> <p>OffsetTime plus(long amountToAdd, TemporalUnit unit)</p> <p>OffsetTime plus(TemporalAmount amountToAdd)</p> </td> 
      <td> <p>Obtenir une copie à laquelle la quantité temporelle a été ajoutée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>OffsetTime plusHours(long hours)</p> </td> 
      <td> <p>Obtenir une copie à laquelle le nombre d'heures a été ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>OffsetTime plusMinutes(long minutes)</p> </td> 
      <td> <p>Obtenir une copie à laquelle le nombre de minutes a été ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>OffsetTime plusNanos(long nanos)</p> </td> 
      <td> <p>Obtenir une copie à laquelle le nombre de nanosecondes a été ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>OffsetTime plusSeconds(long seconds)</p> </td> 
      <td> <p>Obtenir une copie à laquelle le nombre de secondes a été ajouté</p> </td> 
     </tr> 
     <tr> 
      <td> <p>&lt;R&gt; R query(TemporalQuery&lt;R&gt; query)</p> </td> 
      <td> <p>Renvoyer le résultat de l'exécution de la requête fournie en paramètre sur l'instance</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ValueRange range(TemporalField field)</p> </td> 
      <td> <p>Obtenir la plage de valeurs valides pour le champ fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>LocalTime toLocalTime()</p> </td> 
      <td> <p>Obtenir une instance de type LocalTime à partir des champs encapsulés</p> </td> 
     </tr> 
     <tr> 
      <td> <p>OffsetTime truncatedTo(TemporalUnit unit)</p> </td> 
      <td> <p>Obtenir une copie de l'instance tronquée à l'unité fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long until(Temporal endExclusive, TemporalUnit unit)</p> </td> 
      <td> <p>Calculer la quantité de temps exprimée dans l'unité fournie entre l'instance et l'objet temporel fournis en paramètres</p> </td> 
     </tr> 
     <tr> 
      <td> <p>OffsetTime with(TemporalAdjuster adjuster)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance ajustée grâce à l'objet fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>OffsetTime with(TemporalField field, long newValue)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dont la valeur du champ fournie en paramètre est remplacée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>OffsetTime withHour(int hour)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dont la valeur du champ heure est remplacée par celle fournie</p> </td> 
     </tr> 
     <tr> 
      <td> <p>OffsetTime withMinute(int minute)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dont la valeur du champ minute est remplacée par celle fournie</p> </td> 
     </tr> 
     <tr> 
      <td> <p>OffsetTime withNano(int nanoOfSecond)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dont la valeur du champ nanosecondes est remplacée par celle fournie</p> </td> 
     </tr> 
     <tr> 
      <td> <p>OffsetTime withOffsetSameInstant(ZoneOffset offset)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance représentant le même instant mais dans le décalage horaire fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>OffsetTime withOffsetSameLocal(ZoneOffset offset)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance représentant la même heure locale avec le décalage horaire fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>OffsetTime withSecond(int second)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dont la valeur du champ seconde est remplacée par celle fournie</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;
      
import java.time.OffsetTime;
import java.time.ZoneOffset;

public class TestOffsetTime {
  public static void main(String[] args) {
    OffsetTime time = OffsetTime.now();
    System.out.println(time);
    // changement du décalage en conservant le même point dans le temps
    ZoneOffset offset = ZoneOffset.ofHours(5);
    OffsetTime sameTimeDifferentOffset = time.withOffsetSameInstant(
        offset);
    System.out.println(sameTimeDifferentOffset);
    // changement du décalage en conservant la date/heure locale
    OffsetTime changeTimeWithNewOffset = time.withOffsetSameLocal(
        offset);
    System.out.println(changeTimeWithNewOffset);
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">13:38:53.187+01:00
17:38:53.187+05:00
13:38:53.187+05:00</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>OffsetTime est une classe de type value-based : il ne faut pas utiliser d'opérations sur une instance de type OffsetTime requérant l'identité de l'objet : opérateur ==, hashCode ou synchronisation. La comparaison de deux instances doit se faire en utilisant la méthode equals().</p> 
   <p>&nbsp;</p> 
   <h3 class="TITRESECTION2">
    <!--nchpdeb--><a name="utilisation_dates-6-8">102.6.8. 
     <!--nchpfin-->L'analyse et le formatage</a></h3> 
   <p>Les classes qui encapsulent une donnée temporelle proposent :</p> 
   <ul> 
    <li>la méthode parse() qui permet d'obtenir une instance à partir de l'analyse d'une représentation textuelle de la donnée</li> 
    <li>la méthode format() pour obtenir une représentation textuelle</li> 
   </ul> 
   <p>Ces opérations sont fréquemment utilisées pour sérialiser/désérialiser des données temporelles.</p> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-6-8-1">102.6.8.1. 
     <!--nchpfin-->La classe DateTimeFormatter</a></h4> 
   <p>L'analyse d'une chaîne de caractères pour obtenir un objet temporel ou le formatage d'un objet temporel pour obtenir une représentation textuelle se font grâce à des objets de type DateTimeFormatter.</p> 
   <p>Ces opérations se font sur la base d'un motif exprimé sous la forme d'une chaîne de caractères qui permet de préciser le format à utiliser.</p> 
   <p>La classe propose des constantes de type DateTimeFormatter qui encapsulent des motifs standard pour faciliter leurs utilisations.</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Nom</p> </td> 
      <td> <p>Rôle</p> </td> 
      <td> <p>Exemple</p> </td> 
     </tr> 
     <tr> 
      <td> <p>BASIC_ISO_DATE</p> </td> 
      <td> <p>Format ISO de base pour date sans décalage horaire</p> </td> 
      <td> <p>"20141225"</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ISO_DATE</p> </td> 
      <td> <p>Format ISO de date avec ou sans décalage horaire</p> </td> 
      <td> <p>"2014-12-25", "2014-12-25+01:00"</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ISO_DATE_TIME</p> </td> 
      <td> <p>Format ISO de date-heure avec ou sans fuseau horaire et décalage horaire</p> </td> 
      <td> <p>"2014-12-25T00:00:00", "2014-12-25T10:00:00+01:00", "2014-12-25T00:00:00+01:00[Europe/Paris]"</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ISO_INSTANT</p> </td> 
      <td> <p>Format ISO de date-heure en UTC</p> </td> 
      <td> <p>"2014-12-25T00:00:00Z"</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ISO_LOCAL_DATE</p> </td> 
      <td> <p>Format ISO de date sans fuseau horaire ni décalage horaire</p> </td> 
      <td> <p>"2014-12-25"</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ISO_LOCAL_DATE_TIME</p> </td> 
      <td> <p>Format ISO de date-heure sans fuseau horaire ni décalage horaire</p> </td> 
      <td> <p>"2014-12-25T00:00:00"</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ISO_LOCAL_TIME</p> </td> 
      <td> <p>Format ISO d'heure sans fuseau horaire ni décalage horaire</p> </td> 
      <td> <p>"20:15", "20:15:30"</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ISO_OFFSET_DATE</p> </td> 
      <td> <p>Format ISO de date avec décalage horaire</p> </td> 
      <td> <p>"2014-12-25+01:00".</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ISO_OFFSET_DATE_TIME</p> </td> 
      <td> <p>Format ISO de date-heure avec décalage horaire</p> </td> 
      <td> <p>"2014-12-25T00:00:00+01:00"</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ISO_OFFSET_TIME</p> </td> 
      <td> <p>Format ISO d'heure avec décalage horaire</p> </td> 
      <td> <p>"10:15+01:00", "10:15:30+01:00"</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ISO_ORDINAL_DATE</p> </td> 
      <td> <p>Format ISO de date exprimée en jour d'une année sans décalage horaire</p> </td> 
      <td> <p>"2014-359", "2014-359+01:00"</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ISO_TIME</p> </td> 
      <td> <p>Format ISO d'heure avec ou sans décalage horaire</p> </td> 
      <td> <p>"10:15", "10:15:30", "10:15:30+01:00"</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ISO_WEEK_DATE</p> </td> 
      <td> <p>Format ISO de date exprimée en semaine d'une année sans décalage horaire</p> </td> 
      <td> <p>"2014-W52-4", "2014-W52-4+01:00"</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ISO_ZONED_DATE_TIME</p> </td> 
      <td> <p>Format ISO avec fuseau horaire et décalage horaire</p> </td> 
      <td> <p>"2014-12-25T00:00:00+01:00[Europe/Paris]"</p> </td> 
     </tr> 
     <tr> 
      <td> <p>RFC_1123_DATE_TIME</p> </td> 
      <td> <p>Format RFC-1123 / RFC 822</p> </td> 
      <td> <p>"Thu, 25 Dec 2014 00:00:00 +0100"</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <p>La classe DateTimeFormatter permet d'exprimer son propre motif pour définir le format de la date-heure :</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Nom</p> </td> 
      <td> <p>Rôle</p> </td> 
      <td> <p>Type de format</p> </td> 
      <td> <p>Exemple</p> </td> 
     </tr> 
     <tr> 
      <td> <p>G</p> </td> 
      <td> <p>Ere</p> </td> 
      <td> <p>Texte</p> </td> 
      <td> <p>AD</p> </td> 
     </tr> 
     <tr> 
      <td> <p>u</p> </td> 
      <td> <p>Année</p> </td> 
      <td> <p>Année (Numérique)</p> </td> 
      <td> <p>2014,14</p> </td> 
     </tr> 
     <tr> 
      <td> <p>y</p> </td> 
      <td> <p>Année de l'ère</p> </td> 
      <td> <p>Année (Numérique)</p> </td> 
      <td> <p>2014,14</p> </td> 
     </tr> 
     <tr> 
      <td> <p>D</p> </td> 
      <td> <p>Jour de l'année</p> </td> 
      <td> <p>Numérique</p> </td> 
      <td> <p>352</p> </td> 
     </tr> 
     <tr> 
      <td> <p>M</p> </td> 
      <td> <p>Mois de l'année</p> </td> 
      <td> <p>Numérique</p> </td> 
      <td> <p>7,07</p> </td> 
     </tr> 
     <tr> 
      <td> <p>L</p> </td> 
      <td> <p>Mois de l'année</p> </td> 
      <td> <p>Texte</p> </td> 
      <td> <p>J, Jul, July</p> </td> 
     </tr> 
     <tr> 
      <td> <p>d</p> </td> 
      <td> <p>Jour du mois</p> </td> 
      <td> <p>Numérique</p> </td> 
      <td> <p>12</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Q</p> </td> 
      <td> <p>Trimestre de l'année</p> </td> 
      <td> <p>Numérique</p> </td> 
      <td> <p>3,03</p> </td> 
     </tr> 
     <tr> 
      <td> <p>q</p> </td> 
      <td> <p>Trimestre de l'année</p> </td> 
      <td> <p>Texte</p> </td> 
      <td> <p>Q3, 3rd quarter</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Y</p> </td> 
      <td> <p>Année</p> </td> 
      <td> <p>Année (Numérique)</p> </td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr> 
      <td> <p>w</p> </td> 
      <td> <p>Semaine de l'année</p> </td> 
      <td> <p>Numérique</p> </td> 
      <td> <p>35</p> </td> 
     </tr> 
     <tr> 
      <td> <p>W</p> </td> 
      <td> <p>Semaine du mois</p> </td> 
      <td> <p>Numérique</p> </td> 
      <td> <p>4</p> </td> 
     </tr> 
     <tr> 
      <td> <p>E</p> </td> 
      <td> <p>Jour de la semaine</p> </td> 
      <td> <p>Texte</p> </td> 
      <td> <p>J, Jeu, Jeudi</p> </td> 
     </tr> 
     <tr> 
      <td> <p>e</p> </td> 
      <td> <p>Jour de la semaine selon la Locale</p> </td> 
      <td> <p>Numérique</p> </td> 
      <td> <p>2; 02</p> </td> 
     </tr> 
     <tr> 
      <td> <p>c</p> </td> 
      <td> <p>Jour de la semaine selon la Locale</p> </td> 
      <td> <p>Texte</p> </td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr> 
      <td> <p>F</p> </td> 
      <td> <p>Semaine du mois</p> </td> 
      <td> <p>Numérique</p> </td> 
      <td> <p>3</p> </td> 
     </tr> 
     <tr> 
      <td> <p>a</p> </td> 
      <td> <p>Matin ou après midi</p> </td> 
      <td> <p>Texte</p> </td> 
      <td> <p>AM, PM</p> </td> 
     </tr> 
     <tr> 
      <td> <p>h</p> </td> 
      <td> <p>Heure de la demi-journée</p> </td> 
      <td> <p>Numérique (1-12)</p> </td> 
      <td> <p>1 10</p> </td> 
     </tr> 
     <tr> 
      <td> <p>K</p> </td> 
      <td> <p>Heure de la demi-journée</p> </td> 
      <td> <p>Numérique (0-11)</p> </td> 
      <td> <p>0 10</p> </td> 
     </tr> 
     <tr> 
      <td> <p>k</p> </td> 
      <td> <p>Heure de la journée</p> </td> 
      <td> <p>Numérique (1-24)</p> </td> 
      <td> <p>1 18</p> </td> 
     </tr> 
     <tr> 
      <td> <p>H</p> </td> 
      <td> <p>Heure de la journée</p> </td> 
      <td> <p>Numérique (0-23)</p> </td> 
      <td> <p>0 18</p> </td> 
     </tr> 
     <tr> 
      <td> <p>m</p> </td> 
      <td> <p>Minute de l'heure</p> </td> 
      <td> <p>Numérique</p> </td> 
      <td> <p>45</p> </td> 
     </tr> 
     <tr> 
      <td> <p>s</p> </td> 
      <td> <p>Seconde de l'heure</p> </td> 
      <td> <p>Numérique</p> </td> 
      <td> <p>59</p> </td> 
     </tr> 
     <tr> 
      <td> <p>S</p> </td> 
      <td> <p>Fraction de la seconde</p> </td> 
      <td> <p>Fraction (Numérique)</p> </td> 
      <td> <p>875</p> </td> 
     </tr> 
     <tr> 
      <td> <p>A</p> </td> 
      <td> <p>Milliseconde de la journée</p> </td> 
      <td> <p>Numérique</p> </td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr> 
      <td> <p>n</p> </td> 
      <td> <p>Nanoseconde de la seconde</p> </td> 
      <td> <p>Numérique</p> </td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr> 
      <td> <p>N</p> </td> 
      <td> <p>Nanoseconde de la journée</p> </td> 
      <td> <p>Numérique</p> </td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr> 
      <td> <p>V</p> </td> 
      <td> <p>Identifiant du fuseau horaire</p> </td> 
      <td> <p>Zone-id (Texte)</p> </td> 
      <td> <p>America/Los_Angeles</p> </td> 
     </tr> 
     <tr> 
      <td> <p>z</p> </td> 
      <td> <p>Nom du fuseau horaire</p> </td> 
      <td> <p>Nom-Zone (Texte)</p> </td> 
      <td> <p>Pacific Standard Time; PST</p> </td> 
     </tr> 
     <tr> 
      <td> <p>O</p> </td> 
      <td> <p>Décalage horaire</p> </td> 
      <td> <p>Offset-O (Texte)</p> </td> 
      <td> <p>GMT+8; GMT+08:00; UTC-08:00;</p> </td> 
     </tr> 
     <tr> 
      <td> <p>X</p> </td> 
      <td> <p>Décalage horaire</p> </td> 
      <td> <p>Offset-X (Texte)</p> </td> 
      <td> <p>Z; -08; -0830; -08:30; -083015; -08:30:15;</p> </td> 
     </tr> 
     <tr> 
      <td> <p>x</p> </td> 
      <td> <p>Décalage horaire</p> </td> 
      <td> <p>Offset-x (Texte)</p> </td> 
      <td> <p>+0000; -08; -0830; -08:30; -083015; -08:30:15;</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Z</p> </td> 
      <td> <p>Décalage horaire</p> </td> 
      <td> <p>Offset-Z (Texte)</p> </td> 
      <td> <p>+0000; -0800; -08:00;</p> </td> 
     </tr> 
     <tr> 
      <td> <p>p</p> </td> 
      <td> <p>Padding</p> </td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr> 
      <td> <p>'</p> </td> 
      <td> <p>Délimiteur d'une chaîne de caractères</p> </td> 
      <td> <p>Texte</p> </td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr> 
      <td> <p>''</p> </td> 
      <td> <p>Simple quote (doublée)</p> </td> 
      <td> <p>Texte</p> </td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr> 
      <td> <p>[</p> </td> 
      <td> <p>Début d'une partie optionnelle</p> </td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr> 
      <td> <p>]</p> </td> 
      <td> <p>Fin d'une partie optionnelle</p> </td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr> 
      <td> <p>#</p> </td> 
      <td> <p>Réservé</p> </td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr> 
      <td> <p>{</p> </td> 
      <td> <p>Réservé</p> </td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr> 
      <td> <p>}</p> </td> 
      <td> <p>Réservé</p> </td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <p>Toutes les lettres minuscules et majuscules sont réservées pour exprimer des données dans le motif.</p> 
   <p>Le nombre d'occurrences d'une lettre permet de préciser le format utilisé selon le type de format :</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Type de format</p> </td> 
      <td> <p>Nb occurrences</p> </td> 
      <td> <p>Format</p> </td> 
     </tr> 
     <tr> 
      <td rowspan="3"> <p>Texte</p> </td> 
      <td> <p>Inférieure à 4</p> </td> 
      <td> <p>Short</p> </td> 
     </tr> 
     <tr> 
      <td> <p>4</p> </td> 
      <td> <p>Full</p> </td> 
     </tr> 
     <tr> 
      <td> <p>5</p> </td> 
      <td> <p>Narrow</p> </td> 
     </tr> 
     <tr> 
      <td rowspan="2"> <p>Numérique</p> </td> 
      <td> <p>1</p> </td> 
      <td> <p>Minimum de chiffres sans padding</p> <p>Obligatoire pour c (jour de la semaine) et F (semaine du mois)</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Supérieur à 1</p> </td> 
      <td> <p>Le nombre d'occurrences précise la taille complétée avec des zéros au besoin</p> <p>Maximum 2 pour d, H, h, K, k, m et s</p> <p>Maximun 3 pour D</p> </td> 
     </tr> 
     <tr> 
      <td rowspan="2"> <p>Numérique/texte</p> </td> 
      <td> <p>Supérieur ou égal à 3</p> </td> 
      <td> <p>Format texte</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Inférieur à 3</p> </td> 
      <td> <p>Format numérique</p> </td> 
     </tr> 
     <tr> 
      <td rowspan="2"> <p>Fraction</p> </td> 
      <td> <p>9</p> </td> 
      <td> <p>Affichage intégral</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Inférieur à 9</p> </td> 
      <td> <p>Tronquée au nombre d'occurrences</p> </td> 
     </tr> 
     <tr> 
      <td rowspan="2"> <p>Year</p> </td> 
      <td> <p>2</p> </td> 
      <td> <p>Deux chiffres complétés au besoin par un zéro</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Supérieur à 2</p> </td> 
      <td> <p>Format intégral</p> </td> 
     </tr> 
     <tr> 
      <td rowspan="2"> <p>Zone-Id</p> </td> 
      <td> <p>2</p> </td> 
      <td> <p>Format intégral</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Différent de 2</p> </td> 
      <td> <p>IllegalArgumentException</p> </td> 
     </tr> 
     <tr> 
      <td rowspan="3"> <p>Nom-zone</p> </td> 
      <td> <p>1, 2, 3</p> </td> 
      <td> <p>Nom court</p> </td> 
     </tr> 
     <tr> 
      <td> <p>4</p> </td> 
      <td> <p>Nom long</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Supérieur à 4</p> </td> 
      <td> <p>IllegalArgumentException</p> </td> 
     </tr> 
     <tr> 
      <td rowspan="6"> <p>Offset-X et Offset-x</p> <p>(x affiche des zéros,</p> <p>X affiche Z pour un zéro)</p> </td> 
      <td> <p>1</p> </td> 
      <td> <p>Uniquement les heures et éventuellement les minutes si elles ne sont pas égales à zéro. Exemple +01</p> </td> 
     </tr> 
     <tr> 
      <td> <p>2</p> </td> 
      <td> <p>Heures et minutes sans séparateur. Exemple +0145</p> </td> 
     </tr> 
     <tr> 
      <td> <p>3</p> </td> 
      <td> <p>Heures et minutes avec un caractère deux points comme séparateur. Exemple +01:45</p> </td> 
     </tr> 
     <tr> 
      <td> <p>4</p> </td> 
      <td> <p>Heures, minutes et secondes sans séparateur. Exemple +014530</p> </td> 
     </tr> 
     <tr> 
      <td> <p>5</p> </td> 
      <td> <p>Heures, minutes et secondes avec un caractère deux points comme séparateur. Exemple +01:45:30</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Supérieur à 5</p> </td> 
      <td> <p>IllegalArgumentException</p> </td> 
     </tr> 
     <tr> 
      <td rowspan="3"> <p>Offset-O</p> </td> 
      <td> <p>1</p> </td> 
      <td> <p>Format court avec les heures non précédées par un zéro. Les minutes et les secondes sont optionnelles. Exemple GMT+1</p> </td> 
     </tr> 
     <tr> 
      <td> <p>4</p> </td> 
      <td> <p>Format long avec les heures et les minutes précédées par un zéro au besoin. Les secondes sont optionnelles. Elles sont séparées par un caractère deux points. Exemple GMT+01:00</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Autres valeurs</p> </td> 
      <td> <p>IllegalArgumentException</p> </td> 
     </tr> 
     <tr> 
      <td rowspan="4"> <p>Offset-Z</p> </td> 
      <td> <p>1, 2, 3</p> </td> 
      <td> <p>Uniquement les heures et les minutes. Exemple +0100, +0000</p> </td> 
     </tr> 
     <tr> 
      <td> <p>4</p> </td> 
      <td> <p>Format long avec les heures et les minutes précédées par un zéro au besoin. Les secondes sont optionnelles. Elles sont séparées par un caractère deux points. Exemple GMT+01:00, GMT+00:00</p> </td> 
     </tr> 
     <tr> 
      <td> <p>5</p> </td> 
      <td> <p>Idem mais Z si l'offset est zéro</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Supérieur à 5</p> </td> 
      <td> <p>IllegalArgumentException</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <p>La lettre p permet de modifier le mode de padding par espaces de l'élément suivant. Le nombre d'occurrences de la lettre p permet de préciser la taille de l'élément.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;
      
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.Month;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;

public class TestDateTimeFormatter {
  public static void main(String[] args) {
    ZonedDateTime date = ZonedDateTime.of(LocalDateTime.of(2014, 
      Month.DECEMBER, 25, 0,0,0), ZoneId.of("GMT"));
    DateTimeFormatter formatter = 
      DateTimeFormatter.ofPattern("dd ppppppppppMMM yyyy xxx");    
    String dateTimeStr = date.format(formatter);
    System.out.println(dateTimeStr);   
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">25       déc. 2014 +00:00</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Toutes les lettres non reconnues lèvent une exception. Tous les caractères différents de '[', ']', '{', '}' et '#' sont utilisés tels quels. Il est cependant recommandé d'entourés ces caractères par des quotes simples pour garantir la compatibilité avec de futures versions.</p> 
   <p>En plus du motif du format à utiliser, il est possible de préciser plusieurs éléments à utiliser dans les traitements :</p> 
   <ul> 
    <li>la Locale qui peut avoir des impacts sur le formatage et l'analyse</li> 
    <li>le calendrier qui sera utilisé pour convertir l'objet temporel avant son formatage et après l'analyse</li> 
    <li>le fuseau horaire qui sera utilisé pour convertir l'objet temporel avant son formatage et après l'analyse</li> 
    <li>le DecimalStyle</li> 
   </ul> 
   <p>La classe DateTimeFormatter possède de nombreuses méthodes :</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Méthode</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>String format(TemporalAccessor temporal)</p> </td> 
      <td> <p>Formater l'objet temporel fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>void formatTo(TemporalAccessor temporal, Appendable appendable)</p> </td> 
      <td> <p>Formater l'objet temporel fourni en paramètre et l'ajouter à l'Appendable</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Chronology getChronology()</p> </td> 
      <td> <p>Obtenir le calendrier utilisé lors des traitements</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DecimalStyle getDecimalStyle()</p> </td> 
      <td> <p>Obtenir l'objet de type DecimalStyle utilisé lors des traitements</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Locale getLocale()</p> </td> 
      <td> <p>Obtenir la Locale utilisée lors des traitements</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Set&lt;TemporalField&gt; getResolverFields()</p> </td> 
      <td> <p>Permet de définir les champs qui seront utilisés pour définir l'objet temporel lors de la phase d'analyse. Par défaut, une instance de type DateTimeFormatter ne possède aucun resolver</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ResolverStyle getResolverStyle()</p> </td> 
      <td> <p>Obtenir le style de résolution utilisé par l'instance. Par défaut, une instance de type DataTimeFormatter possède le style SMART</p> </td> 
     </tr> 
     <tr> 
      <td> <p>ZoneId getZone()</p> </td> 
      <td> <p>Obtenir le fuseau horaire utilisé lors des traitements</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static DateTimeFormatter ofLocalizedDate(FormatStyle dateStyle)</p> </td> 
      <td> <p>Obtenir une instance pour le calendrier ISO tenant compte de la Locale pour des dates</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static DateTimeFormatter ofLocalizedDateTime(FormatStyle dateTimeStyle)</p> <p>static DateTimeFormatter ofLocalizedDateTime(FormatStyle dateStyle, FormatStyle timeStyle)</p> </td> 
      <td> <p>Obtenir une instance pour le calendrier ISO tenant compte de la Locale pour des dates heures</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static DateTimeFormatter ofLocalizedTime(FormatStyle timeStyle)</p> </td> 
      <td> <p>Obtenir une instance pour le calendrier ISO tenant compte de la Locale pour des heures</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static DateTimeFormatter ofPattern(String pattern)</p> </td> 
      <td> <p>Obtenir une instance qui utilise le motif passé en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static DateTimeFormatter ofPattern(String pattern, Locale locale)</p> </td> 
      <td> <p>Obtenir une instance qui utilise le motif et la Locale passés en paramètres</p> </td> 
     </tr> 
     <tr> 
      <td> <p>TemporalAccessor parse(CharSequence text)</p> </td> 
      <td> <p>Analyser la chaîne de caractères fournie en paramètre pour obtenir une instance d'un objet temporel</p> </td> 
     </tr> 
     <tr> 
      <td> <p>TemporalAccessor parse(CharSequence text, ParsePosition position)</p> </td> 
      <td> <p>Analyser le texte fourni à partir de la position précisée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>&lt;T&gt; T parse(CharSequence text, TemporalQuery&lt;T&gt; query)</p> </td> 
      <td> <p>Analyser le texte pour obtenir une instance du type précisé par la requête</p> </td> 
     </tr> 
     <tr> 
      <td> <p>TemporalAccessor parseBest(CharSequence text, TemporalQuery&lt;?&gt;... queries)</p> </td> 
      <td> <p>Analyser au mieux le texte pour renvoyer une instance d'un des types précisés par les requêtes fournies</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static TemporalQuery&lt;Period&gt; parsedExcessDays()</p> </td> 
      <td> <p>Retourner une requête qui permet d'obtenir une instance de type Period contenant un nombre de jours supplémentaires résultant de l'analyse. Cette période peut par exemple valoir un jour selon le ResolutionStyle et la valeur 24:00 pour l'heure</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static TemporalQuery&lt;Boolean&gt; parsedLeapSecond()</p> </td> 
      <td> <p>Retourner une requête qui permet de déterminer si l'analyse à trouver une leap-second (la valeur de la seconde est 60)</p> </td> 
     </tr> 
     <tr> 
      <td> <p>TemporalAccessor parseUnresolved(CharSequence text, ParsePosition position)</p> </td> 
      <td> <p>Effectuer l'analyse pour extraire les champs sans les résoudre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Format toFormat()</p> </td> 
      <td> <p>Assurer une certaine compatibilité en retournant une implémentation de type java.text.Format de l'instance</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Format toFormat(TemporalQuery&lt;?&gt; parseQuery)</p> </td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr> 
      <td> <p>DateTimeFormatter withChronology(Chronology chrono)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance qui utilise le calendrier fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTimeFormatter withDecimalStyle(DecimalStyle decimalStyle)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance qui utilise le DecimalStyle fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTimeFormatter withLocale(Locale locale)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance qui utilise la Locale fournie en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTimeFormatter withResolverFields(Set&lt;TemporalField&gt; resolverFields)</p> <p>DateTimeFormatter withResolverFields(TemporalField... resolverFields)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dans laquelle les champs qui seront utilisés pour définir l'objet temporel lors de la phase d'analyse sont précisés</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTimeFormatter withResolverStyle(ResolverStyle resolverStyle)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance dans laquelle le style de résolution est modifié avec celui fourni en paramètre (LENIENT, SMART, STRICT)</p> </td> 
     </tr> 
     <tr> 
      <td> <p>DateTimeFormatter withZone(ZoneId zone)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance qui utilise le fuseau horaire fourni en paramètre</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <p>L'analyse d'une chaîne de caractères par rapport au motif se fait en deux phases :</p> 
   <ul> 
    <li>l'analyse du texte en utilisant le motif crée une collection de type Map qui contient pour chaque champ, la valeur ainsi qu'un calendrier et un fuseau horaire</li> 
    <li>le contenu de la Map est validé et combiné dans une étape nommée résolution</li> 
   </ul> 
   <p>La méthode parseUnresolved() ne réalise que la première étape, ce qui réserve son utilisation à des besoins très spécifiques de bas niveau.</p> 
   <p>L'étape de résolution peut être configurée grâce à deux propriétés :</p> 
   <ul> 
    <li>ResolverStyle qui est une énumération du mode de résolution : strict, smart (par défaut) et lenient</li> 
    <li>resolverFields qui permet de préciser quels champs doivent être utilisés pour la résolution</li> 
   </ul> 
   <p>La résolution est un processus complexe. Il est possible que l'analyse extrait plusieurs champs : année, mois, jour du mois et jour de l'année. Pour composer la date, il est possible d'utiliser :</p> 
   <ul> 
    <li>soit année, mois, jour du mois</li> 
    <li>soit année et jour de l'année</li> 
   </ul> 
   <p>La définition de la propriété resolverFields permet de définir les champs à utiliser. Si la propriété n'est pas définie dans le cas ci-dessus, alors les deux résolutions sont effectuées et doivent renvoyer le même résultat.</p> 
   <p>Les méthodes d'analyse et de formatage lève une exception en cas de problème durant leur exécution :</p> 
   <ul> 
    <li>DateTimeParseException durant une analyse</li> 
    <li>DateTimeException durant un formatage</li> 
   </ul> 
   <p>Plusieurs méthodes de l'API permettent de faciliter l'utilisation d'un DateTimeFormatter.</p> 
   <p>La méthode format() d'un objet de type ChronoLocalDate permet d'obtenir une représentation de l'instance sous une forme textuelle en utilisant le DateTimeFormatter fourni en paramètre.</p> 
   <p>La méthode parse() de la classe LocalDate qui attend en paramètre la chaîne de caractères à analyser utilise le Formatter ISO_LOCAL_DATE. Une surcharge de la méthode parse() attend un second paramètre de type DateTimeFormatter qui permet de préciser le formateur à utiliser.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;
      
import java.time.LocalDateTime;
import java.time.Month;
import java.time.format.DateTimeFormatter;

public class TestDateTimeFormatter {
  public static void main(String[] args) {
           
    String dateStr = "";
    LocalDateTime dateTime = LocalDateTime.of(2014, Month.DECEMBER, 25, 0,0,0);
    System.out.println(dateTime.format(DateTimeFormatter.BASIC_ISO_DATE));   
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">20141225</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Il est aussi possible de définir son propre format.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;
      
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.Month;
import java.time.format.DateTimeFormatter;

public class TestDateTimeFormatter {
  public static void main(String[] args) {
    LocalDateTime dateTime = LocalDateTime.of(2014, Month.DECEMBER, 25, 0,0,0);
    DateTimeFormatter formatter =
      DateTimeFormatter.ofPattern("dd MMM yyyy");
    String dateTimeStr = dateTime.format(formatter);
    System.out.println(dateTimeStr);  

    LocalDate date = LocalDate.parse(dateTimeStr, formatter);
    System.out.println(date);  
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">25 déc. 2014
2014-12-25</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>La méthode parseBest() permet d'obtenir un objet temporel dont les types possibles sont fournis en paramètre sous la forme de requêtes. Ceci est pratique lorsque le motif possède des parties optionnelles : selon le texte fourni, plusieurs types d'objets temporels peuvent être obtenus. Cette méthode tente de renvoyer la plus complète possible en fonction du texte.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;
      
import java.time.LocalDateTime;
import java.time.Month;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.time.temporal.TemporalAccessor;

public class TestDateTimeFormatter {
  public static void main(String[] args) {
    parseBest("2014-12-25 00:00");
    parseBest("2014-12-25 00:00[Europe/Paris]");
  }
  
  private static void parseBest(String str) {
    System.out.println("Texte = " + str);
    DateTimeFormatter formatter = DateTimeFormatter.ofPattern("uuuu-MM-dd HH:mm['['VV']']");
    TemporalAccessor dt = formatter.parseBest(str, ZonedDateTime::from, LocalDateTime::from);
    if (dt instanceof ZonedDateTime) {
      System.out.println("ZonedDateTime obtenu = " + dt);
    } else {
      System.out.println("LocalDateTime obtenu = " + dt);
    }
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">Texte = 2014-12-25 00:00
LocalDateTime obtenu = 2014-12-25T00:00
Texte = 2014-12-25 00:00[Europe/Paris]
ZonedDateTime obtenu =
2014-12-25T00:00+01:00[Europe/Paris]</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>La classe DateTimeFormatter est immuable et thread-safe : elle peut donc sans soucis être définie comme variable static.</p> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-6-8-2">102.6.8.2. 
     <!--nchpfin-->La classe DateTimeFormatterBuilder</a></h4> 
   <p>La classe DateTimeFormatterBuilder permet de faciliter la composition dynamique d'un motif complexe encapsulé dans une instance de type DateTimeFormatter.</p> 
   <p>Elle possède de nombreuses méthodes à invoquer successivement pour composer le motif. La méthode toFormatter() permet d'obtenir l'instance une fois la composition réalisée.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;
      
import java.time.LocalDate;
import java.time.ZonedDateTime;
import java.time.chrono.Chronology;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeFormatterBuilder;
import java.time.format.FormatStyle;
import java.time.temporal.ChronoField;
import java.util.Locale;

public class TestDateTimeFormatterBuilder {
  public static void main(String[] args) {
    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();
    builder.appendText(ChronoField.DAY_OF_MONTH);
    builder.appendLiteral(" ");
    builder.appendText(ChronoField.MONTH_OF_YEAR);
    builder.appendLiteral(" ");
    builder.appendText(ChronoField.YEAR);
    DateTimeFormatter formatter = builder.toFormatter();
    System.out.println(formatter.toString());
    System.out.println(formatter.format(LocalDate.now()));
    String motif = DateTimeFormatterBuilder.getLocalizedDateTimePattern(
       FormatStyle.FULL, FormatStyle.FULL, Chronology.of("ISO"), Locale.FRENCH);
    System.out.println(motif);
    formatter = DateTimeFormatter.ofPattern(motif);   
    System.out.println(formatter.format(ZonedDateTime.now()));
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">Text(DayOfMonth)' 'Text(MonthOfYear)' 'Text(Year)
25 février 2015
EEEE d MMMM yyyy HH' h 'mm z
mercredi 25 février 2015 23 h 57 CET</pre></td>
     </tr>
    </tbody>
   </table> 
   <p>&nbsp;</p> 
   <h3 class="TITRESECTION2">
    <!--nchpdeb--><a name="utilisation_dates-6-9">102.6.9. 
     <!--nchpfin-->Les calendriers</a></h3> 
   <p>Par défaut, l'API Date-Time utilise le calendrier ISO-8601 qui repose sur le calendrier Grégorien.</p> 
   <p>Le package java.time.chrono propose plusieurs autres implémentations de calendriers : Hijrah, Japanese, Minguo, ThaiBuddhist.</p> 
   <p>L'interface Chronology définit les fonctionnalités d'un calendrier. Un calendrier permet de représenter de manière humaine un point dans le temps.</p> 
   <p>L'interface Era définit les fonctionnalités d'une ère. Généralement un calendrier contient deux ères mais certains calendriers sont divisés en plusieurs ères comme par exemple le calendrier japonais.</p> 
   <p>Plusieurs interfaces permettent de définir les fonctionnalités d'un objet temporel pour un calendrier :</p> 
   <ul> 
    <li>ChronoLocalDate : définit les fonctionnalités pour manipuler une date sans heure dans un calendrier quelconque sans fuseau horaire</li> 
    <li>ChronoLocalDateTime : définit les fonctionnalités pour manipuler une date et une heure dans un calendrier quelconque sans fuseau horaire</li> 
    <li>ChronoZonedDateTime : définit les fonctionnalités pour manipuler une date et une heure dans un calendrier quelconque avec un fuseau horaire</li> 
   </ul> 
   <p>L'utilisation de ces interfaces est à réserver pour des besoins calendaires spécifiques et ne devrait pas être utilisée dans un contexte courant.</p> 
   <p>Chaque calendrier doit proposer une implémentation de Chronology, ChronoLocalDate et Era. Le JDK 8 fournit en standard plusieurs implémentations de calendriers :</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Calendrier</p></td> 
      <td> <p align="center">Chronology</p></td> 
      <td> <p align="center">ChronoLocalDate</p></td> 
      <td> <p align="center">Era</p></td> 
     </tr> 
     <tr> 
      <td> <p>ISO</p></td> 
      <td> <p align="center">IsoChronology</p></td> 
      <td> <p align="center">LocalDate</p></td> 
      <td> <p align="center">IsoEra</p></td> 
     </tr> 
     <tr> 
      <td> <p>Hijrah</p></td> 
      <td> <p align="center">HijrahChronology</p></td> 
      <td> <p align="center">HijrahDate</p></td> 
      <td> <p align="center">HijrahEra</p></td> 
     </tr> 
     <tr> 
      <td> <p>Japanese</p></td> 
      <td> <p align="center">JapaneseChronology</p></td> 
      <td> <p align="center">JapaneseDate</p></td> 
      <td> <p align="center">JapaneseEra</p></td> 
     </tr> 
     <tr> 
      <td> <p>Minguo</p></td> 
      <td> <p align="center">MinguoChronology</p></td> 
      <td> <p align="center">MinguoDate</p></td> 
      <td> <p align="center">MinguoEra</p></td> 
     </tr> 
     <tr> 
      <td> <p>ThaiBuddhist</p></td> 
      <td> <p align="center">ThaiBuddhistChronology</p></td> 
      <td> <p align="center">ThaiBuddhistDate</p></td> 
      <td> <p align="center">ThaiBuddhistEra</p></td> 
     </tr> 
    </tbody>
   </table> 
   <br> 
   <p>La méthode from() d'un calendrier permet de convertir l'objet temporel fourni en paramètre pour obtenir sa représentation dans le calendrier. Elle lève une exception de type DateTimeException si cette conversion échoue.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;
      
import java.time.LocalDate;
import java.time.Month;
import java.time.chrono.HijrahChronology;
import java.time.chrono.HijrahDate;
import java.time.chrono.JapaneseChronology;
import java.time.chrono.JapaneseDate;
import java.time.chrono.MinguoChronology;
import java.time.chrono.MinguoDate;
import java.time.chrono.ThaiBuddhistChronology;
import java.time.chrono.ThaiBuddhistDate;
import java.time.format.DateTimeFormatter;
import java.time.format.FormatStyle;
import java.util.Locale;

public class TestChronology {
  public static void main(String[] args) {
    LocalDate date = LocalDate.of(2014, Month.DECEMBER, 25);
    DateTimeFormatter dtf = DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT)
                            .withLocale(Locale.getDefault(Locale.Category.FORMAT));
        
    JapaneseDate jdate = JapaneseDate.from(date);
    dtf = dtf.withChronology(JapaneseChronology.INSTANCE);
    System.out.println("Japanese      : "+dtf.format(jdate));
    
    HijrahDate hdate = HijrahDate.from(date);
    dtf = dtf.withChronology(HijrahChronology.INSTANCE);
    System.out.println("Hijrah        : "+dtf.format(hdate));
    
    MinguoDate mdate = MinguoDate.from(date);
    dtf = dtf.withChronology(MinguoChronology.INSTANCE);
    System.out.println("Minguo        : "+dtf.format(mdate));
    
    ThaiBuddhistDate tdate = ThaiBuddhistDate.from(date);
    dtf = dtf.withChronology(ThaiBuddhistChronology.INSTANCE);
    System.out.println("Thai Buddhist : "+dtf.format(tdate));
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">Japanese      : 25/12/26 H
Hijrah        : 3/3/1436 AH
Minguo        : 25/12/103 1
Thai Buddhist : 25/12/2557</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Inversement, il est possible de convertir une date d'un calendrier différent d'ISO en la passant en paramètre de la méthode from() de la classe LocalDate.</p> 
   <p>&nbsp;</p> 
   <h3 class="TITRESECTION2">
    <!--nchpdeb--><a name="utilisation_dates-6-10">102.6.10. 
     <!--nchpfin-->Les autres classes de l'API</a></h3> 
   <p>L'API Date-Time propose quelques classes et interfaces pour des fonctionnalités spécifiques.</p> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-6-10-1">102.6.10.1. 
     <!--nchpfin-->La classe Clock</a></h4> 
   <p>Une instance de type Clock permet d'obtenir une date-heure «courante» dans un fuseau horaire.</p> 
   <p>L'implémentation par défaut est équivalente à une utilisation de la méthode currentTimeMillis() de la classe System et de la méthode getDefault() de la classe TimeZone.</p> 
   <p>L'utilisation d'une instance de type Clock est facultative car la plupart des classes qui encapsulent des données temporelles possèdent une méthode now() qui permet de créer une instance encapsulant tout ou partie de la date-heure système dans le fuseau horaire par défaut. Cette méthode utilise une instance de type Clock pour obtenir ces informations du système d'exploitation.</p> 
   <p>Une surcharge de la méthode now() attend en paramètre un objet de type Clock qui permet de fournir sa propre implémentation.</p> 
   <p>Cependant, le but de la classe Clock est de fournir facilement une implémentation alternative : ceci peut être particulièrement intéressant notamment pour les tests automatisés. Une bonne pratique est alors de permettre l'injection d'une instance de type Clock et d'utiliser cette dernière pour obtenir l'instant courant. Cela permet par exemple d'utiliser l'implémentation par défaut en production et d'utiliser une instance obtenue en invoquant la fabrique fixed() ou offset() lors des tests automatisés. Ceci pour, par exemple, tester le code dans différents fuseaux horaires ou renvoyer systématiquement le même instant à chaque invocation.</p> 
   <p>La classe Clock est abstraite : il n'est pas possible d'en créer une instance en utilisant l'opérateur new. Il est obligatoire d'utiliser une des méthodes statiques qui sont des fabriques : systemDefaultZone(), system(ZoneId), offset(Clock, Duration), systemUTC(), fixed(Instant, ZoneId), tick(Clock, Duration), tickMinutes(ZoneId) et tickSeconds(ZoneId).</p> 
   <p>Elle possède plusieurs méthodes :</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Méthode</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>boolean equals(Object obj)</p> </td> 
      <td> <p>Vérifier l'égalité avec l'objet fourni en paramètre</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Clock fixed(Instant fixedInstant, ZoneId zone)</p> </td> 
      <td> <p>Obtenir une instance qui renvoie toujours le même instant</p> </td> 
     </tr> 
     <tr> 
      <td> <p>abstract ZoneId getZone()</p> </td> 
      <td> <p>Obtenir le fuseau horaire utilisé lors de la détermination des dates et heures</p> </td> 
     </tr> 
     <tr> 
      <td> <p>abstract Instant instant()</p> </td> 
      <td> <p>Obtenir l'instant courant de l'horloge</p> </td> 
     </tr> 
     <tr> 
      <td> <p>long millis()</p> </td> 
      <td> <p>Obtenir le nombre de millisecondes courantes de l'horloge depuis le 1er janvier 1970</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Clock offset(Clock baseClock, Duration offsetDuration)</p> </td> 
      <td> <p>Obtenir une instance qui va utiliser l'instance de type Clock passée en paramètre pour obtenir la date-heure de base et appliquée la durée fournie comme décalage</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Clock system(ZoneId zone)</p> </td> 
      <td> <p>Obtenir une instance qui utilise l'horloge système</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Clock systemDefaultZone()</p> </td> 
      <td> <p>Obtenir une instance qui utilise l'horloge système dans le fuseau horaire par défaut</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Clock systemUTC()</p> </td> 
      <td> <p>Obtenir une instance qui utilise l'horloge système dans le fuseau horaire UTC</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Clock tick(Clock baseClock, Duration tickDuration)</p> </td> 
      <td> <p>Obtenir une instance qui renvoie l'instant de la Clock fournie en paramètre tronquée avec la durée fournie</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Clock tickMinutes(ZoneId zone)</p> </td> 
      <td> <p>Obtenir l'instant courant de l'horloge avec les nanosecondes et les secondes toujours à zéro</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static Clock tickSeconds(ZoneId zone)</p> </td> 
      <td> <p>Obtenir l'instant courant de l'horloge avec les nanosecondes toujours à zéro</p> </td> 
     </tr> 
     <tr> 
      <td> <p>abstract Clock withZone(ZoneId zone)</p> </td> 
      <td> <p>Renvoyer une copie de l'instance courante qui utilise le fuseau horaire passé en paramètre</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;
      
import java.time.Clock;
import java.time.Duration;
import java.time.Instant;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Locale;

public class TestClock {
  public static void main(String[] args) {
    Clock clock = Clock.systemDefaultZone();
    Instant instant = clock.instant();
    System.out.println("instant=    "+instant);
    DateTimeFormatter df = 
      DateTimeFormatter.ofPattern("uuuu-MM-dd hh:mm:ss",Locale.FRENCH);
    System.out.println("            "
      +df.format(ZonedDateTime.ofInstant(instant, ZoneId.systemDefault())));
    clock = Clock.systemUTC();
    System.out.println("systemUTC=  "+clock.instant());
    clock = Clock.system(ZoneId.of("America/Los_Angeles"));
    System.out.println("system=     "+clock.instant());
    clock = Clock.fixed(Instant.parse("2014-12-25T23:59:59Z"), ZoneId.systemDefault());
    System.out.println("fixed=      "+clock.instant());
    clock = Clock.tick(Clock.systemDefaultZone(), Duration.ofDays(400L));
    System.out.println("tick=       "+clock.instant());
    clock = Clock.tick(Clock.systemDefaultZone(), Duration.ofHours(2L));
    System.out.println("tick=       "+clock.instant());
    clock = Clock.tickMinutes(ZoneId.systemDefault());
    System.out.println("tickMinutes="+clock.instant());
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">instant=    2015-02-10T06:18:52.156Z
            2015-02-10 07:18:52
systemUTC=  2015-02-10T06:18:52.203Z
system=     2015-02-10T06:18:52.203Z
fixed=      2014-12-25T23:59:59Z
tick=       2014-11-26T00:00:00Z
tick=       2015-02-10T06:00:00Z
tickMinutes=2015-02-10T06:18:00Z</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Par défaut, les instances obtenues avec l'implémentation fournie par le JDK tentent d'utiliser la meilleure horloge disponible sur le système : par défaut c'est la méthode currentTimeMillis() de la classe System ou une autre solution si une meilleure est disponible sur le système pour obtenir l'instant courant. La méthode currentTimeMillis() de la classe System possède cependant des limites en termes de précision et de véracité. Il est possible de définir ses propres implémentations de la classe Clock pour par exemple utiliser un serveur NTP.</p> 
   <p>Une implémentation personnelle de classe Clock doit respecter plusieurs recommandations :</p> 
   <ul> 
    <li>être final, immuable et thread-safe</li> 
    <li>certaines méthodes peuvent lever une exception mais cela devrait être dans des cas particuliers</li> 
    <li>l'implémentation peut être Serializable</li> 
   </ul> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-6-10-2">102.6.10.2. 
     <!--nchpfin-->L'interface TemporalAdjuster et la classe TemporalAdjusters</a></h4> 
   <p>L'interface java.time.temporal.TemporalAdjuster définit le contrat d'un objet qui contient des traitements pour ajuster une date encapsulée sous la forme d'un type Temporal tel que le premier ou le dernier jour du mois, le prochain mardi, le troisième vendredi du mois, ...</p> 
   <p>Elle ne définit qu'une seule méthode :</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Méthode</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Temporal adjustInto(Temporal temporal)</p> </td> 
      <td> <p>Renvoyer une copie ajustée de l'objet temporel fourni en paramètre</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <p>La classe TemporalAdjusters propose plusieurs méthodes statiques qui renvoient des implémentations de type TemporalAdjuster pour réaliser plusieurs ajustements courants :</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Méthode</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static TemporalAdjuster dayOfWeekInMonth(int ordinal, DayOfWeek dayOfWeek)</p> </td> 
      <td> <p>Renvoyer une instance qui encapsule la date courante ajustée au N-ième (précisé par le paramètre ordinal) jour de la semaine (précisé par le paramètre dayOfWeek) du même mois</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static TemporalAdjuster firstDayOfMonth()</p> </td> 
      <td> <p>Renvoyer une instance qui encapsule la date courante ajustée au premier jour du mois</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static TemporalAdjuster firstDayOfNextMonth()</p> </td> 
      <td> <p>Renvoyer une instance qui encapsule la date courante ajustée au premier jour du mois suivant</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static TemporalAdjuster firstDayOfNextYear()</p> </td> 
      <td> <p>Renvoyer une instance qui encapsule la date courante ajustée au premier jour de l'année suivante</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static TemporalAdjuster firstDayOfYear()</p> </td> 
      <td> <p>Renvoyer une instance qui encapsule la date courante ajustée au premier jour de l'année</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static TemporalAdjuster firstInMonth(DayOfWeek dayOfWeek)</p> </td> 
      <td> <p>Renvoyer une instance qui encapsule la date courante ajustée sur le premier dayOfWeek du mois</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static TemporalAdjuster lastDayOfMonth()</p> </td> 
      <td> <p>Renvoyer une instance qui encapsule la date courante ajustée au dernier jour du mois</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static TemporalAdjuster lastDayOfYear()</p> </td> 
      <td> <p>Renvoyer une instance qui encapsule la date courante ajustée au dernier jour de l'année</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static TemporalAdjuster lastInMonth(DayOfWeek dayOfWeek)</p> </td> 
      <td> <p>Renvoyer une instance qui encapsule la date courante ajustée sur le dernier dayOfWeek du même mois</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static TemporalAdjuster next(DayOfWeek dayOfWeek)</p> </td> 
      <td> <p>Renvoyer une instance qui encapsule la date courante ajustée au prochain dayOfWeek</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static TemporalAdjuster nextOrSame(DayOfWeek dayOfWeek)</p> </td> 
      <td> <p>Renvoyer une instance qui ajuste la date à la première occurrence du dayOfWeek qui suit la date ajustée sauf si ce jour est déjà atteint auquel cas la même instance est retournée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static TemporalAdjuster ofDateAdjuster(UnaryOperator&lt;LocalDate&gt; dateBasedAdjuster)</p> </td> 
      <td> <p>Obtenir une instance qui encapsule l'objet de type UnaryOperator&lt;LocalDate&gt; réalisant l'ajustement</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static TemporalAdjuster previous(DayOfWeek dayOfWeek)</p> </td> 
      <td> <p>Renvoyer une instance qui ajuste la date sur la première occurrence du dayOfWeek fourni qui précède la date à ajuster</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static TemporalAdjuster previousOrSame(DayOfWeek dayOfWeek)</p> </td> 
      <td> <p>Renvoyer une instance qui ajuste la date sur la première occurrence du dayOfWeek fourni qui précède la date ajustée sauf si ce jour est déjà atteint auquel cas la même instance est retournée</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <p>L'ajustement de ces méthodes ne concerne que la date : par exemple, si l'instance fournie en paramètre est de type ZonedDateTime alors la valeur retournée aura l'heure et le fuseau horaire originaux.</p> 
   <p>Toutes les instances retournées par les méthodes statiques sont immuables.</p> 
   <p>Il existe deux manières d'utiliser un TemporalAdjuster :</p> 
   <ul> 
    <li>invoquer la méthode adjustInto() de l'instance de type TemporalAdjuster en lui passant l'objet temporel en paramètre</li> 
    <li>invoquer la méthode with() de l'objet temporel en lui passant l'instance de type TemporalAdjuster en paramètre</li> 
   </ul> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;
      
import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.Month;
import static java.time.temporal.TemporalAdjusters.*;

public class TestTemporalAdjuster {
 
  public static void main(String[] args) {
    LocalDate date = LocalDate.of(2015, Month.JANUARY, 31);
    System.out.println("premier jour du mois : "
      + date.with(firstDayOfMonth()));
    System.out.println("premier lundi du mois : "
      + date.with(firstInMonth(DayOfWeek.MONDAY)));
    System.out.println("dernier jour du mois : "
      + date.with(lastDayOfMonth()));
    System.out.println("premier jour de l'année : "
      + date.with(firstDayOfYear()));
    System.out.println("troisieme mardi du mois : "
      + date.with(dayOfWeekInMonth(3, DayOfWeek.FRIDAY)));
    System.out.println("prochain vendredi du mois : "
      + date.with(next(DayOfWeek.FRIDAY)));
    System.out.println("prochain samedi du mois ou lui meme : "
      + date.with(nextOrSame(DayOfWeek.SATURDAY)));
    System.out.println("premier jour du mois suivant : "
      + date.with(firstDayOfNextMonth()));
    System.out.println("premier jour de l'année suivante : "
      + date.with(firstDayOfNextYear()));
    System.out.println("premier jour du mois : "
      + firstDayOfMonth().adjustInto(date));
    System.out.println("premier lundi du mois : "
      + firstInMonth(DayOfWeek.MONDAY).adjustInto(date));
    System.out.println("dernier jour du mois : "
      + lastDayOfMonth().adjustInto(date));
    System.out.println("troisieme mardi du mois : "
      + dayOfWeekInMonth(3, DayOfWeek.MONDAY).adjustInto(date));
    System.out.println("prochain vendredi du mois : "
      + next(DayOfWeek.FRIDAY).adjustInto(date));
    System.out.println("prochain samedi du mois ou lui-meme : "
      + nextOrSame(DayOfWeek.SATURDAY).adjustInto(date));
    System.out.println("premier jour de l'année : "
      + firstDayOfYear().adjustInto(date));
    System.out.println("premier jour du mois suivant : "
      + firstDayOfNextMonth().adjustInto(date));
    System.out.println("premier jour de l'année suivante : "
      + firstDayOfNextYear().adjustInto(date));
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">premier jour du mois : 2015-01-01
premier lundi du mois : 2015-01-05
dernier jour du mois : 2015-01-31
premier jour de l'année : 2015-01-01
troisieme mardi du mois : 2015-01-16
prochain vendredi du mois : 2015-02-06
prochain samedi du mois ou lui meme : 2015-01-31
premier jour du mois suivant : 2015-02-01
premier jour de l'année suivante : 2016-01-01
premier jour du mois : 2015-01-01
premier lundi du mois : 2015-01-05
dernier jour du mois : 2015-01-31
troisieme mardi du mois : 2015-01-19
prochain vendredi du mois : 2015-02-06
prochain samedi du mois ou lui-meme : 2015-01-31
premier jour de l'année : 2015-01-01
premier jour du mois suivant : 2015-02-01
premier jour de l'année suivante : 2016-01-01</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Il est possible de développer ses propres TemporalAdjuster pour des besoins spécifiques. Pour cela, il faut créer une classe qui implémente l'interface TemporalAdjuster.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;
      
import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.Month;
import java.time.temporal.Temporal;
import java.time.temporal.TemporalAdjuster;
import static java.time.temporal.TemporalAdjusters.*;

public class JourDePaieAdjuster implements TemporalAdjuster {

  @Override
  public Temporal adjustInto(Temporal date) {
    LocalDate resultat = LocalDate.from(date);
    if (resultat.getDayOfMonth() &gt;= 20) {
        resultat = resultat.with(firstDayOfNextMonth());
    }
    resultat = resultat.withDayOfMonth(20);
    
    if (resultat.getDayOfWeek() == DayOfWeek.SATURDAY
        || resultat.getDayOfWeek() == DayOfWeek.SUNDAY) {
      resultat = resultat.with(previous(DayOfWeek.FRIDAY));
    }
    return date.with(resultat);
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Dans l'exemple ci-dessus, la classe JourDePaieAdjuster permet de déterminer la date de prochaine paie par rapport à la date fournie en paramètre selon les règles suivantes :</p> 
   <ul> 
    <li>si le jour du mois de la date est inférieur à 20 alors on prend le 20 du mois courant</li> 
    <li>sinon on prend le 20 du mois suivant</li> 
    <li>si ce 20ième jour est un samedi ou un dimanche alors on détermine le vendredi précédent</li> 
   </ul> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;
      
import java.time.LocalDate;
import java.time.Month;
import java.time.temporal.Temporal;
import org.junit.Before;
import org.junit.Test;
import static org.junit.Assert.*;

public class JourDePaieAdjusterTest {
  
  private JourDePaieAdjuster sut;
  
  public JourDePaieAdjusterTest() {
  }
  
  @Before
  public void setUp() {
    sut = new JourDePaieAdjuster();
  }
  
  /**
   * Test la date est avant le 20 du mois
   */
  @Test
  public void testAdjustIntoAvantLe20() {
    // given
    Temporal date = LocalDate.of(2015, Month.JANUARY, 15);
    Temporal expResult = LocalDate.of(2015, Month.JANUARY, 20);
    // when
    Temporal result = sut.adjustInto(date);
    // then
    assertEquals("Mauvaise date ajustee", expResult, result);
  }

  /**
   * Test la date est le 20 du mois
   */
  @Test
  public void testAdjustIntoLe20() {
    // given 
    Temporal date = LocalDate.of(2015, Month.JANUARY, 20);
    Temporal expResult = LocalDate.of(2015, Month.FEBRUARY, 20);
    // when
    Temporal result = sut.adjustInto(date);
    // then
    assertEquals("Mauvaise date ajustee", expResult, result);
  }
  /**
   * Test la date est le 21 du mois
   */
  @Test
  public void testAdjustIntoLe21() {
    // given
    Temporal date = LocalDate.of(2015, Month.JANUARY, 21);
    Temporal expResult = LocalDate.of(2015, Month.FEBRUARY, 20);
    // when
    Temporal result = sut.adjustInto(date);
    // then
    assertEquals("Mauvaise date ajustee", expResult, result);
  }
  
  /**
   * Test la date est le 15 juin (le 20 juin est un week end)
   */
  @Test
  public void testAdjustIntoLe15Juin() {
    // given 
    Temporal date = LocalDate.of(2015, Month.JUNE, 15);
    Temporal expResult = LocalDate.of(2015, Month.JUNE, 19);
    // when
    Temporal result = sut.adjustInto(date);
    // then
    assertEquals("Mauvaise date ajustee", expResult, result);
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Il est recommandé que l'implémentation soit immuable.</p> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-6-10-3">102.6.10.3. 
     <!--nchpfin-->L'interface TemporalQuery et la classe TemporalQueries</a></h4> 
   <p>L'interface java.time.temporal.TemporalQuery définit les fonctionnalités qui permettent d'obtenir des informations d'un objet temporel sous la forme d'une requête. C'est une interface fonctionnelle.</p> 
   <p>La requête peut retourner n'importe quel type.</p> 
   <p>Remarque : l'interface TemporalField définit aussi les fonctionnalités pour obtenir la valeur d'un champ d'une date mais sa valeur de retour se limite à un entier long.</p> 
   <p>Elle ne définit qu'une seule méthode</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Méthode</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>R queryFrom(TemporalAccessor temporal)</p> </td> 
      <td> <p>Traiter la requête sur l'instance fournie en paramètre et renvoyer le résultat sous la forme d'une instance du type generic R</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <p>La classe java.time.temporal.TemporalQueries propose plusieurs méthodes statiques qui renvoient des implémentations de type TemporalQuery pour réaliser des requêtes courantes :</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Méthode</p> </td> 
      <td> <p>Rôle</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static TemporalQuery&lt;Chronology&gt; chronology()</p> </td> 
      <td> <p>Appliquer une requête qui renvoie le calendrier ou null si aucun n'est trouvé</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static TemporalQuery&lt;LocalDate&gt; localDate()</p> </td> 
      <td> <p>Appliquer une requête qui renvoie la LocalDate ou null si aucune n'est trouvée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static TemporalQuery&lt;LocalTime&gt; localTime()</p> </td> 
      <td> <p>Appliquer une requête qui renvoie la LocalTime ou null si aucune n'est trouvée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static TemporalQuery&lt;ZoneOffset&gt; offset()</p> </td> 
      <td> <p>Appliquer une requête qui renvoie la ZoneOffset ou null si aucune n'est trouvée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static TemporalQuery&lt;TemporalUnit&gt; precision()</p> </td> 
      <td> <p>Appliquer une requête qui renvoie la plus petite unité temporelle supportée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static TemporalQuery&lt;ZoneId&gt; zone()</p> </td> 
      <td> <p>Appliquer une requête qui renvoie la ZoneId ou la ZoneOffset si aucune n'est trouvée</p> </td> 
     </tr> 
     <tr> 
      <td> <p>static TemporalQuery&lt;ZoneId&gt; zoneId()</p> </td> 
      <td> <p>Appliquer une requête qui renvoie la ZoneId ou null si aucune n'est trouvée</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <p>Ces méthodes sont utiles notamment lorsque l'on ne connaît pas précisément le type de l'objet temporel.</p> 
   <p>Il existe deux manières d'utiliser un TemporalQuery :</p> 
   <ul> 
    <li>invoquer la méthode queryFrom() de l'instance de type TemporalQuery en lui passant l'objet temporel en paramètre</li> 
    <li>invoquer la méthode query() de l'objet temporel de type TemporalAccessor en lui passant l'instance de type TemporalQuery en paramètre</li> 
   </ul> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;
      
import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.OffsetDateTime;
import java.time.Year;
import java.time.YearMonth;
import java.time.ZoneId;
import java.time.ZoneOffset;
import java.time.ZonedDateTime;
import java.time.chrono.Chronology;
import static java.time.temporal.TemporalQueries.*;
import java.time.temporal.TemporalQuery;
import java.time.temporal.TemporalUnit;

public class TestTemporalQuery {
  public static void main(String[] args) {
    TemporalQuery&lt;TemporalUnit&gt; queryPrecision = precision();
    System.out.println("Precision : ");
    System.out.println("LocalDate : " +  LocalDate.now().query(queryPrecision));
    System.out.println("LocalDateTime : " + LocalDateTime.now().query(queryPrecision));
    System.out.println("  Year : " + Year.now().query(queryPrecision));
    System.out.println("  YearMonth : " + YearMonth.now().query(queryPrecision));
    System.out.println("  Instant : " +  Instant.now().query(queryPrecision));
    TemporalQuery&lt;ZoneId&gt; queryZoneId = zoneId();
    System.out.println("ZoneId : ");
    System.out.println("  ZonedDateTime : " + ZonedDateTime.now().query(queryZoneId));
    System.out.println("  LocalDate : " + LocalDate.now().query(queryZoneId));
       
    TemporalQuery&lt;Chronology&gt; queryChronology = chronology();
    System.out.println("Chronology : ");
    System.out.println("  ZonedDateTime : " + ZonedDateTime.now().query(queryChronology));
    System.out.println("  Instant : " + Instant.now().query(queryChronology));

    TemporalQuery&lt;ZoneId&gt; queryZone = zone();
    System.out.println("Zone : ");
    System.out.println("  ZonedDateTime : " + ZonedDateTime.now().query(queryZone));
    System.out.println("  OffsetDateTime : " + OffsetDateTime.now().query(queryZone));
    System.out.println("  Instant : " + Instant.now().query(queryZone));

    TemporalQuery&lt;ZoneOffset&gt; queryOffset = offset();
    System.out.println("Offset : ");
    System.out.println("  ZonedDateTime : " + ZonedDateTime.now().query(queryOffset));
    System.out.println("  OffsetDateTime : " + OffsetDateTime.now().query(queryOffset));
    System.out.println("  Instant : " + Instant.now().query(queryOffset));

    TemporalQuery&lt;LocalDate&gt; queryLocalDate = localDate();
    System.out.println("LocalDateTime : ");
    System.out.println("  LocalDateTime : " + ZonedDateTime.now().query(queryLocalDate));
    System.out.println("  Instant : " + Instant.now().query(queryLocalDate));
    
    TemporalQuery&lt;LocalTime&gt; queryLocalTime = localTime();
    System.out.println("LocalTime : ");
    System.out.println("  LocalTime : " + ZonedDateTime.now().query(queryLocalTime));
    System.out.println("  Instant : " + Instant.now().query(queryLocalTime));
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">Precision : 
  LocalDate : Days
  LocalDateTime : Nanos
  Year : Years 
  YearMonth : Months
  Instant : Nanos
ZoneId :    
ZonedDateTime : Europe/Paris
  LocalDate : null
Chronology : 
  ZonedDateTime : ISO
  Instant : null
Zone : 
  ZonedDateTime :
Europe/Paris
  OffsetDateTime : +01:00
  Instant : null
Offset : 
  ZonedDateTime : +01:00
  OffsetDateTime : +01:00
  Instant : null 
LocalDateTime : 
  LocalDateTime : 2015-02-11
  Instant : null
LocalTime : 
  LocalTime : 18:43:20.250
  Instant : null</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Il est possible de définir ses propres requêtes en créant une classe qui implémente l'interface TemporalQuery. Cette implémentation contient les traitements réalisés par la requête : elle doit être thread-safe. L'objet fourni en paramètre ne doit pas être modifié. Celui-ci peut ne pas utiliser le calendrier ISO : l'implémentation doit en tenir compte et éventuellement ne pas exécuter la requête si ce n'est pas le cas.</p> 
   <p>La valeur de retour peut être null pour indiquer qu'il n'y a pas de résultat à la requête.</p> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;
      
import java.time.Month;
import java.time.MonthDay;
import java.time.temporal.ChronoField;
import java.time.temporal.TemporalAccessor;
import java.time.temporal.TemporalQuery;

public class EstPrintempsQuery implements TemporalQuery&lt;Boolean&gt; {
  @Override
  public Boolean queryFrom(TemporalAccessor date) {
    Boolean resultat = null;
    int jour = date.get(ChronoField.DAY_OF_MONTH);
    int mois = date.get(ChronoField.MONTH_OF_YEAR);
    MonthDay courant = MonthDay.of(mois, jour);
    MonthDay debut = MonthDay.of(Month.MARCH, 20);
    MonthDay fin = MonthDay.of(Month.JUNE, 21);
    
    return (courant.isAfter(debut) &amp;&amp; courant.isBefore(fin));
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;
      
import java.time.LocalDate;
import java.time.Month;
import java.time.temporal.Temporal;
import org.junit.Before;
import org.junit.Test;
import static org.junit.Assert.*;

public class EstPrintempsQueryTest {
  private EstPrintempsQuery sut;
  @Before
  public void setUp() {
    sut = new EstPrintempsQuery();
  }
  
  /**
   * Test date avant le printemps
   */
  @Test
  public void testQueryFromAvantPrintemps() {
    // given
    Temporal date = LocalDate.of(2015, Month.JANUARY, 15);
    // when
    Boolean result = sut.queryFrom(date);
    // then
    assertEquals("Mauvaise reponse", Boolean.FALSE, result);
  }
  
  /**
   * Test date apres le printemps
   */
  @Test
  public void testQueryFromApresPrintemps() {
    // given
    Temporal date = LocalDate.of(2015, Month.OCTOBER, 15);
    // when
    Boolean result = sut.queryFrom(date);
    // then
    assertEquals("Mauvaise reponse", Boolean.FALSE, result);
  }

  /**
   * Test date le premier jour du printemps
   */
  @Test
  public void testQueryFromPremierJourDuPrintemps() {
    // given
    Temporal date = LocalDate.of(2015, Month.MARCH, 21);
    // when
    Boolean result = sut.queryFrom(date);
    // then
    assertEquals("Mauvaise reponse", Boolean.TRUE, result);
  }

  /**
   * Test date le dernier jour du printemps
   */
  @Test
  public void testQueryFromDernierJourDuPrintemps() {
    // given
    Temporal date = LocalDate.of(2015, Month.JUNE, 20);
    // when
    Boolean result = sut.queryFrom(date);
    // then
    assertEquals("Mauvaise reponse", Boolean.TRUE, result);
  }

  /**
   * Test date le dernier jour de l'hiver
   */
  @Test
  public void testQueryFromDernierJourHiver() {
    // given
    Temporal date = LocalDate.of(2015, Month.MARCH, 20);
    // when
    Boolean result = sut.queryFrom(date);
    // then
    assertEquals("Mauvaise reponse", Boolean.FALSE, result);
  }

  /**
   * Test date le premier jour de l'été
   */
  @Test
  public void testQueryFromPermierJourEte() {
    // given
    Temporal date = LocalDate.of(2015, Month.JUNE, 21);
    // when
    Boolean result = sut.queryFrom(date);
    // then
    assertEquals("Mauvaise reponse", Boolean.FALSE, result);
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>Certaines méthodes de classes temporelles respectent la signature de l'interface TemporalQuery et peuvent donc être utilisées sous la forme d'une référence de méthode dans une expression lambda de type TemporalQuery. C'est par exemple le cas des méthodes from() des classes LocalDate et ZoneId.</p> 
   <p>&nbsp;</p> 
   <h3 class="TITRESECTION2">
    <!--nchpdeb--><a name="utilisation_dates-6-11">102.6.11. 
     <!--nchpfin-->L'utilisation de l'API Date-Time</a></h3> 
   <p>La définition d'une API aussi riche que l'API Date-Time pose nécessairement plusieurs questions relatives à son utilisation :</p> 
   <ul> 
    <li>le choix du type d'objet temporel à utiliser</li> 
    <li>les exceptions de l'API</li> 
    <li>l'intégration avec du code avant Java 8</li> 
   </ul> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-6-11-1">102.6.11.1. 
     <!--nchpfin-->Le choix du type d'objet temporel à utiliser</a></h4> 
   <p>L'API Date-Time contient de nombreuses classes répondant à la plupart des besoins en matière de gestion de données temporelles utilisant le calendrier ISO :</p> 
   <ul> 
    <li>Instant : représentation machine d'un point dans la ligne du temps par rapport à l'EPOCH</li> 
    <li>LocalDate, LocalTime, LocalDateTime : représentation humaine d'une date et/ou d'une heure sans fuseau horaire</li> 
    <li>ZonedDateTime : représentation humaine d'une date et d'une heure avec fuseau horaire</li> 
    <li>OffsetTime, OffsetDateTime : représentation humaine d'une date et/ou d'une heure avec décalage horaire</li> 
    <li>Duration : une durée mesurée en secondes et nanosecondes</li> 
    <li>Period : une période est une quantité temporelle exprimée en années, mois et jours</li> 
   </ul> 
   <p>Cette richesse oblige à choisir la classe la plus adaptée à son besoin selon plusieurs critères :</p> 
   <ul> 
    <li>représentation humaine ou machine de la donnée</li> 
    <li>utilisation d'un fuseau horaire</li> 
    <li>date et/ou heure</li> 
    <li>pour une date uniquement, quelle combinaison de champs est utile : année, mois, jour</li> 
   </ul> 
   <p>Le tableau ci-dessous synthétise les principaux champs supportés par chaque objet temporel :</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>Class</p></td> 
      <td> <p align="center">Année</p></td> 
      <td> <p align="center">Mois</p></td> 
      <td> <p align="center">Jour</p></td> 
      <td> <p align="center">Heure</p></td> 
      <td> <p align="center">Min</p></td> 
      <td> <p align="center">Sec</p></td> 
      <td> <p align="center">Nano</p></td> 
      <td> <p align="center">ZoneOffset</p></td> 
      <td> <p align="center">ZoneID</p></td> 
     </tr> 
     <tr> 
      <td> <p>Instant<br>2014-12-25T17:46:39.567Z</p></td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td> <p align="center">X</p></td> 
      <td> <p align="center">X</p></td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr> 
      <td> <p>LocalDate<br>2014-12-25</p></td> 
      <td> <p align="center">X</p></td> 
      <td> <p align="center">X</p></td> 
      <td> <p align="center">X</p></td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr> 
      <td> <p>LocalDateTime<br>2014-12-25T17:46:39.567</p></td> 
      <td> <p align="center">X</p></td> 
      <td> <p align="center">X</p></td> 
      <td> <p align="center">X</p></td> 
      <td> <p align="center">X</p></td> 
      <td> <p align="center">X</p></td> 
      <td> <p align="center">X</p></td> 
      <td> <p align="center">X</p></td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr> 
      <td> <p>ZonedDateTime<br>2014-12-25T17:46:39.567+01:00[Europe/Paris]</p></td> 
      <td> <p align="center">X</p></td> 
      <td> <p align="center">X</p></td> 
      <td> <p align="center">X</p></td> 
      <td> <p align="center">X</p></td> 
      <td> <p align="center">X</p></td> 
      <td> <p align="center">X</p></td> 
      <td> <p align="center">X</p></td> 
      <td> <p align="center">X</p></td> 
      <td> <p align="center">X</p></td> 
     </tr> 
     <tr> 
      <td> <p>LocalTime<br>17:46:39.567</p></td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td> <p align="center">X</p></td> 
      <td> <p align="center">X</p></td> 
      <td> <p align="center">X</p></td> 
      <td> <p align="center">X</p></td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr> 
      <td> <p>MonthDay<br>--12-25</p></td> 
      <td>&nbsp;</td> 
      <td> <p align="center">X</p></td> 
      <td> <p align="center">X</p></td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr> 
      <td> <p>Year<br>2014</p></td> 
      <td> <p align="center">X</p></td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr> 
      <td> <p>YearMonth<br>2014-12</p></td> 
      <td> <p align="center">X</p></td> 
      <td> <p align="center">X</p></td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr> 
      <td> <p>Month<br>DECEMBER</p></td> 
      <td>&nbsp;</td> 
      <td> <p align="center">X</p></td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr> 
      <td> <p>OffsetDateTime<br>2014-12-25T17:46:39.567+01:00</p></td> 
      <td> <p align="center">X</p></td> 
      <td> <p align="center">X</p></td> 
      <td> <p align="center">X</p></td> 
      <td> <p align="center">X</p></td> 
      <td> <p align="center">X</p></td> 
      <td> <p align="center">X</p></td> 
      <td> <p align="center">X</p></td> 
      <td> <p align="center">X</p></td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr> 
      <td> <p>OffsetTime<br>17:66:39.567+01:00</p></td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td> <p align="center">X</p></td> 
      <td> <p align="center">X</p></td> 
      <td> <p align="center">X</p></td> 
      <td> <p align="center">X</p></td> 
      <td> <p align="center">X</p></td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr> 
      <td> <p>Duration<br>PT10H</p></td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td> <p align="center">1</p></td> 
      <td> <p align="center">1</p></td> 
      <td> <p align="center">1</p></td> 
      <td> <p align="center">X</p></td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr> 
      <td> <p>Period<br>P15D</p></td> 
      <td> <p align="center">X</p></td> 
      <td> <p align="center">X</p></td> 
      <td> <p align="center">X</p></td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
     </tr> 
    </tbody>
   </table> 
   <br> 
   <p>(1) : la classe Duration ne stocke pas ces données mais propose des méthodes pour convertir la valeur dans ces unités</p> 
   <p>Il est préférable d'utiliser autant que possible des instances de type LocalDate, LocalTime, LocalDateTime et Instant. L'utilisation d'objets temporels qui gèrent un fuseau horaire rend les calculs beaucoup plus complexes. Ainsi, il est préférable de faire les calculs sur des objets sans fuseau puis de les convertir pour par exemple les afficher dans l'interface graphique.</p> 
   <p>L'utilisation principale des classes OffsetTime et OffsetDateTime est d'échanger une donnée temporelle sur le réseau ou de la stocker dans une base de données.</p> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-6-11-2">102.6.11.2. 
     <!--nchpfin-->Les exceptions de l'API</a></h4> 
   <p>Généralement, l'API tente de respecter plusieurs règles dans l'utilisation des exceptions :</p> 
   <ul> 
    <li>le passage de null comme argument à une méthode d'un objet temporel lève une exception de type NullPointerException</li> 
    <li>les méthodes qui permettent de réaliser des calculs sur des objets temporels peuvent lever une exception unchecked de type java.time.DateTimeException ou ArithmeticException</li> 
   </ul> 
   <p>L'exception de type java.time.temporal.UnsupportedTemporalTypeException est levée par une méthode d'un objet temporel si ce dernier ne supporte pas un champ (ChronoField) ou une unité (ChronoUnit). Pour éviter cette exception, il faut s'assurer que les champs ou les unités utilisées directement ou indirectement sont supportés par l'objet temporel : ce n'est pas toujours évident au premier abord.</p> 
   <p>&nbsp;</p> 
   <h4 class="TITRESECTION3">
    <!--nchpdeb--><a name="utilisation_dates-6-11-3">102.6.11.3. 
     <!--nchpfin-->L'intégration avec le code avant Java 8</a></h4> 
   <p>Avant Java 8, la gestion des données temporelles était assurée par les classes java.util.Date, java.util.Calendar, java.util.TimeZone et leurs sous-classes.</p> 
   <p>La conception et l'implémentation de l'API Date-Time est complètement différente des classes historiques de gestion des données temporelles contenues dans le package java.util. Il n'est donc pas toujours facile de trouver une correspondance direct entre les fonctionnalités des deux API. Le tableau ci-dessous tente de fournir une approche assez globale de cette correspondance :</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p>java.util</p> </td> 
      <td> <p>java.time</p> </td> 
      <td> <p>Commentaires</p> </td> 
     </tr> 
     <tr> 
      <td> <p>Date</p> </td> 
      <td> <p>Instant</p> </td> 
      <td> <p>Elles encapsulent toutes les deux un point dans le temps de manière indépendante de tout fuseau horaire</p> </td> 
     </tr> 
     <tr> 
      <td> <p>GregorianCalendar</p> </td> 
      <td> <p>ZonedDateTime</p> </td> 
      <td> <p>Les méthodes from() et to() de la classe GregorianCalendar permettent de faire les conversions</p> </td> 
     </tr> 
     <tr> 
      <td> <p>TimeZone</p> </td> 
      <td> <p>ZoneId ou</p> <p>ZoneOffset</p> </td> 
      <td> <p>ZoneId pour un fuseau horaire, ZoneOffset pour un décalage horaire</p> </td> 
     </tr> 
     <tr> 
      <td> <p>GregorianCalendar avec l'heure à 00:00</p> </td> 
      <td> <p>LocalDate</p> </td> 
      <td>&nbsp;</td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <p>Pour permettre de faciliter l'intégration avec du code antérieur à Java 8, plusieurs méthodes ont été ajoutées :</p> 
   <ul> 
    <li>la méthode toInstant() de la classe Calendar permet d'obtenir un Instant à partir d'un Calendar</li> 
    <li>la méthode from() de la classe Date permet de créer un objet de type Date à partir d'une instance de type Instant</li> 
    <li>la méthode toInstant() de la classe Date permet de créer un objet de type Instant à partir de l'instance de type Date</li> 
    <li>la méthode toZonedDateTime() de la classe GregorianCalendar permet d'obtenir une instance de type ZonedDateTime à partir de l'instance de GregorianCalendar</li> 
    <li>la méthode from() de la classe GregorianCalendar permet d'obtenir une instance de type GregorianCalendar à partir du ZonedDateTime fourni en paramètre</li> 
    <li>la méthode toZoneId() de la classe TimeZone permet d'obtenir une instance de type ZoneId à partir de l'instance de type TimeZone</li> 
   </ul> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Exemple ( code Java 8 ) : </td>
     </tr>
     <tr>
      <td><pre class="brush: java">package com.jmdoudoux.test.java8.datetime;
      
import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.TimeZone;

public class TestAvecCodeLegacy {
  public static void main(String[] args) {
    Calendar maintenant = Calendar.getInstance();
    ZonedDateTime zonedDateTime = 
      ZonedDateTime.ofInstant(maintenant.toInstant(), ZoneId.systemDefault());
    System.out.println("zonedDateTime="+zonedDateTime);
    
    Date date = new Date();
    Instant instant = date.toInstant();
    System.out.println("instant="+instant);
    
    date = Date.from(instant);
    System.out.println("date="+date);
    
    GregorianCalendar calendar = (GregorianCalendar) GregorianCalendar.getInstance();
    TimeZone timezone = calendar.getTimeZone();
    System.out.println("timezone="+timezone);
    int offset = calendar.get(Calendar.ZONE_OFFSET);
    System.out.println("offset="+offset);
    zonedDateTime = calendar.toZonedDateTime();
    System.out.println("zonedDateTime="+zonedDateTime);
    LocalDateTime localDateTime = zonedDateTime.toLocalDateTime();
    System.out.println("localDateTime="+localDateTime);

    calendar = GregorianCalendar.from(zonedDateTime);
    System.out.println("date="+calendar.getTime());
  }
}</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <table border="1" cellpadding="4" cellspacing="0" width="100%" align="center">
    <tbody>
     <tr bgcolor="#A6A5C2">
      <td>Résultat : </td>
     </tr>
     <tr>
      <td><pre class="brush: plain">zonedDateTime=2015-03-09T23:32:17.328+01:00[Europe/Paris]
instant=2015-03-09T22:32:17.500Z
date=Mon Mar 09 23:32:17 CET 2015
timezone=sun.util.calendar.ZoneInfo[id="Europe/Paris",offset=3600000,
dstSavings=3600000,useDaylight=true,transitions=184,
lastRule=java.util.SimpleTimeZone[id=Europe/Paris,offset=3600000,
dstSavings=3600000,useDaylight=true,startYear=0,startMode=2,startMonth=2,
startDay=-1,startDayOfWeek=1,startTime=3600000,startTimeMode=2,endMode=2,
endMonth=9,endDay=-1,endDayOfWeek=1,endTime=3600000,endTimeMode=2]]
offset=3600000
zonedDateTime=2015-03-09T23:32:17.515+01:00[Europe/Paris]
localDateTime=2015-03-09T23:32:17.515
date=Mon Mar 09 23:32:17 CET 2015</pre></td>
     </tr>
    </tbody>
   </table>
   <br> 
   <p>L'API JDBC n'a pas été modifiée spécifiquement pour le support de l'API Date-Time : il suffit simplement d'utiliser les méthodes setObject() et getObject().</p> 
   <p>Le tableau ci-dessous montre la correspondance entre les types ANSI SQL et Java 8 :</p> 
   <table class="tableau" width="100%" border="1" align="center" cellpadding="4" cellspacing="0"> 
    <tbody>
     <tr> 
      <td> <p align="center">ANSI SQL</p> </td> 
      <td> <p align="center">Java SE 8</p> </td> 
     </tr> 
     <tr> 
      <td> <p align="center">DATE</p> </td> 
      <td> <p align="center">LocalDate</p> </td> 
     </tr> 
     <tr> 
      <td> <p align="center">TIME</p> </td> 
      <td> <p align="center">LocalTime</p> </td> 
     </tr> 
     <tr> 
      <td> <p align="center">TIMESTAMP</p> </td> 
      <td> <p align="center">LocalDateTime</p> </td> 
     </tr> 
     <tr> 
      <td> <p align="center">TIME WITH TIMEZONE</p> </td> 
      <td> <p align="center">OffsetTime</p> </td> 
     </tr> 
     <tr> 
      <td> <p align="center">TIMESTAMP WITH TIMEZONE</p> </td> 
      <td> <p align="center">OffsetDateTime</p> </td> 
     </tr> 
    </tbody>
   </table>
   <br> 
   <p>Attention : les types "TIME WITH TIME ZONE" et "TIMESTAMP WITH TIME ZONE" sont relativement mal nommés car ils ne contiennent pas de fuseau horaire mais uniquement un offset. Il n'est donc pas possible à partir d'une donnée d'un de ces types de déterminer le fuseau horaire. Si celui-ci est requis, il faut le stocker dans une colonne dédiée.</p> 
   <p>&nbsp;</p> 
  </div> 
  <!--PIED-->
  <hr> 
  <table border="0" cellpadding="2" cellspacing="0" width="100%" bgcolor="#7B7BC2"> 
   <tbody> 
    <tr> 
     <td rowspan="2" align="center" width="50">&nbsp;</td>
     <td rowspan="2" align="center" width="50"> <a href="chap-validation_donnees.htm" alt="101. La validation des données"> <img src="FlecheG.gif" alt="101. La validation des données" align="left" border="0" hspace="0" width="31" height="31"> </a> </td> 
     <td rowspan="2" align="center" width="50"> <a href="chap-planification_taches.htm" alt="103. La planification de tâches"> <img src="FlecheD.gif" alt="103. La planification de tâches" align="left" border="0" hspace="0" width="31" height="31"> </a> </td> 
     <td rowspan="2" align="center"> <a href="javascript:window.print()"> <img src="imprimer.gif" width="46" height="40" align="middle" alt="Imprimer" border="0"> </a> </td> 
     <td rowspan="2" align="center"> <a href="index.htm"> <img src="index.gif" alt="Sommaire" align="middle" border="0" hspace="0" width="34" height="31"> </a> </td> 
     <td rowspan="2" align="center"> <a href="indexavecframes.htm" target="_top"> <img src="frame.png" alt="Consulter avec table des matières" align="middle" border="0" hspace="0" width="46" height="40"> </a> </td> 
     <td rowspan="2" align="right" valign="middle"> <script language="JavaScript1.1">
<!--
hsh = new Date();
hsd = document;
//hsr = hsd.referrer.replace(/[<>]/g, '');
hsr = parent.document.referrer.replace(/[<>]/g, '');
hsi = '<a href="http://www.xiti.com/xiti.asp?s=128624"';
hsi += ' TARGET="_top"><img width="39" height="25" border=0 ';
hsi += 'src="http://logv23.xiti.com/hit.xiti?s=128624';
hsi += '&p=';
hsi += '&hl=' + hsh.getHours() + 'x' + hsh.getMinutes() + 'x' + hsh.getSeconds();
if(parseFloat(navigator.appVersion)>=4)
{Xiti_s=screen;hsi += '&r=' + Xiti_s.width + 'x' + Xiti_s.height + 'x' + Xiti_s.pixelDepth + 'x' + Xiti_s.colorDepth;}
hsd.writeln(hsi + '&ref=' + hsr.replace(/&/g, '$') + '" title="Mesurez votre audience"></a>');
//-->
</script> 
      <noscript> 
       <a href="http://www.xiti.com/xiti.asp?s=128624" target="_top"><img width="39" height="25" border="0" src="http://logv23.xiti.com/hit.xiti?s=128624&amp;p=&amp;" title="Mesurez votre audience"></a> 
      </noscript> </td> 
     <td align="right"> <font color="#FFFFFF" size="5"><b><i>Développons en Java&nbsp;&nbsp;</i></b></font><font color="#FFFFFF" size="-1"> v 2.10&nbsp;&nbsp;</font></td> 
    </tr> 
    <tr> 
     <td align="right"><font color="#FFFFFF" size="-1">Copyright (C) 1999-2016 <a class="auteur" href="http://www.jmdoudoux.fr/presentation.htm" rel="author">Jean-Michel DOUDOUX</a>.&nbsp;&nbsp;</font></td> 
    </tr> 
   </tbody> 
  </table> 
  <script language="javascript">

SyntaxHighlighter.config.clipboardSwf = 'clipboard.swf';

SyntaxHighlighter.all();

</script>   
 </body>
</html>