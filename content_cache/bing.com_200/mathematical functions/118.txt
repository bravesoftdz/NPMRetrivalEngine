<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- code.jsp -->
<html>
 <head> 
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> 
  <title>java.lang: Math.java</title> 
 </head> 
 <body style="padding:0 0 0 0;margin:0 0 0 0"> 
  <div style="width:100%;background-color:#ddeeff;border:1px solid #ccddee;margin:0 0 0 0;padding:2px 2px 2px 2px"> 
   <div style="float:right">
    <a href="http://del.icio.us/post" onclick="window.open('http://del.icio.us/post?v=4&amp;noui&amp;jump=close&amp;url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title), 'delicious','toolbar=no,width=700,height=400'); return false;"><img src="http://images.del.icio.us/static/img/delicious.small.gif" border="0"> Save This Page</a>
   </div> 
   <a href="/">Home</a> » 
   <a href="/projects/openjdk-7-java.html">openjdk-7</a> » java » 
   <a href="/docs/api/java/lang/package-index.html">lang</a> » [
   <a href="/docs/api/java/lang/Math.html">javadoc</a> | source] 
  </div> 
  <pre>
<a name="1">    1 &nbsp; /*
    2 &nbsp;  * Copyright (c) 1994, 2011, Oracle and/or its affiliates. All rights reserved.
    3 &nbsp;  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4 &nbsp;  *
    5 &nbsp;  * This code is free software; you can redistribute it and/or modify it
    6 &nbsp;  * under the terms of the GNU General Public License version 2 only, as
    7 &nbsp;  * published by the Free Software Foundation.  Oracle designates this
    8 &nbsp;  * particular file as subject to the "Classpath" exception as provided
    9 &nbsp;  * by Oracle in the LICENSE file that accompanied this code.
   10 &nbsp;  *
</a><a name="11">   11 &nbsp;  * This code is distributed in the hope that it will be useful, but WITHOUT
   12 &nbsp;  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   13 &nbsp;  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   14 &nbsp;  * version 2 for more details (a copy is included in the LICENSE file that
   15 &nbsp;  * accompanied this code).
   16 &nbsp;  *
   17 &nbsp;  * You should have received a copy of the GNU General Public License version
   18 &nbsp;  * 2 along with this work; if not, write to the Free Software Foundation,
   19 &nbsp;  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   20 &nbsp;  *
</a><a name="21">   21 &nbsp;  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   22 &nbsp;  * or visit www.oracle.com if you need additional information or have any
   23 &nbsp;  * questions.
   24 &nbsp;  */
   25 &nbsp; 
   26 &nbsp; <span class="kw">package</span> </a><a href="/docs/api/java/lang/package-index.html">java.lang</a>;
   27 &nbsp; <span class="kw">import</span> <a href="/docs/api/java/util/Random.html">java.util.Random</a>;
   28 &nbsp; 
   29 &nbsp; 
   30 &nbsp; /**
<a name="31">   31 &nbsp;  * The class {@code Math} contains methods for performing basic
   32 &nbsp;  * numeric operations such as the elementary exponential, logarithm,
   33 &nbsp;  * square root, and trigonometric functions.
   34 &nbsp;  *
   35 &nbsp;  * &lt;p&gt;Unlike some of the numeric methods of class
   36 &nbsp;  * {@code StrictMath}, all implementations of the equivalent
   37 &nbsp;  * functions of class {@code Math} are not defined to return the
   38 &nbsp;  * bit-for-bit same results.  This relaxation permits
   39 &nbsp;  * better-performing implementations where strict reproducibility is
   40 &nbsp;  * not required.
</a><a name="41">   41 &nbsp;  *
   42 &nbsp;  * &lt;p&gt;By default many of the {@code Math} methods simply call
   43 &nbsp;  * the equivalent method in {@code StrictMath} for their
   44 &nbsp;  * implementation.  Code generators are encouraged to use
   45 &nbsp;  * platform-specific native libraries or microprocessor instructions,
   46 &nbsp;  * where available, to provide higher-performance implementations of
   47 &nbsp;  * {@code Math} methods.  Such higher-performance
   48 &nbsp;  * implementations still must conform to the specification for
   49 &nbsp;  * {@code Math}.
   50 &nbsp;  *
</a><a name="51">   51 &nbsp;  * &lt;p&gt;The quality of implementation specifications concern two
   52 &nbsp;  * properties, accuracy of the returned result and monotonicity of the
   53 &nbsp;  * method.  Accuracy of the floating-point {@code Math} methods
   54 &nbsp;  * is measured in terms of &lt;i&gt;ulps&lt;/i&gt;, units in the last place.  For
   55 &nbsp;  * a given floating-point format, an ulp of a specific real number
   56 &nbsp;  * value is the distance between the two floating-point values
   57 &nbsp;  * bracketing that numerical value.  When discussing the accuracy of a
   58 &nbsp;  * method as a whole rather than at a specific argument, the number of
   59 &nbsp;  * ulps cited is for the worst-case error at any argument.  If a
   60 &nbsp;  * method always has an error less than 0.5 ulps, the method always
</a><a name="61">   61 &nbsp;  * returns the floating-point number nearest the exact result; such a
   62 &nbsp;  * method is &lt;i&gt;correctly rounded&lt;/i&gt;.  A correctly rounded method is
   63 &nbsp;  * generally the best a floating-point approximation can be; however,
   64 &nbsp;  * it is impractical for many floating-point methods to be correctly
   65 &nbsp;  * rounded.  Instead, for the {@code Math} class, a larger error
   66 &nbsp;  * bound of 1 or 2 ulps is allowed for certain methods.  Informally,
   67 &nbsp;  * with a 1 ulp error bound, when the exact result is a representable
   68 &nbsp;  * number, the exact result should be returned as the computed result;
   69 &nbsp;  * otherwise, either of the two floating-point values which bracket
   70 &nbsp;  * the exact result may be returned.  For exact results large in
</a><a name="71">   71 &nbsp;  * magnitude, one of the endpoints of the bracket may be infinite.
   72 &nbsp;  * Besides accuracy at individual arguments, maintaining proper
   73 &nbsp;  * relations between the method at different arguments is also
   74 &nbsp;  * important.  Therefore, most methods with more than 0.5 ulp errors
   75 &nbsp;  * are required to be &lt;i&gt;semi-monotonic&lt;/i&gt;: whenever the mathematical
   76 &nbsp;  * function is non-decreasing, so is the floating-point approximation,
   77 &nbsp;  * likewise, whenever the mathematical function is non-increasing, so
   78 &nbsp;  * is the floating-point approximation.  Not all approximations that
   79 &nbsp;  * have 1 ulp accuracy will automatically meet the monotonicity
   80 &nbsp;  * requirements.
</a><a name="81">   81 &nbsp;  *
   82 &nbsp;  * @author  unascribed
   83 &nbsp;  * @author  Joseph D. Darcy
   84 &nbsp;  * @since   JDK1.0
   85 &nbsp;  */
   86 &nbsp; 
   87 &nbsp; public final class Math {
   88 &nbsp; 
   89 &nbsp;     /**
   90 &nbsp;      * Don't let anyone instantiate this class.
</a><a name="91">   91 &nbsp;      */
   92 &nbsp;     private Math() {}
   93 &nbsp; 
   94 &nbsp;     /**
   95 &nbsp;      * The {@code double} value that is closer than any other to
   96 &nbsp;      * &lt;i&gt;e&lt;/i&gt;, the base of the natural logarithms.
   97 &nbsp;      */
   98 &nbsp;     public static final double E = 2.7182818284590452354;
   99 &nbsp; 
  100 &nbsp;     /**
</a><a name="101">  101 &nbsp;      * The {@code double} value that is closer than any other to
  102 &nbsp;      * &lt;i&gt;pi&lt;/i&gt;, the ratio of the circumference of a circle to its
  103 &nbsp;      * diameter.
  104 &nbsp;      */
  105 &nbsp;     public static final double PI = 3.14159265358979323846;
  106 &nbsp; 
  107 &nbsp;     /**
  108 &nbsp;      * Returns the trigonometric sine of an angle.  Special cases:
  109 &nbsp;      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or an infinity, then the
  110 &nbsp;      * result is NaN.
</a><a name="111">  111 &nbsp;      * &lt;li&gt;If the argument is zero, then the result is a zero with the
  112 &nbsp;      * same sign as the argument.&lt;/ul&gt;
  113 &nbsp;      *
  114 &nbsp;      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
  115 &nbsp;      * Results must be semi-monotonic.
  116 &nbsp;      *
  117 &nbsp;      * @param   a   an angle, in radians.
  118 &nbsp;      * @return  the sine of the argument.
  119 &nbsp;      */
  120 &nbsp;     public static double sin(double a) {
</a><a name="121">  121 &nbsp;         return StrictMath.sin(a); // default impl. delegates to StrictMath
  122 &nbsp;     }
  123 &nbsp; 
  124 &nbsp;     /**
  125 &nbsp;      * Returns the trigonometric cosine of an angle. Special cases:
  126 &nbsp;      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or an infinity, then the
  127 &nbsp;      * result is NaN.&lt;/ul&gt;
  128 &nbsp;      *
  129 &nbsp;      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
  130 &nbsp;      * Results must be semi-monotonic.
</a><a name="131">  131 &nbsp;      *
  132 &nbsp;      * @param   a   an angle, in radians.
  133 &nbsp;      * @return  the cosine of the argument.
  134 &nbsp;      */
  135 &nbsp;     public static double cos(double a) {
  136 &nbsp;         return StrictMath.cos(a); // default impl. delegates to StrictMath
  137 &nbsp;     }
  138 &nbsp; 
  139 &nbsp;     /**
  140 &nbsp;      * Returns the trigonometric tangent of an angle.  Special cases:
</a><a name="141">  141 &nbsp;      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or an infinity, then the result
  142 &nbsp;      * is NaN.
  143 &nbsp;      * &lt;li&gt;If the argument is zero, then the result is a zero with the
  144 &nbsp;      * same sign as the argument.&lt;/ul&gt;
  145 &nbsp;      *
  146 &nbsp;      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
  147 &nbsp;      * Results must be semi-monotonic.
  148 &nbsp;      *
  149 &nbsp;      * @param   a   an angle, in radians.
  150 &nbsp;      * @return  the tangent of the argument.
</a><a name="151">  151 &nbsp;      */
  152 &nbsp;     public static double tan(double a) {
  153 &nbsp;         return StrictMath.tan(a); // default impl. delegates to StrictMath
  154 &nbsp;     }
  155 &nbsp; 
  156 &nbsp;     /**
  157 &nbsp;      * Returns the arc sine of a value; the returned angle is in the
  158 &nbsp;      * range -&lt;i&gt;pi&lt;/i&gt;/2 through &lt;i&gt;pi&lt;/i&gt;/2.  Special cases:
  159 &nbsp;      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or its absolute value is greater
  160 &nbsp;      * than 1, then the result is NaN.
</a><a name="161">  161 &nbsp;      * &lt;li&gt;If the argument is zero, then the result is a zero with the
  162 &nbsp;      * same sign as the argument.&lt;/ul&gt;
  163 &nbsp;      *
  164 &nbsp;      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
  165 &nbsp;      * Results must be semi-monotonic.
  166 &nbsp;      *
  167 &nbsp;      * @param   a   the value whose arc sine is to be returned.
  168 &nbsp;      * @return  the arc sine of the argument.
  169 &nbsp;      */
  170 &nbsp;     public static double asin(double a) {
</a><a name="171">  171 &nbsp;         return StrictMath.asin(a); // default impl. delegates to StrictMath
  172 &nbsp;     }
  173 &nbsp; 
  174 &nbsp;     /**
  175 &nbsp;      * Returns the arc cosine of a value; the returned angle is in the
  176 &nbsp;      * range 0.0 through &lt;i&gt;pi&lt;/i&gt;.  Special case:
  177 &nbsp;      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or its absolute value is greater
  178 &nbsp;      * than 1, then the result is NaN.&lt;/ul&gt;
  179 &nbsp;      *
  180 &nbsp;      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
</a><a name="181">  181 &nbsp;      * Results must be semi-monotonic.
  182 &nbsp;      *
  183 &nbsp;      * @param   a   the value whose arc cosine is to be returned.
  184 &nbsp;      * @return  the arc cosine of the argument.
  185 &nbsp;      */
  186 &nbsp;     public static double acos(double a) {
  187 &nbsp;         return StrictMath.acos(a); // default impl. delegates to StrictMath
  188 &nbsp;     }
  189 &nbsp; 
  190 &nbsp;     /**
</a><a name="191">  191 &nbsp;      * Returns the arc tangent of a value; the returned angle is in the
  192 &nbsp;      * range -&lt;i&gt;pi&lt;/i&gt;/2 through &lt;i&gt;pi&lt;/i&gt;/2.  Special cases:
  193 &nbsp;      * &lt;ul&gt;&lt;li&gt;If the argument is NaN, then the result is NaN.
  194 &nbsp;      * &lt;li&gt;If the argument is zero, then the result is a zero with the
  195 &nbsp;      * same sign as the argument.&lt;/ul&gt;
  196 &nbsp;      *
  197 &nbsp;      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
  198 &nbsp;      * Results must be semi-monotonic.
  199 &nbsp;      *
  200 &nbsp;      * @param   a   the value whose arc tangent is to be returned.
</a><a name="201">  201 &nbsp;      * @return  the arc tangent of the argument.
  202 &nbsp;      */
  203 &nbsp;     public static double atan(double a) {
  204 &nbsp;         return StrictMath.atan(a); // default impl. delegates to StrictMath
  205 &nbsp;     }
  206 &nbsp; 
  207 &nbsp;     /**
  208 &nbsp;      * Converts an angle measured in degrees to an approximately
  209 &nbsp;      * equivalent angle measured in radians.  The conversion from
  210 &nbsp;      * degrees to radians is generally inexact.
</a><a name="211">  211 &nbsp;      *
  212 &nbsp;      * @param   angdeg   an angle, in degrees
  213 &nbsp;      * @return  the measurement of the angle {@code angdeg}
  214 &nbsp;      *          in radians.
  215 &nbsp;      * @since   1.2
  216 &nbsp;      */
  217 &nbsp;     public static double toRadians(double angdeg) {
  218 &nbsp;         return angdeg / 180.0 * PI;
  219 &nbsp;     }
  220 &nbsp; 
</a><a name="221">  221 &nbsp;     /**
  222 &nbsp;      * Converts an angle measured in radians to an approximately
  223 &nbsp;      * equivalent angle measured in degrees.  The conversion from
  224 &nbsp;      * radians to degrees is generally inexact; users should
  225 &nbsp;      * &lt;i&gt;not&lt;/i&gt; expect {@code cos(toRadians(90.0))} to exactly
  226 &nbsp;      * equal {@code 0.0}.
  227 &nbsp;      *
  228 &nbsp;      * @param   angrad   an angle, in radians
  229 &nbsp;      * @return  the measurement of the angle {@code angrad}
  230 &nbsp;      *          in degrees.
</a><a name="231">  231 &nbsp;      * @since   1.2
  232 &nbsp;      */
  233 &nbsp;     public static double toDegrees(double angrad) {
  234 &nbsp;         return angrad * 180.0 / PI;
  235 &nbsp;     }
  236 &nbsp; 
  237 &nbsp;     /**
  238 &nbsp;      * Returns Euler's number &lt;i&gt;e&lt;/i&gt; raised to the power of a
  239 &nbsp;      * {@code double} value.  Special cases:
  240 &nbsp;      * &lt;ul&gt;&lt;li&gt;If the argument is NaN, the result is NaN.
</a><a name="241">  241 &nbsp;      * &lt;li&gt;If the argument is positive infinity, then the result is
  242 &nbsp;      * positive infinity.
  243 &nbsp;      * &lt;li&gt;If the argument is negative infinity, then the result is
  244 &nbsp;      * positive zero.&lt;/ul&gt;
  245 &nbsp;      *
  246 &nbsp;      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
  247 &nbsp;      * Results must be semi-monotonic.
  248 &nbsp;      *
  249 &nbsp;      * @param   a   the exponent to raise &lt;i&gt;e&lt;/i&gt; to.
  250 &nbsp;      * @return  the value &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;{@code a}&lt;/sup&gt;,
</a><a name="251">  251 &nbsp;      *          where &lt;i&gt;e&lt;/i&gt; is the base of the natural logarithms.
  252 &nbsp;      */
  253 &nbsp;     public static double exp(double a) {
  254 &nbsp;         return StrictMath.exp(a); // default impl. delegates to StrictMath
  255 &nbsp;     }
  256 &nbsp; 
  257 &nbsp;     /**
  258 &nbsp;      * Returns the natural logarithm (base &lt;i&gt;e&lt;/i&gt;) of a {@code double}
  259 &nbsp;      * value.  Special cases:
  260 &nbsp;      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or less than zero, then the result
</a><a name="261">  261 &nbsp;      * is NaN.
  262 &nbsp;      * &lt;li&gt;If the argument is positive infinity, then the result is
  263 &nbsp;      * positive infinity.
  264 &nbsp;      * &lt;li&gt;If the argument is positive zero or negative zero, then the
  265 &nbsp;      * result is negative infinity.&lt;/ul&gt;
  266 &nbsp;      *
  267 &nbsp;      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
  268 &nbsp;      * Results must be semi-monotonic.
  269 &nbsp;      *
  270 &nbsp;      * @param   a   a value
</a><a name="271">  271 &nbsp;      * @return  the value ln&amp;nbsp;{@code a}, the natural logarithm of
  272 &nbsp;      *          {@code a}.
  273 &nbsp;      */
  274 &nbsp;     public static double log(double a) {
  275 &nbsp;         return StrictMath.log(a); // default impl. delegates to StrictMath
  276 &nbsp;     }
  277 &nbsp; 
  278 &nbsp;     /**
  279 &nbsp;      * Returns the base 10 logarithm of a {@code double} value.
  280 &nbsp;      * Special cases:
</a><a name="281">  281 &nbsp;      *
  282 &nbsp;      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or less than zero, then the result
  283 &nbsp;      * is NaN.
  284 &nbsp;      * &lt;li&gt;If the argument is positive infinity, then the result is
  285 &nbsp;      * positive infinity.
  286 &nbsp;      * &lt;li&gt;If the argument is positive zero or negative zero, then the
  287 &nbsp;      * result is negative infinity.
  288 &nbsp;      * &lt;li&gt; If the argument is equal to 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt; for
  289 &nbsp;      * integer &lt;i&gt;n&lt;/i&gt;, then the result is &lt;i&gt;n&lt;/i&gt;.
  290 &nbsp;      * &lt;/ul&gt;
</a><a name="291">  291 &nbsp;      *
  292 &nbsp;      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
  293 &nbsp;      * Results must be semi-monotonic.
  294 &nbsp;      *
  295 &nbsp;      * @param   a   a value
  296 &nbsp;      * @return  the base 10 logarithm of  {@code a}.
  297 &nbsp;      * @since 1.5
  298 &nbsp;      */
  299 &nbsp;     public static double log10(double a) {
  300 &nbsp;         return StrictMath.log10(a); // default impl. delegates to StrictMath
</a><a name="301">  301 &nbsp;     }
  302 &nbsp; 
  303 &nbsp;     /**
  304 &nbsp;      * Returns the correctly rounded positive square root of a
  305 &nbsp;      * {@code double} value.
  306 &nbsp;      * Special cases:
  307 &nbsp;      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or less than zero, then the result
  308 &nbsp;      * is NaN.
  309 &nbsp;      * &lt;li&gt;If the argument is positive infinity, then the result is positive
  310 &nbsp;      * infinity.
</a><a name="311">  311 &nbsp;      * &lt;li&gt;If the argument is positive zero or negative zero, then the
  312 &nbsp;      * result is the same as the argument.&lt;/ul&gt;
  313 &nbsp;      * Otherwise, the result is the {@code double} value closest to
  314 &nbsp;      * the true mathematical square root of the argument value.
  315 &nbsp;      *
  316 &nbsp;      * @param   a   a value.
  317 &nbsp;      * @return  the positive square root of {@code a}.
  318 &nbsp;      *          If the argument is NaN or less than zero, the result is NaN.
  319 &nbsp;      */
  320 &nbsp;     public static double sqrt(double a) {
</a><a name="321">  321 &nbsp;         return StrictMath.sqrt(a); // default impl. delegates to StrictMath
  322 &nbsp;                                    // Note that hardware sqrt instructions
  323 &nbsp;                                    // frequently can be directly used by JITs
  324 &nbsp;                                    // and should be much faster than doing
  325 &nbsp;                                    // Math.sqrt in software.
  326 &nbsp;     }
  327 &nbsp; 
  328 &nbsp; 
  329 &nbsp;     /**
  330 &nbsp;      * Returns the cube root of a {@code double} value.  For
</a><a name="331">  331 &nbsp;      * positive finite {@code x}, {@code cbrt(-x) ==
  332 &nbsp;      * -cbrt(x)}; that is, the cube root of a negative value is
  333 &nbsp;      * the negative of the cube root of that value's magnitude.
  334 &nbsp;      *
  335 &nbsp;      * Special cases:
  336 &nbsp;      *
  337 &nbsp;      * &lt;ul&gt;
  338 &nbsp;      *
  339 &nbsp;      * &lt;li&gt;If the argument is NaN, then the result is NaN.
  340 &nbsp;      *
</a><a name="341">  341 &nbsp;      * &lt;li&gt;If the argument is infinite, then the result is an infinity
  342 &nbsp;      * with the same sign as the argument.
  343 &nbsp;      *
  344 &nbsp;      * &lt;li&gt;If the argument is zero, then the result is a zero with the
  345 &nbsp;      * same sign as the argument.
  346 &nbsp;      *
  347 &nbsp;      * &lt;/ul&gt;
  348 &nbsp;      *
  349 &nbsp;      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
  350 &nbsp;      *
</a><a name="351">  351 &nbsp;      * @param   a   a value.
  352 &nbsp;      * @return  the cube root of {@code a}.
  353 &nbsp;      * @since 1.5
  354 &nbsp;      */
  355 &nbsp;     public static double cbrt(double a) {
  356 &nbsp;         return StrictMath.cbrt(a);
  357 &nbsp;     }
  358 &nbsp; 
  359 &nbsp;     /**
  360 &nbsp;      * Computes the remainder operation on two arguments as prescribed
</a><a name="361">  361 &nbsp;      * by the IEEE 754 standard.
  362 &nbsp;      * The remainder value is mathematically equal to
  363 &nbsp;      * &lt;code&gt;f1&amp;nbsp;-&amp;nbsp;f2&lt;/code&gt;&amp;nbsp;&amp;times;&amp;nbsp;&lt;i&gt;n&lt;/i&gt;,
  364 &nbsp;      * where &lt;i&gt;n&lt;/i&gt; is the mathematical integer closest to the exact
  365 &nbsp;      * mathematical value of the quotient {@code f1/f2}, and if two
  366 &nbsp;      * mathematical integers are equally close to {@code f1/f2},
  367 &nbsp;      * then &lt;i&gt;n&lt;/i&gt; is the integer that is even. If the remainder is
  368 &nbsp;      * zero, its sign is the same as the sign of the first argument.
  369 &nbsp;      * Special cases:
  370 &nbsp;      * &lt;ul&gt;&lt;li&gt;If either argument is NaN, or the first argument is infinite,
</a><a name="371">  371 &nbsp;      * or the second argument is positive zero or negative zero, then the
  372 &nbsp;      * result is NaN.
  373 &nbsp;      * &lt;li&gt;If the first argument is finite and the second argument is
  374 &nbsp;      * infinite, then the result is the same as the first argument.&lt;/ul&gt;
  375 &nbsp;      *
  376 &nbsp;      * @param   f1   the dividend.
  377 &nbsp;      * @param   f2   the divisor.
  378 &nbsp;      * @return  the remainder when {@code f1} is divided by
  379 &nbsp;      *          {@code f2}.
  380 &nbsp;      */
</a><a name="381">  381 &nbsp;     public static double IEEEremainder(double f1, double f2) {
  382 &nbsp;         return StrictMath.IEEEremainder(f1, f2); // delegate to StrictMath
  383 &nbsp;     }
  384 &nbsp; 
  385 &nbsp;     /**
  386 &nbsp;      * Returns the smallest (closest to negative infinity)
  387 &nbsp;      * {@code double} value that is greater than or equal to the
  388 &nbsp;      * argument and is equal to a mathematical integer. Special cases:
  389 &nbsp;      * &lt;ul&gt;&lt;li&gt;If the argument value is already equal to a
  390 &nbsp;      * mathematical integer, then the result is the same as the
</a><a name="391">  391 &nbsp;      * argument.  &lt;li&gt;If the argument is NaN or an infinity or
  392 &nbsp;      * positive zero or negative zero, then the result is the same as
  393 &nbsp;      * the argument.  &lt;li&gt;If the argument value is less than zero but
  394 &nbsp;      * greater than -1.0, then the result is negative zero.&lt;/ul&gt; Note
  395 &nbsp;      * that the value of {@code Math.ceil(x)} is exactly the
  396 &nbsp;      * value of {@code -Math.floor(-x)}.
  397 &nbsp;      *
  398 &nbsp;      *
  399 &nbsp;      * @param   a   a value.
  400 &nbsp;      * @return  the smallest (closest to negative infinity)
</a><a name="401">  401 &nbsp;      *          floating-point value that is greater than or equal to
  402 &nbsp;      *          the argument and is equal to a mathematical integer.
  403 &nbsp;      */
  404 &nbsp;     public static double ceil(double a) {
  405 &nbsp;         return StrictMath.ceil(a); // default impl. delegates to StrictMath
  406 &nbsp;     }
  407 &nbsp; 
  408 &nbsp;     /**
  409 &nbsp;      * Returns the largest (closest to positive infinity)
  410 &nbsp;      * {@code double} value that is less than or equal to the
</a><a name="411">  411 &nbsp;      * argument and is equal to a mathematical integer. Special cases:
  412 &nbsp;      * &lt;ul&gt;&lt;li&gt;If the argument value is already equal to a
  413 &nbsp;      * mathematical integer, then the result is the same as the
  414 &nbsp;      * argument.  &lt;li&gt;If the argument is NaN or an infinity or
  415 &nbsp;      * positive zero or negative zero, then the result is the same as
  416 &nbsp;      * the argument.&lt;/ul&gt;
  417 &nbsp;      *
  418 &nbsp;      * @param   a   a value.
  419 &nbsp;      * @return  the largest (closest to positive infinity)
  420 &nbsp;      *          floating-point value that less than or equal to the argument
</a><a name="421">  421 &nbsp;      *          and is equal to a mathematical integer.
  422 &nbsp;      */
  423 &nbsp;     public static double floor(double a) {
  424 &nbsp;         return StrictMath.floor(a); // default impl. delegates to StrictMath
  425 &nbsp;     }
  426 &nbsp; 
  427 &nbsp;     /**
  428 &nbsp;      * Returns the {@code double} value that is closest in value
  429 &nbsp;      * to the argument and is equal to a mathematical integer. If two
  430 &nbsp;      * {@code double} values that are mathematical integers are
</a><a name="431">  431 &nbsp;      * equally close, the result is the integer value that is
  432 &nbsp;      * even. Special cases:
  433 &nbsp;      * &lt;ul&gt;&lt;li&gt;If the argument value is already equal to a mathematical
  434 &nbsp;      * integer, then the result is the same as the argument.
  435 &nbsp;      * &lt;li&gt;If the argument is NaN or an infinity or positive zero or negative
  436 &nbsp;      * zero, then the result is the same as the argument.&lt;/ul&gt;
  437 &nbsp;      *
  438 &nbsp;      * @param   a   a {@code double} value.
  439 &nbsp;      * @return  the closest floating-point value to {@code a} that is
  440 &nbsp;      *          equal to a mathematical integer.
</a><a name="441">  441 &nbsp;      */
  442 &nbsp;     public static double rint(double a) {
  443 &nbsp;         return StrictMath.rint(a); // default impl. delegates to StrictMath
  444 &nbsp;     }
  445 &nbsp; 
  446 &nbsp;     /**
  447 &nbsp;      * Returns the angle &lt;i&gt;theta&lt;/i&gt; from the conversion of rectangular
  448 &nbsp;      * coordinates ({@code x},&amp;nbsp;{@code y}) to polar
  449 &nbsp;      * coordinates (r,&amp;nbsp;&lt;i&gt;theta&lt;/i&gt;).
  450 &nbsp;      * This method computes the phase &lt;i&gt;theta&lt;/i&gt; by computing an arc tangent
</a><a name="451">  451 &nbsp;      * of {@code y/x} in the range of -&lt;i&gt;pi&lt;/i&gt; to &lt;i&gt;pi&lt;/i&gt;. Special
  452 &nbsp;      * cases:
  453 &nbsp;      * &lt;ul&gt;&lt;li&gt;If either argument is NaN, then the result is NaN.
  454 &nbsp;      * &lt;li&gt;If the first argument is positive zero and the second argument
  455 &nbsp;      * is positive, or the first argument is positive and finite and the
  456 &nbsp;      * second argument is positive infinity, then the result is positive
  457 &nbsp;      * zero.
  458 &nbsp;      * &lt;li&gt;If the first argument is negative zero and the second argument
  459 &nbsp;      * is positive, or the first argument is negative and finite and the
  460 &nbsp;      * second argument is positive infinity, then the result is negative zero.
</a><a name="461">  461 &nbsp;      * &lt;li&gt;If the first argument is positive zero and the second argument
  462 &nbsp;      * is negative, or the first argument is positive and finite and the
  463 &nbsp;      * second argument is negative infinity, then the result is the
  464 &nbsp;      * {@code double} value closest to &lt;i&gt;pi&lt;/i&gt;.
  465 &nbsp;      * &lt;li&gt;If the first argument is negative zero and the second argument
  466 &nbsp;      * is negative, or the first argument is negative and finite and the
  467 &nbsp;      * second argument is negative infinity, then the result is the
  468 &nbsp;      * {@code double} value closest to -&lt;i&gt;pi&lt;/i&gt;.
  469 &nbsp;      * &lt;li&gt;If the first argument is positive and the second argument is
  470 &nbsp;      * positive zero or negative zero, or the first argument is positive
</a><a name="471">  471 &nbsp;      * infinity and the second argument is finite, then the result is the
  472 &nbsp;      * {@code double} value closest to &lt;i&gt;pi&lt;/i&gt;/2.
  473 &nbsp;      * &lt;li&gt;If the first argument is negative and the second argument is
  474 &nbsp;      * positive zero or negative zero, or the first argument is negative
  475 &nbsp;      * infinity and the second argument is finite, then the result is the
  476 &nbsp;      * {@code double} value closest to -&lt;i&gt;pi&lt;/i&gt;/2.
  477 &nbsp;      * &lt;li&gt;If both arguments are positive infinity, then the result is the
  478 &nbsp;      * {@code double} value closest to &lt;i&gt;pi&lt;/i&gt;/4.
  479 &nbsp;      * &lt;li&gt;If the first argument is positive infinity and the second argument
  480 &nbsp;      * is negative infinity, then the result is the {@code double}
</a><a name="481">  481 &nbsp;      * value closest to 3*&lt;i&gt;pi&lt;/i&gt;/4.
  482 &nbsp;      * &lt;li&gt;If the first argument is negative infinity and the second argument
  483 &nbsp;      * is positive infinity, then the result is the {@code double} value
  484 &nbsp;      * closest to -&lt;i&gt;pi&lt;/i&gt;/4.
  485 &nbsp;      * &lt;li&gt;If both arguments are negative infinity, then the result is the
  486 &nbsp;      * {@code double} value closest to -3*&lt;i&gt;pi&lt;/i&gt;/4.&lt;/ul&gt;
  487 &nbsp;      *
  488 &nbsp;      * &lt;p&gt;The computed result must be within 2 ulps of the exact result.
  489 &nbsp;      * Results must be semi-monotonic.
  490 &nbsp;      *
</a><a name="491">  491 &nbsp;      * @param   y   the ordinate coordinate
  492 &nbsp;      * @param   x   the abscissa coordinate
  493 &nbsp;      * @return  the &lt;i&gt;theta&lt;/i&gt; component of the point
  494 &nbsp;      *          (&lt;i&gt;r&lt;/i&gt;,&amp;nbsp;&lt;i&gt;theta&lt;/i&gt;)
  495 &nbsp;      *          in polar coordinates that corresponds to the point
  496 &nbsp;      *          (&lt;i&gt;x&lt;/i&gt;,&amp;nbsp;&lt;i&gt;y&lt;/i&gt;) in Cartesian coordinates.
  497 &nbsp;      */
  498 &nbsp;     public static double atan2(double y, double x) {
  499 &nbsp;         return StrictMath.atan2(y, x); // default impl. delegates to StrictMath
  500 &nbsp;     }
</a><a name="501">  501 &nbsp; 
  502 &nbsp;     /**
  503 &nbsp;      * Returns the value of the first argument raised to the power of the
  504 &nbsp;      * second argument. Special cases:
  505 &nbsp;      *
  506 &nbsp;      * &lt;ul&gt;&lt;li&gt;If the second argument is positive or negative zero, then the
  507 &nbsp;      * result is 1.0.
  508 &nbsp;      * &lt;li&gt;If the second argument is 1.0, then the result is the same as the
  509 &nbsp;      * first argument.
  510 &nbsp;      * &lt;li&gt;If the second argument is NaN, then the result is NaN.
</a><a name="511">  511 &nbsp;      * &lt;li&gt;If the first argument is NaN and the second argument is nonzero,
  512 &nbsp;      * then the result is NaN.
  513 &nbsp;      *
  514 &nbsp;      * &lt;li&gt;If
  515 &nbsp;      * &lt;ul&gt;
  516 &nbsp;      * &lt;li&gt;the absolute value of the first argument is greater than 1
  517 &nbsp;      * and the second argument is positive infinity, or
  518 &nbsp;      * &lt;li&gt;the absolute value of the first argument is less than 1 and
  519 &nbsp;      * the second argument is negative infinity,
  520 &nbsp;      * &lt;/ul&gt;
</a><a name="521">  521 &nbsp;      * then the result is positive infinity.
  522 &nbsp;      *
  523 &nbsp;      * &lt;li&gt;If
  524 &nbsp;      * &lt;ul&gt;
  525 &nbsp;      * &lt;li&gt;the absolute value of the first argument is greater than 1 and
  526 &nbsp;      * the second argument is negative infinity, or
  527 &nbsp;      * &lt;li&gt;the absolute value of the
  528 &nbsp;      * first argument is less than 1 and the second argument is positive
  529 &nbsp;      * infinity,
  530 &nbsp;      * &lt;/ul&gt;
</a><a name="531">  531 &nbsp;      * then the result is positive zero.
  532 &nbsp;      *
  533 &nbsp;      * &lt;li&gt;If the absolute value of the first argument equals 1 and the
  534 &nbsp;      * second argument is infinite, then the result is NaN.
  535 &nbsp;      *
  536 &nbsp;      * &lt;li&gt;If
  537 &nbsp;      * &lt;ul&gt;
  538 &nbsp;      * &lt;li&gt;the first argument is positive zero and the second argument
  539 &nbsp;      * is greater than zero, or
  540 &nbsp;      * &lt;li&gt;the first argument is positive infinity and the second
</a><a name="541">  541 &nbsp;      * argument is less than zero,
  542 &nbsp;      * &lt;/ul&gt;
  543 &nbsp;      * then the result is positive zero.
  544 &nbsp;      *
  545 &nbsp;      * &lt;li&gt;If
  546 &nbsp;      * &lt;ul&gt;
  547 &nbsp;      * &lt;li&gt;the first argument is positive zero and the second argument
  548 &nbsp;      * is less than zero, or
  549 &nbsp;      * &lt;li&gt;the first argument is positive infinity and the second
  550 &nbsp;      * argument is greater than zero,
</a><a name="551">  551 &nbsp;      * &lt;/ul&gt;
  552 &nbsp;      * then the result is positive infinity.
  553 &nbsp;      *
  554 &nbsp;      * &lt;li&gt;If
  555 &nbsp;      * &lt;ul&gt;
  556 &nbsp;      * &lt;li&gt;the first argument is negative zero and the second argument
  557 &nbsp;      * is greater than zero but not a finite odd integer, or
  558 &nbsp;      * &lt;li&gt;the first argument is negative infinity and the second
  559 &nbsp;      * argument is less than zero but not a finite odd integer,
  560 &nbsp;      * &lt;/ul&gt;
</a><a name="561">  561 &nbsp;      * then the result is positive zero.
  562 &nbsp;      *
  563 &nbsp;      * &lt;li&gt;If
  564 &nbsp;      * &lt;ul&gt;
  565 &nbsp;      * &lt;li&gt;the first argument is negative zero and the second argument
  566 &nbsp;      * is a positive finite odd integer, or
  567 &nbsp;      * &lt;li&gt;the first argument is negative infinity and the second
  568 &nbsp;      * argument is a negative finite odd integer,
  569 &nbsp;      * &lt;/ul&gt;
  570 &nbsp;      * then the result is negative zero.
</a><a name="571">  571 &nbsp;      *
  572 &nbsp;      * &lt;li&gt;If
  573 &nbsp;      * &lt;ul&gt;
  574 &nbsp;      * &lt;li&gt;the first argument is negative zero and the second argument
  575 &nbsp;      * is less than zero but not a finite odd integer, or
  576 &nbsp;      * &lt;li&gt;the first argument is negative infinity and the second
  577 &nbsp;      * argument is greater than zero but not a finite odd integer,
  578 &nbsp;      * &lt;/ul&gt;
  579 &nbsp;      * then the result is positive infinity.
  580 &nbsp;      *
</a><a name="581">  581 &nbsp;      * &lt;li&gt;If
  582 &nbsp;      * &lt;ul&gt;
  583 &nbsp;      * &lt;li&gt;the first argument is negative zero and the second argument
  584 &nbsp;      * is a negative finite odd integer, or
  585 &nbsp;      * &lt;li&gt;the first argument is negative infinity and the second
  586 &nbsp;      * argument is a positive finite odd integer,
  587 &nbsp;      * &lt;/ul&gt;
  588 &nbsp;      * then the result is negative infinity.
  589 &nbsp;      *
  590 &nbsp;      * &lt;li&gt;If the first argument is finite and less than zero
</a><a name="591">  591 &nbsp;      * &lt;ul&gt;
  592 &nbsp;      * &lt;li&gt; if the second argument is a finite even integer, the
  593 &nbsp;      * result is equal to the result of raising the absolute value of
  594 &nbsp;      * the first argument to the power of the second argument
  595 &nbsp;      *
  596 &nbsp;      * &lt;li&gt;if the second argument is a finite odd integer, the result
  597 &nbsp;      * is equal to the negative of the result of raising the absolute
  598 &nbsp;      * value of the first argument to the power of the second
  599 &nbsp;      * argument
  600 &nbsp;      *
</a><a name="601">  601 &nbsp;      * &lt;li&gt;if the second argument is finite and not an integer, then
  602 &nbsp;      * the result is NaN.
  603 &nbsp;      * &lt;/ul&gt;
  604 &nbsp;      *
  605 &nbsp;      * &lt;li&gt;If both arguments are integers, then the result is exactly equal
  606 &nbsp;      * to the mathematical result of raising the first argument to the power
  607 &nbsp;      * of the second argument if that result can in fact be represented
  608 &nbsp;      * exactly as a {@code double} value.&lt;/ul&gt;
  609 &nbsp;      *
  610 &nbsp;      * &lt;p&gt;(In the foregoing descriptions, a floating-point value is
</a><a name="611">  611 &nbsp;      * considered to be an integer if and only if it is finite and a
  612 &nbsp;      * fixed point of the method {@link #ceil ceil} or,
  613 &nbsp;      * equivalently, a fixed point of the method {@link #floor
  614 &nbsp;      * floor}. A value is a fixed point of a one-argument
  615 &nbsp;      * method if and only if the result of applying the method to the
  616 &nbsp;      * value is equal to the value.)
  617 &nbsp;      *
  618 &nbsp;      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
  619 &nbsp;      * Results must be semi-monotonic.
  620 &nbsp;      *
</a><a name="621">  621 &nbsp;      * @param   a   the base.
  622 &nbsp;      * @param   b   the exponent.
  623 &nbsp;      * @return  the value {@code a}&lt;sup&gt;{@code b}&lt;/sup&gt;.
  624 &nbsp;      */
  625 &nbsp;     public static double pow(double a, double b) {
  626 &nbsp;         return StrictMath.pow(a, b); // default impl. delegates to StrictMath
  627 &nbsp;     }
  628 &nbsp; 
  629 &nbsp;     /**
  630 &nbsp;      * Returns the closest {@code int} to the argument, with ties
</a><a name="631">  631 &nbsp;      * rounding up.
  632 &nbsp;      *
  633 &nbsp;      * &lt;p&gt;
  634 &nbsp;      * Special cases:
  635 &nbsp;      * &lt;ul&gt;&lt;li&gt;If the argument is NaN, the result is 0.
  636 &nbsp;      * &lt;li&gt;If the argument is negative infinity or any value less than or
  637 &nbsp;      * equal to the value of {@code Integer.MIN_VALUE}, the result is
  638 &nbsp;      * equal to the value of {@code Integer.MIN_VALUE}.
  639 &nbsp;      * &lt;li&gt;If the argument is positive infinity or any value greater than or
  640 &nbsp;      * equal to the value of {@code Integer.MAX_VALUE}, the result is
</a><a name="641">  641 &nbsp;      * equal to the value of {@code Integer.MAX_VALUE}.&lt;/ul&gt;
  642 &nbsp;      *
  643 &nbsp;      * @param   a   a floating-point value to be rounded to an integer.
  644 &nbsp;      * @return  the value of the argument rounded to the nearest
  645 &nbsp;      *          {@code int} value.
  646 &nbsp;      * @see     java.lang.Integer#MAX_VALUE
  647 &nbsp;      * @see     java.lang.Integer#MIN_VALUE
  648 &nbsp;      */
  649 &nbsp;     public static int round(float a) {
  650 &nbsp;         if (a != 0x1.fffffep-2f) // greatest float value less than 0.5
</a><a name="651">  651 &nbsp;             return (int)floor(a + 0.5f);
  652 &nbsp;         else
  653 &nbsp;             return 0;
  654 &nbsp;     }
  655 &nbsp; 
  656 &nbsp;     /**
  657 &nbsp;      * Returns the closest {@code long} to the argument, with ties
  658 &nbsp;      * rounding up.
  659 &nbsp;      *
  660 &nbsp;      * &lt;p&gt;Special cases:
</a><a name="661">  661 &nbsp;      * &lt;ul&gt;&lt;li&gt;If the argument is NaN, the result is 0.
  662 &nbsp;      * &lt;li&gt;If the argument is negative infinity or any value less than or
  663 &nbsp;      * equal to the value of {@code Long.MIN_VALUE}, the result is
  664 &nbsp;      * equal to the value of {@code Long.MIN_VALUE}.
  665 &nbsp;      * &lt;li&gt;If the argument is positive infinity or any value greater than or
  666 &nbsp;      * equal to the value of {@code Long.MAX_VALUE}, the result is
  667 &nbsp;      * equal to the value of {@code Long.MAX_VALUE}.&lt;/ul&gt;
  668 &nbsp;      *
  669 &nbsp;      * @param   a   a floating-point value to be rounded to a
  670 &nbsp;      *          {@code long}.
</a><a name="671">  671 &nbsp;      * @return  the value of the argument rounded to the nearest
  672 &nbsp;      *          {@code long} value.
  673 &nbsp;      * @see     java.lang.Long#MAX_VALUE
  674 &nbsp;      * @see     java.lang.Long#MIN_VALUE
  675 &nbsp;      */
  676 &nbsp;     public static long round(double a) {
  677 &nbsp;         if (a != 0x1.fffffffffffffp-2) // greatest double value less than 0.5
  678 &nbsp;             return (long)floor(a + 0.5d);
  679 &nbsp;         else
  680 &nbsp;             return 0;
</a><a name="681">  681 &nbsp;     }
  682 &nbsp; 
  683 &nbsp;     private static Random randomNumberGenerator;
  684 &nbsp; 
  685 &nbsp;     private static synchronized Random initRNG() {
  686 &nbsp;         Random rnd = randomNumberGenerator;
  687 &nbsp;         return (rnd == null) ? (randomNumberGenerator = new Random()) : rnd;
  688 &nbsp;     }
  689 &nbsp; 
  690 &nbsp;     /**
</a><a name="691">  691 &nbsp;      * Returns a {@code double} value with a positive sign, greater
  692 &nbsp;      * than or equal to {@code 0.0} and less than {@code 1.0}.
  693 &nbsp;      * Returned values are chosen pseudorandomly with (approximately)
  694 &nbsp;      * uniform distribution from that range.
  695 &nbsp;      *
  696 &nbsp;      * &lt;p&gt;When this method is first called, it creates a single new
  697 &nbsp;      * pseudorandom-number generator, exactly as if by the expression
  698 &nbsp;      *
  699 &nbsp;      * &lt;blockquote&gt;{@code new java.util.Random()}&lt;/blockquote&gt;
  700 &nbsp;      *
</a><a name="701">  701 &nbsp;      * This new pseudorandom-number generator is used thereafter for
  702 &nbsp;      * all calls to this method and is used nowhere else.
  703 &nbsp;      *
  704 &nbsp;      * &lt;p&gt;This method is properly synchronized to allow correct use by
  705 &nbsp;      * more than one thread. However, if many threads need to generate
  706 &nbsp;      * pseudorandom numbers at a great rate, it may reduce contention
  707 &nbsp;      * for each thread to have its own pseudorandom-number generator.
  708 &nbsp;      *
  709 &nbsp;      * @return  a pseudorandom {@code double} greater than or equal
  710 &nbsp;      * to {@code 0.0} and less than {@code 1.0}.
</a><a name="711">  711 &nbsp;      * @see Random#nextDouble()
  712 &nbsp;      */
  713 &nbsp;     public static double random() {
  714 &nbsp;         Random rnd = randomNumberGenerator;
  715 &nbsp;         if (rnd == null) rnd = initRNG();
  716 &nbsp;         return rnd.nextDouble();
  717 &nbsp;     }
  718 &nbsp; 
  719 &nbsp;     /**
  720 &nbsp;      * Returns the absolute value of an {@code int} value.
</a><a name="721">  721 &nbsp;      * If the argument is not negative, the argument is returned.
  722 &nbsp;      * If the argument is negative, the negation of the argument is returned.
  723 &nbsp;      *
  724 &nbsp;      * &lt;p&gt;Note that if the argument is equal to the value of
  725 &nbsp;      * {@link Integer#MIN_VALUE}, the most negative representable
  726 &nbsp;      * {@code int} value, the result is that same value, which is
  727 &nbsp;      * negative.
  728 &nbsp;      *
  729 &nbsp;      * @param   a   the argument whose absolute value is to be determined
  730 &nbsp;      * @return  the absolute value of the argument.
</a><a name="731">  731 &nbsp;      */
  732 &nbsp;     public static int abs(int a) {
  733 &nbsp;         return (a &lt; 0) ? -a : a;
  734 &nbsp;     }
  735 &nbsp; 
  736 &nbsp;     /**
  737 &nbsp;      * Returns the absolute value of a {@code long} value.
  738 &nbsp;      * If the argument is not negative, the argument is returned.
  739 &nbsp;      * If the argument is negative, the negation of the argument is returned.
  740 &nbsp;      *
</a><a name="741">  741 &nbsp;      * &lt;p&gt;Note that if the argument is equal to the value of
  742 &nbsp;      * {@link Long#MIN_VALUE}, the most negative representable
  743 &nbsp;      * {@code long} value, the result is that same value, which
  744 &nbsp;      * is negative.
  745 &nbsp;      *
  746 &nbsp;      * @param   a   the argument whose absolute value is to be determined
  747 &nbsp;      * @return  the absolute value of the argument.
  748 &nbsp;      */
  749 &nbsp;     public static long abs(long a) {
  750 &nbsp;         return (a &lt; 0) ? -a : a;
</a><a name="751">  751 &nbsp;     }
  752 &nbsp; 
  753 &nbsp;     /**
  754 &nbsp;      * Returns the absolute value of a {@code float} value.
  755 &nbsp;      * If the argument is not negative, the argument is returned.
  756 &nbsp;      * If the argument is negative, the negation of the argument is returned.
  757 &nbsp;      * Special cases:
  758 &nbsp;      * &lt;ul&gt;&lt;li&gt;If the argument is positive zero or negative zero, the
  759 &nbsp;      * result is positive zero.
  760 &nbsp;      * &lt;li&gt;If the argument is infinite, the result is positive infinity.
</a><a name="761">  761 &nbsp;      * &lt;li&gt;If the argument is NaN, the result is NaN.&lt;/ul&gt;
  762 &nbsp;      * In other words, the result is the same as the value of the expression:
  763 &nbsp;      * &lt;p&gt;{@code Float.intBitsToFloat(0x7fffffff &amp; Float.floatToIntBits(a))}
  764 &nbsp;      *
  765 &nbsp;      * @param   a   the argument whose absolute value is to be determined
  766 &nbsp;      * @return  the absolute value of the argument.
  767 &nbsp;      */
  768 &nbsp;     public static float abs(float a) {
  769 &nbsp;         return (a &lt;= 0.0F) ? 0.0F - a : a;
  770 &nbsp;     }
</a><a name="771">  771 &nbsp; 
  772 &nbsp;     /**
  773 &nbsp;      * Returns the absolute value of a {@code double} value.
  774 &nbsp;      * If the argument is not negative, the argument is returned.
  775 &nbsp;      * If the argument is negative, the negation of the argument is returned.
  776 &nbsp;      * Special cases:
  777 &nbsp;      * &lt;ul&gt;&lt;li&gt;If the argument is positive zero or negative zero, the result
  778 &nbsp;      * is positive zero.
  779 &nbsp;      * &lt;li&gt;If the argument is infinite, the result is positive infinity.
  780 &nbsp;      * &lt;li&gt;If the argument is NaN, the result is NaN.&lt;/ul&gt;
</a><a name="781">  781 &nbsp;      * In other words, the result is the same as the value of the expression:
  782 &nbsp;      * &lt;p&gt;{@code Double.longBitsToDouble((Double.doubleToLongBits(a)&lt;&lt;1)&gt;&gt;&gt;1)}
  783 &nbsp;      *
  784 &nbsp;      * @param   a   the argument whose absolute value is to be determined
  785 &nbsp;      * @return  the absolute value of the argument.
  786 &nbsp;      */
  787 &nbsp;     public static double abs(double a) {
  788 &nbsp;         return (a &lt;= 0.0D) ? 0.0D - a : a;
  789 &nbsp;     }
  790 &nbsp; 
</a><a name="791">  791 &nbsp;     /**
  792 &nbsp;      * Returns the greater of two {@code int} values. That is, the
  793 &nbsp;      * result is the argument closer to the value of
  794 &nbsp;      * {@link Integer#MAX_VALUE}. If the arguments have the same value,
  795 &nbsp;      * the result is that same value.
  796 &nbsp;      *
  797 &nbsp;      * @param   a   an argument.
  798 &nbsp;      * @param   b   another argument.
  799 &nbsp;      * @return  the larger of {@code a} and {@code b}.
  800 &nbsp;      */
</a><a name="801">  801 &nbsp;     public static int max(int a, int b) {
  802 &nbsp;         return (a &gt;= b) ? a : b;
  803 &nbsp;     }
  804 &nbsp; 
  805 &nbsp;     /**
  806 &nbsp;      * Returns the greater of two {@code long} values. That is, the
  807 &nbsp;      * result is the argument closer to the value of
  808 &nbsp;      * {@link Long#MAX_VALUE}. If the arguments have the same value,
  809 &nbsp;      * the result is that same value.
  810 &nbsp;      *
</a><a name="811">  811 &nbsp;      * @param   a   an argument.
  812 &nbsp;      * @param   b   another argument.
  813 &nbsp;      * @return  the larger of {@code a} and {@code b}.
  814 &nbsp;      */
  815 &nbsp;     public static long max(long a, long b) {
  816 &nbsp;         return (a &gt;= b) ? a : b;
  817 &nbsp;     }
  818 &nbsp; 
  819 &nbsp;     private static long negativeZeroFloatBits = Float.floatToIntBits(-0.0f);
  820 &nbsp;     private static long negativeZeroDoubleBits = Double.doubleToLongBits(-0.0d);
</a><a name="821">  821 &nbsp; 
  822 &nbsp;     /**
  823 &nbsp;      * Returns the greater of two {@code float} values.  That is,
  824 &nbsp;      * the result is the argument closer to positive infinity. If the
  825 &nbsp;      * arguments have the same value, the result is that same
  826 &nbsp;      * value. If either value is NaN, then the result is NaN.  Unlike
  827 &nbsp;      * the numerical comparison operators, this method considers
  828 &nbsp;      * negative zero to be strictly smaller than positive zero. If one
  829 &nbsp;      * argument is positive zero and the other negative zero, the
  830 &nbsp;      * result is positive zero.
</a><a name="831">  831 &nbsp;      *
  832 &nbsp;      * @param   a   an argument.
  833 &nbsp;      * @param   b   another argument.
  834 &nbsp;      * @return  the larger of {@code a} and {@code b}.
  835 &nbsp;      */
  836 &nbsp;     public static float max(float a, float b) {
  837 &nbsp;         if (a != a) return a;   // a is NaN
  838 &nbsp;         if ((a == 0.0f) &amp;&amp; (b == 0.0f)
  839 &nbsp;             &amp;&amp; (Float.floatToIntBits(a) == negativeZeroFloatBits)) {
  840 &nbsp;             return b;
</a><a name="841">  841 &nbsp;         }
  842 &nbsp;         return (a &gt;= b) ? a : b;
  843 &nbsp;     }
  844 &nbsp; 
  845 &nbsp;     /**
  846 &nbsp;      * Returns the greater of two {@code double} values.  That
  847 &nbsp;      * is, the result is the argument closer to positive infinity. If
  848 &nbsp;      * the arguments have the same value, the result is that same
  849 &nbsp;      * value. If either value is NaN, then the result is NaN.  Unlike
  850 &nbsp;      * the numerical comparison operators, this method considers
</a><a name="851">  851 &nbsp;      * negative zero to be strictly smaller than positive zero. If one
  852 &nbsp;      * argument is positive zero and the other negative zero, the
  853 &nbsp;      * result is positive zero.
  854 &nbsp;      *
  855 &nbsp;      * @param   a   an argument.
  856 &nbsp;      * @param   b   another argument.
  857 &nbsp;      * @return  the larger of {@code a} and {@code b}.
  858 &nbsp;      */
  859 &nbsp;     public static double max(double a, double b) {
  860 &nbsp;         if (a != a) return a;   // a is NaN
</a><a name="861">  861 &nbsp;         if ((a == 0.0d) &amp;&amp; (b == 0.0d)
  862 &nbsp;             &amp;&amp; (Double.doubleToLongBits(a) == negativeZeroDoubleBits)) {
  863 &nbsp;             return b;
  864 &nbsp;         }
  865 &nbsp;         return (a &gt;= b) ? a : b;
  866 &nbsp;     }
  867 &nbsp; 
  868 &nbsp;     /**
  869 &nbsp;      * Returns the smaller of two {@code int} values. That is,
  870 &nbsp;      * the result the argument closer to the value of
</a><a name="871">  871 &nbsp;      * {@link Integer#MIN_VALUE}.  If the arguments have the same
  872 &nbsp;      * value, the result is that same value.
  873 &nbsp;      *
  874 &nbsp;      * @param   a   an argument.
  875 &nbsp;      * @param   b   another argument.
  876 &nbsp;      * @return  the smaller of {@code a} and {@code b}.
  877 &nbsp;      */
  878 &nbsp;     public static int min(int a, int b) {
  879 &nbsp;         return (a &lt;= b) ? a : b;
  880 &nbsp;     }
</a><a name="881">  881 &nbsp; 
  882 &nbsp;     /**
  883 &nbsp;      * Returns the smaller of two {@code long} values. That is,
  884 &nbsp;      * the result is the argument closer to the value of
  885 &nbsp;      * {@link Long#MIN_VALUE}. If the arguments have the same
  886 &nbsp;      * value, the result is that same value.
  887 &nbsp;      *
  888 &nbsp;      * @param   a   an argument.
  889 &nbsp;      * @param   b   another argument.
  890 &nbsp;      * @return  the smaller of {@code a} and {@code b}.
</a><a name="891">  891 &nbsp;      */
  892 &nbsp;     public static long min(long a, long b) {
  893 &nbsp;         return (a &lt;= b) ? a : b;
  894 &nbsp;     }
  895 &nbsp; 
  896 &nbsp;     /**
  897 &nbsp;      * Returns the smaller of two {@code float} values.  That is,
  898 &nbsp;      * the result is the value closer to negative infinity. If the
  899 &nbsp;      * arguments have the same value, the result is that same
  900 &nbsp;      * value. If either value is NaN, then the result is NaN.  Unlike
</a><a name="901">  901 &nbsp;      * the numerical comparison operators, this method considers
  902 &nbsp;      * negative zero to be strictly smaller than positive zero.  If
  903 &nbsp;      * one argument is positive zero and the other is negative zero,
  904 &nbsp;      * the result is negative zero.
  905 &nbsp;      *
  906 &nbsp;      * @param   a   an argument.
  907 &nbsp;      * @param   b   another argument.
  908 &nbsp;      * @return  the smaller of {@code a} and {@code b}.
  909 &nbsp;      */
  910 &nbsp;     public static float min(float a, float b) {
</a><a name="911">  911 &nbsp;         if (a != a) return a;   // a is NaN
  912 &nbsp;         if ((a == 0.0f) &amp;&amp; (b == 0.0f)
  913 &nbsp;             &amp;&amp; (Float.floatToIntBits(b) == negativeZeroFloatBits)) {
  914 &nbsp;             return b;
  915 &nbsp;         }
  916 &nbsp;         return (a &lt;= b) ? a : b;
  917 &nbsp;     }
  918 &nbsp; 
  919 &nbsp;     /**
  920 &nbsp;      * Returns the smaller of two {@code double} values.  That
</a><a name="921">  921 &nbsp;      * is, the result is the value closer to negative infinity. If the
  922 &nbsp;      * arguments have the same value, the result is that same
  923 &nbsp;      * value. If either value is NaN, then the result is NaN.  Unlike
  924 &nbsp;      * the numerical comparison operators, this method considers
  925 &nbsp;      * negative zero to be strictly smaller than positive zero. If one
  926 &nbsp;      * argument is positive zero and the other is negative zero, the
  927 &nbsp;      * result is negative zero.
  928 &nbsp;      *
  929 &nbsp;      * @param   a   an argument.
  930 &nbsp;      * @param   b   another argument.
</a><a name="931">  931 &nbsp;      * @return  the smaller of {@code a} and {@code b}.
  932 &nbsp;      */
  933 &nbsp;     public static double min(double a, double b) {
  934 &nbsp;         if (a != a) return a;   // a is NaN
  935 &nbsp;         if ((a == 0.0d) &amp;&amp; (b == 0.0d)
  936 &nbsp;             &amp;&amp; (Double.doubleToLongBits(b) == negativeZeroDoubleBits)) {
  937 &nbsp;             return b;
  938 &nbsp;         }
  939 &nbsp;         return (a &lt;= b) ? a : b;
  940 &nbsp;     }
</a><a name="941">  941 &nbsp; 
  942 &nbsp;     /**
  943 &nbsp;      * Returns the size of an ulp of the argument.  An ulp of a
  944 &nbsp;      * {@code double} value is the positive distance between this
  945 &nbsp;      * floating-point value and the {@code double} value next
  946 &nbsp;      * larger in magnitude.  Note that for non-NaN &lt;i&gt;x&lt;/i&gt;,
  947 &nbsp;      * &lt;code&gt;ulp(-&lt;i&gt;x&lt;/i&gt;) == ulp(&lt;i&gt;x&lt;/i&gt;)&lt;/code&gt;.
  948 &nbsp;      *
  949 &nbsp;      * &lt;p&gt;Special Cases:
  950 &nbsp;      * &lt;ul&gt;
</a><a name="951">  951 &nbsp;      * &lt;li&gt; If the argument is NaN, then the result is NaN.
  952 &nbsp;      * &lt;li&gt; If the argument is positive or negative infinity, then the
  953 &nbsp;      * result is positive infinity.
  954 &nbsp;      * &lt;li&gt; If the argument is positive or negative zero, then the result is
  955 &nbsp;      * {@code Double.MIN_VALUE}.
  956 &nbsp;      * &lt;li&gt; If the argument is &amp;plusmn;{@code Double.MAX_VALUE}, then
  957 &nbsp;      * the result is equal to 2&lt;sup&gt;971&lt;/sup&gt;.
  958 &nbsp;      * &lt;/ul&gt;
  959 &nbsp;      *
  960 &nbsp;      * @param d the floating-point value whose ulp is to be returned
</a><a name="961">  961 &nbsp;      * @return the size of an ulp of the argument
  962 &nbsp;      * @author Joseph D. Darcy
  963 &nbsp;      * @since 1.5
  964 &nbsp;      */
  965 &nbsp;     public static double ulp(double d) {
  966 &nbsp;         return sun.misc.FpUtils.ulp(d);
  967 &nbsp;     }
  968 &nbsp; 
  969 &nbsp;     /**
  970 &nbsp;      * Returns the size of an ulp of the argument.  An ulp of a
</a><a name="971">  971 &nbsp;      * {@code float} value is the positive distance between this
  972 &nbsp;      * floating-point value and the {@code float} value next
  973 &nbsp;      * larger in magnitude.  Note that for non-NaN &lt;i&gt;x&lt;/i&gt;,
  974 &nbsp;      * &lt;code&gt;ulp(-&lt;i&gt;x&lt;/i&gt;) == ulp(&lt;i&gt;x&lt;/i&gt;)&lt;/code&gt;.
  975 &nbsp;      *
  976 &nbsp;      * &lt;p&gt;Special Cases:
  977 &nbsp;      * &lt;ul&gt;
  978 &nbsp;      * &lt;li&gt; If the argument is NaN, then the result is NaN.
  979 &nbsp;      * &lt;li&gt; If the argument is positive or negative infinity, then the
  980 &nbsp;      * result is positive infinity.
</a><a name="981">  981 &nbsp;      * &lt;li&gt; If the argument is positive or negative zero, then the result is
  982 &nbsp;      * {@code Float.MIN_VALUE}.
  983 &nbsp;      * &lt;li&gt; If the argument is &amp;plusmn;{@code Float.MAX_VALUE}, then
  984 &nbsp;      * the result is equal to 2&lt;sup&gt;104&lt;/sup&gt;.
  985 &nbsp;      * &lt;/ul&gt;
  986 &nbsp;      *
  987 &nbsp;      * @param f the floating-point value whose ulp is to be returned
  988 &nbsp;      * @return the size of an ulp of the argument
  989 &nbsp;      * @author Joseph D. Darcy
  990 &nbsp;      * @since 1.5
</a><a name="991">  991 &nbsp;      */
  992 &nbsp;     public static float ulp(float f) {
  993 &nbsp;         return sun.misc.FpUtils.ulp(f);
  994 &nbsp;     }
  995 &nbsp; 
  996 &nbsp;     /**
  997 &nbsp;      * Returns the signum function of the argument; zero if the argument
  998 &nbsp;      * is zero, 1.0 if the argument is greater than zero, -1.0 if the
  999 &nbsp;      * argument is less than zero.
 1000 &nbsp;      *
</a><a name="1001"> 1001 &nbsp;      * &lt;p&gt;Special Cases:
 1002 &nbsp;      * &lt;ul&gt;
 1003 &nbsp;      * &lt;li&gt; If the argument is NaN, then the result is NaN.
 1004 &nbsp;      * &lt;li&gt; If the argument is positive zero or negative zero, then the
 1005 &nbsp;      *      result is the same as the argument.
 1006 &nbsp;      * &lt;/ul&gt;
 1007 &nbsp;      *
 1008 &nbsp;      * @param d the floating-point value whose signum is to be returned
 1009 &nbsp;      * @return the signum function of the argument
 1010 &nbsp;      * @author Joseph D. Darcy
</a><a name="1011"> 1011 &nbsp;      * @since 1.5
 1012 &nbsp;      */
 1013 &nbsp;     public static double signum(double d) {
 1014 &nbsp;         return sun.misc.FpUtils.signum(d);
 1015 &nbsp;     }
 1016 &nbsp; 
 1017 &nbsp;     /**
 1018 &nbsp;      * Returns the signum function of the argument; zero if the argument
 1019 &nbsp;      * is zero, 1.0f if the argument is greater than zero, -1.0f if the
 1020 &nbsp;      * argument is less than zero.
</a><a name="1021"> 1021 &nbsp;      *
 1022 &nbsp;      * &lt;p&gt;Special Cases:
 1023 &nbsp;      * &lt;ul&gt;
 1024 &nbsp;      * &lt;li&gt; If the argument is NaN, then the result is NaN.
 1025 &nbsp;      * &lt;li&gt; If the argument is positive zero or negative zero, then the
 1026 &nbsp;      *      result is the same as the argument.
 1027 &nbsp;      * &lt;/ul&gt;
 1028 &nbsp;      *
 1029 &nbsp;      * @param f the floating-point value whose signum is to be returned
 1030 &nbsp;      * @return the signum function of the argument
</a><a name="1031"> 1031 &nbsp;      * @author Joseph D. Darcy
 1032 &nbsp;      * @since 1.5
 1033 &nbsp;      */
 1034 &nbsp;     public static float signum(float f) {
 1035 &nbsp;         return sun.misc.FpUtils.signum(f);
 1036 &nbsp;     }
 1037 &nbsp; 
 1038 &nbsp;     /**
 1039 &nbsp;      * Returns the hyperbolic sine of a {@code double} value.
 1040 &nbsp;      * The hyperbolic sine of &lt;i&gt;x&lt;/i&gt; is defined to be
</a><a name="1041"> 1041 &nbsp;      * (&lt;i&gt;e&lt;sup&gt;x&lt;/sup&gt;&amp;nbsp;-&amp;nbsp;e&lt;sup&gt;-x&lt;/sup&gt;&lt;/i&gt;)/2
 1042 &nbsp;      * where &lt;i&gt;e&lt;/i&gt; is {@linkplain Math#E Euler's number}.
 1043 &nbsp;      *
 1044 &nbsp;      * &lt;p&gt;Special cases:
 1045 &nbsp;      * &lt;ul&gt;
 1046 &nbsp;      *
 1047 &nbsp;      * &lt;li&gt;If the argument is NaN, then the result is NaN.
 1048 &nbsp;      *
 1049 &nbsp;      * &lt;li&gt;If the argument is infinite, then the result is an infinity
 1050 &nbsp;      * with the same sign as the argument.
</a><a name="1051"> 1051 &nbsp;      *
 1052 &nbsp;      * &lt;li&gt;If the argument is zero, then the result is a zero with the
 1053 &nbsp;      * same sign as the argument.
 1054 &nbsp;      *
 1055 &nbsp;      * &lt;/ul&gt;
 1056 &nbsp;      *
 1057 &nbsp;      * &lt;p&gt;The computed result must be within 2.5 ulps of the exact result.
 1058 &nbsp;      *
 1059 &nbsp;      * @param   x The number whose hyperbolic sine is to be returned.
 1060 &nbsp;      * @return  The hyperbolic sine of {@code x}.
</a><a name="1061"> 1061 &nbsp;      * @since 1.5
 1062 &nbsp;      */
 1063 &nbsp;     public static double sinh(double x) {
 1064 &nbsp;         return StrictMath.sinh(x);
 1065 &nbsp;     }
 1066 &nbsp; 
 1067 &nbsp;     /**
 1068 &nbsp;      * Returns the hyperbolic cosine of a {@code double} value.
 1069 &nbsp;      * The hyperbolic cosine of &lt;i&gt;x&lt;/i&gt; is defined to be
 1070 &nbsp;      * (&lt;i&gt;e&lt;sup&gt;x&lt;/sup&gt;&amp;nbsp;+&amp;nbsp;e&lt;sup&gt;-x&lt;/sup&gt;&lt;/i&gt;)/2
</a><a name="1071"> 1071 &nbsp;      * where &lt;i&gt;e&lt;/i&gt; is {@linkplain Math#E Euler's number}.
 1072 &nbsp;      *
 1073 &nbsp;      * &lt;p&gt;Special cases:
 1074 &nbsp;      * &lt;ul&gt;
 1075 &nbsp;      *
 1076 &nbsp;      * &lt;li&gt;If the argument is NaN, then the result is NaN.
 1077 &nbsp;      *
 1078 &nbsp;      * &lt;li&gt;If the argument is infinite, then the result is positive
 1079 &nbsp;      * infinity.
 1080 &nbsp;      *
</a><a name="1081"> 1081 &nbsp;      * &lt;li&gt;If the argument is zero, then the result is {@code 1.0}.
 1082 &nbsp;      *
 1083 &nbsp;      * &lt;/ul&gt;
 1084 &nbsp;      *
 1085 &nbsp;      * &lt;p&gt;The computed result must be within 2.5 ulps of the exact result.
 1086 &nbsp;      *
 1087 &nbsp;      * @param   x The number whose hyperbolic cosine is to be returned.
 1088 &nbsp;      * @return  The hyperbolic cosine of {@code x}.
 1089 &nbsp;      * @since 1.5
 1090 &nbsp;      */
</a><a name="1091"> 1091 &nbsp;     public static double cosh(double x) {
 1092 &nbsp;         return StrictMath.cosh(x);
 1093 &nbsp;     }
 1094 &nbsp; 
 1095 &nbsp;     /**
 1096 &nbsp;      * Returns the hyperbolic tangent of a {@code double} value.
 1097 &nbsp;      * The hyperbolic tangent of &lt;i&gt;x&lt;/i&gt; is defined to be
 1098 &nbsp;      * (&lt;i&gt;e&lt;sup&gt;x&lt;/sup&gt;&amp;nbsp;-&amp;nbsp;e&lt;sup&gt;-x&lt;/sup&gt;&lt;/i&gt;)/(&lt;i&gt;e&lt;sup&gt;x&lt;/sup&gt;&amp;nbsp;+&amp;nbsp;e&lt;sup&gt;-x&lt;/sup&gt;&lt;/i&gt;),
 1099 &nbsp;      * in other words, {@linkplain Math#sinh
 1100 &nbsp;      * sinh(&lt;i&gt;x&lt;/i&gt;)}/{@linkplain Math#cosh cosh(&lt;i&gt;x&lt;/i&gt;)}.  Note
</a><a name="1101"> 1101 &nbsp;      * that the absolute value of the exact tanh is always less than
 1102 &nbsp;      * 1.
 1103 &nbsp;      *
 1104 &nbsp;      * &lt;p&gt;Special cases:
 1105 &nbsp;      * &lt;ul&gt;
 1106 &nbsp;      *
 1107 &nbsp;      * &lt;li&gt;If the argument is NaN, then the result is NaN.
 1108 &nbsp;      *
 1109 &nbsp;      * &lt;li&gt;If the argument is zero, then the result is a zero with the
 1110 &nbsp;      * same sign as the argument.
</a><a name="1111"> 1111 &nbsp;      *
 1112 &nbsp;      * &lt;li&gt;If the argument is positive infinity, then the result is
 1113 &nbsp;      * {@code +1.0}.
 1114 &nbsp;      *
 1115 &nbsp;      * &lt;li&gt;If the argument is negative infinity, then the result is
 1116 &nbsp;      * {@code -1.0}.
 1117 &nbsp;      *
 1118 &nbsp;      * &lt;/ul&gt;
 1119 &nbsp;      *
 1120 &nbsp;      * &lt;p&gt;The computed result must be within 2.5 ulps of the exact result.
</a><a name="1121"> 1121 &nbsp;      * The result of {@code tanh} for any finite input must have
 1122 &nbsp;      * an absolute value less than or equal to 1.  Note that once the
 1123 &nbsp;      * exact result of tanh is within 1/2 of an ulp of the limit value
 1124 &nbsp;      * of &amp;plusmn;1, correctly signed &amp;plusmn;{@code 1.0} should
 1125 &nbsp;      * be returned.
 1126 &nbsp;      *
 1127 &nbsp;      * @param   x The number whose hyperbolic tangent is to be returned.
 1128 &nbsp;      * @return  The hyperbolic tangent of {@code x}.
 1129 &nbsp;      * @since 1.5
 1130 &nbsp;      */
</a><a name="1131"> 1131 &nbsp;     public static double tanh(double x) {
 1132 &nbsp;         return StrictMath.tanh(x);
 1133 &nbsp;     }
 1134 &nbsp; 
 1135 &nbsp;     /**
 1136 &nbsp;      * Returns sqrt(&lt;i&gt;x&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;&amp;nbsp;+&lt;i&gt;y&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;)
 1137 &nbsp;      * without intermediate overflow or underflow.
 1138 &nbsp;      *
 1139 &nbsp;      * &lt;p&gt;Special cases:
 1140 &nbsp;      * &lt;ul&gt;
</a><a name="1141"> 1141 &nbsp;      *
 1142 &nbsp;      * &lt;li&gt; If either argument is infinite, then the result
 1143 &nbsp;      * is positive infinity.
 1144 &nbsp;      *
 1145 &nbsp;      * &lt;li&gt; If either argument is NaN and neither argument is infinite,
 1146 &nbsp;      * then the result is NaN.
 1147 &nbsp;      *
 1148 &nbsp;      * &lt;/ul&gt;
 1149 &nbsp;      *
 1150 &nbsp;      * &lt;p&gt;The computed result must be within 1 ulp of the exact
</a><a name="1151"> 1151 &nbsp;      * result.  If one parameter is held constant, the results must be
 1152 &nbsp;      * semi-monotonic in the other parameter.
 1153 &nbsp;      *
 1154 &nbsp;      * @param x a value
 1155 &nbsp;      * @param y a value
 1156 &nbsp;      * @return sqrt(&lt;i&gt;x&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;&amp;nbsp;+&lt;i&gt;y&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;)
 1157 &nbsp;      * without intermediate overflow or underflow
 1158 &nbsp;      * @since 1.5
 1159 &nbsp;      */
 1160 &nbsp;     public static double hypot(double x, double y) {
</a><a name="1161"> 1161 &nbsp;         return StrictMath.hypot(x, y);
 1162 &nbsp;     }
 1163 &nbsp; 
 1164 &nbsp;     /**
 1165 &nbsp;      * Returns &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;x&lt;/sup&gt;&amp;nbsp;-1.  Note that for values of
 1166 &nbsp;      * &lt;i&gt;x&lt;/i&gt; near 0, the exact sum of
 1167 &nbsp;      * {@code expm1(x)}&amp;nbsp;+&amp;nbsp;1 is much closer to the true
 1168 &nbsp;      * result of &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;x&lt;/sup&gt; than {@code exp(x)}.
 1169 &nbsp;      *
 1170 &nbsp;      * &lt;p&gt;Special cases:
</a><a name="1171"> 1171 &nbsp;      * &lt;ul&gt;
 1172 &nbsp;      * &lt;li&gt;If the argument is NaN, the result is NaN.
 1173 &nbsp;      *
 1174 &nbsp;      * &lt;li&gt;If the argument is positive infinity, then the result is
 1175 &nbsp;      * positive infinity.
 1176 &nbsp;      *
 1177 &nbsp;      * &lt;li&gt;If the argument is negative infinity, then the result is
 1178 &nbsp;      * -1.0.
 1179 &nbsp;      *
 1180 &nbsp;      * &lt;li&gt;If the argument is zero, then the result is a zero with the
</a><a name="1181"> 1181 &nbsp;      * same sign as the argument.
 1182 &nbsp;      *
 1183 &nbsp;      * &lt;/ul&gt;
 1184 &nbsp;      *
 1185 &nbsp;      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
 1186 &nbsp;      * Results must be semi-monotonic.  The result of
 1187 &nbsp;      * {@code expm1} for any finite input must be greater than or
 1188 &nbsp;      * equal to {@code -1.0}.  Note that once the exact result of
 1189 &nbsp;      * &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;{@code x}&lt;/sup&gt;&amp;nbsp;-&amp;nbsp;1 is within 1/2
 1190 &nbsp;      * ulp of the limit value -1, {@code -1.0} should be
</a><a name="1191"> 1191 &nbsp;      * returned.
 1192 &nbsp;      *
 1193 &nbsp;      * @param   x   the exponent to raise &lt;i&gt;e&lt;/i&gt; to in the computation of
 1194 &nbsp;      *              &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;{@code x}&lt;/sup&gt;&amp;nbsp;-1.
 1195 &nbsp;      * @return  the value &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;{@code x}&lt;/sup&gt;&amp;nbsp;-&amp;nbsp;1.
 1196 &nbsp;      * @since 1.5
 1197 &nbsp;      */
 1198 &nbsp;     public static double expm1(double x) {
 1199 &nbsp;         return StrictMath.expm1(x);
 1200 &nbsp;     }
</a><a name="1201"> 1201 &nbsp; 
 1202 &nbsp;     /**
 1203 &nbsp;      * Returns the natural logarithm of the sum of the argument and 1.
 1204 &nbsp;      * Note that for small values {@code x}, the result of
 1205 &nbsp;      * {@code log1p(x)} is much closer to the true result of ln(1
 1206 &nbsp;      * + {@code x}) than the floating-point evaluation of
 1207 &nbsp;      * {@code log(1.0+x)}.
 1208 &nbsp;      *
 1209 &nbsp;      * &lt;p&gt;Special cases:
 1210 &nbsp;      *
</a><a name="1211"> 1211 &nbsp;      * &lt;ul&gt;
 1212 &nbsp;      *
 1213 &nbsp;      * &lt;li&gt;If the argument is NaN or less than -1, then the result is
 1214 &nbsp;      * NaN.
 1215 &nbsp;      *
 1216 &nbsp;      * &lt;li&gt;If the argument is positive infinity, then the result is
 1217 &nbsp;      * positive infinity.
 1218 &nbsp;      *
 1219 &nbsp;      * &lt;li&gt;If the argument is negative one, then the result is
 1220 &nbsp;      * negative infinity.
</a><a name="1221"> 1221 &nbsp;      *
 1222 &nbsp;      * &lt;li&gt;If the argument is zero, then the result is a zero with the
 1223 &nbsp;      * same sign as the argument.
 1224 &nbsp;      *
 1225 &nbsp;      * &lt;/ul&gt;
 1226 &nbsp;      *
 1227 &nbsp;      * &lt;p&gt;The computed result must be within 1 ulp of the exact result.
 1228 &nbsp;      * Results must be semi-monotonic.
 1229 &nbsp;      *
 1230 &nbsp;      * @param   x   a value
</a><a name="1231"> 1231 &nbsp;      * @return the value ln({@code x}&amp;nbsp;+&amp;nbsp;1), the natural
 1232 &nbsp;      * log of {@code x}&amp;nbsp;+&amp;nbsp;1
 1233 &nbsp;      * @since 1.5
 1234 &nbsp;      */
 1235 &nbsp;     public static double log1p(double x) {
 1236 &nbsp;         return StrictMath.log1p(x);
 1237 &nbsp;     }
 1238 &nbsp; 
 1239 &nbsp;     /**
 1240 &nbsp;      * Returns the first floating-point argument with the sign of the
</a><a name="1241"> 1241 &nbsp;      * second floating-point argument.  Note that unlike the {@link
 1242 &nbsp;      * StrictMath#copySign(double, double) StrictMath.copySign}
 1243 &nbsp;      * method, this method does not require NaN {@code sign}
 1244 &nbsp;      * arguments to be treated as positive values; implementations are
 1245 &nbsp;      * permitted to treat some NaN arguments as positive and other NaN
 1246 &nbsp;      * arguments as negative to allow greater performance.
 1247 &nbsp;      *
 1248 &nbsp;      * @param magnitude  the parameter providing the magnitude of the result
 1249 &nbsp;      * @param sign   the parameter providing the sign of the result
 1250 &nbsp;      * @return a value with the magnitude of {@code magnitude}
</a><a name="1251"> 1251 &nbsp;      * and the sign of {@code sign}.
 1252 &nbsp;      * @since 1.6
 1253 &nbsp;      */
 1254 &nbsp;     public static double copySign(double magnitude, double sign) {
 1255 &nbsp;         return sun.misc.FpUtils.rawCopySign(magnitude, sign);
 1256 &nbsp;     }
 1257 &nbsp; 
 1258 &nbsp;     /**
 1259 &nbsp;      * Returns the first floating-point argument with the sign of the
 1260 &nbsp;      * second floating-point argument.  Note that unlike the {@link
</a><a name="1261"> 1261 &nbsp;      * StrictMath#copySign(float, float) StrictMath.copySign}
 1262 &nbsp;      * method, this method does not require NaN {@code sign}
 1263 &nbsp;      * arguments to be treated as positive values; implementations are
 1264 &nbsp;      * permitted to treat some NaN arguments as positive and other NaN
 1265 &nbsp;      * arguments as negative to allow greater performance.
 1266 &nbsp;      *
 1267 &nbsp;      * @param magnitude  the parameter providing the magnitude of the result
 1268 &nbsp;      * @param sign   the parameter providing the sign of the result
 1269 &nbsp;      * @return a value with the magnitude of {@code magnitude}
 1270 &nbsp;      * and the sign of {@code sign}.
</a><a name="1271"> 1271 &nbsp;      * @since 1.6
 1272 &nbsp;      */
 1273 &nbsp;     public static float copySign(float magnitude, float sign) {
 1274 &nbsp;         return sun.misc.FpUtils.rawCopySign(magnitude, sign);
 1275 &nbsp;     }
 1276 &nbsp; 
 1277 &nbsp;     /**
 1278 &nbsp;      * Returns the unbiased exponent used in the representation of a
 1279 &nbsp;      * {@code float}.  Special cases:
 1280 &nbsp;      *
</a><a name="1281"> 1281 &nbsp;      * &lt;ul&gt;
 1282 &nbsp;      * &lt;li&gt;If the argument is NaN or infinite, then the result is
 1283 &nbsp;      * {@link Float#MAX_EXPONENT} + 1.
 1284 &nbsp;      * &lt;li&gt;If the argument is zero or subnormal, then the result is
 1285 &nbsp;      * {@link Float#MIN_EXPONENT} -1.
 1286 &nbsp;      * &lt;/ul&gt;
 1287 &nbsp;      * @param f a {@code float} value
 1288 &nbsp;      * @return the unbiased exponent of the argument
 1289 &nbsp;      * @since 1.6
 1290 &nbsp;      */
</a><a name="1291"> 1291 &nbsp;     public static int getExponent(float f) {
 1292 &nbsp;         return sun.misc.FpUtils.getExponent(f);
 1293 &nbsp;     }
 1294 &nbsp; 
 1295 &nbsp;     /**
 1296 &nbsp;      * Returns the unbiased exponent used in the representation of a
 1297 &nbsp;      * {@code double}.  Special cases:
 1298 &nbsp;      *
 1299 &nbsp;      * &lt;ul&gt;
 1300 &nbsp;      * &lt;li&gt;If the argument is NaN or infinite, then the result is
</a><a name="1301"> 1301 &nbsp;      * {@link Double#MAX_EXPONENT} + 1.
 1302 &nbsp;      * &lt;li&gt;If the argument is zero or subnormal, then the result is
 1303 &nbsp;      * {@link Double#MIN_EXPONENT} -1.
 1304 &nbsp;      * &lt;/ul&gt;
 1305 &nbsp;      * @param d a {@code double} value
 1306 &nbsp;      * @return the unbiased exponent of the argument
 1307 &nbsp;      * @since 1.6
 1308 &nbsp;      */
 1309 &nbsp;     public static int getExponent(double d) {
 1310 &nbsp;         return sun.misc.FpUtils.getExponent(d);
</a><a name="1311"> 1311 &nbsp;     }
 1312 &nbsp; 
 1313 &nbsp;     /**
 1314 &nbsp;      * Returns the floating-point number adjacent to the first
 1315 &nbsp;      * argument in the direction of the second argument.  If both
 1316 &nbsp;      * arguments compare as equal the second argument is returned.
 1317 &nbsp;      *
 1318 &nbsp;      * &lt;p&gt;
 1319 &nbsp;      * Special cases:
 1320 &nbsp;      * &lt;ul&gt;
</a><a name="1321"> 1321 &nbsp;      * &lt;li&gt; If either argument is a NaN, then NaN is returned.
 1322 &nbsp;      *
 1323 &nbsp;      * &lt;li&gt; If both arguments are signed zeros, {@code direction}
 1324 &nbsp;      * is returned unchanged (as implied by the requirement of
 1325 &nbsp;      * returning the second argument if the arguments compare as
 1326 &nbsp;      * equal).
 1327 &nbsp;      *
 1328 &nbsp;      * &lt;li&gt; If {@code start} is
 1329 &nbsp;      * &amp;plusmn;{@link Double#MIN_VALUE} and {@code direction}
 1330 &nbsp;      * has a value such that the result should have a smaller
</a><a name="1331"> 1331 &nbsp;      * magnitude, then a zero with the same sign as {@code start}
 1332 &nbsp;      * is returned.
 1333 &nbsp;      *
 1334 &nbsp;      * &lt;li&gt; If {@code start} is infinite and
 1335 &nbsp;      * {@code direction} has a value such that the result should
 1336 &nbsp;      * have a smaller magnitude, {@link Double#MAX_VALUE} with the
 1337 &nbsp;      * same sign as {@code start} is returned.
 1338 &nbsp;      *
 1339 &nbsp;      * &lt;li&gt; If {@code start} is equal to &amp;plusmn;
 1340 &nbsp;      * {@link Double#MAX_VALUE} and {@code direction} has a
</a><a name="1341"> 1341 &nbsp;      * value such that the result should have a larger magnitude, an
 1342 &nbsp;      * infinity with same sign as {@code start} is returned.
 1343 &nbsp;      * &lt;/ul&gt;
 1344 &nbsp;      *
 1345 &nbsp;      * @param start  starting floating-point value
 1346 &nbsp;      * @param direction value indicating which of
 1347 &nbsp;      * {@code start}'s neighbors or {@code start} should
 1348 &nbsp;      * be returned
 1349 &nbsp;      * @return The floating-point number adjacent to {@code start} in the
 1350 &nbsp;      * direction of {@code direction}.
</a><a name="1351"> 1351 &nbsp;      * @since 1.6
 1352 &nbsp;      */
 1353 &nbsp;     public static double nextAfter(double start, double direction) {
 1354 &nbsp;         return sun.misc.FpUtils.nextAfter(start, direction);
 1355 &nbsp;     }
 1356 &nbsp; 
 1357 &nbsp;     /**
 1358 &nbsp;      * Returns the floating-point number adjacent to the first
 1359 &nbsp;      * argument in the direction of the second argument.  If both
 1360 &nbsp;      * arguments compare as equal a value equivalent to the second argument
</a><a name="1361"> 1361 &nbsp;      * is returned.
 1362 &nbsp;      *
 1363 &nbsp;      * &lt;p&gt;
 1364 &nbsp;      * Special cases:
 1365 &nbsp;      * &lt;ul&gt;
 1366 &nbsp;      * &lt;li&gt; If either argument is a NaN, then NaN is returned.
 1367 &nbsp;      *
 1368 &nbsp;      * &lt;li&gt; If both arguments are signed zeros, a value equivalent
 1369 &nbsp;      * to {@code direction} is returned.
 1370 &nbsp;      *
</a><a name="1371"> 1371 &nbsp;      * &lt;li&gt; If {@code start} is
 1372 &nbsp;      * &amp;plusmn;{@link Float#MIN_VALUE} and {@code direction}
 1373 &nbsp;      * has a value such that the result should have a smaller
 1374 &nbsp;      * magnitude, then a zero with the same sign as {@code start}
 1375 &nbsp;      * is returned.
 1376 &nbsp;      *
 1377 &nbsp;      * &lt;li&gt; If {@code start} is infinite and
 1378 &nbsp;      * {@code direction} has a value such that the result should
 1379 &nbsp;      * have a smaller magnitude, {@link Float#MAX_VALUE} with the
 1380 &nbsp;      * same sign as {@code start} is returned.
</a><a name="1381"> 1381 &nbsp;      *
 1382 &nbsp;      * &lt;li&gt; If {@code start} is equal to &amp;plusmn;
 1383 &nbsp;      * {@link Float#MAX_VALUE} and {@code direction} has a
 1384 &nbsp;      * value such that the result should have a larger magnitude, an
 1385 &nbsp;      * infinity with same sign as {@code start} is returned.
 1386 &nbsp;      * &lt;/ul&gt;
 1387 &nbsp;      *
 1388 &nbsp;      * @param start  starting floating-point value
 1389 &nbsp;      * @param direction value indicating which of
 1390 &nbsp;      * {@code start}'s neighbors or {@code start} should
</a><a name="1391"> 1391 &nbsp;      * be returned
 1392 &nbsp;      * @return The floating-point number adjacent to {@code start} in the
 1393 &nbsp;      * direction of {@code direction}.
 1394 &nbsp;      * @since 1.6
 1395 &nbsp;      */
 1396 &nbsp;     public static float nextAfter(float start, double direction) {
 1397 &nbsp;         return sun.misc.FpUtils.nextAfter(start, direction);
 1398 &nbsp;     }
 1399 &nbsp; 
 1400 &nbsp;     /**
</a><a name="1401"> 1401 &nbsp;      * Returns the floating-point value adjacent to {@code d} in
 1402 &nbsp;      * the direction of positive infinity.  This method is
 1403 &nbsp;      * semantically equivalent to {@code nextAfter(d,
 1404 &nbsp;      * Double.POSITIVE_INFINITY)}; however, a {@code nextUp}
 1405 &nbsp;      * implementation may run faster than its equivalent
 1406 &nbsp;      * {@code nextAfter} call.
 1407 &nbsp;      *
 1408 &nbsp;      * &lt;p&gt;Special Cases:
 1409 &nbsp;      * &lt;ul&gt;
 1410 &nbsp;      * &lt;li&gt; If the argument is NaN, the result is NaN.
</a><a name="1411"> 1411 &nbsp;      *
 1412 &nbsp;      * &lt;li&gt; If the argument is positive infinity, the result is
 1413 &nbsp;      * positive infinity.
 1414 &nbsp;      *
 1415 &nbsp;      * &lt;li&gt; If the argument is zero, the result is
 1416 &nbsp;      * {@link Double#MIN_VALUE}
 1417 &nbsp;      *
 1418 &nbsp;      * &lt;/ul&gt;
 1419 &nbsp;      *
 1420 &nbsp;      * @param d starting floating-point value
</a><a name="1421"> 1421 &nbsp;      * @return The adjacent floating-point value closer to positive
 1422 &nbsp;      * infinity.
 1423 &nbsp;      * @since 1.6
 1424 &nbsp;      */
 1425 &nbsp;     public static double nextUp(double d) {
 1426 &nbsp;         return sun.misc.FpUtils.nextUp(d);
 1427 &nbsp;     }
 1428 &nbsp; 
 1429 &nbsp;     /**
 1430 &nbsp;      * Returns the floating-point value adjacent to {@code f} in
</a><a name="1431"> 1431 &nbsp;      * the direction of positive infinity.  This method is
 1432 &nbsp;      * semantically equivalent to {@code nextAfter(f,
 1433 &nbsp;      * Float.POSITIVE_INFINITY)}; however, a {@code nextUp}
 1434 &nbsp;      * implementation may run faster than its equivalent
 1435 &nbsp;      * {@code nextAfter} call.
 1436 &nbsp;      *
 1437 &nbsp;      * &lt;p&gt;Special Cases:
 1438 &nbsp;      * &lt;ul&gt;
 1439 &nbsp;      * &lt;li&gt; If the argument is NaN, the result is NaN.
 1440 &nbsp;      *
</a><a name="1441"> 1441 &nbsp;      * &lt;li&gt; If the argument is positive infinity, the result is
 1442 &nbsp;      * positive infinity.
 1443 &nbsp;      *
 1444 &nbsp;      * &lt;li&gt; If the argument is zero, the result is
 1445 &nbsp;      * {@link Float#MIN_VALUE}
 1446 &nbsp;      *
 1447 &nbsp;      * &lt;/ul&gt;
 1448 &nbsp;      *
 1449 &nbsp;      * @param f starting floating-point value
 1450 &nbsp;      * @return The adjacent floating-point value closer to positive
</a><a name="1451"> 1451 &nbsp;      * infinity.
 1452 &nbsp;      * @since 1.6
 1453 &nbsp;      */
 1454 &nbsp;     public static float nextUp(float f) {
 1455 &nbsp;         return sun.misc.FpUtils.nextUp(f);
 1456 &nbsp;     }
 1457 &nbsp; 
 1458 &nbsp; 
 1459 &nbsp;     /**
 1460 &nbsp;      * Return {@code d} &amp;times;
</a><a name="1461"> 1461 &nbsp;      * 2&lt;sup&gt;{@code scaleFactor}&lt;/sup&gt; rounded as if performed
 1462 &nbsp;      * by a single correctly rounded floating-point multiply to a
 1463 &nbsp;      * member of the double value set.  See the Java
 1464 &nbsp;      * Language Specification for a discussion of floating-point
 1465 &nbsp;      * value sets.  If the exponent of the result is between {@link
 1466 &nbsp;      * Double#MIN_EXPONENT} and {@link Double#MAX_EXPONENT}, the
 1467 &nbsp;      * answer is calculated exactly.  If the exponent of the result
 1468 &nbsp;      * would be larger than {@code Double.MAX_EXPONENT}, an
 1469 &nbsp;      * infinity is returned.  Note that if the result is subnormal,
 1470 &nbsp;      * precision may be lost; that is, when {@code scalb(x, n)}
</a><a name="1471"> 1471 &nbsp;      * is subnormal, {@code scalb(scalb(x, n), -n)} may not equal
 1472 &nbsp;      * &lt;i&gt;x&lt;/i&gt;.  When the result is non-NaN, the result has the same
 1473 &nbsp;      * sign as {@code d}.
 1474 &nbsp;      *
 1475 &nbsp;      * &lt;p&gt;Special cases:
 1476 &nbsp;      * &lt;ul&gt;
 1477 &nbsp;      * &lt;li&gt; If the first argument is NaN, NaN is returned.
 1478 &nbsp;      * &lt;li&gt; If the first argument is infinite, then an infinity of the
 1479 &nbsp;      * same sign is returned.
 1480 &nbsp;      * &lt;li&gt; If the first argument is zero, then a zero of the same
</a><a name="1481"> 1481 &nbsp;      * sign is returned.
 1482 &nbsp;      * &lt;/ul&gt;
 1483 &nbsp;      *
 1484 &nbsp;      * @param d number to be scaled by a power of two.
 1485 &nbsp;      * @param scaleFactor power of 2 used to scale {@code d}
 1486 &nbsp;      * @return {@code d} &amp;times; 2&lt;sup&gt;{@code scaleFactor}&lt;/sup&gt;
 1487 &nbsp;      * @since 1.6
 1488 &nbsp;      */
 1489 &nbsp;     public static double scalb(double d, int scaleFactor) {
 1490 &nbsp;         return sun.misc.FpUtils.scalb(d, scaleFactor);
</a><a name="1491"> 1491 &nbsp;     }
 1492 &nbsp; 
 1493 &nbsp;     /**
 1494 &nbsp;      * Return {@code f} &amp;times;
 1495 &nbsp;      * 2&lt;sup&gt;{@code scaleFactor}&lt;/sup&gt; rounded as if performed
 1496 &nbsp;      * by a single correctly rounded floating-point multiply to a
 1497 &nbsp;      * member of the float value set.  See the Java
 1498 &nbsp;      * Language Specification for a discussion of floating-point
 1499 &nbsp;      * value sets.  If the exponent of the result is between {@link
 1500 &nbsp;      * Float#MIN_EXPONENT} and {@link Float#MAX_EXPONENT}, the
</a><a name="1501"> 1501 &nbsp;      * answer is calculated exactly.  If the exponent of the result
 1502 &nbsp;      * would be larger than {@code Float.MAX_EXPONENT}, an
 1503 &nbsp;      * infinity is returned.  Note that if the result is subnormal,
 1504 &nbsp;      * precision may be lost; that is, when {@code scalb(x, n)}
 1505 &nbsp;      * is subnormal, {@code scalb(scalb(x, n), -n)} may not equal
 1506 &nbsp;      * &lt;i&gt;x&lt;/i&gt;.  When the result is non-NaN, the result has the same
 1507 &nbsp;      * sign as {@code f}.
 1508 &nbsp;      *
 1509 &nbsp;      * &lt;p&gt;Special cases:
 1510 &nbsp;      * &lt;ul&gt;
</a><a name="1511"> 1511 &nbsp;      * &lt;li&gt; If the first argument is NaN, NaN is returned.
 1512 &nbsp;      * &lt;li&gt; If the first argument is infinite, then an infinity of the
 1513 &nbsp;      * same sign is returned.
 1514 &nbsp;      * &lt;li&gt; If the first argument is zero, then a zero of the same
 1515 &nbsp;      * sign is returned.
 1516 &nbsp;      * &lt;/ul&gt;
 1517 &nbsp;      *
 1518 &nbsp;      * @param f number to be scaled by a power of two.
 1519 &nbsp;      * @param scaleFactor power of 2 used to scale {@code f}
 1520 &nbsp;      * @return {@code f} &amp;times; 2&lt;sup&gt;{@code scaleFactor}&lt;/sup&gt;
</a><a name="1521"> 1521 &nbsp;      * @since 1.6
 1522 &nbsp;      */
 1523 &nbsp;     public static float scalb(float f, int scaleFactor) {
 1524 &nbsp;         return sun.misc.FpUtils.scalb(f, scaleFactor);
 1525 &nbsp;     }
 1526 &nbsp; }

</a></pre>
  <a name="1521"> </a>
  <div style="width:100%;background-color:#ddeeff;border:1px solid #ccddee;margin:0 0 0 0;padding:2px 2px 2px 2px">
   <a name="1521"> 
    <div style="float:right">
     <a href="http://del.icio.us/post" onclick="window.open('http://del.icio.us/post?v=4&amp;noui&amp;jump=close&amp;url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title), 'delicious','toolbar=no,width=700,height=400'); return false;"><img src="http://images.del.icio.us/static/img/delicious.small.gif" border="0"> Save This Page</a>
    </div></a> 
   <a href="/">Home</a> » 
   <a href="/projects/openjdk-7-java.html">openjdk-7</a> » java » 
   <a href="/docs/api/java/lang/package-index.html">lang</a> » [
   <a href="/docs/api/java/lang/Math.html">javadoc</a> | source] 
  </div> 
  <script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script> 
  <script type="text/javascript">
var pageTracker = _gat._getTracker("UA-138120-1");
pageTracker._trackPageview();
</script>   
  <!-- end -->
 </body>
</html>