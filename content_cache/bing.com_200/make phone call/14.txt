<!doctype html>
<html>
 <head> 
  <title>Compiled code · R packages</title> 
  <meta charset="utf-8"> 
  <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
  <link href="www/bootstrap.min.css" rel="stylesheet"> 
  <link href="www/highlight.css" rel="stylesheet"> 
  <link href="http://fonts.googleapis.com/css?family=Inconsolata:400,700" rel="stylesheet" type="text/css"> 
 </head> 
 <body> 
  <div class="container"> 
   <div class="masthead"> 
    <ul class="nav nav-pills pull-right"> 
     <li class="dropdown"> <a href="#" class="dropdown-toggle" data-toggle="dropdown"> Table of contents <b class="caret"></b> </a> 
      <ul class="dropdown-menu pull-right" role="menu"> 
       <li class="dropdown-header">Getting started</li> 
       <li><a href="intro.html">Introduction</a></li> 
       <li><a href="package.html">Package structure</a></li> 
       <li class="dropdown-header">Package components</li> 
       <li><a href="r.html">Code (<code>R/</code>)</a></li> 
       <li><a href="description.html">Package metadata (<code>DESCRIPTION</code>)</a></li> 
       <li><a href="man.html">Object documentation (<code>man/</code>)</a></li> 
       <li><a href="vignettes.html">Vignettes (<code>vignettes/</code>)</a></li> 
       <li><a href="tests.html">Testing (<code>tests/</code>)</a></li> 
       <li><a href="namespace.html">Namespaces (<code>NAMESPACE</code>)</a></li> 
       <li><a href="data.html">Data (<code>data/</code>)</a></li> 
       <li><a href="src.html">Compiled code (<code>src/</code>)</a></li> 
       <li><a href="inst.html">Installed files (<code>inst/</code>)</a></li> 
       <li><a href="misc.html">Other components</a></li> 
       <li class="dropdown-header">Best practices</li> 
       <li><a href="git.html">Git and GitHub</a></li> 
       <li><a href="check.html">Checking</a></li> 
       <li><a href="release.html">Release</a></li> 
      </ul> </li> 
    </ul> 
    <h3 class="muted"><a href="/">R packages</a> <small>by Hadley Wickham</small></h3> 
    <hr> 
   </div> 
   <div class="row"> 
    <div class="col-xs-12 col-sm-3" id="nav"> 
     <div class="well">
       Want a physical copy of this material? 
      <a href="http://amzn.com/1491910593?tag=r-pkgs-20">Buy from amazon!</a>. 
     </div> 
     <h4>Contents</h4> 
     <ul class="list-unstyled" id="toc"></ul> 
     <hr> 
     <p><a href="/contribute.html">How to contribute</a></p> 
     <p><a class="btn btn-primary" href="https://github.com/hadley/r-pkgs/edit/master/src.rmd">Edit this page</a></p> 
    </div> 
    <div id="content" class="col-xs-12 col-sm-8 pull-right"> 
     <h1 id="src">Compiled code</h1> 
     <p>R is high-level, expressive language. But that expressivity comes at a price: speed. That’s why incorporating a low-level, compiled language like C or C++ can powerfully complement your R code. While C and C++ often require more lines of code (and more careful thought) to solve the same problem, they can be orders of magnitude faster than R.</p> 
     <p>Unfortunately, teaching you how to program in C or C++ is beyond the scope of the book. If you’d like to learn, I recommend starting with C++ and the Rcpp package. Rcpp makes it easy to connect C++ to R. I’d also recommend using RStudio because it has many tools that facilitate the entire process. Start by reading my <a href="http://adv-r.had.co.nz/Rcpp.html">“High performance functions with Rcpp”</a>, a freely available book chapter from <a href="http://amzn.com/1466586966?tag=devtools-20">Advanced R</a>: it gently introduces the language by translating examples of familiar R code into C++. Next, check out the <a href="http://www.rcpp.org/book">Rcpp book</a> and the other resources listed in <a href="http://adv-r.had.co.nz/Rcpp.html#rcpp-more">learning more</a>.</p> 
     <h2 id="cpp">C++</h2> 
     <p>To set up your package with Rcpp, run:</p> 
     <div class="sourceCode">
      <pre class="sourceCode r"><code class="sourceCode r">devtools::<span class="kw">use_rcpp</span>()</code></pre>
     </div> 
     <p>This will:</p> 
     <ul> 
      <li><p>Create a <code>src/</code> directory to hold your <code>.cpp</code> files.</p></li> 
      <li><p>Add <code>Rcpp</code> to the <code>LinkingTo</code> and <code>Imports</code> fields in the <code>DESCRIPTION</code>.</p></li> 
      <li><p>Set up a <code>.gitignore</code> file to make sure you don’t accidentally check in any compiled files (learn more about this in <a href="git.html#git">git</a>).</p></li> 
      <li><p>Tell you the two roxygen tags you need to add to your package:</p> 
       <div class="sourceCode">
        <pre class="sourceCode r"><code class="sourceCode r"><span class="co">#' @useDynLib your-package-name</span>
<span class="co">#' @importFrom Rcpp sourceCpp</span>
<span class="ot">NULL</span></code></pre>
       </div> <pre><code>## NULL</code></pre></li> 
     </ul> 
     <h3 id="cpp-workflow">Workflow</h3> 
     <p>Once you’re set up, the basic workflow should now be familiar:</p> 
     <ol style="list-style-type: decimal"> 
      <li><p>Create a new C++ file:</p> <p><img src="screenshots/new-cpp.png" width="387" height="202"></p> <p>The default template looks like this:</p> 
       <div class="sourceCode">
        <pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;Rcpp.h&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> Rcpp;

<span class="co">// Below is a simple example of exporting a C++ function to R. You can</span>
<span class="co">// source this function into an R session using the Rcpp::sourceCpp </span>
<span class="co">// function (or via the Source button on the editor toolbar)</span>

<span class="co">// For more on using Rcpp click the Help button on the editor toolbar</span>

<span class="co">// [[Rcpp::export]]</span>
<span class="dt">int</span> timesTwo(<span class="dt">int</span> x) {
   <span class="kw">return</span> x * <span class="dv">2</span>;
}</code></pre>
       </div> <p>It includes a basic function and some instructions to get started. The two most important parts are the header <code>#includes</code>, and the special attribute <code>// [[Rcpp::export]]</code>.</p></li> 
      <li><p>Generate the necessary modifications to your <code>NAMESPACE</code> by documenting them with Ctrl/Cmd + Shift + D.</p></li> 
      <li><p>Click Build &amp; Reload in the build pane, or press Ctrl/Cmd + Shift + B. You can continue to use the standard <code>devtools::load_all()</code> process but it is more risky. Because you’re loading and unloading C code, the chances of corrupting memory are high, and you’re better off with the safer, but slower, “Build &amp; Reload” which installs the package then restarts R.</p></li> 
      <li><p>Run <code>timesTwo(10)</code> from the console to check that it works.</p></li> 
     </ol> 
     <p>Behind the scenes, “Build and reload” is doing a lot of work for you. They:</p> 
     <ul> 
      <li><p>Set up your R environment to compile code and warn you if you’re missing necessary pieces.</p></li> 
      <li><p>Call <code>Rcpp::compileAttributes()</code>. This inspects your <code>.cpp</code> functions looking for <strong>attributes</strong> of the form <code>// [[Rcpp::export]]</code>. When it finds one, it generates the code needed to make the function available in R, and creates <code>src/RcppExports.cpp</code> and <code>R/RcppExports.R</code>. You should never modify these files by hand.</p></li> 
      <li><p>Build a DLL (dynamically linked library) and make it available to R.</p></li> 
     </ul> 
     <h3 id="cpp-man">Documentation</h3> 
     <p>Each exported C++ function automatically gets a wrapper function (it will be located in <code>R/RcppExports.R</code>). For example, the R <code>timesTwo()</code> function looks like:</p> 
     <div class="sourceCode">
      <pre class="sourceCode r"><code class="sourceCode r">timesTwo &lt;-<span class="st"> </span>function(x) {
  <span class="kw">.Call</span>(<span class="st">'timesTwo'</span>, <span class="dt">PACKAGE =</span> <span class="st">'mypackage'</span>, x)
}</code></pre>
     </div> 
     <p>This uses the base function <code>.Call()</code> to execute the C function <code>timesTwo</code> provided by “mypackage”. You can use roxygen2 to document this like a regular R function. But instead of using <code>#'</code> for comments use <code>//'</code>, the C++ convention:</p> 
     <div class="sourceCode">
      <pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//' Multiply a number by two</span>
<span class="co">//' </span>
<span class="co">//' @param x A single integer.</span>
<span class="co">//' @export</span>
<span class="co">// [[Rcpp::export]]</span>
<span class="dt">int</span> timesTwo(<span class="dt">int</span> x) {
   <span class="kw">return</span> x * <span class="dv">2</span>;
}</code></pre>
     </div> 
     <p>That generates roxygen comments in <code>R/RcppExports.R</code>:</p> 
     <div class="sourceCode">
      <pre class="sourceCode r"><code class="sourceCode r"><span class="co">#' Multiply a number by two</span>
<span class="co">#' </span>
<span class="co">#' @param x A single integer.</span>
<span class="co">#' @export</span>
timesTwo &lt;-<span class="st"> </span>function(x) {
  <span class="kw">.Call</span>(<span class="st">'timesTwo'</span>, <span class="dt">PACKAGE =</span> <span class="st">'mypackage'</span>, x)
}</code></pre>
     </div> 
     <p>The distinctions between the two export directives is important:</p> 
     <ul> 
      <li><p><code>[[Rcpp::export]]</code> makes the C++ function available to R. If you have trouble remembering the exact details, note that everything comes in twos: Two <code>/</code>, two <code>[</code>, two <code>:</code> and two <code>]</code>.</p></li> 
      <li><p><code>@export</code> makes the R wrapper function available outside your package by adding it to the <code>NAMESPACE</code>.</p></li> 
     </ul> 
     <h3 id="cpp-export">Exporting C++ code</h3> 
     <p>To make your C++ code callable from C++ code in other packages, add:</p> 
     <div class="sourceCode">
      <pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// [[Rcpp::interfaces(r, cpp)]]</span></code></pre>
     </div> 
     <p>This will generate a header file, <code>inst/include/mypackage.h</code> that can be included by other packages (The low-level details are described in <a href="#c-export">Exporting C code</a>{#c-export}). See “<a href="http://dirk.eddelbuettel.com/code/rcpp/Rcpp-attributes.pdf">Rcpp Attributes</a>” for more details, including how to combine hand-written and automatically generated header files.</p> 
     <h3 id="cpp-import">Importing C++ code</h3> 
     <p>To use C++ code from another package:</p> 
     <ol style="list-style-type: decimal"> 
      <li><p>In <code>DESCRIPTION</code>, add <code>LinkingTo: otherPackage</code>. Confusingly this has nothing to do with the linker. It’s called <code>LinkingTo</code> because it adds <code>otherPackage/include</code> to the include path, allowing you to dynamically “link to” other code via the headers.</p></li> 
      <li><p>In the C++ file, add:</p> 
       <div class="sourceCode">
        <pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;otherPackage.h&gt;</span></code></pre>
       </div></li> 
      <li><p>C++ functions from otherPackage will be included in the <code>otherPackage</code> namespace. Use <code>otherPackage::foo()</code> to access functions, or make them available globally with <code>using namespace otherPackage</code>.</p></li> 
     </ol> 
     <h3 id="cpp-best-practices">Best practices</h3> 
     <ul> 
      <li><p>To print output use <code>Rcout &lt;&lt; ...</code> (not <code>cout &lt;&lt; ...</code>). This prints to the right place, which might be a GUI console or a file (if <code>sink()</code> is active)</p></li> 
      <li><p>In long-running loops, regularly run <code>Rcpp::checkUserInterrupt()</code>. This aborts your C++ if the user has pressed Ctrl + C or Escape in R.</p></li> 
      <li><p>Use <code>.h</code> extension for headers and include files. (If you don’t <code>R CMD check</code> will complain).</p></li> 
      <li><p>Follow Martyn Plummer’s recommendations on <a href="http://journal.r-project.org/archive/2011-2/RJournal_2011-2_Plummer.pdf">Portable C++ for R packages</a>.</p></li> 
      <li><p>Whenever you use C++ code in your package, you need to clean up after yourself when your package is unloaded. Do this by writing a <code>.onUnload()</code> function that unloads the DLL:</p> 
       <div class="sourceCode">
        <pre class="sourceCode r"><code class="sourceCode r">.onUnload &lt;-<span class="st"> </span>function (libpath) {
  <span class="kw">library.dynam.unload</span>(<span class="st">"mypackage"</span>, libpath)
}</code></pre>
       </div></li> 
      <li><p>Use <code>clang</code> instead of <code>gcc</code> to compile your C++ code: it gives much better error messages. You can make <code>clang</code> the default by creating a <code>.R/Makevars</code> (linux and mac) or <code>.R/Makevars.win</code> (windows) file in your home directory that contains:</p> 
       <div class="sourceCode">
        <pre class="sourceCode bash"><code class="sourceCode bash"><span class="ot">CXX=</span>clang++</code></pre>
       </div> <p>(If you don’t know where your home directory is <code>path.expand("~")</code> will tell you.)</p></li> 
      <li><p>To speed up compilation on linux or mac, install <code>ccache</code>, then replace <code>~/.R/Makevars</code> with:</p> 
       <div class="sourceCode">
        <pre class="sourceCode bash"><code class="sourceCode bash"><span class="ot">CC=</span>ccache <span class="kw">clang</span> -Qunused-arguments
<span class="ot">CXX=</span>ccache <span class="kw">clang++</span> -Qunused-arguments
<span class="ot">CCACHE_CPP2=</span>yes</code></pre>
       </div></li> 
     </ul> 
     <h2 id="clang">C</h2> 
     <p>If you’re writing new compiled code, it’s almost always better to use Rcpp. It’s less work, more consistent, better documented, and it has better tools. However, there are some reasons to choose C:</p> 
     <ul> 
      <li>You’re working with an older package that already uses the C API.</li> 
      <li>You’re binding to an existing C library.</li> 
     </ul> 
     <p>There are two ways to call C functions from R: <code>.C()</code> and <code>.Call()</code>. <code>.C()</code> is a quick and dirty way to call an C function that doesn’t know anything about R because <code>.C()</code> automatically converts between R vectors and the corresponding C types. <code>.Call()</code> is more flexible, but more work: your C function needs to use the R API to convert its inputs to standard C data types.</p> 
     <h3>Getting started with <code>.Call()</code></h3> 
     <p>To call a C function from R, you first need a C function! In an R package, C code lives in <code>.c</code> files in <code>src/</code>. You’ll need to include two header files:</p> 
     <div class="sourceCode">
      <pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &lt;R.h&gt;</span>
<span class="ot">#include &lt;Rinternals.h&gt;</span></code></pre>
     </div> 
     <p>(Yes, including <code>&lt;Rinternals.h&gt;</code> seems like bad form. On top of that, doing so doesn’t actually give you access to the “internal” internal API unless you set some additional flags. The default just gives you access to the “public” internal API, which is both necessary and done for safety’s sake. Yes, this is confusing.)</p> 
     <p>These headers allow you to access R’s C API. Unfortunately this API is not well documented. I’d recommend starting with my notes at <a href="http://adv-r.had.co.nz/C-interface.html">R’s C interface</a>. After that, read “<a href="http://cran.rstudio.com/doc/manuals/r-devel/R-exts.html#The-R-API">The R API</a>” in “Writing R Extensions”. A number of exported functions are not documented, so you’ll also need to read the <a href="https://github.com/wch/r-source">R source code</a> to figure out the details.</p> 
     <p>Here’s the bare minimum you need to know: C functions that talk to R must use the <code>SEXP</code> type for both inputs and outputs. <code>SEXP</code>, short for S expression, is the C struct used to represent every type of object in R. A C function typically starts by converting <code>SEXP</code>s to atomic C objects, and ends by converting C objects back to a <code>SEXP</code>. (The R API is designed so that these conversions often don’t require copying.) The following table lists the functions that convert length one R vectors to and from C scalars:</p> 
     <table> 
      <thead> 
       <tr class="header"> 
        <th align="left">R type</th> 
        <th align="left">C type</th> 
        <th align="left">R -&gt; C</th> 
        <th align="left">C -&gt; R</th> 
       </tr> 
      </thead> 
      <tbody> 
       <tr class="odd"> 
        <td align="left">integer</td> 
        <td align="left">int</td> 
        <td align="left"><code>asInteger(x)</code></td> 
        <td align="left"><code>ScalarInteger(x)</code></td> 
       </tr> 
       <tr class="even"> 
        <td align="left">numeric</td> 
        <td align="left">double</td> 
        <td align="left"><code>asReal(x)</code></td> 
        <td align="left"><code>ScalarReal(x)</code></td> 
       </tr> 
       <tr class="odd"> 
        <td align="left">logical</td> 
        <td align="left">int</td> 
        <td align="left"><code>asLogical(x)</code></td> 
        <td align="left"><code>ScalarLogical(x)</code></td> 
       </tr> 
       <tr class="even"> 
        <td align="left">character</td> 
        <td align="left">const char*</td> 
        <td align="left"><code>CHAR(asChar(x))</code></td> 
        <td align="left"><code>mkString(x)</code></td> 
       </tr> 
      </tbody> 
     </table> 
     <p>We now have enough information to write a simple C function that can add two numbers:</p> 
     <div class="sourceCode">
      <pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &lt;R.h&gt;</span>
<span class="ot">#include &lt;Rinternals.h&gt;</span>

SEXP add_(SEXP x_, SEXP y_) {
  <span class="dt">double</span> x = asReal(x_);
  <span class="dt">double</span> y = asReal(y_);
  
  <span class="dt">double</span> sum = x + y;
  
  <span class="kw">return</span> ScalarReal(sum);
}</code></pre>
     </div> 
     <p>We call this from R with <code>.Call()</code>:</p> 
     <div class="sourceCode">
      <pre class="sourceCode r"><code class="sourceCode r"><span class="co">#' @useDynLib mypackage add_</span>
add &lt;-<span class="st"> </span>function(x, y) <span class="kw">.Call</span>(add_, x, y)</code></pre>
     </div> 
     <p>Where does the first argument to <code>.Call()</code>, <code>add_</code>, come from? It comes from <code>@useDynLib</code>, which creates a line in the NAMESPACE that looks like:</p> 
     <pre><code>useDynLib(mypackage, add_)</code></pre> 
     <p>This directive instructs R to create an object called <code>add_</code> which describes a C function pointer:</p> 
     <div class="sourceCode">
      <pre class="sourceCode r"><code class="sourceCode r">mypackage:::add_
<span class="co">#&gt; $name</span>
<span class="co">#&gt; [1] "add_"</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $address</span>
<span class="co">#&gt; &lt;pointer: 0x107be3f40&gt;</span>
<span class="co">#&gt; $package</span>
<span class="co">#&gt; NULL</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; attr(,"class")</span>
<span class="co">#&gt; [1] "NativeSymbolInfo"</span></code></pre>
     </div> 
     <p><code>.Call()</code> takes the pointer to a C function and calls it. All R objects have the same C type (the <code>SEXP</code>) you need to make sure the arguments are of the type you expect. Either do that in the R function, in the C function, or just accept that R will crash every time you accidentally supply the wrong type of input.</p> 
     <p>The most complicated part of working with the <code>.Call()</code> interface is memory-management. Whenever you create an R-level data structure, you must <code>PROTECT()</code> it so the garbage collector doesn’t try and free it, then <code>UNPROTECT()</code> it at the end of the function. This topic is beyond the scope of this chapter, but you can learn more about it at <a href="http://adv-r.had.co.nz/C-interface.html#c-vectors" class="uri">http://adv-r.had.co.nz/C-interface.html#c-vectors</a>.</p> 
     <h3>Getting started with <code>.C()</code></h3> 
     <p><code>.C()</code> is simpler than <code>.Call()</code> and can be useful if you already have standard C code. Since you never create R objects in <code>.C()</code>, you never need to worry about memory management. To use it, you first write a void C function, using in-place modification of function parameters to return values:</p> 
     <div class="sourceCode">
      <pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> add_(<span class="dt">double</span>* x, <span class="dt">double</span>* y, <span class="dt">double</span>* out) {
  out[<span class="dv">0</span>] = x[<span class="dv">0</span>] + y[<span class="dv">0</span>];
}</code></pre>
     </div> 
     <p>Then like <code>.Call()</code> you create an R wrapper:</p> 
     <div class="sourceCode">
      <pre class="sourceCode r"><code class="sourceCode r"><span class="co">#' @useDynLib mypackage add_</span>
add &lt;-<span class="st"> </span>function(x, y) {
  <span class="kw">.C</span>(add_, x, y, <span class="kw">numeric</span>(<span class="dv">1</span>))[[<span class="dv">3</span>]]
}</code></pre>
     </div> 
     <p>(Here we extract the 3rd element of the result because that corresponds to the out parameter.)</p> 
     <p><code>.C()</code> automatically converts back and forth between R vectors and their C equivalents:</p> 
     <table> 
      <thead> 
       <tr class="header"> 
        <th align="left">R type</th> 
        <th align="left">C type</th> 
       </tr> 
      </thead> 
      <tbody> 
       <tr class="odd"> 
        <td align="left">logical</td> 
        <td align="left"><code>int*</code></td> 
       </tr> 
       <tr class="even"> 
        <td align="left">integer</td> 
        <td align="left"><code>int*</code></td> 
       </tr> 
       <tr class="odd"> 
        <td align="left">double</td> 
        <td align="left"><code>double*</code></td> 
       </tr> 
       <tr class="even"> 
        <td align="left">character</td> 
        <td align="left"><code>char**</code></td> 
       </tr> 
       <tr class="odd"> 
        <td align="left">raw</td> 
        <td align="left"><code>unsigned char*</code></td> 
       </tr> 
      </tbody> 
     </table> 
     <p>Note that <code>.C()</code> assumes your function doesn’t know how to deal with missing values and will throw an error if any arguments contain an NA. If it can correctly handle missing values, set <code>NAOK = TRUE</code> in the call to <code>.C()</code>.</p> 
     <p>You can learn more about <code>.C()</code> in its help, <code>?.C</code> and in <a href="http://cran.rstudio.com/doc/manuals/r-devel/R-exts.html#Interface-functions-_002eC-and-_002eFortran">R-extensions</a>.</p> 
     <h3 id="c-workflow">Workflow</h3> 
     <p>The usual workflow still applies:</p> 
     <ol style="list-style-type: decimal"> 
      <li>Modify the C code.</li> 
      <li>Build and reload the package with Ctrl/Cmd + Shift + B</li> 
      <li>Experiment at the console.</li> 
     </ol> 
     <p>The first time you add <code>@useDynLib</code>, you’ll also need to run <code>devtools::document()</code> (Ctrl/Cmd + Shift + D) and reload the package.</p> 
     <h3 id="c-export">Exporting C code</h3> 
     <p>R packages need to provide DLLs that can be relocated; DLLs that work regardless of where they live on disk. This is because most R users don’t build packages from source. Instead, they get binaries from CRAN that can get installed in many different places. This need for relocatable DLLs adds a few more steps to the job of importing and exporting C code for R packages (the same problem arises for C++, but Rcpp attributes automate the manual steps described below).</p> 
     <p>R solves this problem using <strong>function registration</strong>. To export a <code>.Call()</code> C function, you register it with <code>R_RegisterCCallable()</code>. To import a <code>.Call()</code> C function, you get a pointer to it with <code>R_GetCCallable()</code>. Similar techniques are available for <code>.C()</code> C functions, but are beyond the scope of this book. As we’ll see below, a user-friendly package will do both these tasks, so users of the package can ignore the details and simply include a header a file.</p> 
     <p>[Sidebar: Confusingly, there’s another type of function registration. Instead of registering C functions using the namespace (i.e. <code>@useDynLib pkg fun</code>), you can register them with <code>R_registerRoutines()</code> and <code>@useDynLib mypackage, .registration = TRUE</code>. To learn the details read <a href="http://cran.r-project.org/doc/manuals/R-exts.html#Registering-native-routines">Registering native extensions</a> in “Writing R extensions”.]</p> 
     <p>To register a function, call <code>R_RegisterCCallable()</code>, defined in <code>&lt;R_ext/Rdynload.h&gt;</code>. Function registration should be done in a function called <code>R_init_&lt;mypackage&gt;</code>. This function is called automatically when the “mypackage” DLL is loaded. <code>R_RegisterCCallable()</code> has three arguments:</p> 
     <ul> 
      <li>A pointer to the DLL.</li> 
      <li>The name of the function.</li> 
      <li>A pointer to the function, cast as <code>DL_FUNC</code> (i.e.&nbsp;a <strong>d</strong>ynamically <strong>l</strong>oaded <strong>func</strong>tion).</li> 
     </ul> 
     <p>The following code registers the <code>add()</code> function defined above:</p> 
     <div class="sourceCode">
      <pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include "add.h"</span>
<span class="ot">#include &lt;R_ext/Rdynload.h&gt;</span>

<span class="dt">void</span> R_init_mypackage(DllInfo *info) {
  R_RegisterCCallable(info, <span class="st">"add_"</span>,  (DL_FUNC) &amp;add_)
}</code></pre>
     </div> 
     <p>It doesn’t matter where this code lives, but it’s usually put in a file called <code>src/mypackage-init.c</code>.</p> 
     <p>To access a registered function from another package, call <code>R_GetCCallable()</code>. It has two arguments, the function name and the package name. It returns a function pointer. The function pointer has no type information, so it should always be wrapped in a helper function that defines the inputs:</p> 
     <div class="sourceCode">
      <pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &lt;R_ext/Rdynload.h&gt;</span>
<span class="ot">#include &lt;R.h&gt;</span>
<span class="ot">#include &lt;Rinternals.h&gt;</span>

SEXP add_(SEXP x, SEXP y) {
  <span class="dt">static</span> SEXP(fun*)(SEXP, SEXP) = NULL;
  <span class="kw">if</span> (fun == NULL)
    fun = (SEXP(*)(SEXP, SEXP)) R_GetCCallable(<span class="st">"add"</span>, <span class="st">"mypackage"</span>);
  <span class="kw">return</span> fun(x, y);
}</code></pre>
     </div> 
     <p>Rather than relying on each package that imports your C code to do this correctly, you should instead do it for them. Write <code>inst/include/mypackageAPI.h</code> which provides a wrapper function for each exported function. A popular package that does that is <a href="http://cran.r-project.org/web/packages/xts/">xts</a>. Download the source package and look in the <code>include/</code> directory to see what it does.</p> 
     <h3 id="c-import">Importing C code</h3> 
     <p>Using C code from another package varies based on how the package is implemented:</p> 
     <ul> 
      <li><p>If it uses the system described above, all you need is <code>LinkingTo: otherPackage</code> in the <code>DESCRIPTION</code>, and <code>#include otherPackageAPI.h</code> in the C file. (Remember <code>LinkingTo</code> is not about the linker, but actually affects the include path).</p></li> 
      <li><p>If it registers the functions, but doesn’t provide a header file, you’ll need to write the wrapper yourself. Since you’re not using any header files from the package, use <code>Imports</code> and not <code>LinkingTo</code>. You also need to make sure the package is loaded. You can do this by importing any function with <code>@importFrom mypackage foo</code>, or by adding <code>requireNamespace("mypackage", quietly = TRUE)</code> to <code>.onLoad()</code>.</p></li> 
      <li><p>If it doesn’t register the functions, you can’t use them. You’ll have to ask the maintainer nicely or even provide a pull request.</p></li> 
     </ul> 
     <h3 id="c-best-practices">Best practices</h3> 
     <ul> 
      <li><p>Avoid calls to <code>assert()</code>, <code>abort()</code> and <code>exit()</code>: these will kill the R process, not just your C code. Instead, use <code>error()</code> which is equivalent to calling <code>stop()</code> in R.</p></li> 
      <li><p>To print output use <code>Rprintf()</code>, not <code>printf()</code>. Doing so always prints to the right place, whether it’s the GUI console or a file (if <code>sink()</code> is active).</p></li> 
      <li><p>In long-running loops, regularly call <code>R_CheckUserInterrupt()</code> to allow the user to interrupt the C code.</p></li> 
      <li><p>Don’t use C’s random number generators (like <code>rand()</code> or <code>random()</code>), instead use the C API to R’s rngs: <code>unif_rand()</code>, <code>norm_rand()</code>, etc. Note the caveats in <a href="http://cran.rstudio.com/doc/manuals/r-devel/R-exts.html#Random-numbers">“Random number generation”</a> - you must call <code>GetRNGstate()</code> before and <code>PutRNGstate()</code> after.</p></li> 
      <li><p>Use R macros <code>ISNAN(x)</code> and <code>R_FINITE(x)</code> to check for NaNs and infinite values. These work on more platforms than the C99 <code>isnan()</code> and <code>isfinite()</code>.</p></li> 
      <li><p>Like with C++, whenever you use C code in your package, you should unload the DLL when the package is unloaded:</p> 
       <div class="sourceCode">
        <pre class="sourceCode r"><code class="sourceCode r">.onUnload &lt;-<span class="st"> </span>function (libpath) {
  <span class="kw">library.dynam.unload</span>(<span class="st">"mypackage"</span>, libpath)
}</code></pre>
       </div></li> 
      <li><p>Use <code>clang</code> instead of <code>gcc</code> to compile your C code: it gives much better error messages. You can make <code>clang</code> the default by creating a <code>~/.R/Makevars</code> that contains:</p> 
       <div class="sourceCode">
        <pre class="sourceCode bash"><code class="sourceCode bash"><span class="ot">C=</span>clang</code></pre>
       </div></li> 
     </ul> 
     <h2 id="src-debugging">Debugging compiled code</h2> 
     <p>It’s possible, with a little extra work, to use an interactive debugger to debug your C/C++ in the same way that you can use <code>browser()</code> and <code>debug()</code> to debug your R code. Unfortunately you won’t be able to use RStudio, you’ll have to run R from the command line.</p> 
     <p>Open a shell (e.g.&nbsp;with Tools | Shell…) and start R by typing:</p> 
     <div class="sourceCode">
      <pre class="sourceCode bash"><code class="sourceCode bash"><span class="co"># If you compile with clang</span>
<span class="kw">R</span> --debugger=lldb
<span class="co"># If you compile with gcc</span>
<span class="kw">R</span> --debugger=gdb</code></pre>
     </div> 
     <p>This will start either <a href="http://lldb.llvm.org">lldb</a> or <a href="http://www.gnu.org/software/gdb/">gdb</a>, the debuggers that work with code produced by <code>clang</code> or <code>gcc</code> respectively. Like R, <code>lldb</code> and <code>gdb</code> provide a REPL, a run-eval-print loop where you enter commands and then look at the results. In the examples below I’ll show the results of <code>lldb</code>, which is what I use (the output from <code>gdb</code> is similar). For each interactive command I’ll tell you the explicit, but long, <code>lldb</code> command and the short, but cryptic, <code>gdb</code> command. Because <code>lldb</code> understand all <code>gdb</code> commands, you can use choose to be explicit of terse.</p> 
     <p>Once you’ve started the debugger, start R by typing <code>process start</code> (lldb) or <code>run</code> (gdb). Now when your C/C++ code crashes you’ll be dumped into an interactive debugger instead of getting a cryptic error message and a crash.</p> 
     <p>Let’s start with a simple C++ function that writes to memory it doesn’t “own”:</p> 
     <div class="sourceCode">
      <pre class="sourceCode r"><code class="sourceCode r">Rcpp::<span class="kw">cppFunction</span>(<span class="st">"</span>
<span class="st">bool mistake() {</span>
<span class="st"> NumericVector x(1);</span>
<span class="st"> int n = INT_MAX;</span>
<span class="st"> x[n] = 0;</span>
<span class="st"> return true;</span>
<span class="st">}</span>
<span class="st">"</span>, <span class="dt">plugins =</span> <span class="st">"debug"</span>, <span class="dt">verbose =</span> <span class="ot">TRUE</span>, <span class="dt">rebuild =</span> <span class="ot">TRUE</span>)
<span class="kw">mistake</span>()</code></pre>
     </div> 
     <p>Use <code>devtools::load_all()</code> to load the current package. Then copy and paste the code that creates the bug. Here’s a crash report from a package I was working on:</p> 
     <pre><code>Process 32743 stopped
* thread #1: tid = 0x1f79f6, 0x... gggeom.so...`
   frame #0: 0x0.. gggeom.so`vw_distance(x=..., y=...) + ... at vw-distance.cpp:54
   51        int prev_idx = prev[idx];
   52   
   53       next[prev[idx]] = next_idx;
-&gt; 54       prev[next[idx]] = prev_idx;
   55       prev[idx] = -1;
   56       next[idx] = -1;
   57</code></pre> 
     <p>It tells us that the crash occurred because of a <code>EXC_BAD_ACCESS</code> - this is one of the most common types of crash in C/C++ code. Helpfully, lldb shows exactly which line of C++ code caused the problem: <code>vw-distance.cpp:54</code>. Often just knowing where the problem occurs is enough to fix it. But we’re also now at an interactive prompt. There are many commands you can run here to explore what’s going on. The most useful are listed below:</p> 
     <ul> 
      <li><p>See a list of all commands: <code>help</code>.</p></li> 
      <li><p>Show your location on the callstack with <code>thread backtrace</code>/<code>bt</code>. This will print a list of calls leading up to the error, much like <code>traceback()</code> does in R. Navigate the callstack with <code>frame select &lt;n&gt;</code>/<code>frame &lt;n&gt;</code>, or <code>up</code> and <code>down</code>.</p></li> 
      <li><p>Evaluate the next expression with <code>thread step-over</code>/<code>next</code>, or step into it with <code>thread step-in</code>/<code>step</code>. Continue executing the rest of the code with <code>thread step-out</code>/<code>finish</code></p></li> 
      <li><p>Show all variables defined in the current frame with <code>frame variable</code>/ <code>info locals</code>, or print the value of a single variable with <code>frame variable &lt;var&gt;</code>/<code>p &lt;var&gt;</code>.</p></li> 
     </ul> 
     <p>Instead of waiting for a crash to occur you can also set breakpoints in your code. To do so, start the debugger, run R, then:</p> 
     <ol style="list-style-type: decimal"> 
      <li><p>Press <code>Ctrl + C</code></p></li> 
      <li><p>Type <code>breakpoint set --file foo.c --line 12</code>/<code>break foo.c:12</code>.</p></li> 
      <li><p><code>process continue</code>/<code>c</code> to go back to the R console. Now run the C code you’re interested in, and the debugger will stop when it gets to the specified line.</p></li> 
     </ol> 
     <p>You can also set a breakpoint for any C++ exception: this allows you to figure out exactly where a C++ error occurs:</p> 
     <ol style="list-style-type: decimal"> 
      <li><p>Press <code>Ctrl + C</code></p></li> 
      <li><p>Type <code>breakpoint set -E c++</code>.</p></li> 
      <li><p><code>process continue</code>/<code>c</code> to go back to the R console. Now if an exception is thrown in C++ code (or by R’s C API when wrapped in Rcpp code), the debugger will stop.</p></li> 
     </ol> 
     <p>Finally, you can also use the debugger if your code is stuck in an infinite loop. Press <code>Ctrl + C</code> to break into the debugger and you’ll see which line of code is causing the problem.</p> 
     <h2 id="make">Makefiles</h2> 
     <p>While makefiles are beyond the scope of this book, they are a useful tool. A good, gentle introduction with a focus on reproducible research is Karl Broman’s <a href="http://kbroman.org/minimal_make/">“Minimal make”</a>.</p> 
     <p>Generally, R packages should avoid a custom <code>Makefile</code>. Instead, use <code>Makevars</code>. <code>Makevars</code> is a make file that overrides the default make file generated by R (which is located at <code>file.path(R.home("etc"), "Makeconf")</code>). This allows you to take advantage of R’s default behaviour (it’s over 150 lines, and battle-tested across many years and many systems, so you want to!) while being able to set the flags you need. The most commonly used flags are:</p> 
     <ul> 
      <li><p><code>PKG_LIBS</code>: Linker flags. A common use is <code>PKG_LIBS = $(BLAS_LIBS)</code>. This allows you to use the same BLAS library as R.</p></li> 
      <li><p><code>PKG_CFLAGS</code> &amp; <code>PKG_CXXFLAGS</code>: C and C++ flags. Most commonly used to set define directives with <code>-D</code>.</p></li> 
      <li><p><code>PKG_CPPFLAGS</code>: Pre-processor flags (not C++ flags!). Most commonly used to set include directories with <code>-I</code>. Any package listed in the <code>LinkingTo</code> field in the <code>DESCRIPTION</code> will be automatically included - you do not need to explicitly add it.</p></li> 
     </ul> 
     <p>To set flags only on Windows, use <code>Makevars.win</code>. To build a <code>Makevars</code> with <code>configure</code>, use <code>Makevars.in</code>.</p> 
     <p>By default, R will use the system make, which is not always GNU compatible (i.e.&nbsp;on Solaris). If you want to use GNU extensions (which are extremely common), add <code>SystemRequirements: GNU make</code> to <code>DESCRIPTION</code>. If you’re not sure if you’re using GNU extensions, play it safe and add it to the system requirement.</p> 
     <h2 id="src-other">Other languages</h2> 
     <p>It is possible to connect R to other languages, but the interfaces are not as nice as the one for C++:</p> 
     <ul> 
      <li><p><strong>Fortran</strong>: It’s possible to call Fortran subroutines directly with <code>.Fortran()</code>, or via C or C++ with <code>.Call()</code>. See <code>?.Fortran</code> and</p></li> 
      <li><p><strong>Java</strong>: The <a href="https://github.com/s-u/rJava">rJava</a> package makes it possible to call Java code from within R. Note that unlike with C and C++, passing an R object to a Java call will involve a copy operation, something which has serious performance implications.</p></li> 
     </ul> 
     <h2 id="src-licensing">Licensing</h2> 
     <p>Because it’s common to use other peoples’ libraries when writing compiled code, you need to make sure that your package license is compatible with the licenses of all included code:</p> 
     <ul> 
      <li><p>The simplest solution is to use the same license as the included code. Since you can’t relicense someone else’s code, you may need to change your license.</p></li> 
      <li><p>If you don’t want to use the same license, you’re best sticking with common cases where the interactions are well known. For example, <a href="https://www.gnu.org/licenses/license-list.html">Various Licenses and Comments about Them</a> describes what licenses are compatible with the GPL license.</p></li> 
     </ul> 
     <p>In this case your description should contain <code>License: &lt;main license&gt; + FILE license</code> where <code>&lt;main license&gt;</code> is a license that is valid for the entire package (both R and compiled code), and the <code>license</code> file describes the licenses of individual components.</p> 
     <ul> 
      <li>For non-standard cases, you’ll need to consult a lawyer.</li> 
     </ul> 
     <p>In all cases, make sure you include copyright and license statements from the original code.</p> 
     <h2 id="src-workflow">Development workflow</h2> 
     <p>When developing C or C++ code, it’s usually better to use RStudio’s Build &amp; Reload instead of <code>devtools::load_all()</code>. If you have C objects that persist between reloads, and you change the data structure, then it’s</p> 
     <h2 id="src-cran">CRAN issues</h2> 
     <p>Packages with compiled code are much more likely to have difficulties getting on CRAN than those without. The reason? Your package must build from source on all major platforms (Linux, Mac and Windows). This is hard!</p> 
     <ul> 
      <li><p>CRAN provides an automated service for checking R packages on windows: <a href="http://win-builder.r-project.org">win-builder</a>. You can easily access this by running <code>devtools::build_win()</code>, which builds and uploads a package bundle.</p></li> 
      <li><p>I’ve tried to include the most important advice in this chapter, but I’d recommend reading the entire section on <a href="http://cran.rstudio.com/doc/manuals/r-devel/R-exts.html#Portable-C-and-C_002b_002b-code">writing portable C and C++ code</a> in “Writing R extensions”.</p></li> 
      <li><p>In exceptional circumstances, like binding to Windows-only functionality, you may be able to opt-out of cross-platform requirement, but be prepared<br> to make a strong case for it.</p></li> 
     </ul> 
     <p>The interface between CRAN’s automated and manual checking can be particularly frustrating for compiled code. Requirements vary from submission to submission, based on which maintainer you get and how much free time they have. The rules are inconsistently applied, but if your package doesn’t pass, it’s better to bite the bullet and make the change rather than trying to argue about it:</p> 
     <ul> 
      <li><p>Sometimes you will need to list all authors and copyright holders of included code in the DESCRIPTION.</p></li> 
      <li><p>Sometimes your package will need to work on Solaris. But due to the difficulty of accessing a computer running Solaris, fixing Solaris issues can be hard. However, you will be in a stronger negotiating position if the package has no problems on other platforms.</p> <p>One common gotcha: gcc/clang flags <code>-Wall</code>, <code>-pedantic</code> and <code>-O0</code> do not work with the default compiler on Solaris.</p></li> 
     </ul> 
    </div> 
   </div> 
   <div class="footer"> 
    <hr> 
    <p>© Hadley Wickham. Powered by <a href="http://jekyllrb.com/">jekyll</a>, <a href="http://yihui.name/knitr/">knitr</a>, and <a href="http://johnmacfarlane.net/pandoc/">pandoc</a>. Source available on <a href="https://github.com/hadley/r-pkgs/">github</a>. </p> 
   </div> 
  </div> 
  <!-- /container --> 
  <script src="//code.jquery.com/jquery.js"></script> 
  <script src="www/bootstrap.min.js"></script> 
  <script src="www/toc.js"></script> 
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-67989-17', 'auto');
    ga('send', 'pageview');

  </script>   
 </body>
</html>