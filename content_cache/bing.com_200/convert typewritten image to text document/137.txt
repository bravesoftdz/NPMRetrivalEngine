<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--Converted with LaTeX2HTML 2002-2-1 (1.70)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<html>
 <head> 
  <title>Introduction to programming with OpenCV</title> 
  <meta NAME="description" CONTENT="Introduction to programming with OpenCV"> 
  <meta NAME="keywords" CONTENT="opencv-intro"> 
  <meta NAME="resource-type" CONTENT="document"> 
  <meta NAME="distribution" CONTENT="global"> 
  <meta NAME="Generator" CONTENT="LaTeX2HTML v2002-2-1"> 
  <meta HTTP-EQUIV="Content-Style-Type" CONTENT="text/css"> 
  <link REL="STYLESHEET" HREF="opencv-intro.css"> 
 </head> 
 <body> 
  <!--Navigation Panel--> 
  <img WIDTH="81" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next_inactive" SRC="file:/usr/share/latex2html/icons/nx_grp_g.png"> 
  <img WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="file:/usr/share/latex2html/icons/up_g.png"> 
  <img WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="file:/usr/share/latex2html/icons/prev_g.png"> 
  <br> 
  <br> 
  <br> 
  <!--End of Navigation Panel--> 
  <p> </p>
  <p> </p>
  <h1 align="CENTER">Introduction to programming with OpenCV</h1> 
  <div> 
   <p align="CENTER"><strong>Gady Agam</strong></p> 
   <p align="CENTER"><i> Department of Computer Science</i></p> 
   <p align="CENTER"><strong>January 27, 2006</strong></p> 
   <p align="LEFT"><small> Illinois Institute of Technology</small></p> 
  </div> 
  <p> </p>
  <h3>Abstract:</h3> 
  <div>
    The purpose of this document is to get you started quickly with OpenCV without having to go through lengthy reference manuals. Once you understand these basics you will be able to consult the OpenCV manuals on a need basis. 
   <p> </p>
  </div> 
  <p> </p>
  <p> </p>
  <p> <br> </p>
  <h2><a name="SECTION00010000000000000000"> Contents</a> </h2> 
  <!--Table of Contents--> 
  <ul> 
   <li><a name="tex2html29" href="opencv-intro.html#SECTION00020000000000000000">Introduction</a> 
    <ul> 
     <li><a name="tex2html30" href="opencv-intro.html#SECTION00021000000000000000">Description of OpenCV</a> </li>
     <li><a name="tex2html31" href="opencv-intro.html#SECTION00022000000000000000">Resources</a> </li>
     <li><a name="tex2html32" href="opencv-intro.html#SECTION00023000000000000000">OpenCV naming conventions</a> </li>
     <li><a name="tex2html33" href="opencv-intro.html#SECTION00024000000000000000">Compilation instructions</a> </li>
     <li><a name="tex2html34" href="opencv-intro.html#SECTION00025000000000000000">Example C Program</a> </li>
    </ul> <br> </li>
   <li><a name="tex2html35" href="opencv-intro.html#SECTION00030000000000000000">GUI commands</a> 
    <ul> 
     <li><a name="tex2html36" href="opencv-intro.html#SECTION00031000000000000000">Window management</a> </li>
     <li><a name="tex2html37" href="opencv-intro.html#SECTION00032000000000000000">Input handling</a> </li>
    </ul> <br> </li>
   <li><a name="tex2html38" href="opencv-intro.html#SECTION00040000000000000000">Basic OpenCV data structures</a> 
    <ul> 
     <li><a name="tex2html39" href="opencv-intro.html#SECTION00041000000000000000">Image data structure</a> </li>
     <li><a name="tex2html40" href="opencv-intro.html#SECTION00042000000000000000">Matrices and vectors</a> </li>
     <li><a name="tex2html41" href="opencv-intro.html#SECTION00043000000000000000">Other data structures</a> </li>
    </ul> <br> </li>
   <li><a name="tex2html42" href="opencv-intro.html#SECTION00050000000000000000">Working with images</a> 
    <ul> 
     <li><a name="tex2html43" href="opencv-intro.html#SECTION00051000000000000000">Allocating and releasing images</a> </li>
     <li><a name="tex2html44" href="opencv-intro.html#SECTION00052000000000000000">Reading and writing images</a> </li>
     <li><a name="tex2html45" href="opencv-intro.html#SECTION00053000000000000000">Accessing image elements</a> </li>
     <li><a name="tex2html46" href="opencv-intro.html#SECTION00054000000000000000">Image conversion</a> </li>
     <li><a name="tex2html47" href="opencv-intro.html#SECTION00055000000000000000">Drawing commands</a> </li>
    </ul> <br> </li>
   <li><a name="tex2html48" href="opencv-intro.html#SECTION00060000000000000000">Working with matrices</a> 
    <ul> 
     <li><a name="tex2html49" href="opencv-intro.html#SECTION00061000000000000000">Allocating and releasing matrices</a> </li>
     <li><a name="tex2html50" href="opencv-intro.html#SECTION00062000000000000000">Accessing matrix elements</a> </li>
     <li><a name="tex2html51" href="opencv-intro.html#SECTION00063000000000000000">Matrix/vector operations</a> </li>
    </ul> <br> </li>
   <li><a name="tex2html52" href="opencv-intro.html#SECTION00070000000000000000">Working with video sequences</a> 
    <ul> 
     <li><a name="tex2html53" href="opencv-intro.html#SECTION00071000000000000000">Capturing a frame from a video sequence</a> </li>
     <li><a name="tex2html54" href="opencv-intro.html#SECTION00072000000000000000">Getting/setting frame information</a> </li>
     <li><a name="tex2html55" href="opencv-intro.html#SECTION00073000000000000000">Saving a video file</a> </li>
    </ul></li>
  </ul> 
  <!--End of Table of Contents--> 
  <p> </p>
  <p> </p>
  <p> </p>
  <h1><a name="SECTION00020000000000000000"> Introduction</a> </h1> 
  <p> </p>
  <h2><a name="SECTION00021000000000000000"> Description of OpenCV</a> </h2> 
  <p> </p>
  <ul> 
   <li>General description 
    <ul> 
     <li>Open source computer vision library in C/C++. </li> 
     <li>Optimized and intended for real-time applications. </li> 
     <li>OS/hardware/window-manager independent. </li> 
     <li>Generic image/video loading, saving, and acquisition. </li> 
     <li>Both low and high level API. </li> 
     <li>Provides interface to Intel's Integrated Performance Primitives (IPP) with processor specific optimization (Intel processors). </li> 
    </ul> <p> </p></li> 
   <li>Features: 
    <ul> 
     <li>Image data manipulation (allocation, release, copying, setting, conversion). </li> 
     <li>Image and video I/O (file and camera based input, image/video file output). </li> 
     <li>Matrix and vector manipulation and linear algebra routines (products, solvers, eigenvalues, SVD). </li> 
     <li>Various dynamic data structures (lists, queues, sets, trees, graphs). </li> 
     <li>Basic image processing (filtering, edge detection, corner detection, sampling and interpolation, color conversion, morphological operations, histograms, image pyramids). </li> 
     <li>Structural analysis (connected components, contour processing, distance transform, various moments, template matching, Hough transform, polygonal approximation, line fitting, ellipse fitting, Delaunay triangulation). </li> 
     <li>Camera calibration (finding and tracking calibration patterns, calibration, fundamental matrix estimation, homography estimation, stereo correspondence). </li> 
     <li>Motion analysis (optical flow, motion segmentation, tracking). </li> 
     <li>Object recognition (eigen-methods, HMM). </li> 
     <li>Basic GUI (display image/video, keyboard and mouse handling, scroll-bars). </li> 
     <li>Image labeling (line, conic, polygon, text drawing) </li> 
    </ul> <p> </p></li> 
   <li>OpenCV modules: 
    <ul> 
     <li><em>cv</em> - Main OpenCV functions. </li> 
     <li><em>cvaux</em> - Auxiliary (experimental) OpenCV functions. </li> 
     <li><em>cxcore</em> - Data structures and linear algebra support. </li> 
     <li><em>highgui</em> - GUI functions. </li> 
    </ul> <p> </p></li> 
  </ul> 
  <p> </p>
  <h2><a name="SECTION00022000000000000000"> Resources</a> </h2> 
  <p> </p>
  <ul> 
   <li>Reference manuals: 
    <ul> 
     <li><tt>&lt;opencv-root&gt;/docs/index.htm</tt> </li> 
    </ul> <p> </p></li> 
   <li>Web resources: 
    <ul> 
     <li>Official webpage: <tt>http://www.intel.com/technology/computing/opencv/</tt> <p> </p></li> 
     <li>Software download: <tt>http://sourceforge.net/projects/opencvlibrary/</tt> <p> </p></li> 
    </ul> <p> </p></li> 
   <li>Books: 
    <ul> 
     <li>Open Source Computer Vision Library by Gary R. Bradski, Vadim Pisarevsky, and Jean-Yves Bouguet, Springer, 1st ed. (June, 2006). </li> 
    </ul> <p> </p></li> 
   <li>Sample programs for video processing (in <tt>&lt;opencv-root&gt;/samples/c/</tt>): 
    <ul> 
     <li>color tracking: <tt>camshiftdemo</tt> </li> 
     <li>point tracking: <tt>lkdemo</tt> </li> 
     <li>motion segmentation: <tt>motempl</tt> </li> 
     <li>edge detection: <tt>laplace</tt> </li> 
    </ul> <p> </p></li> 
   <li>Sample programs for image processing (in <tt>&lt;opencv-root&gt;/samples/c/</tt>): 
    <ul> 
     <li>edge detection: <tt>edge</tt> </li> 
     <li>segmentation: <tt>pyramid_segmentation</tt> </li> 
     <li>morphology: <tt>morphology</tt> </li> 
     <li>histogram: <tt>demhist</tt> </li> 
     <li>distance transform: <tt>distrans</tt> </li> 
     <li>ellipse fitting: <tt>fitellipse</tt> </li> 
    </ul> <p> </p></li> 
  </ul> 
  <p> </p>
  <p> </p>
  <h2><a name="SECTION00023000000000000000"> OpenCV naming conventions</a> </h2> 
  <p> </p>
  <ul> 
   <li>Function naming conventions: <pre>
    cvActionTargetMod(...)

    Action = the core functionality (e.g. set, create)
    Target = the target image area (e.g. contour, polygon)
    Mod    = optional modifiers (e.g. argument type)
</pre> <p> </p></li> 
   <li>Matrix data types: <pre>
    CV_&lt;bit_depth&gt;(S|U|F)C&lt;number_of_channels&gt;

    S = Signed integer
    U = Unsigned integer
    F = Float 

    E.g.: CV_8UC1 means an 8-bit unsigned single-channel matrix, 
          CV_32FC2 means a 32-bit float matrix with two channels.
</pre> <p> </p></li> 
   <li>Image data types: <pre>
    IPL_DEPTH_&lt;bit_depth&gt;(S|U|F)

    E.g.: IPL_DEPTH_8U means an  8-bit unsigned image.
          IPL_DEPTH_32F means a 32-bit float image.
</pre> <p> </p></li> 
   <li>Header files: <pre>
    #include &lt;cv.h&gt;
    #include &lt;cvaux.h&gt;
    #include &lt;highgui.h&gt;  
    #include &lt;cxcore.h&gt;   // unnecessary - included in cv.h
</pre> <p> </p></li> 
  </ul> 
  <p> </p>
  <h2><a name="SECTION00024000000000000000"> Compilation instructions</a> </h2> 
  <p> </p>
  <ul> 
   <li>Linux: <pre>
g++ hello-world.cpp -o hello-world \
    -I /usr/local/include/opencv -L /usr/local/lib  \
    -lm -lcv -lhighgui -lcvaux
</pre> <p> </p></li> 
   <li>Windows: <pre>
In the project preferences set the path to the OpenCV header files and
the path to the OpenCV library files.
</pre> <p> </p></li> 
  </ul> 
  <p> </p>
  <p> </p>
  <h2><a name="SECTION00025000000000000000"> Example C Program</a> </h2> 
  <p> <font size="-1"></font> </p>
  <p> <font size="-1"></font></p>
  <pre>
////////////////////////////////////////////////////////////////////////
//
// hello-world.cpp
//
// This is a simple, introductory OpenCV program. The program reads an
// image from a file, inverts it, and displays the result. 
//
////////////////////////////////////////////////////////////////////////
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;cv.h&gt;
#include &lt;highgui.h&gt;


int main(int argc, char *argv[])
{
  IplImage* img = 0; 
  int height,width,step,channels;
  uchar *data;
  int i,j,k;

  if(argc&lt;2){
    printf("Usage: main &lt;image-file-name&gt;\n\7");
    exit(0);
  }

  // load an image  
  img=cvLoadImage(argv[1]);
  if(!img){
    printf("Could not load image file: %s\n",argv[1]);
    exit(0);
  }

  // get the image data
  height    = img-&gt;height;
  width     = img-&gt;width;
  step      = img-&gt;widthStep;
  channels  = img-&gt;nChannels;
  data      = (uchar *)img-&gt;imageData;
  printf("Processing a %dx%d image with %d channels\n",height,width,channels); 

  // create a window
  cvNamedWindow("mainWin", CV_WINDOW_AUTOSIZE); 
  cvMoveWindow("mainWin", 100, 100);

  // invert the image
  for(i=0;i&lt;height;i++) for(j=0;j&lt;width;j++) for(k=0;k&lt;channels;k++)
    data[i*step+j*channels+k]=255-data[i*step+j*channels+k];

  // show the image
  cvShowImage("mainWin", img );

  // wait for a key
  cvWaitKey(0);

  // release the image
  cvReleaseImage(&amp;img );
  return 0;
}
</pre>
  <font size="-1"></font> 
  <p> <font size="-1"> </font> </p>
  <p> </p>
  <p> </p>
  <h1><a name="SECTION00030000000000000000"> GUI commands</a> </h1> 
  <p> </p>
  <h2><a name="SECTION00031000000000000000"> Window management</a> </h2> 
  <p> </p>
  <ul> 
   <li>Create and position a window: <pre>
  cvNamedWindow("win1", CV_WINDOW_AUTOSIZE); 
  cvMoveWindow("win1", 100, 100); // offset from the UL corner of the screen
</pre> <p> </p></li> 
   <li>Load an image: <pre>
  IplImage* img=0; 
  img=cvLoadImage(fileName);
  if(!img) printf("Could not load image file: %s\n",fileName);
</pre> <p> </p></li> 
   <li>Display an image: <pre>
  cvShowImage("win1",img);
</pre> <p> Can display a color or grayscale byte/float-image. A byte image is assumed to have values in the range <img WIDTH="59" HEIGHT="36" ALIGN="MIDDLE" BORDER="0" SRC="img1.png" ALT="$[0..255]$">. A float image is assumed to have values in the range <img WIDTH="41" HEIGHT="36" ALIGN="MIDDLE" BORDER="0" SRC="img2.png" ALT="$[0..1]$">. A color image is assumed to have data in BGR order. </p><p> </p></li> 
   <li>Close a window: <pre>
  cvDestroyWindow("win1");
</pre> <p> </p></li> 
   <li>Resize a window: <pre>
  cvResizeWindow("win1",100,100); // new width/heigh in pixels
</pre> <p> </p></li> 
  </ul> 
  <p> </p>
  <p> </p>
  <h2><a name="SECTION00032000000000000000"> Input handling</a> </h2> 
  <p> </p>
  <ul> 
   <li>Handle mouse events: 
    <ul> 
     <li>Define a mouse handler: <pre>
  void mouseHandler(int event, int x, int y, int flags, void* param)
  {
    switch(event){
      case CV_EVENT_LBUTTONDOWN:
        if(flags &amp; CV_EVENT_FLAG_CTRLKEY) 
          printf("Left button down with CTRL pressed\n");
        break;

      case CV_EVENT_LBUTTONUP:
        printf("Left button up\n");
        break;
    }
  }

  x,y:   pixel coordinates with respect to the UL corner

  event: CV_EVENT_LBUTTONDOWN,   CV_EVENT_RBUTTONDOWN,   CV_EVENT_MBUTTONDOWN,
         CV_EVENT_LBUTTONUP,     CV_EVENT_RBUTTONUP,     CV_EVENT_MBUTTONUP,
         CV_EVENT_LBUTTONDBLCLK, CV_EVENT_RBUTTONDBLCLK, CV_EVENT_MBUTTONDBLCLK,
         CV_EVENT_MOUSEMOVE:

  flags: CV_EVENT_FLAG_CTRLKEY, CV_EVENT_FLAG_SHIFTKEY, CV_EVENT_FLAG_ALTKEY,
         CV_EVENT_FLAG_LBUTTON, CV_EVENT_FLAG_RBUTTON,  CV_EVENT_FLAG_MBUTTON
</pre> <p> </p></li> 
     <li>Register the handler: <pre>
  mouseParam=5;
  cvSetMouseCallback("win1",mouseHandler,&amp;mouseParam);
</pre> <p> </p></li> 
    </ul> <p> </p><p> </p></li> 
   <li>Handle keyboard events: 
    <ul> 
     <li>The keyboard does not have an event handler. <p> </p></li> 
     <li>Get keyboard input without blocking: <pre>
  int key;
  key=cvWaitKey(10); // wait 10ms for input
</pre> <p> </p></li> 
     <li>Get keyboard input with blocking: <pre>
  int key;
  key=cvWaitKey(0); // wait indefinitely for input
</pre> <p> </p></li> 
     <li>The main keyboard event loop: <pre>
  while(1){
    key=cvWaitKey(10);
    if(key==27) break;

    switch(key){
      case 'h':
        ...
        break;
      case 'i':
        ...
        break;
    }
  }
</pre> <p> </p></li> 
    </ul> <p> </p></li> 
   <li>Handle trackbar events: 
    <ul> 
     <li>Define a trackbar handler: <pre>
  void trackbarHandler(int pos)
  {
    printf("Trackbar position: %d\n",pos);
  }
</pre> <p> </p></li> 
     <li>Register the handler: <pre>
  int trackbarVal=25;
  int maxVal=100;
  cvCreateTrackbar("bar1", "win1", &amp;trackbarVal ,maxVal , trackbarHandler);
</pre> <p> </p></li> 
     <li>Get the current trackbar position: <pre>
  int pos = cvGetTrackbarPos("bar1","win1");
</pre> <p> </p></li> 
     <li>Set the trackbar position: <pre>
  cvSetTrackbarPos("bar1", "win1", 25);
</pre> <p> </p></li> 
    </ul> <p> </p></li> 
  </ul> 
  <p> </p>
  <h1><a name="SECTION00040000000000000000"> Basic OpenCV data structures</a> </h1> 
  <p> </p>
  <h2><a name="SECTION00041000000000000000"> Image data structure</a> </h2> 
  <p> </p>
  <ul> 
   <li>IPL image: <pre>
IplImage
  |-- int  nChannels;     // Number of color channels (1,2,3,4)
  |-- int  depth;         // Pixel depth in bits: 
  |                       //   IPL_DEPTH_8U, IPL_DEPTH_8S, 
  |                       //   IPL_DEPTH_16U,IPL_DEPTH_16S, 
  |                       //   IPL_DEPTH_32S,IPL_DEPTH_32F, 
  |                       //   IPL_DEPTH_64F
  |-- int  width;         // image width in pixels
  |-- int  height;        // image height in pixels
  |-- char* imageData;    // pointer to aligned image data
  |                       // Note that color images are stored in BGR order
  |-- int  dataOrder;     // 0 - interleaved color channels, 
  |                       // 1 - separate color channels
  |                       // cvCreateImage can only create interleaved images
  |-- int  origin;        // 0 - top-left origin,
  |                       // 1 - bottom-left origin (Windows bitmaps style)
  |-- int  widthStep;     // size of aligned image row in bytes
  |-- int  imageSize;     // image data size in bytes = height*widthStep
  |-- struct _IplROI *roi;// image ROI. when not NULL specifies image
  |                       // region  to be processed.
  |-- char *imageDataOrigin; // pointer to the unaligned origin of image data
  |                          // (needed for correct image deallocation)
  |
  |-- int  align;         // Alignment of image rows: 4 or 8 byte alignment
  |                       // OpenCV ignores this and uses widthStep instead
  |-- char colorModel[4]; // Color model - ignored by OpenCV
</pre> <p> </p></li> 
  </ul> 
  <p> </p>
  <p> </p>
  <h2><a name="SECTION00042000000000000000"> Matrices and vectors</a> </h2> 
  <p> </p>
  <ul> 
   <li>Matrices: <pre>
CvMat                      // 2D array
  |-- int   type;          // elements type (uchar,short,int,float,double) and flags
  |-- int   step;          // full row length in bytes
  |-- int   rows, cols;    // dimensions
  |-- int   height, width; // alternative dimensions reference
  |-- union data;
      |-- uchar*  ptr;     // data pointer for an unsigned char matrix
      |-- short*  s;       // data pointer for a short matrix
      |-- int*    i;       // data pointer for an integer matrix
      |-- float*  fl;      // data pointer for a float matrix
      |-- double* db;      // data pointer for a double matrix


CvMatND                    // N-dimensional array
  |-- int   type;          // elements type (uchar,short,int,float,double) and flags
  |-- int   dims;          // number of array dimensions
  |-- union data;
  |   |-- uchar*  ptr;     // data pointer for an unsigned char matrix
  |   |-- short*  s;       // data pointer for a short matrix
  |   |-- int*    i;       // data pointer for an integer matrix
  |   |-- float*  fl;      // data pointer for a float matrix
  |   |-- double* db;      // data pointer for a double matrix
  |
  |-- struct dim[];        // information for each dimension
      |-- size;            // number of elements in a given dimension
      |-- step;            // distance between elements in a given dimension


CvSparseMat // SPARSE N-dimensional array
</pre> <p> </p></li> 
   <li>Generic arrays: <pre>
CvArr*     // Used only as a function parameter to specify that the
           // function accepts arrays of more than a single type, such
           // as: IplImage*, CvMat* or even CvSeq*. The particular array 
           // type is determined at runtime by analyzing the first 4
           // bytes of the header of the actual array.
</pre> <p> </p><p> </p></li> 
   <li>Scalars: <pre>
CvScalar
  |-- double val[4]; //4D vector
</pre> <p> Initializer function: </p><pre>
CvScalar s = cvScalar(double val0, double val1=0, double val2=0, double val3=0);
</pre> <p> Example: </p><pre>
CvScalar s = cvScalar(20.0);
s.val[0]=10.0;
</pre> <p> Note that the initializer function has the same name as the data structure only starting with a lower case character. It is not a C++ constructor. </p><p> </p></li> 
  </ul> 
  <p> </p>
  <h2><a name="SECTION00043000000000000000"> Other data structures</a> </h2> 
  <p> </p>
  <ul> 
   <li>Points: <pre>
CvPoint      p = cvPoint(int x, int y);
CvPoint2D32f p = cvPoint2D32f(float x, float y);
CvPoint3D32f p = cvPoint3D32f(float x, float y, float z);

E.g.:
p.x=5.0;
p.y=5.0;
</pre> <p> </p></li> 
   <li>Rectangular dimensions: <pre>
CvSize       r = cvSize(int width, int height);
CvSize2D32f  r = cvSize2D32f(float width, float height);
</pre> <p> </p></li> 
   <li>Rectangular dimensions with offset: <pre>
CvRect       r = cvRect(int x, int y, int width, int height);
</pre> <p> </p></li> 
  </ul> 
  <p> </p>
  <p> </p>
  <h1><a name="SECTION00050000000000000000"> Working with images</a> </h1> 
  <p> </p>
  <h2><a name="SECTION00051000000000000000"> Allocating and releasing images</a> </h2> 
  <p> </p>
  <ul> 
   <li>Allocate an image: <pre>
IplImage* cvCreateImage(CvSize size, int depth, int channels);

  size:  cvSize(width,height);

  depth: pixel depth in bits: IPL_DEPTH_8U, IPL_DEPTH_8S, IPL_DEPTH_16U,
    IPL_DEPTH_16S, IPL_DEPTH_32S, IPL_DEPTH_32F, IPL_DEPTH_64F

  channels: Number of channels per pixel. Can be 1, 2, 3 or 4. The channels 
    are interleaved. The usual data layout of a color image is
    b0 g0 r0 b1 g1 r1 ...
</pre> <p> Examples: </p><pre>
// Allocate a 1-channel byte image
IplImage* img1=cvCreateImage(cvSize(640,480),IPL_DEPTH_8U,1); 

// Allocate a 3-channel float image
IplImage* img2=cvCreateImage(cvSize(640,480),IPL_DEPTH_32F,3);
</pre> <p> </p></li> 
   <li>Release an image: <pre>
IplImage* img=cvCreateImage(cvSize(640,480),IPL_DEPTH_8U,1); 
cvReleaseImage(&amp;img);
</pre> <p> </p></li> 
   <li>Clone an image: <pre>
IplImage* img1=cvCreateImage(cvSize(640,480),IPL_DEPTH_8U,1); 
IplImage* img2;
img2=cvCloneImage(img1);
</pre> <p> </p></li> 
   <li>Set/get the region of interest: <pre>
void  cvSetImageROI(IplImage* image, CvRect rect);
void  cvResetImageROI(IplImage* image);
vRect cvGetImageROI(const IplImage* image);

The majority of OpenCV functions support ROI.
</pre> <p> </p></li> 
   <li>Set/get the channel of interest: <pre>
void cvSetImageCOI(IplImage* image, int coi); // 0=all
int cvGetImageCOI(const IplImage* image);

The majority of OpenCV functions do NOT support COI.
</pre> <p> </p></li> 
  </ul> 
  <p> </p>
  <h2><a name="SECTION00052000000000000000"> Reading and writing images</a> </h2> 
  <p> </p>
  <ul> 
   <li>Reading an image from a file: <pre>
  IplImage* img=0; 
  img=cvLoadImage(fileName);
  if(!img) printf("Could not load image file: %s\n",fileName);

  Supported image formats: BMP, DIB, JPEG, JPG, JPE, PNG, PBM, PGM, PPM,
                           SR, RAS, TIFF, TIF
</pre> <p> By default, the loaded image is forced to be a 3-channel color image. This default can be modified by using: </p><pre>
  img=cvLoadImage(fileName,flag);

  flag: &gt;0 the loaded image is forced to be a 3-channel color image
        =0 the loaded image is forced to be a 1 channel grayscale image
        &lt;0 the loaded image is loaded as is (with number of channels in the file).
</pre> <p> </p></li> 
   <li>Writing an image to a file: <pre>
  if(!cvSaveImage(outFileName,img)) printf("Could not save: %s\n",outFileName);
</pre> <p> The output file format is determined based on the file name extension. </p><p> </p></li> 
  </ul> 
  <p> </p>
  <h2><a name="SECTION00053000000000000000"> Accessing image elements</a> </h2> 
  <p> </p>
  <ul> 
   <li>Assume that you need to access the <img WIDTH="14" HEIGHT="15" ALIGN="BOTTOM" BORDER="0" SRC="img3.png" ALT="$k$">-th channel of the pixel at the <img WIDTH="10" HEIGHT="18" ALIGN="BOTTOM" BORDER="0" SRC="img4.png" ALT="$i$">-row and <img WIDTH="13" HEIGHT="33" ALIGN="MIDDLE" BORDER="0" SRC="img5.png" ALT="$j$">-th column. The row index <img WIDTH="10" HEIGHT="18" ALIGN="BOTTOM" BORDER="0" SRC="img4.png" ALT="$i$"> is in the range 
    <!-- MATH
 $[0,\mbox{height}-1]$
 --> <img WIDTH="108" HEIGHT="36" ALIGN="MIDDLE" BORDER="0" SRC="img6.png" ALT="$[0,\mbox{height}-1]$">. The column index <img WIDTH="13" HEIGHT="33" ALIGN="MIDDLE" BORDER="0" SRC="img5.png" ALT="$j$"> is in the range 
    <!-- MATH
 $[0,\mbox{width}-1]$
 --> <img WIDTH="104" HEIGHT="36" ALIGN="MIDDLE" BORDER="0" SRC="img7.png" ALT="$[0,\mbox{width}-1]$">. The channel index <img WIDTH="14" HEIGHT="15" ALIGN="BOTTOM" BORDER="0" SRC="img3.png" ALT="$k$"> is in the range 
    <!-- MATH
 $[0,\mbox{nchannels}-1]$
 --> <img WIDTH="135" HEIGHT="36" ALIGN="MIDDLE" BORDER="0" SRC="img8.png" ALT="$[0,\mbox{nchannels}-1]$">. <p> </p></li> 
   <li><em>Indirect access:</em> (General, but inefficient, access to any type image) <p> </p>
    <ul> 
     <li>For a single-channel byte image: <pre>
IplImage* img=cvCreateImage(cvSize(640,480),IPL_DEPTH_8U,1);
CvScalar s;
s=cvGet2D(img,i,j); // get the (i,j) pixel value
printf("intensity=%f\n",s.val[0]);
s.val[0]=111;
cvSet2D(img,i,j,s); // set the (i,j) pixel value
</pre> <p> </p></li> 
     <li>For a multi-channel float (or byte) image: <pre>
IplImage* img=cvCreateImage(cvSize(640,480),IPL_DEPTH_32F,3);
CvScalar s;
s=cvGet2D(img,i,j); // get the (i,j) pixel value
printf("B=%f, G=%f, R=%f\n",s.val[0],s.val[1],s.val[2]);
s.val[0]=111;
s.val[1]=111;
s.val[2]=111;
cvSet2D(img,i,j,s); // set the (i,j) pixel value
</pre> <p> </p></li> 
    </ul> <p> </p></li> 
   <li><em>Direct access:</em> (Efficient access, but error prone) <p> </p>
    <ul> 
     <li>For a single-channel byte image: <pre>
IplImage* img=cvCreateImage(cvSize(640,480),IPL_DEPTH_8U,1);
((uchar *)(img-&gt;imageData + i*img-&gt;widthStep))[j]=111;
</pre> <p> </p></li> 
     <li>For a multi-channel byte image: <pre>
IplImage* img=cvCreateImage(cvSize(640,480),IPL_DEPTH_8U,3);
((uchar *)(img-&gt;imageData + i*img-&gt;widthStep))[j*img-&gt;nChannels + 0]=111; // B
((uchar *)(img-&gt;imageData + i*img-&gt;widthStep))[j*img-&gt;nChannels + 1]=112; // G
((uchar *)(img-&gt;imageData + i*img-&gt;widthStep))[j*img-&gt;nChannels + 2]=113; // R
</pre> <p> </p></li> 
     <li>For a multi-channel float image: <pre>
IplImage* img=cvCreateImage(cvSize(640,480),IPL_DEPTH_32F,3);
((float *)(img-&gt;imageData + i*img-&gt;widthStep))[j*img-&gt;nChannels + 0]=111; // B
((float *)(img-&gt;imageData + i*img-&gt;widthStep))[j*img-&gt;nChannels + 1]=112; // G
((float *)(img-&gt;imageData + i*img-&gt;widthStep))[j*img-&gt;nChannels + 2]=113; // R
</pre> <p> </p></li> 
    </ul> <p> </p></li> 
   <li><em>Direct access using a pointer:</em> (Simplified and efficient access under limiting assumptions) <p> </p>
    <ul> 
     <li>For a single-channel byte image: <pre>
IplImage* img  = cvCreateImage(cvSize(640,480),IPL_DEPTH_8U,1);
int height     = img-&gt;height;
int width      = img-&gt;width;
int step       = img-&gt;widthStep/sizeof(uchar);
uchar* data    = (uchar *)img-&gt;imageData;
data[i*step+j] = 111;
</pre> <p> </p></li> 
     <li>For a multi-channel byte image: <pre>
IplImage* img  = cvCreateImage(cvSize(640,480),IPL_DEPTH_8U,3);
int height     = img-&gt;height;
int width      = img-&gt;width;
int step       = img-&gt;widthStep/sizeof(uchar);
int channels   = img-&gt;nChannels;
uchar* data    = (uchar *)img-&gt;imageData;
data[i*step+j*channels+k] = 111;
</pre> <p> </p></li> 
     <li>For a multi-channel float image (assuming a 4-byte alignment): <pre>
IplImage* img  = cvCreateImage(cvSize(640,480),IPL_DEPTH_32F,3);
int height     = img-&gt;height;
int width      = img-&gt;width;
int step       = img-&gt;widthStep/sizeof(float);
int channels   = img-&gt;nChannels;
float * data    = (float *)img-&gt;imageData;
data[i*step+j*channels+k] = 111;
</pre> <p> </p></li> 
    </ul> <p> </p><p> </p></li> 
   <li><em>Direct access using a c++ wrapper:</em> (Simple and efficient access) <p> </p>
    <ul> 
     <li>Define a c++ wrapper for single-channel byte images, multi-channel byte images, and multi-channel float images: <pre>
template&lt;class T&gt; class Image
{
  private:
  IplImage* imgp;
  public:
  Image(IplImage* img=0) {imgp=img;}
  ~Image(){imgp=0;}
  void operator=(IplImage* img) {imgp=img;}
  inline T* operator[](const int rowIndx) {
    return ((T *)(imgp-&gt;imageData + rowIndx*imgp-&gt;widthStep));}
};

typedef struct{
  unsigned char b,g,r;
} RgbPixel;

typedef struct{
  float b,g,r;
} RgbPixelFloat;

typedef Image&lt;RgbPixel&gt;       RgbImage;
typedef Image&lt;RgbPixelFloat&gt;  RgbImageFloat;
typedef Image&lt;unsigned char&gt;  BwImage;
typedef Image&lt;float&gt;          BwImageFloat;
</pre> <p> </p></li> 
     <li>For a single-channel byte image: <pre>
IplImage* img=cvCreateImage(cvSize(640,480),IPL_DEPTH_8U,1);
BwImage imgA(img);
imgA[i][j] = 111;
</pre> <p> </p></li> 
     <li>For a multi-channel byte image: <pre>
IplImage* img=cvCreateImage(cvSize(640,480),IPL_DEPTH_8U,3);
RgbImage  imgA(img);
imgA[i][j].b = 111;
imgA[i][j].g = 111;
imgA[i][j].r = 111;
</pre> <p> </p></li> 
     <li>For a multi-channel float image: <pre>
IplImage* img=cvCreateImage(cvSize(640,480),IPL_DEPTH_32F,3);
RgbImageFloat imgA(img);
imgA[i][j].b = 111;
imgA[i][j].g = 111;
imgA[i][j].r = 111;
</pre> <p> </p></li> 
    </ul> <p> </p></li> 
  </ul> 
  <p> </p>
  <h2><a name="SECTION00054000000000000000"> Image conversion</a> </h2> 
  <p> </p>
  <ul> 
   <li>Convert to a grayscale or color byte-image: <pre>
cvConvertImage(src, dst, flags=0);

  src = float/byte grayscale/color image
  dst = byte grayscale/color image
  flags = CV_CVTIMG_FLIP     (flip vertically)
          CV_CVTIMG_SWAP_RB  (swap the R and B channels)
</pre> <p> </p></li> 
   <li>Convert a color image to grayscale: <p> </p><p> <br> Using the OpenCV conversion: </p><pre>
cvCvtColor(cimg,gimg,CV_BGR2GRAY); // cimg -&gt; gimg
</pre> <p> </p><p> <br> Using a direct conversion: </p><pre>
for(i=0;i&lt;cimg-&gt;height;i++) for(j=0;j&lt;cimg-&gt;width;j++) 
  gimgA[i][j]= (uchar)(cimgA[i][j].b*0.114 + 
                       cimgA[i][j].g*0.587 + 
                       cimgA[i][j].r*0.299);
</pre> <p> </p></li> 
   <li>Convert between color spaces: <p> </p><pre>
cvCvtColor(src,dst,code); // src -&gt; dst

  code    = CV_&lt;X&gt;2&lt;Y&gt;
  &lt;X&gt;/&lt;Y&gt; = RGB, BGR, GRAY, HSV, YCrCb, XYZ, Lab, Luv, HLS

e.g.: CV_BGR2GRAY, CV_BGR2HSV, CV_BGR2Lab
</pre> <p> </p></li> 
  </ul> 
  <p> </p>
  <h2><a name="SECTION00055000000000000000"> Drawing commands</a> </h2> 
  <p> </p>
  <ul> 
   <li>Draw a box: <pre>
// draw a box with red lines of width 1 between (100,100) and (200,200)
cvRectangle(img, cvPoint(100,100), cvPoint(200,200), cvScalar(255,0,0), 1);
</pre> <p> </p></li> 
   <li>Draw a circle: <pre>
// draw a circle at (100,100) with a radius of 20. Use green lines of width 1
cvCircle(img, cvPoint(100,100), 20, cvScalar(0,255,0), 1);
</pre> <p> </p></li> 
   <li>Draw a line segment: <pre>
// draw a green line of width 1 between (100,100) and (200,200)
cvLine(img, cvPoint(100,100), cvPoint(200,200), cvScalar(0,255,0), 1);
</pre> <p> </p></li> 
   <li>Draw a set of polylines: <pre>
CvPoint  curve1[]={10,10,  10,100,  100,100,  100,10};
CvPoint  curve2[]={30,30,  30,130,  130,130,  130,30,  150,10};
CvPoint* curveArr[2]={curve1, curve2};
int      nCurvePts[2]={4,5};
int      nCurves=2;
int      isCurveClosed=1;
int      lineWidth=1;

cvPolyLine(img,curveArr,nCurvePts,nCurves,isCurveClosed,cvScalar(0,255,255),lineWidth);
</pre> <p> </p></li> 
   <li>Draw a set of filled polygons: <pre>
cvFillPoly(img,curveArr,nCurvePts,nCurves,cvScalar(0,255,255));
</pre> <p> </p></li> 
   <li>Add text: <pre>
CvFont font;
double hScale=1.0;
double vScale=1.0;
int    lineWidth=1;
cvInitFont(&amp;font,CV_FONT_HERSHEY_SIMPLEX|CV_FONT_ITALIC, hScale,vScale,0,lineWidth);

cvPutText (img,"My comment",cvPoint(200,400), &amp;font, cvScalar(255,255,0));
</pre> <p> Other possible fonts: </p><pre>
CV_FONT_HERSHEY_SIMPLEX, CV_FONT_HERSHEY_PLAIN,
CV_FONT_HERSHEY_DUPLEX, CV_FONT_HERSHEY_COMPLEX,
CV_FONT_HERSHEY_TRIPLEX, CV_FONT_HERSHEY_COMPLEX_SMALL,
CV_FONT_HERSHEY_SCRIPT_SIMPLEX, CV_FONT_HERSHEY_SCRIPT_COMPLEX,
</pre> <p> </p></li> 
  </ul> 
  <p> </p>
  <p> </p>
  <h1><a name="SECTION00060000000000000000"> Working with matrices</a> </h1> 
  <p> </p>
  <h2><a name="SECTION00061000000000000000"> Allocating and releasing matrices</a> </h2> 
  <p> </p>
  <ul> 
   <li>General: 
    <ul> 
     <li>OpenCV has a C interface to matrix operations. There are many alternatives that have a C++ interface (which is more convenient) and are as efficient as OpenCV. </li> 
     <li>Vectors are obtained in OpenCV as matrices having one of their dimensions as 1. </li> 
     <li>Matrices are stored row by row where each row has a 4 byte alignment. </li> 
    </ul> <p> </p></li> 
   <li>Allocate a matrix: <pre>
CvMat* cvCreateMat(int rows, int cols, int type);

  type: Type of the matrix elements. Specified in form
  CV_&lt;bit_depth&gt;(S|U|F)C&lt;number_of_channels&gt;.  E.g.: CV_8UC1 means an
  8-bit unsigned single-channel matrix, CV_32SC2 means a 32-bit signed
  matrix with two channels.

  Example:
  CvMat* M = cvCreateMat(4,4,CV_32FC1);
</pre> <p> </p></li> 
   <li>Release a matrix: <pre>
CvMat* M = cvCreateMat(4,4,CV_32FC1);
cvReleaseMat(&amp;M);
</pre> <p> </p></li> 
   <li>Clone a matrix: <pre>
CvMat* M1 = cvCreateMat(4,4,CV_32FC1);
CvMat* M2;
M2=cvCloneMat(M1);
</pre> <p> </p></li> 
   <li>Initialize a matrix: <pre>
double a[] = { 1,  2,  3,  4,
               5,  6,  7,  8,
               9, 10, 11, 12 };

CvMat Ma=cvMat(3, 4, CV_64FC1, a);
</pre> <p> Alternatively: </p><pre>
CvMat Ma;
cvInitMatHeader(&amp;Ma, 3, 4, CV_64FC1, a);
</pre> <p> </p></li> 
   <li>Initialize a matrix to identity: <pre>
CvMat* M = cvCreateMat(4,4,CV_32FC1);
cvSetIdentity(M); // does not seem to be working properly
</pre> <p> </p></li> 
  </ul> 
  <p> </p>
  <h2><a name="SECTION00062000000000000000"> Accessing matrix elements</a> </h2> 
  <p> </p>
  <ul> 
   <li>Assume that you need to access the <img WIDTH="40" HEIGHT="36" ALIGN="MIDDLE" BORDER="0" SRC="img9.png" ALT="$(i,j)$"> cell of a 2D float matrix. <p> </p></li> 
   <li>Indirect matrix element access: <pre>
cvmSet(M,i,j,2.0); // Set M(i,j)
t = cvmGet(M,i,j); // Get M(i,j)
</pre> <p> </p></li> 
   <li>Direct matrix element access assuming a 4-byte alignment: <pre>
CvMat* M    = cvCreateMat(4,4,CV_32FC1);
int n       = M-&gt;cols;
float *data = M-&gt;data.fl;

data[i*n+j] = 3.0;
</pre> <p> </p></li> 
   <li>Direct matrix element access assuming possible alignment gaps: <pre>
CvMat* M    = cvCreateMat(4,4,CV_32FC1);
int   step  = M-&gt;step/sizeof(float);
float *data = M-&gt;data.fl;

(data+i*step)[j] = 3.0;
</pre> <p> </p></li> 
   <li>Direct matrix element access of an initialized matrix: <pre>
double a[16];
CvMat Ma = cvMat(3, 4, CV_64FC1, a);
a[i*4+j] = 2.0; // Ma(i,j)=2.0;
</pre> <p> </p></li> 
  </ul> 
  <p> </p>
  <h2><a name="SECTION00063000000000000000"> Matrix/vector operations</a> </h2> 
  <p> </p>
  <ul> 
   <li>Matrix-matrix operations: <pre>
CvMat *Ma, *Mb, *Mc;
cvAdd(Ma, Mb, Mc);      // Ma+Mb   -&gt; Mc
cvSub(Ma, Mb, Mc);      // Ma-Mb   -&gt; Mc
cvMatMul(Ma, Mb, Mc);   // Ma*Mb   -&gt; Mc
</pre> <p> </p></li> 
   <li>Elementwise matrix operations: <pre>
CvMat *Ma, *Mb, *Mc;
cvMul(Ma, Mb, Mc);      // Ma.*Mb  -&gt; Mc
cvDiv(Ma, Mb, Mc);      // Ma./Mb  -&gt; Mc
cvAddS(Ma, cvScalar(-10.0), Mc); // Ma.-10 -&gt; Mc
</pre> <p> </p><p> </p></li> 
   <li>Vector products: <pre>
double va[] = {1, 2, 3};
double vb[] = {0, 0, 1};
double vc[3];

CvMat Va=cvMat(3, 1, CV_64FC1, va);
CvMat Vb=cvMat(3, 1, CV_64FC1, vb);
CvMat Vc=cvMat(3, 1, CV_64FC1, vc);

double res=cvDotProduct(&amp;Va,&amp;Vb); // dot product:   Va . Vb -&gt; res
cvCrossProduct(&amp;Va, &amp;Vb, &amp;Vc);    // cross product: Va x Vb -&gt; Vc
end{verbatim}
</pre> <p> Note that Va, Vb, Vc, must be 3 element vectors in a cross product. </p><p> <br> </p><p> </p></li> 
   <li>Single matrix operations: <pre>
CvMat *Ma, *Mb;
cvTranspose(Ma, Mb);      // transpose(Ma) -&gt; Mb (cannot transpose onto self)
CvScalar t = cvTrace(Ma); // trace(Ma) -&gt; t.val[0] 
double d = cvDet(Ma);     // det(Ma) -&gt; d
cvInvert(Ma, Mb);         // inv(Ma) -&gt; Mb
</pre> <p> </p></li> 
   <li>Inhomogeneous linear system solver: <pre>
CvMat* A  = cvCreateMat(3,3,CV_32FC1);
CvMat* x  = cvCreateMat(3,1,CV_32FC1);
CvMat* b  = cvCreateMat(3,1,CV_32FC1);
cvSolve(&amp;A, &amp;b, &amp;x);    // solve (Ax=b) for x
</pre> <p> </p></li> 
   <li>Eigen analysis (of a symmetric matrix): <pre>
CvMat* A  = cvCreateMat(3,3,CV_32FC1);
CvMat* E  = cvCreateMat(3,3,CV_32FC1);
CvMat* l  = cvCreateMat(3,1,CV_32FC1);
cvEigenVV(&amp;A, &amp;E, &amp;l);  // l = eigenvalues of A (descending order)
                        // E = corresponding eigenvectors (rows)
</pre> <p> </p></li> 
   <li>Singular value decomposition: <pre>
CvMat* A  = cvCreateMat(3,3,CV_32FC1);
CvMat* U  = cvCreateMat(3,3,CV_32FC1);
CvMat* D  = cvCreateMat(3,3,CV_32FC1);
CvMat* V  = cvCreateMat(3,3,CV_32FC1);
cvSVD(A, D, U, V, CV_SVD_U_T|CV_SVD_V_T); // A = U D V^T
</pre> <p> The flags cause U and V to be returned transposed (does not work well without the transpose flags). </p><p> </p></li> 
  </ul> 
  <p> </p>
  <h1><a name="SECTION00070000000000000000"> Working with video sequences</a> </h1> 
  <p> </p>
  <h2><a name="SECTION00071000000000000000"> Capturing a frame from a video sequence</a> </h2> 
  <p> </p>
  <ul> 
   <li>OpenCV supports capturing images from a camera or a video file (AVI). <p> </p></li> 
   <li>Initializing capture from a camera: <pre>
CvCapture* capture = cvCaptureFromCAM(0); // capture from video device #0
</pre> <p> </p></li> 
   <li>Initializing capture from a file: <pre>
CvCapture* capture = cvCaptureFromAVI("infile.avi");
</pre> <p> </p></li> 
   <li>Capturing a frame: <pre>
IplImage* img = 0; 
if(!cvGrabFrame(capture)){              // capture a frame 
  printf("Could not grab a frame\n\7");
  exit(0);
}
img=cvRetrieveFrame(capture);           // retrieve the captured frame
</pre> <p> To obtain images from several cameras simultaneously, first grab an image from each camera. Retrieve the captured images after the grabbing is complete. </p><p> </p></li> 
   <li>Releasing the capture source: <pre>
cvReleaseCapture(&amp;capture);
</pre> <p> Note that the image captured by the device is allocated/released by the capture function. There is no need to release it explicitly. </p><p> </p></li> 
  </ul> 
  <p> </p>
  <h2><a name="SECTION00072000000000000000"> Getting/setting frame information</a> </h2> 
  <p> </p>
  <ul> 
   <li>Get capture device properties: <pre>
cvQueryFrame(capture); // this call is necessary to get correct 
                       // capture properties
int frameH    = (int) cvGetCaptureProperty(capture, CV_CAP_PROP_FRAME_HEIGHT);
int frameW    = (int) cvGetCaptureProperty(capture, CV_CAP_PROP_FRAME_WIDTH);
int fps       = (int) cvGetCaptureProperty(capture, CV_CAP_PROP_FPS);
int numFrames = (int) cvGetCaptureProperty(capture,  CV_CAP_PROP_FRAME_COUNT);
</pre> <p> The total frame count is relevant for video files only. It does not seem to be working properly. </p><p> </p><p> </p></li> 
   <li>Get frame information: <pre>
float posMsec   =       cvGetCaptureProperty(capture, CV_CAP_PROP_POS_MSEC);
int posFrames   = (int) cvGetCaptureProperty(capture, CV_CAP_PROP_POS_FRAMES);
float posRatio  =       cvGetCaptureProperty(capture, CV_CAP_PROP_POS_AVI_RATIO);
</pre> <p> Get the position of the captured frame in [msec] with respect to the first frame, or get its index where the first frame starts with an index of 0. The relative position (ratio) is 0 in the first frame and 1 in the last frame. This ratio is valid only for capturing images from a file. </p><p> </p></li> 
   <li>Set the index of the first frame to capture: <pre>
// start capturing from a relative position of 0.9 of a video file
cvSetCaptureProperty(capture, CV_CAP_PROP_POS_AVI_RATIO, (double)0.9);
</pre> <p> This only applies for capturing from a file. It does not seem to be working properly. </p><p> </p></li> 
  </ul> 
  <p> </p>
  <h2><a name="SECTION00073000000000000000"> Saving a video file</a> </h2> 
  <p> </p>
  <ul> 
   <li>Initializing a video writer: <pre>
CvVideoWriter *writer = 0;
int isColor = 1;
int fps     = 25;  // or 30
int frameW  = 640; // 744 for firewire cameras
int frameH  = 480; // 480 for firewire cameras
writer=cvCreateVideoWriter("out.avi",CV_FOURCC('P','I','M','1'),
                           fps,cvSize(frameW,frameH),isColor);
</pre> <p> Other possible codec codes: </p><pre>
CV_FOURCC('P','I','M','1')    = MPEG-1 codec
CV_FOURCC('M','J','P','G')    = motion-jpeg codec (does not work well)
CV_FOURCC('M', 'P', '4', '2') = MPEG-4.2 codec
CV_FOURCC('D', 'I', 'V', '3') = MPEG-4.3 codec
CV_FOURCC('D', 'I', 'V', 'X') = MPEG-4 codec
CV_FOURCC('U', '2', '6', '3') = H263 codec
CV_FOURCC('I', '2', '6', '3') = H263I codec
CV_FOURCC('F', 'L', 'V', '1') = FLV1 codec
</pre> <p> A codec code of -1 will open a codec selection window (in windows). </p><p> </p><p> </p></li> 
   <li>Writing the video file: <pre>
IplImage* img = 0; 
int nFrames = 50;
for(i=0;i&lt;nFrames;i++){
  cvGrabFrame(capture);          // capture a frame
  img=cvRetrieveFrame(capture);  // retrieve the captured frame
  cvWriteFrame(writer,img);      // add the frame to the file
}
</pre> <p> To view the captured frames during capture, add the following in the loop: </p><pre>
cvShowImage("mainWin", img); 
key=cvWaitKey(20);           // wait 20 ms
</pre> <p> Note that without the 20[msec] delay the captured sequence is not displayed properly. </p><p> </p></li> 
   <li>Releasing the video writer: <pre>
cvReleaseVideoWriter(&amp;writer);
</pre> <p> </p></li> 
  </ul> 
  <p> </p>
  <hr> 
  <!--Navigation Panel--> 
  <img WIDTH="81" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next_inactive" SRC="file:/usr/share/latex2html/icons/nx_grp_g.png"> 
  <img WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="file:/usr/share/latex2html/icons/up_g.png"> 
  <img WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="file:/usr/share/latex2html/icons/prev_g.png"> 
  <br> 
  <!--End of Navigation Panel--> 
  <address> Gady Agam 2006-03-31 </address>   
 </body>
</html>