<html>
 <head>
  <title>Java and XSLT: Chapter 5: XSLT Processingwith Java</title>
 </head> 
 <body bgcolor="#ffffff" text="#000000" link="#990000" vlink="#0000cc"> 
  <table border="0" cellpadding="0" cellspacing="0" width="90%"> 
   <tbody>
    <tr> 
     <td colspan="2"> <img width="515" height="37" align="bottom" alt="Search the Catalog" border="0" usemap="#catalog_header_buttons" ismap src="Ch05_files/catalog_header_butto.gif"> <map name="catalog_header_buttons"><area shape="Rect" coords="407,17,512,32" href="http://www.oreilly.com/catalog/search.html"><area shape="Rect" coords="431,3,512,18" href="http://www.oreilly.com/catalog/prdindex.html"></map> </td> 
    </tr> 
    <tr> 
     <td width="25%" valign="top"> <a href="http://www.oreilly.com/catalog/javaxslt/"> <img hspace="10" vspace="10" src="Ch05_files/javaxslt.gif" alt="Java and XSLT" align="left" valign="top" border="0"> </a> </td> 
     <td height="105" valign="top"> <br> <h2>Java and XSLT</h2> <font size="-1"> By Eric M. Burke<br> September 2001<br> 0-596-00143-6, Order Number: 143-6<br> 528 pages, $39.95 </font> </td> 
    </tr> 
   </tbody>
  </table> 
  <hr size="1" noshade> 
  <!--sample chapter begins --> 
  <blockquote> 
   <h2 class="ChapterTitle">Chapter 5 <br> <a name="79915"></a>XSLT Processing with Java</h2> 
   <p class="Body">Since many of the XSLT processors are written in Java, they can be directly invoked from a Java application or servlet. Embedding the processor into a Java application is generally a matter of including one or two JAR files on the CLASSPATH and then invoking the appropriate methods. This chapter shows how to do this, along with a whole host of other programming techniques.</p> 
   <p class="Body">When invoked from the command line, an XSLT processor such as Xalan expects the location of an XML file and an XSLT stylesheet to be passed as parameters. The two files are then parsed into memory using an XML parser such as Xerces or Crimson, and the transformation is performed. But when the XSLT processor is invoked programmatically, you are not limited to using static files. Instead, you can send a precompiled stylesheet and a dynamically generated DOM tree directly to the processor, or even fire SAX events as processor input. A major goal is to eliminate the overhead of parsing, which can dramatically improve performance.</p> 
   <p class="Body">This chapter is devoted to Java and XSLT programming techniques that work for both standalone applications as well as servlets, with a particular emphasis on Sun's Java API for XML Processing (JAXP) API. In Chapter 6, we will apply these techniques to servlets, taking into account issues such as concurrency, deployment, and performance.</p> 
   <h2 class="HeadA">A Simple Example</h2> 
   <p class="Body">Let's start with perhaps the simplest program that can be written. For this task, we will write a simple Java program that transforms a static XML data file into HTML using an XSLT stylesheet. The key benefit of beginning with a simple program is that it isolates problems with your development environment, particularly CLASSPATH issues, before you move on to more complex tasks.</p> 
   <p class="Body">Two versions of our Java program will be written, one for Xalan and another for SAXON. A JAXP implementation will follow in the next section, showing how the same code can be utilized for many different processors.</p> 
   <blockquote> 
    <table border="1"> 
     <tbody>
      <tr> 
       <td rowspan="1" colspan="1"> <p class="SidebarTitle"></p>
        <center>
         <h3>CLASSPATH Problems</h3>
        </center><p></p> <p class="SidebarBody">CLASSPATH problems are a common culprit when your code is not working, particularly with XML-related APIs. Since so many tools now use XML, it is very likely that a few different DOM and SAX implementations reside on your system. Before trying any of the examples in this chapter, you may want to verify that older parsers are not listed on your CLASSPATH.</p> <p class="SidebarBody">More subtle problems can occur if an older library resides in the Java 2 <em class="Emphasis">optional packages</em> directory. Any JAR file found in the <em class="Filename">jre/lib/ext</em> directory is automatically available to the JVM without being added to the CLASSPATH. You should look for files such as <em class="Filename">jaxp.jar</em> and <em class="Filename">parser.jar</em>, which could contain older, incompatible XML APIs. If you experience problems, remove all JAR files from the optional packages directory.</p> <p class="SidebarBody">Unfortunately, you will have to do some detective work to figure out where the JAR files came from. Although Java 2 Version 1.3 introduced enhanced JAR features that included versioning information, most of the JAR files you encounter probably will not utilize this capability.</p> </td> 
      </tr> 
     </tbody>
    </table> 
   </blockquote> 
   <h3 class="HeadB">The Design</h3> 
   <p class="Body">The design of this application is pretty simple. A single class contains a <code class="Literal">main( )</code> method that performs the transformation. The application requires two arguments: the XML file name followed by the XSLT file name. The results of the transformation are simply written to <code class="Literal">System.out</code>. We will use the following XML data for our example:</p> 
   <pre><code class="Code">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</code>
<code class="Code">&lt;message&gt;Yep, it worked!&lt;/message&gt;</code>
</pre> 
   <p class="Body">The following XSLT stylesheet will be used. It's output method is <code class="Literal">text</code>, and it simply prints out the contents of the <code class="Literal">&lt;message&gt;</code> element. In this case, the text will be <code class="Literal">Yep, it worked!</code>.</p> 
   <pre><code class="Code">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</code>
<code class="Code">&lt;xsl:stylesheet </code>
<code class="Code">    version="1.0"</code>
<code class="Code">    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;</code>
<code class="Code">  &lt;xsl:output method="text" encoding="UTF-8"/&gt;</code>
<code class="Code">?</code>
<code class="Code">  &lt;!-- simply copy the message to the result tree --&gt;</code>
<code class="Code">  &lt;xsl:template match="/"&gt;</code>
<code class="Code">    &lt;xsl:value-of select="message"/&gt;</code>
<code class="Code">  &lt;/xsl:template&gt;</code>
<code class="Code">&lt;/xsl:stylesheet&gt; </code>
</pre> 
   <p class="Body">Since the filenames are passed as command-line parameters, the application can be used with other XML and XSLT files. You might want to try this out with one of the president examples from Chapters and 3.</p> 
   <h3 class="HeadB">Xalan 1 Implementation</h3> 
   <p class="Body">The complete code for the Xalan implementation is listed in <a href="http://www.oreilly.com/catalog/javaxslt/chapter/ch05.html#51041" class="XRef">Example 5-1</a>. As comments in the code indicate, this code was developed and tested using Xalan 1.2.2, which is not the most recent XSLT processor from Apache. Fully qualified Java class names, such as <code class="Literal">org.apache.xalan.xslt.XSLTProcessor</code>, are used for all Xalan-specific code.</p> 
   <blockquote> 
    <p class="NoteTip"><b>TIP:</b> A Xalan 2 example is not shown here because Xalan 2 is compatible with Sun's JAXP. The JAXP version of this program works with Xalan 2, as well as any other JAXP compatible processor.</p>
   </blockquote> 
   <p> <b class="ExampleLabel"><a name="51041">Example 5-1:</a></b> <b class="ExampleTitle">SimpleXalan1.java </b> </p>
   <pre><code class="Code">package chap5;</code>
<code class="Code">?</code>
<code class="Code">import java.io.*;</code>
<code class="Code">import java.net.MalformedURLException;</code>
<code class="Code">import java.net.URL;</code>
<code class="Code">import org.xml.sax.SAXException;</code>
<code class="Code">?</code>
<code class="Code">?</code>
<code class="Code">/**</code>
<code class="Code"> * A simple demo of Xalan 1. This code was originally written using</code>
<code class="Code"> * Xalan 1.2.2.  It will not work with Xalan 2.</code>
<code class="Code"> */</code>
<code class="Code">public class SimpleXalan1 {</code>
<code class="Code">?</code>
<code class="Code">    /**</code>
<code class="Code">     * Accept two command line arguments: the name of an XML file, and</code>
<code class="Code">     * the name of an XSLT stylesheet. The result of the transformation</code>
<code class="Code">     * is written to stdout.</code>
<code class="Code">     */</code>
<code class="Code">    public static void main(String[] args)</code>
<code class="Code">            throws MalformedURLException, SAXException {</code>
<code class="Code">        if (args.length != 2) {</code>
<code class="Code">            System.err.println("Usage:");</code>
<code class="Code">            System.err.println("  java " + SimpleXalan1.class.getName(  )</code>
<code class="Code">                    + " xmlFileName xsltFileName");</code>
<code class="Code">            System.exit(1);</code>
<code class="Code">        }</code>
<code class="Code">?</code>
<code class="Code">        String xmlFileName = args[0];</code>
<code class="Code">        String xsltFileName = args[1];</code>
<code class="Code">?</code>
<code class="Code">        String xmlSystemId = new File(xmlFileName).toURL().toExternalForm(  );</code>
<code class="Code">        String xsltSystemId = new File(xsltFileName).toURL().toExternalForm(  );</code>
<code class="Code">?</code>
<code class="Code">        org.apache.xalan.xslt.XSLTProcessor processor =</code>
<code class="Code">                org.apache.xalan.xslt.XSLTProcessorFactory.getProcessor(  );</code>
<code class="Code">?</code>
<code class="Code">        org.apache.xalan.xslt.XSLTInputSource xmlInputSource =</code>
<code class="Code">                new org.apache.xalan.xslt.XSLTInputSource(xmlSystemId);</code>
<code class="Code">?</code>
<code class="Code">        org.apache.xalan.xslt.XSLTInputSource xsltInputSource =</code>
<code class="Code">                new org.apache.xalan.xslt.XSLTInputSource(xsltSystemId);</code>
<code class="Code">?</code>
<code class="Code">        org.apache.xalan.xslt.XSLTResultTarget resultTree =</code>
<code class="Code">                new org.apache.xalan.xslt.XSLTResultTarget(System.out);</code>
<code class="Code">?</code>
<code class="Code">        processor.process(xmlInputSource, xsltInputSource, resultTree);</code>
<code class="Code">    }</code>
<code class="Code">}</code>
</pre> 
   <p class="Body">The code begins with the usual list of imports and the class declaration, followed by a simple check to ensure that two command line arguments are provided. If all is OK, then the XML file name and XSLT file name are converted into <em class="Emphasis">system identifier</em> values:</p> 
   <pre><code class="Code">String xmlSystemId = new File(xmlFileName).toURL().toExternalForm(  );</code>
<code class="Code">String xsltSystemId = new File(xsltFileName).toURL().toExternalForm(  );</code>
</pre> 
   <p class="Body">System identifiers are part of the XML specification and really mean the same thing as a Uniform Resource Identifier (URI). A Uniform Resource Locator (URL) is a specific type of URI and can be used for methods that require system identifiers as parameters. From a Java programming perspective, this means that a platform-specific filename such as <em class="Filename">C:/data/simple.xml</em> needs to be converted to <i>file:///C:/data/simple.xml</i> before it can be used by most XML APIs. The code shown here does the conversion and will work on Unix, Windows, and other platforms supported by Java. Although you could try to manually prepend the filename with the literal string <code class="Literal">file:///</code>, that may not result in portable code. The documentation for <code class="Literal">java.io.File</code> clearly states that its <code class="Literal">toURL( )</code> method generates a system-dependent URL, so the results will vary when the same code is executed on a non-Windows platform. In fact, on Windows the code actually produces a nonstandard URL (with a single slash), although it does work within Java programs: <i>file:/C:/data/simple.xml.</i></p> 
   <p class="Body">Now that we have system identifiers for our two input files, an instance of the XSLT processor is created:</p> 
   <pre><code class="Code">org.apache.xalan.xslt.XSLTProcessor processor =</code>
<code class="Code">        org.apache.xalan.xslt.XSLTProcessorFactory.getProcessor(  );</code>
</pre> 
   <p class="Body"><code class="Literal">XSLTProcessor</code> is an interface, and <code class="Literal">XSLTProcessorFactory</code> is a factory for creating new instances of classes that implement it. Because Xalan is open source software, it is easy enough to determine that <code class="Literal">XSLTEngineImpl</code> is the class that implements the <code class="Literal">XSLTProcessor</code> interface, although you should try to avoid code that depends on the specific implementation.</p> 
   <p class="Body">The next few lines of code create <code class="Literal">XSLTInputSource</code> objects, one for the XML file and another for the XSLT file:</p> 
   <pre><code class="Code">org.apache.xalan.xslt.XSLTInputSource xmlInputSource =</code>
<code class="Code">        new org.apache.xalan.xslt.XSLTInputSource(xmlSystemId);</code>
<code class="Code">?</code>
<code class="Code">org.apache.xalan.xslt.XSLTInputSource xsltInputSource =</code>
<code class="Code">        new org.apache.xalan.xslt.XSLTInputSource(xsltSystemId);</code>
</pre> 
   <p class="Body"><code class="Literal">XSLTInputSource</code> is a subclass of <code class="Literal">org.xml.sax.InputSource</code>, adding the ability to read directly from a DOM <code class="Literal">Node</code>. <code class="Literal">XSLTInputSource</code> has the ability to read XML or XSLT data from a system ID, <code class="Literal">java.io.InputStream</code>, <code class="Literal">java.io.Reader</code>, <code class="Literal">org.w3c.dom.Node</code>, or an existing <code class="Literal">InputSource</code>. As shown in the code, the source of the data is specified in the constructor. <code class="Literal">XSLTInputSource</code> also has a <code class="Literal">no-arg</code> constructor, along with get/set methods for each of the supported data source types.</p> 
   <p class="Body">An instance of <code class="Literal">XSLTResultTarget</code> is created next, sending the result of the transformation to <code class="Literal">System.out</code>:</p> 
   <pre><code class="Code">org.apache.xalan.xslt.XSLTResultTarget resultTree =</code>
<code class="Code">        new org.apache.xalan.xslt.XSLTResultTarget(System.out);</code>
</pre> 
   <p class="Body">In a manner similar to <code class="Literal">XSLTInputSource</code>, the <code class="Literal">XSLTResultTarget</code> can also be wrapped around an instance of <code class="Literal">org.w3c.dom.Node</code>, an <code class="Literal">OutputStream</code> or <code class="Literal">Writer</code>, a filename (not a system ID!), or an instance of <code class="Literal">org.xml.sax.DocumentHandler</code>.</p> 
   <p class="Body">The final line of code simply instructs the processor to perform the transformation:</p> 
   <pre><code class="Code">processor.process(xmlInputSource, xsltInputSource, resultTree);</code>
</pre> 
   <h3 class="HeadB">SAXON Implementation</h3> 
   <p class="Body">For comparison, a SAXON 5.5.1 implementation is presented in <a href="http://www.oreilly.com/catalog/javaxslt/chapter/ch05.html#95848" class="XRef">Example 5-2</a>. As you scan through the code, you will notice the word "trax" appearing in the Java packages. This is an indication that Version 5.5.1 of SAXON was moving towards something called Transformation API for XML (TrAX). More information on TrAX is coming up in the JAXP discussion. In a nutshell, TrAX provides a uniform API that should work with any XSLT processor.</p> 
   <p> <b class="ExampleLabel"><a name="95848">Example 5-2:</a></b> <b class="ExampleTitle">SimpleSaxon.java </b> </p>
   <pre><code class="Code">package chap5;</code>
<code class="Code">?</code>
<code class="Code">import java.io.*;</code>
<code class="Code">import java.net.MalformedURLException;</code>
<code class="Code">import java.net.URL;</code>
<code class="Code">import org.xml.sax.SAXException;</code>
<code class="Code">?</code>
<code class="Code">/**</code>
<code class="Code"> * A simple demo of SAXON. This code was originally written using</code>
<code class="Code"> * SAXON 5.5.1.</code>
<code class="Code"> */</code>
<code class="Code">public class SimpleSaxon {</code>
<code class="Code">?</code>
<code class="Code">    /**</code>
<code class="Code">     * Accept two command line arguments: the name of an XML file, and</code>
<code class="Code">     * the name of an XSLT stylesheet. The result of the transformation</code>
<code class="Code">     * is written to stdout.</code>
<code class="Code">     */</code>
<code class="Code">    public static void main(String[] args)</code>
<code class="Code">            throws MalformedURLException, IOException, SAXException {</code>
<code class="Code">        if (args.length != 2) {</code>
<code class="Code">            System.err.println("Usage:");</code>
<code class="Code">            System.err.println("  java " + SimpleSaxon.class.getName(  )</code>
<code class="Code">                    + " xmlFileName xsltFileName");</code>
<code class="Code">            System.exit(1);</code>
<code class="Code">        }</code>
<code class="Code">?</code>
<code class="Code">        String xmlFileName = args[0];</code>
<code class="Code">        String xsltFileName = args[1];</code>
<code class="Code">?</code>
<code class="Code">        String xmlSystemId = new File(xmlFileName).toURL().toExternalForm(  );</code>
<code class="Code">        String xsltSystemId = new File(xsltFileName).toURL().toExternalForm(  );</code>
<code class="Code">?</code>
<code class="Code">        com.icl.saxon.trax.Processor processor =</code>
<code class="Code">                com.icl.saxon.trax.Processor.newInstance("xslt");</code>
<code class="Code">?</code>
<code class="Code">        // unlike Xalan, SAXON uses the SAX InputSource.  Xalan</code>
<code class="Code">        // uses its own class, XSLTInputSource</code>
<code class="Code">        org.xml.sax.InputSource xmlInputSource =</code>
<code class="Code">                new org.xml.sax.InputSource(xmlSystemId);</code>
<code class="Code">        org.xml.sax.InputSource xsltInputSource =</code>
<code class="Code">                new org.xml.sax.InputSource(xsltSystemId);</code>
<code class="Code">?</code>
<code class="Code">        com.icl.saxon.trax.Result result =</code>
<code class="Code">                new com.icl.saxon.trax.Result(System.out);</code>
<code class="Code">?</code>
<code class="Code">        // create a new compiled stylesheet</code>
<code class="Code">        com.icl.saxon.trax.Templates templates =</code>
<code class="Code">                processor.process(xsltInputSource);</code>
<code class="Code">?</code>
<code class="Code">        // create a transformer that can be used for a single transformation</code>
<code class="Code">        com.icl.saxon.trax.Transformer trans = templates.newTransformer(  );</code>
<code class="Code">        trans.transform(xmlInputSource, result);</code>
<code class="Code">    }</code>
<code class="Code">}</code>
</pre> 
   <p class="Body">The SAXON implementation starts exactly as the Xalan implementation does. Following the class declaration, the command-line parameters are validated and then converted to system IDs. The XML and XSLT system IDs are then wrapped in <code class="Literal">org.xml.sax.InputSource</code> objects as follows:</p> 
   <pre><code class="Code">org.xml.sax.InputSource xmlInputSource =</code>
<code class="Code">        new org.xml.sax.InputSource(xmlSystemId);</code>
<code class="Code">org.xml.sax.InputSource xsltInputSource =</code>
<code class="Code">        new org.xml.sax.InputSource(xsltSystemId);</code>
</pre> 
   <p class="Body">This code is virtually indistinguishable from the Xalan code, except Xalan uses <code class="Literal">XSLTInputSource</code> instead of <code class="Literal">InputSource</code>. As mentioned before, <code class="Literal">XSLTInputSource</code> is merely a subclass of <code class="Literal">InputSource</code> that adds support for reading from a DOM <code class="Literal">Node</code>. SAXON also has the ability to read from a DOM node, although its approach is slightly different.</p> 
   <p class="Body">Creating a <code class="Literal">Result</code> object sets up the destination for the XSLT result tree, which is directed to <code class="Literal">System.out</code> in this example:</p> 
   <pre><code class="Code">com.icl.saxon.trax.Result result =</code>
<code class="Code">        new com.icl.saxon.trax.Result(System.out);</code>
</pre> 
   <p class="Body">The XSLT stylesheet is then compiled, resulting in an object that can be used repeatedly from many concurrent threads:</p> 
   <pre><code class="Code">com.icl.saxon.trax.Templates templates =</code>
<code class="Code">        processor.process(xsltInputSource);</code>
</pre> 
   <p class="Body">In a typical XML and XSLT web site, the XML data is generated dynamically, but the same stylesheets are used repeatedly. For instance, stylesheets generating common headers, footers, and navigation bars will be used by many pages. To maximize performance, you will want to process the stylesheets once and reuse the instances for many clients at the same time. For this reason, the thread safety that <code class="Literal">Templates</code> offers is critical.</p> 
   <p class="Body">An instance of the <code class="Literal">Transformer</code> class is then created to perform the actual transformation. Unlike the stylesheet itself, the transformer cannot be shared by many clients and is not thread-safe. If this was a servlet implementation, the <code class="Literal">Transformer</code> instance would have to be created with each invocation of <code class="Literal">doGet</code> or <code class="Literal">doPost</code>. In our example, the code is as follows:</p> 
   <pre><code class="Code">com.icl.saxon.trax.Transformer trans = templates.newTransformer(  );</code>
<code class="Code">trans.transform(xmlInputSource, result);</code>
</pre> 
   <h3 class="HeadB">SAXON, Xalan, or TrAX?</h3> 
   <p class="Body">As the previous examples show, SAXON and Xalan have many similarities. While similarities make learning the various APIs easy, they do not result in portable code. If you write code directly against either of these interfaces, you lock yourself into that particular implementation unless you want to rewrite your application.</p> 
   <p class="Body">The other option is to write a facade around both processors, presenting a consistent interface that works with either processor behind the scenes. The only problem with this approach is that as new processors are introduced, you must update the implementation of your facade. It would be very difficult for one individual or organization to keep up with the rapidly changing world of XSLT processors.</p> 
   <p class="Body">But if the facade was an open standard and supported by a large enough user base, the people and organizations that write the XSLT processors would feel pressure to adhere to the common API, rather than the other way around. TrAX was initiated in early 2000 as an effort to define a consistent API to any XSLT processor. Since some of the key people behind TrAX were also responsible for implementing some of the major XSLT processors, it was quickly accepted that TrAX would be a de facto standard, much in the way that SAX is.</p> 
   <h2 class="HeadA">Introduction to JAXP 1.1</h2> 
   <p class="Body">TrAX was a great idea, and the original work and concepts behind it were absorbed into JAXP Version 1.1. If you search for TrAX on the Web and get the feeling that the effort is waning, this is only because focus has shifted from TrAX to JAXP. Although the name has changed, the concept has not: JAXP provides a standard Java interface to many XSLT processors, allowing you to choose your favorite underlying implementation while retaining portability.</p> 
   <p class="Body">First released in March 2000, Sun's JAXP 1.0 utilized XML 1.0, XML Namespaces 1.0, SAX 1.0, and DOM Level 1. JAXP is a standard extension to Java, meaning that Sun provides a specification through its Java Community Process (JCP) as well as a reference implementation. JAXP 1.1 follows the same basic design philosophies of JAXP 1.0, adding support for DOM Level 2, SAX 2, and XSLT 1.0. A tool like JAXP is necessary because the XSLT specification defines only a transformation language; it says nothing about how to write a Java XSLT processor. Although they all perform the same basic tasks, every processor uses a different API and has its own set of programming conventions.</p> 
   <p class="Body">JAXP is not an XML parser, nor is it an XSLT processor. Instead, it provides a common Java interface that masks differences between various implementations of the supported standards. When using JAXP, your code can avoid dependencies on specific vendor tools, allowing flexibility to upgrade to newer tools when they become available. </p> 
   <p class="Body">The key to JAXP's design is the concept of <em class="Emphasis">plugability layers</em>. These layers provide consistent Java interfaces to the underlying SAX, DOM, and XSLT implementations. In order to utilize one of these APIs, you must obtain a factory class without hardcoding Xalan or SAXON code into your application. This is accomplished via a lookup mechanism that relies on Java system properties. Since three separate plugability layers are used, you can use a DOM parser from one vendor, a SAX parser from another vendor, and yet another XSLT processor from someone else. In reality, you will probably need to use a DOM parser compatible with your XSLT processor if you try to transform the DOM tree directly. <a href="http://www.oreilly.com/catalog/javaxslt/chapter/ch05.html#41886" class="XRef">Figure 5-1</a> illustrates the high-level architecture of JAXP 1.1.</p> 
   <table> 
    <caption> 
     <b class="FigureLabel"><a name="41886"></a>Figure 5-1.</b> 
     <b class="FigureTitle">JAXP 1.1 architecture</b> 
    </caption> 
    <tbody>
     <tr> 
      <td rowspan="1" colspan="1"> <p class="FigureHolder"><img src="Ch05_files/jxt_0501.gif" align="bottom"> ?</p> </td> 
     </tr> 
    </tbody>
   </table> 
   <p class="Body">As shown, application code does not deal directly with specific parser or processor implementations, such as SAXON or Xalan. Instead, you write code against abstract classes that JAXP provides. This level of indirection allows you to pick and choose among different implementations without even recompiling your application.</p> 
   <p class="Body">The main drawback to an API such as JAXP is the "least common denominator" effect, which is all too familiar to AWT programmers. In order to maximize portability, JAXP mostly provides functionality that all XSLT processors support. This means, for instance, that Xalan's custom XPath APIs are not included in JAXP. In order to use value-added features of a particular processor, you must revert to nonportable code, negating the benefits of a plugability layer. Fortunately, most common tasks are supported by JAXP, so reverting to implementation-specific code is the exception, not the rule.</p> 
   <p class="Body">Although the JAXP specification does not define an XML parser or XSLT processor, reference implementations do include these tools. These reference implementations are open source Apache XML tools,<a href="#footnote-1" title="Footnote" class="footnote">[1]</a> so complete source code is available.</p> 
   <h3 class="HeadB">JAXP 1.1 Implementation</h3> 
   <p class="Body">You guessed it--we will now reimplement the simple example using Sun's JAXP 1.1. Behind the scenes, this could use any JAXP 1.1-compliant XSLT processor; this code was developed and tested using Apache's Xalan 2 processor. <a href="http://www.oreilly.com/catalog/javaxslt/chapter/ch05.html#71777" class="XRef">Example 5-3</a> contains the complete source code.</p> 
   <p> <b class="ExampleLabel"><a name="71777">Example 5-3:</a></b> <b class="ExampleTitle">SimpleJaxp.java </b> </p>
   <pre><code class="Code">package chap5;</code>
<code class="Code">?</code>
<code class="Code">import java.io.*;</code>
<code class="Code">?</code>
<code class="Code">/**</code>
<code class="Code"> * A simple demo of JAXP 1.1</code>
<code class="Code"> */</code>
<code class="Code">public class SimpleJaxp {</code>
<code class="Code">?</code>
<code class="Code">    /**</code>
<code class="Code">     * Accept two command line arguments: the name of an XML file, and</code>
<code class="Code">     * the name of an XSLT stylesheet. The result of the transformation</code>
<code class="Code">     * is written to stdout.</code>
<code class="Code">     */</code>
<code class="Code">    public static void main(String[] args)</code>
<code class="Code">            throws javax.xml.transform.TransformerException {</code>
<code class="Code">        if (args.length != 2) {</code>
<code class="Code">            System.err.println("Usage:");</code>
<code class="Code">            System.err.println("  java " + SimpleJaxp.class.getName(  )</code>
<code class="Code">                    + " xmlFileName xsltFileName");</code>
<code class="Code">            System.exit(1);</code>
<code class="Code">        }</code>
<code class="Code">?</code>
<code class="Code">        File xmlFile = new File(args[0]);</code>
<code class="Code">        File xsltFile = new File(args[1]);</code>
<code class="Code">?</code>
<code class="Code">        javax.xml.transform.Source xmlSource =</code>
<code class="Code">                new javax.xml.transform.stream.StreamSource(xmlFile);</code>
<code class="Code">        javax.xml.transform.Source xsltSource =</code>
<code class="Code">                new javax.xml.transform.stream.StreamSource(xsltFile);</code>
<code class="Code">        javax.xml.transform.Result result =</code>
<code class="Code">                new javax.xml.transform.stream.StreamResult(System.out);</code>
<code class="Code">?</code>
<code class="Code">        // create an instance of TransformerFactory</code>
<code class="Code">        javax.xml.transform.TransformerFactory transFact =</code>
<code class="Code">                javax.xml.transform.TransformerFactory.newInstance(  );</code>
<code class="Code">?</code>
<code class="Code">        javax.xml.transform.Transformer trans =</code>
<code class="Code">                transFact.newTransformer(xsltSource);</code>
<code class="Code">?</code>
<code class="Code">        trans.transform(xmlSource, result);</code>
<code class="Code">    }</code>
<code class="Code">}</code>
</pre> 
   <p class="Body">As in the earlier examples, explicit package names are used in the code to point out which classes are parts of JAXP. In future examples, <code class="Literal">import</code> statements will be favored because they result in less typing and more readable code. Our new program begins by declaring that it may throw <code class="Literal">TransformerException</code>:</p> 
   <pre><code class="Code">public static void main(String[] args)</code>
<code class="Code">        throws javax.xml.transform.TransformerException {</code>
</pre> 
   <p class="Body">This is a general-purpose exception representing anything that might go wrong during the transformation process. In other processors, SAX-specific exceptions are typically propagated to the caller. In JAXP, <code class="Literal">TransformerException</code> can be wrapped around any type of <code class="Literal">Exception</code> object that various XSLT processors may throw.</p> 
   <p class="Body">Next, the command-line arguments are converted into <code class="Literal">File</code> objects. In the SAXON and Xalan examples, we created a system ID for each of these files. Since JAXP can read directly from a <code class="Literal">File</code> object, the extra conversion to a URI is not needed:</p> 
   <pre><code class="Code">File xmlFile = new File(args[0]);</code>
<code class="Code">File xsltFile = new File(args[1]);</code>
<code class="Code">?</code>
<code class="Code">javax.xml.transform.Source xmlSource =</code>
<code class="Code">        new javax.xml.transform.stream.StreamSource(xmlFile);</code>
<code class="Code">javax.xml.transform.Source xsltSource =</code>
<code class="Code">        new javax.xml.transform.stream.StreamSource(xsltFile);</code>
</pre> 
   <p class="Body">The <code class="Literal">Source</code> interface is used to read both the XML file and the XSLT file. Unlike the SAX <code class="Literal">InputSource</code> class or Xalan's <code class="Literal">XSLTInputSource</code> class, <code class="Literal">Source</code> is an interface that can have many implementations. In this simple example we are using <code class="Literal">StreamSource</code>, which has the ability to read from a <code class="Literal">File</code> object, an <code class="Literal">InputStream</code>, a <code class="Literal">Reader</code>, or a system ID. Later we will examine additional <code class="Literal">Source</code> implementations that use SAX and DOM as input. Just like <code class="Literal">Source</code>, <code class="Literal">Result</code> is an interface that can have several implementations. In this example, a <code class="Literal">StreamResult</code> sends the output of the transformations to <code class="Literal">System.out</code>:</p> 
   <pre><code class="Code">javax.xml.transform.Result result =</code>
<code class="Code">        new javax.xml.transform.stream.StreamResult(System.out);</code>
</pre> 
   <p class="Body">Next, an instance of <code class="Literal">TransformerFactory</code> is created:</p> 
   <pre><code class="Code">javax.xml.transform.TransformerFactory transFact =</code>
<code class="Code">        javax.xml.transform.TransformerFactory.newInstance(  );</code>
</pre> 
   <p class="Body">The <code class="Literal">TransformerFactory</code> is responsible for creating <code class="Literal">Transformer</code> and <code class="Literal">Template</code> objects. In our simple example, we create a <code class="Literal">Transformer</code> object:</p> 
   <pre><code class="Code">javax.xml.transform.Transformer trans =</code>
<code class="Code">        transFact.newTransformer(xsltSource);</code>
</pre> 
   <p class="Body"><code class="Literal">Transformer</code> objects are not thread-safe, although they can be used multiple times. For a simple example like this, we will not encounter any problems. In a threaded servlet environment, however, multiple users cannot concurrently access the same <code class="Literal">Transformer</code> instance. JAXP also provides a <code class="Literal">Templates</code> interface, which represents a stylesheet that can be accessed by many concurrent threads.</p> 
   <p class="Body">The transformer instance is then used to perform the actual transformation:</p> 
   <pre><code class="Code">trans.transform(xmlSource, result);</code>
</pre> 
   <p class="Body">This applies the XSLT stylesheet to the XML data, sending the result to <code class="Literal">System.out</code>.</p> 
   <h3 class="HeadB">XSLT Plugability Layer</h3> 
   <p class="Body">JAXP 1.1 defines a specific lookup procedure to locate an appropriate XSLT processor. This must be accomplished without hardcoding vendor-specific code into applications, so Java system properties and JAR file service providers are used. Within your code, first locate an instance of the <code class="Literal">TransformerFactory</code> class as follows:</p> 
   <pre><code class="Code">javax.xml.transform.TransformerFactory transFact =</code>
<code class="Code">        javax.xml.transform.TransformerFactory.newInstance(  );</code>
</pre> 
   <p class="Body">Since <code class="Literal">TransformerFactory</code> is abstract, its <code class="Literal">newInstance( )</code> factory method is used to instantiate an instance of a specific subclass. The algorithm for locating this subclass begins by looking at the <code class="Literal">javax.xml.transform.TransformerFactory</code> system property. Let us suppose that <code class="Literal">com.foobar.AcmeTransformer</code> is a new XSLT processor compliant with JAXP 1.1. To utilize this processor instead of JAXP's default processor, you can specify the system property on the command line<a href="#footnote-2" title="Footnote" class="footnote">[2]</a> when you start your Java application:</p> 
   <pre><code class="Code">java -Djavax.xml.transform.TransformerFactory=com.foobar.AcmeTransformer MyApp</code>
</pre> 
   <p class="Body">Provided that JAXP is able to instantiate an instance of <code class="Literal">AcmeTransformer</code>, this is the XSLT processor that will be used. Of course, <code class="Literal">AcmeTransformer</code> must be a subclass of <code class="Literal">TransformerFactory</code> for this to work, so it is up to vendors to offer support for JAXP.</p> 
   <p class="Body">If the system property is not specified, JAXP next looks for a property file named <em class="Filename">lib/jaxp.properties</em> in the JRE directory. A property file consists of <code class="Literal">name=value</code> pairs, and JAXP looks for a line like this:</p> 
   <pre><code class="Code">javax.xml.transform.TransformerFactory=com.foobar.AcmeTransformer</code>
</pre> 
   <p class="Body">You can obtain the location of the JRE with the following code:</p> 
   <pre><code class="Code">String javaHomeDir = System.getProperty("java.home");</code>
</pre> 
   <blockquote> 
    <p class="NoteTip"><b>TIP:</b> Some popular development tools change the value of <em class="Filename">java.home</em> when they are installed, which could prevent JAXP from locating <em class="Filename">jaxp.properties</em>. JBuilder, for instance, installs its own version of Java 2 that it uses by default.</p>
   </blockquote> 
   <p class="Body">The advantage of creating <em class="Filename">jaxp.properties</em> in this directory is that you can use your preferred processor for all of your applications that use JAXP without having to specify the system property on the command line. You can still override this file with the <kbd class="UserInput">-D</kbd> command-line syntax, however. </p>
   <p class="Body">If <em class="Filename">jaxp.properties</em> is not found, JAXP uses the JAR file <em class="Emphasis">service provider</em> mechanism to locate an appropriate subclass of <code class="Literal">TransformerFactory</code>. The service provider mechanism is outlined in the JAR file specification from Sun and simply means that you must create a file in the <em class="Filename">META-INF/services</em> directory of a JAR file. In JAXP, this file is called <em class="Filename">javax.xml.transform.TransformerFactory</em>. It contains a single line that specifies the implementation of <code class="Literal">TransformerFactory</code>: <code class="Literal">com.foobar.AcmeTransformer</code> in our fictitious example. If you look inside of <em class="Filename">xalan.jar</em> in JAXP 1.1, you will find this file. In order to utilize a different parser that follows the JAXP 1.1 convention, simply make sure its JAR file is located first on your CLASSPATH. </p>
   <p class="Body">Finally, if JAXP cannot find an implementation class from any of the three locations, it uses its default implementation of <code class="Literal">TransformerFactory</code>. To summarize, here are the steps that JAXP performs when attempting to locate a factory: </p>
   <ol> 
    <li class="ListNumber">Use the value of the <code class="Literal">javax.xml.transform.TransformerFactory</code> system property if it exists.</li> 
    <p> </p>
    <li class="ListNumber">If <em class="Filename">JRE/lib/jaxp.properties</em> exists, then look for a <code class="Literal">javax.xml.transform.TransformerFactory=ImplementationClass</code> entry in that file.</li> 
    <p> </p>
    <li class="ListNumber">Use a JAR file service provider to look for a file called <em class="Filename">META-INF/services/javax.xml.transform.TransformerFactory</em> in any JAR file on the CLASSPATH.</li> 
    <p> </p>
    <li class="ListNumber">Use the default <code class="Literal">TransformerFactory</code> instance.</li> 
    <p> </p>
   </ol> 
   <p class="Body">The JAXP 1.1 plugability layers for SAX and DOM follow the exact same process as the XSLT layer, only they use the <code class="Literal">javax.xml.parsers.SAXParserFactory</code> and <code class="Literal">javax.xml.parsers.DocumentBuilderFactory</code> system properties respectively. It should be noted that JAXP 1.0 uses a much simpler algorithm where it checks only for the existence of the system property. If that property is not set, the default implementation is used. </p>
   <h3 class="HeadB">The Transformer Class</h3> 
   <p class="Body">As shown in <a href="http://www.oreilly.com/catalog/javaxslt/chapter/ch05.html#71777" class="XRef">Example 5-3</a>, a <code class="Literal">Transformer</code> object can be obtained from the <code class="Literal">TransformerFactory</code> as follows: </p>
   <pre><code class="Code">javax.xml.transform.TransformerFactory transFact =</code>
<code class="Code">        javax.xml.transform.TransformerFactory.newInstance(  );</code>
<code class="Code">javax.xml.transform.Transformer trans =</code>
<code class="Code">        transFact.newTransformer(xsltSource);</code>
</pre> 
   <p class="Body">The <code class="Literal">Transformer</code> instance is wrapped around an XSLT stylesheet and allows you to perform as many transformations as you wish. The main caveat is thread safety, because many threads cannot use a single <code class="Literal">Transformer</code> instance concurrently. For each transformation, invoke the <code class="Literal">transform</code> method: </p>
   <pre><code class="Code">abstract void transform(Source xmlSource, Result outputTarget)</code>
<code class="Code">    throws TransformerException</code>
</pre> 
   <p class="Body">This method is abstract because the <code class="Literal">TransformerFactory</code> returns a subclass of <code class="Literal">Transformer</code> that does the actual work. The <code class="Literal">Source</code> interface defines where the XML data comes from and the <code class="Literal">Result</code> interface specifies where the transformation result is sent. The <code class="Literal">TransformerException</code> will be thrown if anything goes wrong during the transformation process and may contain the location of the error and a reference to the original exception. The ability to properly report the location of the error is entirely dependent upon the quality of the underlying XSLT transformer implementation's error reporting. We will talk about specific classes that implement the <code class="Literal">Source</code> and <code class="Literal">Result</code> interfaces later in this chapter. </p>
   <p class="Body">Aside from actually performing the transformation, the <code class="Literal">Transformer</code> implementation allows you to set output properties and stylesheet parameters. In XSLT, a stylesheet parameter is declared and used as follows: </p>
   <pre><code class="Code">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</code>
<code class="Code">&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;</code>
<code class="Code">  &lt;xsl:output method="html"/&gt;</code>
<code class="CodeEmphasis"><b> &lt;xsl:param name="image_dir" select="'images'"/&gt;</b></code>
<code class="Code">  </code>
<code class="Code">  &lt;xsl:template match="/"&gt;</code>
<code class="Code">    &lt;html&gt;</code>
<code class="Code">      &lt;body&gt;</code>
<code class="Code">        &lt;h1&gt;Stylesheet Parameter Example&lt;/h2&gt;</code>
<code class="CodeEmphasis"><b> &lt;img src="{$image_dir}/sample.gif"/&gt;</b></code>
<code class="Code">      &lt;/body&gt;</code>
<code class="Code">    &lt;/html&gt;</code>
<code class="Code">  &lt;/xsl:template&gt;</code>
<code class="Code">&lt;/xsl:stylesheet&gt;</code>
</pre> 
   <p class="Body">The <code class="Literal">&lt;xsl:param&gt;</code> element declares the parameter name and an optional <code class="Literal">select</code> attribute. This attribute specifies the default value if the stylesheet parameter is not provided. In this case, the string <code class="Literal">'images'</code> is the default value and is enclosed in apostrophes so it is treated as a string instead of an XPath expression. Later, the <code class="Literal">image_dir</code> variable is referred to with the attribute value template syntax: <code class="Literal">{$image_dir}</code>. </p>
   <p class="Body">Passing a variable for the location of your images is a common technique because your development environment might use a different directory name than your production web server. Another common use for a stylesheet parameter is to pass in data that a servlet generates dynamically, such as a unique ID for session tracking. </p>
   <p class="Body">From JAXP, pass this parameter via the <code class="Literal">Transformer</code> instance. The code is simple enough: </p>
   <pre><code class="Code">javax.xml.transform.Transformer trans =</code>
<code class="Code">        transFact.newTransformer(xsltSource);</code>
<code class="CodeEmphasis"><b>trans.setParameter("image_dir", "graphics");</b></code>
</pre> 
   <p class="Body">You can set as many parameters as you like, and these parameters will be saved and reused for every transformation you make with this <code class="Literal">Transformer</code> instance. If you wish to remove a parameter, you must call <code class="Literal">clearParameters( )</code>, which clears all parameters for this <code class="Literal">Transformer</code> instance. Parameters work similarly to a <code class="Literal">java.util.Map</code>; if you set the same parameter twice, the second value overwrites the first value. </p>
   <p class="Body">Another use for the <code class="Literal">Transformer</code> class is to get and set output properties through one of the following methods: </p>
   <pre><code class="Code">void setOutputProperties(java.util.Properties props)</code>
<code class="Code">void setOutputProperty(String name, String value)</code>
<code class="Code">java.util.Properties getOutputProperties(  )</code>
<code class="Code">String getOutputProperty(String name)</code>
</pre> 
   <p class="Body">As you can see, properties are specified as name/value pairs of Strings and can be set and retrieved individually or as a group. Unlike stylesheet parameters, you can un-set an individual property by simply passing in <code class="Literal">null</code> for the value. <code class="Literal"></code>The permitted property names are defined in the <code class="Literal">javax.xml.transform.OutputKeys</code> class and are explained in <a href="http://www.oreilly.com/catalog/javaxslt/chapter/ch05.html#98581" class="XRef">Table 5-1</a>. </p>
   <p> </p>
   <table border="1"> 
    <caption> 
     <b class="TableLabel"><a name="98581">Table 5-1:</a></b> 
     <b class="TableTitle">Constants defined in javax.xml.transform.OutputKeys </b> 
    </caption> 
    <tbody>
     <tr> 
      <th rowspan="1" colspan="1"> <p class="CellHeading">Constant </p></th> 
      <th rowspan="1" colspan="1"> <p class="CellHeading">Meaning </p></th> 
     </tr> 
     <tr> 
      <td rowspan="1" colspan="1"> <p class="CellCode">CDATA_SECTION_ELEMENTS </p></td> 
      <td rowspan="1" colspan="1"> <p class="CellBody">Specifies a whitespace-separated list of element names whose content should be output as CDATA sections. See the XSLT specification from the W3C for examples. </p></td> 
     </tr> 
     <tr> 
      <td rowspan="1" colspan="1"> <p class="CellCode">DOCTYPE_PUBLIC </p></td> 
      <td rowspan="1" colspan="1"> <p class="CellBody">Only used if <code class="Literal">DOCTYPE_SYSTEM</code> is also used, this instructs the processor to output a PUBLIC document type declaration. For example: <code class="Literal">&lt;!DOCTYPE rootElem PUBLIC</code> <code class="Literal">"public id" "system id"&gt;</code>. </p></td> 
     </tr> 
     <tr> 
      <td rowspan="1" colspan="1"> <p class="CellCode">DOCTYPE_SYSTEM </p></td> 
      <td rowspan="1" colspan="1"> <p class="CellBody">Instructs the processor to output a document-type declaration. For example: <code class="Literal">&lt;!DOCTYPE rootElem SYSTEM</code> <code class="Literal">"system id"&gt;</code>. </p></td> 
     </tr> 
     <tr> 
      <td rowspan="1" colspan="1"> <p class="CellCode">ENCODING </p></td> 
      <td rowspan="1" colspan="1"> <p class="CellBody">Specifies the character encoding of the result tree, such as UTF-8 or UTF-16. </p></td> 
     </tr> 
     <tr> 
      <td rowspan="1" colspan="1"> <p class="CellCode">INDENT </p></td> 
      <td rowspan="1" colspan="1"> <p class="CellBody">Specifies whether or not whitespace may be added to the result tree, making the output more readable. Acceptable values are <code class="Literal">yes</code> and <code class="Literal">no</code>. Although indentation makes the output more readable, it does make the file size larger, thus harming performance. </p></td> 
     </tr> 
     <tr> 
      <td rowspan="1" colspan="1"> <p class="CellCode">MEDIA_TYPE </p></td> 
      <td rowspan="1" colspan="1"> <p class="CellBody">The MIME type of the result tree. </p></td> 
     </tr> 
     <tr> 
      <td rowspan="1" colspan="1"> <p class="CellCode">METHOD </p></td> 
      <td rowspan="1" colspan="1"> <p class="CellBody">The output method, either <code class="Literal">xml</code>, <code class="Literal">html</code>, or <code class="Literal">text</code>. Although other values are possible, such as <code class="Literal">xhtml</code>, these are implementation-defined and may be rejected by your processor. </p></td> 
     </tr> 
     <tr> 
      <td rowspan="1" colspan="1"> <p class="CellCode">OMIT_XML_DECLARATION </p></td> 
      <td rowspan="1" colspan="1"> <p class="CellBody">Acceptable values are <code class="Literal">yes</code> and <code class="Literal">no</code>, specifying whether or not to include the XML declaration on the first line of the result tree. </p></td> 
     </tr> 
     <tr> 
      <td rowspan="1" colspan="1"> <p class="CellCode">STANDALONE </p></td> 
      <td rowspan="1" colspan="1"> <p class="CellBody">Acceptable values are <code class="Literal">yes</code> and <code class="Literal">no</code>, specifying whether or not the XML declaration indicates that the document is standalone. For example: <code class="Literal">&lt;?xml version="1.0"</code> <code class="Literal">encoding="UTF-8" standalone="yes"?&gt;</code>. </p></td> 
     </tr> 
     <tr> 
      <td rowspan="1" colspan="1"> <p class="CellCode">VERSION </p></td> 
      <td rowspan="1" colspan="1"> <p class="CellBody">Specifies the version of the output method, typically <code class="Literal">1.0</code> for XML output. This shows up in the XML declaration as follows: <code class="Literal">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</code>. </p></td> 
     </tr> 
    </tbody>
   </table> 
   <p></p>
   <p class="Body">It is no coincidence that these output properties are the same as the properties you can set on the <code class="Literal">&lt;xsl:output&gt;</code> element in your stylesheets. For example: </p>
   <pre><code class="Code">&lt;xsl:output method="xml" indent="yes" encoding="UTF-8"/&gt;</code>
</pre> 
   <p class="Body">Using JAXP, you can either specify additional output properties or override those set in the stylesheet. To change the encoding, write this code: </p>
   <pre><code class="Code">// this will take precedence over any encoding specified in the stylesheet</code>
<code class="Code">trans.setOutputProperty(OutputKeys.ENCODING, "UTF-16");</code>
</pre> 
   <p class="Body">Keep in mind that this will, in addition to adding <code class="Literal">encoding="UTF-16"</code> to the XML declaration, actually cause the processor to use that encoding in the result tree. For a value of <code class="Literal">UTF-16</code>, this means that 16-bit Unicode characters will be generated, so you may have trouble viewing the result tree in many ASCII-only text editors. </p>
   <h3 class="HeadB">JAXP XSLT Design</h3> 
   <p class="Body">Now that we have seen some example code and have begun our exploration of the <code class="Literal">Transformer</code> class, let's step back and look at the overall design of the XSLT plugability layer. JAXP support for XSLT is broken down into the packages listed in <a href="http://www.oreilly.com/catalog/javaxslt/chapter/ch05.html#21104" class="XRef">Table 5-2</a>. </p>
   <p> </p>
   <table border="1"> 
    <caption> 
     <b class="TableLabel"><a name="21104">Table 5-2:</a></b> 
     <b class="TableTitle">JAXP transformation packages </b> 
    </caption> 
    <tbody>
     <tr> 
      <th rowspan="1" colspan="1"> <p class="CellHeading">Package </p></th> 
      <th rowspan="1" colspan="1"> <p class="CellHeading">Description </p></th> 
     </tr> 
     <tr> 
      <td rowspan="1" colspan="1"> <p class="CellCode">javax.xml.transform </p></td> 
      <td rowspan="1" colspan="1"> <p class="CellBody">Defines a general-purpose API for XML transformations without any dependencies on SAX or DOM. The <code class="Literal">Transformer</code> class is obtained from the <code class="Literal">TransformerFactory</code> class. The <code class="Literal">Transformer</code> transforms from a <code class="Literal">Source</code> to a <code class="Literal">Result</code>. </p></td> 
     </tr> 
     <tr> 
      <td rowspan="1" colspan="1"> <p class="CellCode">javax.xml.transform.dom </p></td> 
      <td rowspan="1" colspan="1"> <p class="CellBody">Defines how transformations can be performed using DOM. Provides implementations of <code class="Literal">Source</code> and <code class="Literal">Result</code>: <code class="Literal">DOMSource</code> and <code class="Literal">DOMResult</code>. </p></td> 
     </tr> 
     <tr> 
      <td rowspan="1" colspan="1"> <p class="CellCode">javax.xml.transform.sax </p></td> 
      <td rowspan="1" colspan="1"> <p class="CellBody">Supports SAX2 transformations. Defines SAX versions of <code class="Literal">Source</code> and <code class="Literal">Result</code>: <code class="Literal">SAXSource</code> and <code class="Literal">SAXResult</code>. Also defines a subclass of <code class="Literal">TransformerFactory</code> that allows SAX2 events to be fed into an XSLT processor. </p></td> 
     </tr> 
     <tr> 
      <td rowspan="1" colspan="1"> <p class="CellCode">javax.xml.transform.stream </p></td> 
      <td rowspan="1" colspan="1"> <p class="CellBody">Defines I/O stream implementations of <code class="Literal">Source</code> and <code class="Literal">Result</code>: <code class="Literal">StreamSource</code> and <code class="Literal">StreamResult</code>. </p></td> 
     </tr> 
    </tbody>
   </table> 
   <p></p>
   <p class="Body">The heart of JAXP XSLT support lies in the <code class="Literal">javax.xml.transform</code> package, which lays out the mechanics and overall process for any transformation that is performed. This package mostly consists of interfaces and abstract classes, except for <code class="Literal">OutputKeys</code> and a few exception and error classes. <a href="http://www.oreilly.com/catalog/javaxslt/chapter/ch05.html#10714" class="XRef">Figure 5-2</a> presents a UML class diagram that shows all of the pieces in this important package. </p>
   <p> </p>
   <table> 
    <caption> 
     <b class="FigureLabel"><a name="10714"></a>Figure 5-2.</b> 
     <b class="FigureTitle">javax.xml.transform class diagram</b> 
    </caption> 
    <tbody>
     <tr> 
      <td rowspan="1" colspan="1"> <p class="FigureHolder"><img src="Ch05_files/jxt_0502.gif" align="bottom"> ? </p></td> 
     </tr> 
    </tbody>
   </table> 
   <p></p>
   <p class="Body">As you can see, this is a small package, indicative of the fact that JAXP is merely a wrapper around the tools that actually perform transformations. The entry point is <code class="Literal">TransformerFactory</code>, which creates instances of <code class="Literal">Transformer</code>, as we have already seen, as well as instances of the <code class="Literal">Templates</code> abstract class. A <code class="Literal">Templates</code> object represents a compiled stylesheet and will be covered in detail later in this chapter.<a href="#footnote-3" title="Footnote" class="footnote">[3]</a> The advantage of compilation is performance: the same <code class="Literal">Templates</code> object can be used over and over by many threads without reparsing the XSLT file. </p>
   <p class="Body">The <code class="Literal">URIResolver</code> is responsible for resolving URIs found within stylesheets and is generally something you will not need to deal with directly. It is used when a stylesheet imports or includes another document, and the processor needs to figure out where to look for that document. For example: </p>
   <pre><code class="Code">&lt;xsl:import href="commonFooter.xslt"/&gt;</code>
</pre> 
   <p class="Body"><code class="Literal">ErrorListener</code>, as you may guess, is an interface that allows your code to register as a listener for error conditions. This interface defines the following three methods: </p>
   <pre><code class="Code">void error(TransformerException ex)</code>
<code class="Code">void fatalError(TransformerException ex)</code>
<code class="Code">void warning(TransformerException ex)</code>
</pre> 
   <p class="Body">The <code class="Literal">TransformerException</code> has the ability to wrap around another <code class="Literal">Exception</code> or <code class="Literal">Throwable</code> object and may return an instance of the <code class="Literal">SourceLocator</code> class. If the underlying XSLT implementation does not provide a <code class="Literal">SourceLocator</code>, <code class="Literal">null</code> is returned. The <code class="Literal">SourceLocator</code> interface defines methods to locate where a <code class="Literal">TransformerException</code> originated. In the case of <code class="Literal">error()</code> and <code class="Literal">warning()</code>, the XSLT processor is required to continue processing the document until the end. For <code class="Literal">fatalError()</code>, on the other hand, the XSLT processor is not required to continue. If you do not register an <code class="Literal">ErrorListener</code> object, then all errors, fatal errors, and warnings are normally written to <code class="Literal">System.err</code>. <code class="Literal">TransformerFactoryConfigurationError</code> and <code class="Literal">TransformerConfigurationException</code> round out the error-handling APIs for JAXP, indicating problems configuring the underlying XSLT processor implementation. The <code class="Literal">TransformerFactoryConfigurationError</code> class is generally used when the implementation class cannot be found on the CLASSPATH or cannot be instantiated at all. <code class="Literal">TransformerConfigurationException</code> simply indicates a "serious configuration error" according to its documentation. </p>
   <h2 class="HeadA">Input and Output</h2> 
   <p class="Body">XSLT processors, like other XML tools, can read their input data from many different sources. In the most basic scenario, you will load a static stylesheet and XML document using the <code class="Literal">java.io.File</code> <code class="Literal"></code>class. More commonly, the XSLT stylesheet will come from a file, but the XML data will be generated dynamically as the result of a database query. In this case, it does not make sense to write the database query results to an XML file and then parse it into the XSLT processor. Instead, it is desirable to pipe the XML data directly into the processor using SAX or DOM. In fact, we will even see how to read nonXML data and transform it using XSLT. </p>
   <h3 class="HeadB">System Identifiers, Files, and URLs</h3> 
   <p class="Body">The simple examples presented earlier in this chapter introduced the concept of a system identifier. As mentioned before, system identifiers are nothing more than URIs and are used frequently by XML tools. For example, <code class="Literal">javax.xml.transform.Source</code>, <code class="Literal"></code>one of the key interfaces in JAXP, has the following API: </p>
   <pre><code class="Code">public interface Source {</code>
<code class="Code">    String getSystemId(  );</code>
<code class="Code">    void setSystemId(String systemId);</code>
<code class="Code">}</code>
</pre> 
   <p class="Body">The second method, <code class="Literal">setSystemId( )</code>, is crucial. By providing a URI to the <code class="Literal">Source</code>, the XSLT processor can resolve URIs encountered in XSLT stylesheets. This allows XSLT code like this to work: </p>
   <pre><code class="Code">&lt;xsl:import href="commonFooter.xslt"/&gt;</code>
</pre> 
   <p class="Body">When it comes to XSLT programming, you will use methods in <code class="Literal">java.io.File</code> and <code class="Literal">java.net.URL</code> to convert platform-specific file names into system IDs. These can then be used as parameters to any methods that expect a system ID as a parameter. For example, you would write the following code to convert a platform-specific filename into a system ID: </p>
   <pre><code class="Code">public static void main(String[] args) {</code>
<code class="Code">    // assume that the first command-line arg contains a file name</code>
<code class="Code">    // - on Windows, something like "C:\home\index.xml"</code>
<code class="Code">    // - on Unix, something like "/usr/home/index.xml"</code>
<code class="Code">    String fileName = args[0];</code>
<code class="Code">    File fileObject = new File(fileName);</code>
<code class="Code">    URL fileURL = fileObject.toURL(  );</code>
<code class="Code">    String systemID = fileURL.toExternalForm(  );</code>
</pre> 
   <p class="Body">This code was written on several lines for clarity; it can be consolidated as follows: </p>
   <pre><code class="Code">String systemID = new File(fileName).toURL().toExternalForm(  );</code>
</pre> 
   <p class="Body">Converting from a system identifier back to a filename or a <code class="Literal">File</code> object can be accomplished with this code: </p>
   <pre><code class="Code">URL url = new URL(systemID);</code>
<code class="Code">String fileName = url.getFile(  );</code>
<code class="Code">File fileObject = new File(fileName);</code>
</pre> 
   <p class="Body">And once again, this code can be condensed into a single line as follows: </p>
   <pre><code class="Code">File fileObject = new File((new URL(systemID)).getFile(  ));</code>
</pre> 
   <h3 class="HeadB">JAXP I/O Design</h3> 
   <p class="Body">The <code class="Literal">Source</code> and <code class="Literal">Result</code> interfaces in <code class="Literal">javax.xml.transform</code> provide the basis for all transformation input and output in JAXP 1.1. Regardless of whether a stylesheet is obtained via a URI, filename, or <code class="Literal">InputStream</code>, its data is fed into JAXP via an implementation of the <code class="Literal">Source</code> interface. The output is then sent to an implementation of the <code class="Literal">Result</code> interface. The implementations provided by JAXP are shown in <a href="http://www.oreilly.com/catalog/javaxslt/chapter/ch05.html#44418" class="XRef">Figure 5-3</a>. </p>
   <p> </p>
   <table> 
    <caption> 
     <b class="FigureLabel"><a name="44418"></a>Figure 5-3.</b> 
     <b class="FigureTitle">Source and Result interfaces</b> 
    </caption> 
    <tbody>
     <tr> 
      <td rowspan="1" colspan="1"> <p class="FigureHolder"><img src="Ch05_files/jxt_0503.gif" align="bottom"> ? </p></td> 
     </tr> 
    </tbody>
   </table> 
   <p></p>
   <p class="Body">As you can see, JAXP is not particular about where it gets its data or sends its results. Remember that two instances of <code class="Literal">Source</code> are always specified: one for the XML data and another for the XSLT stylesheet. </p>
   <h3 class="HeadB">JAXP Stream I/O</h3> 
   <p class="Body">As shown in <a href="http://www.oreilly.com/catalog/javaxslt/chapter/ch05.html#44418" class="XRef">Figure 5-3</a>, <code class="Literal">StreamSource</code> is one of the implementations of the <code class="Literal">Source</code> interface. In addition to the system identifiers that <code class="Literal">Source</code> provides, <code class="Literal">StreamSource</code> allows input to be obtained from a <code class="Literal">File</code>, an <code class="Literal">InputStream</code>, or a <code class="Literal">Reader</code>. The <code class="Literal">SimpleJaxp</code> class in <a href="http://www.oreilly.com/catalog/javaxslt/chapter/ch05.html#71777" class="XRef">Example 5-3</a> showed how to use <code class="Literal">StreamSource</code> to read from a <code class="Literal">File</code> object. There are also four constructors that allow you to construct a <code class="Literal">StreamSource</code> from either an <code class="Literal">InputStream</code> or <code class="Literal">Reader</code>. The complete list of constructors is shown here: </p>
   <pre><code class="Code">public StreamSource(  )</code>
<code class="Code">public StreamSource(File f)</code>
<code class="Code">public StreamSource(String systemId)</code>
<code class="Code">public StreamSource(InputStream byteStream)</code>
<code class="Code">public StreamSource(InputStream byteStream, String systemId)</code>
<code class="Code">public StreamSource(Reader characterStream)</code>
<code class="Code">public StreamSource(Reader characterStream, String systemId)</code>
</pre> 
   <p class="Body">For the constructors that take <code class="Literal">InputStream</code> and <code class="Literal">Reader</code> as arguments, the first argument provides either the XML data or the XSLT stylesheet. The second argument, if present, is used to resolve relative URI references in the document. As mentioned before, your XSLT stylesheet may include the following code: </p>
   <pre><code class="Code">&lt;xsl:import href="commonFooter.xslt"/&gt;</code>
</pre> 
   <p class="Body">By providing a system identifier as a parameter to the <code class="Literal">StreamSource</code>, you are telling the XSLT processor where to look for <em class="Filename">commonFooter.xslt</em>. Without this parameter, you may encounter an error when the processor cannot resolve this URI. The simple fix is to call the <code class="Literal">setSystemId( )</code> method as follows: </p>
   <pre><code class="Code">// construct a Source that reads from an InputStream</code>
<code class="Code">Source mySrc = new StreamSource(anInputStream);</code>
<code class="Code">// specify a system ID (a String) so the Source can resolve relative URLs</code>
<code class="Code">// that are encountered in XSLT stylesheets</code>
<code class="Code">mySrc.setSystemId(aSystemId);</code>
</pre> 
   <p class="Body">The documentation for <code class="Literal">StreamSource</code> also advises that <code class="Literal">InputStream</code> is preferred to <code class="Literal">Reader</code> because this allows the processor to properly handle the character encoding as specified in the XML declaration. </p>
   <p class="Body"><code class="Literal">StreamResult</code> is similar in functionality to <code class="Literal">StreamSource</code>, although it is not necessary to resolve relative URIs. The available constructors are as follows: </p>
   <pre><code class="Code">public StreamResult(  )</code>
<code class="Code">public StreamResult(File f)</code>
<code class="Code">public StreamResult(String systemId)</code>
<code class="Code">public StreamResult(OutputStream byteStream)</code>
<code class="Code">public StreamResult(Writer characterStream)</code>
</pre> 
   <p class="Body">Let's look at some of the other options for <code class="Literal">StreamSource</code> and <code class="Literal">StreamResult</code>. <a href="http://www.oreilly.com/catalog/javaxslt/chapter/ch05.html#86289" class="XRef">Example 5-4</a> is a modification of the <code class="Literal">SimpleJaxp</code> program that was presented earlier. It downloads the XML specification from the W3C web site and stores it in a temporary file on your local disk. To download the file, construct a <code class="Literal">StreamSource</code> with a system identifier as a parameter. The stylesheet is a simple one that merely performs an identity transformation, copying the unmodified XML data to the result tree. The result is then sent to a <code class="Literal">StreamResult</code> using its <code class="Literal">File</code> constructor. </p>
   <p> <b class="ExampleLabel"><a name="86289">Example 5-4:</a></b> <b class="ExampleTitle">Streams.java </b> </p>
   <pre><code class="Code">package chap5;</code>
<code class="Code">?</code>
<code class="Code">import java.io.*;</code>
<code class="Code">import javax.xml.transform.*;</code>
<code class="Code">import javax.xml.transform.stream.*;</code>
<code class="Code">?</code>
<code class="Code">/**</code>
<code class="Code"> * A simple demo of JAXP 1.1 StreamSource and StreamResult. This </code>
<code class="Code"> * program downloads the XML specification from the W3C and prints</code>
<code class="Code"> * it to a temporary file.</code>
<code class="Code"> */</code>
<code class="Code">public class Streams {</code>
<code class="Code">?</code>
<code class="Code">    // an identity copy stylesheet</code>
<code class="CodeEmphasis"><b> private static final String IDENTITY_XSLT =</b></code>
<code class="CodeEmphasis"><b> "&lt;xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform'"</b></code>
<code class="CodeEmphasis"><b> + " version='1.0'&gt;"</b></code>
<code class="CodeEmphasis"><b> + "&lt;xsl:template match='/'&gt;&lt;xsl:copy-of select='.'/&gt;"</b></code>
<code class="CodeEmphasis"><b> + "&lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt;";</b></code>
<code class="Code">?</code>
<code class="Code">    // the XML spec in XML format</code>
<code class="Code">    // (using an HTTP URL rather than a file URL)</code>
<code class="CodeEmphasis"><b> private static String xmlSystemId =</b></code>
<code class="CodeEmphasis"><b> "http://www.w3.org/TR/2000/REC-xml-20001006.xml";</b></code>
<code class="Code">?</code>
<code class="Code">    public static void main(String[] args) throws IOException,</code>
<code class="Code">            TransformerException {</code>
<code class="Code">?</code>
<code class="Code">        // show how to read from a system identifier and a Reader</code>
<code class="CodeEmphasis"><b> Source xmlSource = new StreamSource(xmlSystemId);</b></code>
<code class="CodeEmphasis"><b> Source xsltSource = new StreamSource(</b></code>
<code class="CodeEmphasis"><b> new StringReader(IDENTITY_XSLT));</b></code>
<code class="Code">?</code>
<code class="Code">        // send the result to a file</code>
<code class="Code">        File resultFile = File.createTempFile("Streams", ".xml");</code>
<code class="CodeEmphasis"><b> Result result = new StreamResult(resultFile);</b></code>
<code class="Code">?</code>
<code class="Code">        System.out.println("Results will go to: "</code>
<code class="Code">                + resultFile.getAbsolutePath(  ));</code>
<code class="Code">?</code>
<code class="Code">        // get the factory</code>
<code class="Code">        TransformerFactory transFact = TransformerFactory.newInstance(  );</code>
<code class="Code">?</code>
<code class="Code">        // get a transformer for this particular stylesheet</code>
<code class="CodeEmphasis"><b> Transformer trans = transFact.newTransformer(xsltSource);</b></code>
<code class="Code">?</code>
<code class="Code">        // do the transformation</code>
<code class="CodeEmphasis"><b> trans.transform(xmlSource, result);</b></code>
<code class="Code">    }</code>
<code class="Code">}</code>
</pre> 
   <p class="Body">The "identity copy" stylesheet simply matches <code class="Literal">"/"</code>, which is the document itself. It then uses <code class="Literal">&lt;xsl:copy-of select='.'/&gt;</code> to select the document and copy it to the result tree. In this case, we coded our own stylesheet. You can also omit the XSLT stylesheet altogether as follows: </p>
   <pre><code class="Code">// construct a Transformer without any XSLT stylesheet</code>
<code class="Code">Transformer trans = transFact.newTransformer(  );</code>
</pre> 
   <p class="Body">In this case, the processor will provide its own stylesheet and do the same thing that our example does. This is useful when you need to use JAXP to convert a DOM tree to XML text for debugging purposes because the default <code class="Literal">Transformer</code> will simply copy the XML data without any transformation. </p>
   <h3 class="HeadB">JAXP DOM I/O</h3> 
   <p class="Body">In many cases, the fastest form of transformation available is to feed an instance of <code class="Literal">org.w3c.dom.Document</code> <code class="Literal"></code>directly into JAXP. Although the transformation is fast, it does take time to generate the DOM; DOM is also memory intensive, and may not be the best choice for large documents. In most cases, the DOM data will be generated dynamically as the result of a database query or some other operation (see Chapter 1). Once the DOM is generated, simply wrap the <code class="Literal">Document</code> object in a <code class="Literal">DOMSource</code> as follows: </p>
   <pre><code class="Code">org.w3c.dom.Document domDoc = createDomDocument(  );</code>
<code class="CodeEmphasis"><b>Source xmlSource = new javax.xml.transform.dom.DOMSource(domDoc);</b></code>
</pre> 
   <p class="Body">The remainder of the transformation looks identical to the file-based transformation shown in <a href="http://www.oreilly.com/catalog/javaxslt/chapter/ch05.html#86289" class="XRef">Example 5-4</a>. JAXP needs only the alternate input <code class="Literal">Source</code> object shown here to read from DOM. </p>
   <h3 class="HeadB">JAXP SAX I/O</h3> 
   <p class="Body">XSLT is designed to transform well-formed XML data into another format, typically HTML. But wouldn't it be nice if we could also use XSLT stylesheets to transform nonXML data into HTML? For example, most spreadsheets have the ability to export their data into Comma Separated Values (CSV) format, as shown here: </p>
   <pre><code class="Code">Burke,Eric,M</code>
<code class="Code">Burke,Jennifer,L</code>
<code class="Code">Burke,Aidan,G</code>
</pre> 
   <p class="Body">One approach is parsing the file into memory, using DOM to create an XML representation of the data, and then feeding that information into JAXP for transformation. This approach works but requires an intermediate programming step to convert the CSV file into a DOM tree. A better option is to write a custom SAX parser, feeding its output directly into JAXP. This avoids the overhead of constructing the DOM tree, offering better memory utilization and performance. </p>
   <h4 class="HeadC">The approach</h4> 
   <p class="Body">It turns out that writing a SAX parser is quite easy.<a href="#footnote-4" title="Footnote" class="footnote">[4]</a> All a SAX parser does is read an XML file top to bottom and fire event notifications as various elements are encountered. In our custom parser, we will read the CSV file top to bottom, firing SAX events as we read the file. A program listening to those SAX events will not realize that the data file is CSV rather than XML; it sees only the events. <a href="http://www.oreilly.com/catalog/javaxslt/chapter/ch05.html#22849" class="XRef">Figure 5-4</a> illustrates the conceptual model. </p>
   <p> </p>
   <table> 
    <caption> 
     <b class="FigureLabel"><a name="22849"></a>Figure 5-4.</b> 
     <b class="FigureTitle">Custom SAX parser</b> 
    </caption> 
    <tbody>
     <tr> 
      <td rowspan="1" colspan="1"> <p class="FigureHolder"><img src="Ch05_files/jxt_0504.gif" align="bottom"> ? </p></td> 
     </tr> 
    </tbody>
   </table> 
   <p></p>
   <p class="Body">In this model, the XSLT processor interprets the SAX events as XML data and uses a normal stylesheet to perform the transformation. The interesting aspect of this model is that we can easily write custom SAX parsers for other file formats, making XSLT a useful transformation language for just about any legacy application data. </p>
   <p class="Body">In SAX, <code class="Literal">org.xml.sax.XMLReader</code> is a standard interface that parsers must implement. It works in conjunction with <code class="Literal">org.xml.sax.ContentHandler</code>, which is the interface that listens to SAX events. For this model to work, your XSLT processor must implement the <code class="Literal">ContentHandler</code> interface so it can listen to the SAX events that the <code class="Literal">XMLReader</code> generates. In the case of JAXP, <code class="Literal">javax.xml.transform.sax.TransformerHandler</code> is used for this purpose. </p>
   <p class="Body">Obtaining an instance of <code class="Literal">TransformerHandler</code> requires a few extra programming steps. First, create a <code class="Literal">TransformerFactory</code> as usual: </p>
   <pre><code class="Code">TransformerFactory transFact = TransformerFactory.newInstance(  );</code>
</pre> 
   <p class="Body">As before, the <code class="Literal">TransformerFactory</code> is the JAXP abstraction to some underlying XSLT processor. This underlying processor may not support SAX features, so you have to query it to determine if you can proceed: </p>
   <pre><code class="Code">if (transFact.getFeature(SAXTransformerFactory.FEATURE)) {</code>
</pre> 
   <p class="Body">If this returns <code class="Literal">false</code>, you are out of luck. Otherwise, you can safely downcast to a <code class="Literal">SAXTransformerFactory</code> and construct the <code class="Literal">TransformerHandler</code> instance: </p>
   <pre><code class="Code">SAXTransformerFactory saxTransFact =</code>
<code class="Code">            (SAXTransformerFactory) transFact;</code>
<code class="Code">  // create a ContentHandler, don't specify a stylesheet.  Without</code>
<code class="Code">  // a stylesheet, raw XML is sent to the output.</code>
<code class="Code">  TransformerHandler transHand = saxTransFact.newTransformerHandler(  );</code>
</pre> 
   <p class="Body">In the code shown here, a stylesheet was not specified. JAXP defaults to the identity transformation stylesheet, which means that the SAX events will be "transformed" into raw XML output. To specify a stylesheet that performs an actual transformation, pass a <code class="Literal">Source</code> to the method as follows: </p>
   <pre><code class="Code">Source xsltSource = new StreamSource(myXsltSystemId);</code>
<code class="Code">TransformerHandler transHand = saxTransFact.newTransformerHandler(</code>
<code class="Code">        xsltSource);</code>
</pre> 
   <h4 class="HeadC">Detailed CSV to SAX design</h4> 
   <p class="Body">Before delving into the complete example program, let's step back and look at a more detailed design diagram. The conceptual model is straightforward, but quite a few classes and interfaces come into play. <a href="http://www.oreilly.com/catalog/javaxslt/chapter/ch05.html#58981" class="XRef">Figure 5-5</a> shows the pieces necessary for SAX-based transformations. </p>
   <p> </p>
   <table> 
    <caption> 
     <b class="FigureLabel"><a name="58981"></a>Figure 5-5.</b> 
     <b class="FigureTitle">SAX and XSLT transformations</b> 
    </caption> 
    <tbody>
     <tr> 
      <td rowspan="1" colspan="1"> <p class="FigureHolder"><img src="Ch05_files/jxt_0505.gif" align="bottom"> ? </p></td> 
     </tr> 
    </tbody>
   </table> 
   <p></p>
   <p class="Body">This diagram certainly appears to be more complex than previous approaches, but is similar in many ways. In previous approaches, we used the <code class="Literal">TransformerFactory</code> to create instances of <code class="Literal">Transformer</code>; in the SAX approach, we start with a subclass of <code class="Literal">TransformerFactory</code>. Before any work can be done, you must verify that your particular implementation supports SAX-based transformations. The reference implementation of JAXP does support this, although other implementations are not required to do so. In the following code fragment, the <code class="Literal">getFeature</code> method of <code class="Literal">TransformerFactory</code> will return <code class="Literal">true</code> if you can safely downcast to a <code class="Literal">SAXTransformerFactory</code> instance: </p>
   <pre><code class="Code">TransformerFactory transFact = TransformerFactory.newInstance(  );</code>
<code class="Code">if (transFact.getFeature(SAXTransformerFactory.FEATURE)) {</code>
<code class="Code">    // downcast is allowed</code>
<code class="Code">    SAXTransformerFactory saxTransFact = (SAXTransformerFactory) transFact;</code>
</pre> 
   <p class="Body">If <code class="Literal">getFeature</code> returns <code class="Literal">false</code>, your only option is to look for an implementation that does support SAX-based transformations. Otherwise, you can proceed to create an instance of <code class="Literal">TransformerHandler</code>: </p>
   <pre><code class="Code">TransformerHandler transHand = saxTransFact.newTransformerHandler(myXsltSource);</code>
</pre> 
   <p class="Body">This object now represents your XSLT stylesheet. As <a href="http://www.oreilly.com/catalog/javaxslt/chapter/ch05.html#58981" class="XRef">Figure 5-5</a> shows, <code class="Literal">TransformerHandler</code> extends <code class="Literal">org.xml.sax.ContentHandler</code>, so it knows how to listen to events from a SAX parser. The series of SAX events will provide the "fake XML" data, so the only remaining piece of the puzzle is to set the <code class="Literal">Result</code> and tell the SAX parser to begin parsing. The <code class="Literal">TransformerHandler</code> also provides a reference to a <code class="Literal">Transformer</code>, which allows you to set output properties such as the character encoding, whether to indent the output or any other attributes of <code class="Literal">&lt;xsl:output&gt;</code>. </p>
   <h4 class="HeadC">Writing the custom parser</h4> 
   <p class="Body">Writing the actual SAX parser sounds harder than it really is. The process basically involves implementing the <code class="Literal">org.xml.sax.XMLReader</code> interface, which provides numerous methods you can safely ignore for most applications. For example, when parsing a CSV file, it is probably not necessary to deal with namespaces or validation. The code for <code class="Literal">AbstractXMLReader.java</code> is shown in <a href="http://www.oreilly.com/catalog/javaxslt/chapter/ch05.html#58471" class="XRef">Example 5-5</a>. This is an abstract class that provides basic implementations of every method in the <code class="Literal">XMLReader</code> interface except for the <code class="Literal">parse( )</code> method. This means that all you need to do to write a parser is create a subclass and override this single method. </p>
   <p> <b class="ExampleLabel"><a name="58471">Example 5-5:</a></b> <b class="ExampleTitle">AbstractXMLReader.java </b> </p>
   <pre><code class="Code">package com.oreilly.javaxslt.util;</code>
<code class="Code">?</code>
<code class="Code">import java.io.IOException;</code>
<code class="Code">import java.util.*;</code>
<code class="Code">import org.xml.sax.*;</code>
<code class="Code">?</code>
<code class="Code">/**</code>
<code class="Code"> * An abstract class that implements the SAX2 XMLReader interface. The</code>
<code class="Code"> * intent of this class is to make it easy for subclasses to act as</code>
<code class="Code"> * SAX2 XMLReader implementations. This makes it possible, for example, for</code>
<code class="Code"> * them to emit SAX2 events that can be fed into an XSLT processor for</code>
<code class="Code"> * transformation.</code>
<code class="Code"> */</code>
<code class="Code">public abstract class AbstractXMLReader implements org.xml.sax.XMLReader {</code>
<code class="Code">    private Map featureMap = new HashMap(  );</code>
<code class="Code">    private Map propertyMap = new HashMap(  );</code>
<code class="Code">    private EntityResolver entityResolver;</code>
<code class="Code">    private DTDHandler dtdHandler;</code>
<code class="Code">    private ContentHandler contentHandler;</code>
<code class="Code">    private ErrorHandler errorHandler;</code>
<code class="Code">?</code>
<code class="Code">    /**</code>
<code class="Code">     * The only abstract method in this class. Derived classes can parse</code>
<code class="Code">     * any source of data and emit SAX2 events to the ContentHandler.</code>
<code class="Code">     */</code>
<code class="Code">    public abstract void parse(InputSource input) throws IOException,</code>
<code class="Code">            SAXException;</code>
<code class="Code">?</code>
<code class="Code">    public boolean getFeature(String name)</code>
<code class="Code">            throws SAXNotRecognizedException, SAXNotSupportedException {</code>
<code class="Code">        Boolean featureValue = (Boolean) this.featureMap.get(name);</code>
<code class="Code">        return (featureValue == null) ? false</code>
<code class="Code">                : featureValue.booleanValue(  );</code>
<code class="Code">    }</code>
<code class="Code">?</code>
<code class="Code">    public void setFeature(String name, boolean value)</code>
<code class="Code">            throws SAXNotRecognizedException, SAXNotSupportedException {</code>
<code class="Code">        this.featureMap.put(name, new Boolean(value));</code>
<code class="Code">    }</code>
<code class="Code">?</code>
<code class="Code">    public Object getProperty(String name)</code>
<code class="Code">            throws SAXNotRecognizedException, SAXNotSupportedException {</code>
<code class="Code">        return this.propertyMap.get(name);</code>
<code class="Code">    }</code>
<code class="Code">?</code>
<code class="Code">    public void setProperty(String name, Object value)</code>
<code class="Code">            throws SAXNotRecognizedException, SAXNotSupportedException {</code>
<code class="Code">        this.propertyMap.put(name, value);</code>
<code class="Code">    }</code>
<code class="Code">?</code>
<code class="Code">    public void setEntityResolver(EntityResolver entityResolver) {</code>
<code class="Code">        this.entityResolver = entityResolver;</code>
<code class="Code">    }</code>
<code class="Code">?</code>
<code class="Code">    public EntityResolver getEntityResolver(  ) {</code>
<code class="Code">        return this.entityResolver;</code>
<code class="Code">    }</code>
<code class="Code">?</code>
<code class="Code">    public void setDTDHandler(DTDHandler dtdHandler) {</code>
<code class="Code">        this.dtdHandler = dtdHandler;</code>
<code class="Code">    }</code>
<code class="Code">?</code>
<code class="Code">    public DTDHandler getDTDHandler(  ) {</code>
<code class="Code">        return this.dtdHandler;</code>
<code class="Code">    }</code>
<code class="Code">?</code>
<code class="Code">    public void setContentHandler(ContentHandler contentHandler) {</code>
<code class="Code">        this.contentHandler = contentHandler;</code>
<code class="Code">    }</code>
<code class="Code">?</code>
<code class="Code">    public ContentHandler getContentHandler(  ) {</code>
<code class="Code">        return this.contentHandler;</code>
<code class="Code">    }</code>
<code class="Code">?</code>
<code class="Code">    public void setErrorHandler(ErrorHandler errorHandler) {</code>
<code class="Code">        this.errorHandler = errorHandler;</code>
<code class="Code">    }</code>
<code class="Code">?</code>
<code class="Code">    public ErrorHandler getErrorHandler(  ) {</code>
<code class="Code">        return this.errorHandler;</code>
<code class="Code">    }</code>
<code class="Code">?</code>
<code class="Code">    public void parse(String systemId) throws IOException, SAXException {</code>
<code class="Code">        parse(new InputSource(systemId));</code>
<code class="Code">    }</code>
<code class="Code">}</code>
</pre> 
   <p class="Body">Creating the subclass, <code class="Literal">CSVXMLReader</code>, involves overriding the <code class="Literal">parse( )</code> method and actually scanning through the CSV file, emitting SAX events as elements in the file are encountered. While the SAX portion is very easy, parsing the CSV file is a little more challenging. To make this class as flexible as possible, it was designed to parse through any CSV file that a spreadsheet such as Microsoft Excel can export. For simple data, your CSV file might look like this: </p>
   <pre><code class="Code">Burke,Eric,M</code>
<code class="Code">Burke,Jennifer,L</code>
<code class="Code">Burke,Aidan,G</code>
</pre> 
   <p class="Body">The XML representation of this file is shown in <a href="http://www.oreilly.com/catalog/javaxslt/chapter/ch05.html#87705" class="XRef">Example 5-6</a>. The only real drawback here is that CSV files are strictly positional, meaning that names are not assigned to each column of data. This means that the XML output merely contains a sequence of three <code class="Literal">&lt;value&gt;</code> elements for each line, so your stylesheet will have to select items based on position. </p>
   <p> <b class="ExampleLabel"><a name="87705">Example 5-6:</a></b> <b class="ExampleTitle">Example XML output from CSV parser </b> </p>
   <pre><code class="Code">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</code>
<code class="Code">&lt;csvFile&gt;</code>
<code class="Code">  &lt;line&gt;</code>
<code class="Code">    &lt;value&gt;Burke&lt;/value&gt;</code>
<code class="Code">    &lt;value&gt;Eric&lt;/value&gt;</code>
<code class="Code">    &lt;value&gt;M&lt;/value&gt;</code>
<code class="Code">  &lt;/line&gt;</code>
<code class="Code">  &lt;line&gt;</code>
<code class="Code">    &lt;value&gt;Burke&lt;/value&gt;</code>
<code class="Code">    &lt;value&gt;Jennifer&lt;/value&gt;</code>
<code class="Code">    &lt;value&gt;L&lt;/value&gt;</code>
<code class="Code">  &lt;/line&gt;</code>
<code class="Code">  &lt;line&gt;</code>
<code class="Code">    &lt;value&gt;Burke&lt;/value&gt;</code>
<code class="Code">    &lt;value&gt;Aidan&lt;/value&gt;</code>
<code class="Code">    &lt;value&gt;G&lt;/value&gt;</code>
<code class="Code">  &lt;/line&gt;</code>
<code class="Code">&lt;/csvFile&gt;</code>
</pre> 
   <p class="Body">One enhancement would be to design the CSV parser so it could accept a list of meaningful column names as parameters, and these could be used in the XML that is generated. Another option would be to write an XSLT stylesheet that transformed this initial output into another form of XML that used meaningful column names. To keep the code example relatively manageable, these features were omitted from this implementation. But there are some complexities to the CSV file format that have to be considered. For example, fields that contain commas must be surrounded with quotes: </p>
   <pre><code class="Code">"Consultant,Author,Teacher",Burke,Eric,M</code>
<code class="Code">Teacher,Burke,Jennifer,L</code>
<code class="Code">None,Burke,Aidan,G</code>
</pre> 
   <p class="Body">To further complicate matters, fields may also contain quotes ("). In this case, they are doubled up, much in the same way you use double backslash characters (\\) in Java to represent a single backslash. In the following example, the first column contains a single quote, so the entire field is quoted, and the single quote is doubled up: </p>
   <pre><code class="Code">"test""quote",Teacher,Burke,Jennifer,L</code>
</pre> 
   <p class="Body">This would be interpreted as: </p>
   <pre><code class="Code">test"quote,Teacher,Burke,Jennifer,L</code>
</pre> 
   <p class="Body">The code in <a href="http://www.oreilly.com/catalog/javaxslt/chapter/ch05.html#45542" class="XRef">Example 5-7</a> shows the complete implementation of the CSV parser. </p>
   <p> <b class="ExampleLabel"><a name="45542">Example 5-7:</a></b> <b class="ExampleTitle">CSVXMLReader.java </b> </p>
   <pre><code class="Code">package com.oreilly.javaxslt.util;</code>
<code class="Code">?</code>
<code class="Code">import java.io.*;</code>
<code class="Code">import java.net.URL;</code>
<code class="Code">?</code>
<code class="Code">import org.xml.sax.*;</code>
<code class="Code">import org.xml.sax.helpers.*;</code>
<code class="Code">?</code>
<code class="Code">/**</code>
<code class="Code"> * A utility class that parses a Comma Separated Values (CSV) file</code>
<code class="Code"> * and outputs its contents using SAX2 events. The format of CSV that</code>
<code class="Code"> * this class reads is identical to the export format for Microsoft</code>
<code class="Code"> * Excel. For simple values, the CSV file may look like this:</code>
<code class="Code"> * &lt;pre&gt;</code>
<code class="Code"> * a,b,c</code>
<code class="Code"> * d,e,f</code>
<code class="Code"> * &lt;/pre&gt;</code>
<code class="Code"> * Quotes are used as delimiters when the values contain commas:</code>
<code class="Code"> * &lt;pre&gt;</code>
<code class="Code"> * a,"b,c",d</code>
<code class="Code"> * e,"f,g","h,i"</code>
<code class="Code"> * &lt;/pre&gt;</code>
<code class="Code"> * And double quotes are used when the values contain quotes. This parser</code>
<code class="Code"> * is smart enough to trim spaces around commas, as well.</code>
<code class="Code"> *</code>
<code class="Code"> * @author Eric M. Burke</code>
<code class="Code"> */</code>
<code class="Code">public class CSVXMLReader extends AbstractXMLReader {</code>
<code class="Code">?</code>
<code class="Code">    // an empty attribute for use with SAX</code>
<code class="Code">    private static final Attributes EMPTY_ATTR = new AttributesImpl(  );</code>
<code class="Code">?</code>
<code class="Code">    /**</code>
<code class="Code">     * Parse a CSV file. SAX events are delivered to the ContentHandler</code>
<code class="Code">     * that was registered via &lt;code&gt;setContentHandler&lt;/code&gt;.</code>
<code class="Code">     *</code>
<code class="Code">     * @param input the comma separated values file to parse.</code>
<code class="Code">     */</code>
<code class="CodeEmphasis"><b> public void parse(InputSource input) throws IOException,</b></code>
<code class="CodeEmphasis"><b> SAXException {</b></code>
<code class="CodeEmphasis"><b> // if no handler is registered to receive events, don't bother</b></code>
<code class="CodeEmphasis"><b> // to parse the CSV file</b></code>
<code class="CodeEmphasis"><b> ContentHandler ch = getContentHandler( );</b></code>
<code class="CodeEmphasis"><b> if (ch == null) {</b></code>
<code class="CodeEmphasis"><b> return;</b></code>
<code class="CodeEmphasis"><b> }</b></code>
<code class="Code">?</code>
<code class="Code">        // convert the InputSource into a BufferedReader</code>
<code class="Code">        BufferedReader br = null;</code>
<code class="Code">        if (input.getCharacterStream(  ) != null) {</code>
<code class="Code">            br = new BufferedReader(input.getCharacterStream(  ));</code>
<code class="Code">        } else if (input.getByteStream(  ) != null) {</code>
<code class="Code">            br = new BufferedReader(new InputStreamReader(</code>
<code class="Code">                    input.getByteStream(  )));</code>
<code class="Code">        } else if (input.getSystemId(  ) != null) {</code>
<code class="Code">            java.net.URL url = new URL(input.getSystemId(  ));</code>
<code class="Code">            br = new BufferedReader(new InputStreamReader(url.openStream(  )));</code>
<code class="Code">        } else {</code>
<code class="CodeEmphasis"><b> throw new SAXException("Invalid InputSource object");</b></code>
<code class="Code">        }</code>
<code class="Code">?</code>
<code class="CodeEmphasis"><b> ch.startDocument( );</b></code>
<code class="Code">?</code>
<code class="Code">        // emit &lt;csvFile&gt;</code>
<code class="CodeEmphasis"><b> ch.startElement("","","csvFile",EMPTY_ATTR);</b></code>
<code class="Code">?</code>
<code class="Code">        // read each line of the file until EOF is reached</code>
<code class="Code">        String curLine = null;</code>
<code class="Code">        while ((curLine = br.readLine(  )) != null) {</code>
<code class="Code">            curLine = curLine.trim(  );</code>
<code class="Code">            if (curLine.length(  ) &gt; 0) {</code>
<code class="Code">                // create the &lt;line&gt; element</code>
<code class="CodeEmphasis"><b> ch.startElement("","","line",EMPTY_ATTR);</b></code>
<code class="Code">                // output data from this line</code>
<code class="Code">                parseLine(curLine, ch);</code>
<code class="Code">                // close the &lt;/line&gt; element</code>
<code class="CodeEmphasis"><b> ch.endElement("","","line");</b></code>
<code class="Code">            }</code>
<code class="Code">        }</code>
<code class="Code">?</code>
<code class="Code">        // emit &lt;/csvFile&gt;</code>
<code class="CodeEmphasis"><b> ch.endElement("","","csvFile");</b></code>
<code class="CodeEmphasis"><b> ch.endDocument( );</b></code>
<code class="Code">    }</code>
<code class="Code">?</code>
<code class="Code">    // Break an individual line into tokens. This is a recursive function</code>
<code class="Code">    // that extracts the first token, then recursively parses the</code>
<code class="Code">    // remainder of the line.</code>
<code class="Code">    private void parseLine(String curLine, ContentHandler ch)</code>
<code class="Code">        throws IOException, SAXException {</code>
<code class="Code">?</code>
<code class="Code">        String firstToken = null;</code>
<code class="Code">        String remainderOfLine = null;</code>
<code class="Code">        int commaIndex = locateFirstDelimiter(curLine);</code>
<code class="Code">        if (commaIndex &gt; -1) {</code>
<code class="Code">            firstToken = curLine.substring(0, commaIndex).trim(  );</code>
<code class="Code">            remainderOfLine = curLine.substring(commaIndex+1).trim(  );</code>
<code class="Code">        } else {</code>
<code class="Code">            // no commas, so the entire line is the token</code>
<code class="Code">            firstToken = curLine;</code>
<code class="Code">        }</code>
<code class="Code">?</code>
<code class="Code">        // remove redundant quotes</code>
<code class="Code">        firstToken = cleanupQuotes(firstToken);</code>
<code class="Code">?</code>
<code class="Code">        // emit the &lt;value&gt; element</code>
<code class="CodeEmphasis"><b> ch.startElement("","","value",EMPTY_ATTR);</b></code>
<code class="CodeEmphasis"><b> ch.characters(firstToken.toCharArray(), 0, firstToken.length( ));</b></code>
<code class="CodeEmphasis"><b> ch.endElement("","","value");</b></code>
<code class="Code">?</code>
<code class="Code">        // recursively process the remainder of the line</code>
<code class="Code">        if (remainderOfLine != null) {</code>
<code class="Code">            parseLine(remainderOfLine, ch);</code>
<code class="Code">        }</code>
<code class="Code">    }</code>
<code class="Code">?</code>
<code class="Code">    // locate the position of the comma, taking into account that</code>
<code class="Code">    // a quoted token may contain ignorable commas.</code>
<code class="Code">    private int locateFirstDelimiter(String curLine) {</code>
<code class="Code">        if (curLine.startsWith("\"")) {</code>
<code class="Code">            boolean inQuote = true;</code>
<code class="Code">            int numChars = curLine.length(  );</code>
<code class="Code">            for (int i=1; i&lt;numChars; i++) {</code>
<code class="Code">                char curChar = curLine.charAt(i);</code>
<code class="Code">                if (curChar == '"') {</code>
<code class="Code">                    inQuote = !inQuote;</code>
<code class="Code">                } else if (curChar == ',' &amp;&amp; !inQuote) {</code>
<code class="Code">                    return i;</code>
<code class="Code">                }</code>
<code class="Code">            }</code>
<code class="Code">            return -1;</code>
<code class="Code">        } else {</code>
<code class="Code">            return curLine.indexOf(',');</code>
<code class="Code">        }</code>
<code class="Code">    }</code>
<code class="Code">?</code>
<code class="Code">    // remove quotes around a token, as well as pairs of quotes</code>
<code class="Code">    // within a token.</code>
<code class="Code">    private String cleanupQuotes(String token) {</code>
<code class="Code">        StringBuffer buf = new StringBuffer(  );</code>
<code class="Code">        int length = token.length(  );</code>
<code class="Code">        int curIndex = 0;</code>
<code class="Code">?</code>
<code class="Code">        if (token.startsWith("\"") &amp;&amp; token.endsWith("\"")) {</code>
<code class="Code">            curIndex = 1;</code>
<code class="Code">            length--;</code>
<code class="Code">        }</code>
<code class="Code">?</code>
<code class="Code">        boolean oneQuoteFound = false;</code>
<code class="Code">        boolean twoQuotesFound = false;</code>
<code class="Code">?</code>
<code class="Code">        while (curIndex &lt; length) {</code>
<code class="Code">            char curChar = token.charAt(curIndex);</code>
<code class="Code">            if (curChar == '"') {</code>
<code class="Code">                twoQuotesFound = (oneQuoteFound) ? true : false;</code>
<code class="Code">                oneQuoteFound = true;</code>
<code class="Code">            } else {</code>
<code class="Code">                oneQuoteFound = false;</code>
<code class="Code">                twoQuotesFound = false;</code>
<code class="Code">            }</code>
<code class="Code">?</code>
<code class="Code">            if (twoQuotesFound) {</code>
<code class="Code">                twoQuotesFound = false;</code>
<code class="Code">                oneQuoteFound = false;</code>
<code class="Code">                curIndex++;</code>
<code class="Code">                continue;</code>
<code class="Code">            }</code>
<code class="Code">?</code>
<code class="Code">            buf.append(curChar);</code>
<code class="Code">            curIndex++;</code>
<code class="Code">        }</code>
<code class="Code">?</code>
<code class="Code">        return buf.toString(  );</code>
<code class="Code">    }</code>
<code class="Code">}</code>
</pre> 
   <p class="Body"><code class="Literal">CSVXMLReader</code> is a subclass of <code class="Literal">AbstractXMLReader</code>, so it must provide an implementation of the abstract <code class="Literal">parse</code> method: </p>
   <pre><code class="Code">public void parse(InputSource input) throws IOException,</code>
<code class="Code">            SAXException {</code>
<code class="Code">        // if no handler is registered to receive events, don't bother</code>
<code class="Code">        // to parse the CSV file</code>
<code class="Code">        ContentHandler ch = getContentHandler(  );</code>
<code class="Code">        if (ch == null) {</code>
<code class="Code">            return;</code>
<code class="Code">        }</code>
</pre> 
   <p class="Body">The first thing this method does is check for the existence of a SAX <code class="Literal">ContentHandler</code>. The base class, <code class="Literal">AbstractXMLReader</code>, provides access to this object, which is responsible for listening to the SAX events. In our example, an instance of JAXP's <code class="Literal">TransformerHandler</code> is used as the SAX <code class="Literal">ContentHandler</code> implementation. If this handler is not registered, our <code class="Literal">parse</code> method simply returns because nobody is registered to listen to the events. In a real SAX parser, the XML would be parsed anyway, which provides an opportunity to check for errors in the XML data. Choosing to return immediately was merely a performance optimization selected for this class. </p>
   <p class="Body">The SAX <code class="Literal">InputSource</code> parameter allows our custom parser to locate the CSV file. Since an <code class="Literal">InputSource</code> has many options for reading its data, parsers must check each potential source in the order shown here: </p>
   <pre><code class="Code">// convert the InputSource into a BufferedReader</code>
<code class="Code">BufferedReader br = null;</code>
<code class="Code">if (input.getCharacterStream(  ) != null) {</code>
<code class="Code">    br = new BufferedReader(input.getCharacterStream(  ));</code>
<code class="Code">} else if (input.getByteStream(  ) != null) {</code>
<code class="Code">    br = new BufferedReader(new InputStreamReader(</code>
<code class="Code">            input.getByteStream(  )));</code>
<code class="Code">} else if (input.getSystemId(  ) != null) {</code>
<code class="Code">    java.net.URL url = new URL(input.getSystemId(  ));</code>
<code class="Code">    br = new BufferedReader(new InputStreamReader(url.openStream(  )));</code>
<code class="Code">} else {</code>
<code class="Code">    throw new SAXException("Invalid InputSource object");</code>
<code class="Code">}</code>
</pre> 
   <p class="Body">Assuming that our <code class="Literal">InputSource</code> was valid, we can now begin parsing the CSV file and emitting SAX events. The first step is to notify the <code class="Literal">ContentHandler</code> that a new document has begun: </p>
   <pre><code class="Code">ch.startDocument(  );</code>
<code class="Code">?</code>
<code class="Code">// emit &lt;csvFile&gt;</code>
<code class="Code">ch.startElement("","","csvFile",EMPTY_ATTR);</code>
</pre> 
   <p class="Body">The XSLT processor interprets this to mean the following: </p>
   <pre><code class="Code">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</code>
<code class="Code">&lt;csvFile&gt;</code>
</pre> 
   <p class="Body">Our parser simply ignores many SAX 2 features, particularly XML namespaces. This is why many values passed as parameters to the various <code class="Literal">ContentHandler</code> methods simply contain empty strings. The <code class="Literal">EMPTY_ATTR</code> constant indicates that this XML element does not have any attributes. </p>
   <p class="Body">The CSV file itself is very straightforward, so we merely loop over every line in the file, emitting SAX events as we read each line. The <code class="Literal">parseLine</code> method is a private helper method that does the actual CSV parsing: </p>
   <pre><code class="Code">// read each line of the file until EOF is reached</code>
<code class="Code">String curLine = null;</code>
<code class="Code">while ((curLine = br.readLine(  )) != null) {</code>
<code class="Code">    curLine = curLine.trim(  );</code>
<code class="Code">    if (curLine.length(  ) &gt; 0) {</code>
<code class="Code">        // create the &lt;line&gt; element</code>
<code class="Code">        ch.startElement("","","line",EMPTY_ATTR);</code>
<code class="Code">        parseLine(curLine, ch);</code>
<code class="Code">        ch.endElement("","","line");</code>
<code class="Code">    }</code>
<code class="Code">}</code>
</pre> 
   <p class="Body">And finally, we must indicate that the parsing is complete: </p>
   <pre><code class="Code">// emit &lt;/csvFile&gt;</code>
<code class="Code">ch.endElement("","","csvFile");</code>
<code class="Code">ch.endDocument(  );</code>
</pre> 
   <p class="Body">The remaining methods in <code class="Literal">CSVXMLReader</code> are not discussed in detail here because they are really just responsible for breaking down each line in the CSV file and checking for commas, quotes, and other mundane parsing tasks. One thing worth noting is the code that emits text, such as the following: </p>
   <pre><code class="Code">&lt;value&gt;Some Text Here&lt;/value&gt;</code>
</pre> 
   <p class="Body">SAX parsers use the <code class="Literal">characters</code> method on <code class="Literal">ContentHandler</code> to represent text, which has this signature: </p>
   <pre><code class="Code">public void characters(char[] ch, int start, int length)</code>
</pre> 
   <p class="Body">Although this method could have been designed to take a <code class="Literal">String</code>, using an array allows SAX parsers to preallocate a large character array and then reuse that buffer repeatedly. This is why an implementation of <code class="Literal">ContentHandler</code> cannot simply assume that the entire <code class="Literal">ch</code> array contains meaningful data. Instead, it must read only the specified number of characters beginning at the <code class="Literal">start</code> position. </p>
   <p class="Body">Our parser uses a relatively straightforward approach, simply converting a <code class="Literal">String</code> to a character array and passing that as a parameter to the <code class="Literal">characters</code> method: </p>
   <pre><code class="Code">// emit the &lt;value&gt;text&lt;/value&gt; element</code>
<code class="Code">ch.startElement("","","value",EMPTY_ATTR);</code>
<code class="Code">ch.characters(firstToken.toCharArray(), 0, firstToken.length(  ));</code>
<code class="Code">ch.endElement("","","value");</code>
</pre> 
   <h4 class="HeadC">Using the parser</h4> 
   <p class="Body">To wrap things up, let's look at how you will actually use this CSV parser with an XSLT stylesheet. The code shown in <a href="http://www.oreilly.com/catalog/javaxslt/chapter/ch05.html#74685" class="XRef">Example 5-8</a> is a standalone Java application that allows you to perform XSLT transformations on CSV files. As the comments indicate, it requires the name of a CSV file as its first parameter and can optionally take the name of an XSLT stylesheet as its second parameter. All output is sent to <code class="Literal">System.out</code>. </p>
   <p> <b class="ExampleLabel"><a name="74685">Example 5-8:</a></b> <b class="ExampleTitle">SimpleCSVProcessor.java </b> </p>
   <pre><code class="Code">package com.oreilly.javaxslt.util;</code>
<code class="Code">?</code>
<code class="Code">import java.io.*;</code>
<code class="Code">import javax.xml.transform.*;</code>
<code class="Code">import javax.xml.transform.sax.*;</code>
<code class="Code">import javax.xml.transform.stream.*;</code>
<code class="Code">import org.xml.sax.*;</code>
<code class="Code">?</code>
<code class="Code">/**</code>
<code class="Code"> * Shows how to use the CSVXMLReader class. This is a command-line</code>
<code class="Code"> * utility that takes a CSV file and optionally an XSLT file as</code>
<code class="Code"> * command line parameters. A transformation is applied and the</code>
<code class="Code"> * output is sent to System.out.</code>
<code class="Code"> */</code>
<code class="Code">public class SimpleCSVProcessor {</code>
<code class="Code">?</code>
<code class="Code">    public static void main(String[] args) throws Exception {</code>
<code class="Code">        if (args.length == 0) {</code>
<code class="Code">            System.err.println("Usage: java "</code>
<code class="Code">                    + SimpleCSVProcessor.class.getName(  )</code>
<code class="Code">                    + " &lt;csvFile&gt; [xsltFile]");</code>
<code class="Code">            System.err.println(" - csvFile is required");</code>
<code class="Code">            System.err.println(" - xsltFile is optional");</code>
<code class="Code">            System.exit(1);</code>
<code class="Code">        }</code>
<code class="Code">?</code>
<code class="Code">        String csvFileName = args[0];</code>
<code class="Code">        String xsltFileName = (args.length &gt; 1) ? args[1] : null;</code>
<code class="Code">?</code>
<code class="Code">        TransformerFactory transFact = TransformerFactory.newInstance(  );</code>
<code class="Code">        if (transFact.getFeature(SAXTransformerFactory.FEATURE)) {</code>
<code class="Code">            SAXTransformerFactory saxTransFact =</code>
<code class="Code">                    (SAXTransformerFactory) transFact;</code>
<code class="CodeEmphasis"><b> TransformerHandler transHand = null;</b></code>
<code class="CodeEmphasis"><b> if (xsltFileName == null) {</b></code>
<code class="CodeEmphasis"><b> transHand = saxTransFact.newTransformerHandler( );</b></code>
<code class="CodeEmphasis"><b> } else {</b></code>
<code class="CodeEmphasis"><b> transHand = saxTransFact.newTransformerHandler(</b></code>
<code class="CodeEmphasis"><b> new StreamSource(new File(xsltFileName)));</b></code>
<code class="CodeEmphasis"><b> }</b></code>
<code class="Code">?</code>
<code class="Code">            // set the destination for the XSLT transformation</code>
<code class="Code">            transHand.setResult(new StreamResult(System.out));</code>
<code class="Code">?</code>
<code class="CodeEmphasis"><b> // hook the CSVXMLReader to the CSV file</b></code>
<code class="CodeEmphasis"><b> CSVXMLReader csvReader = new CSVXMLReader( );</b></code>
<code class="CodeEmphasis"><b> InputSource csvInputSrc = new InputSource(</b></code>
<code class="CodeEmphasis"><b> new FileReader(csvFileName));</b></code>
<code class="Code">?</code>
<code class="CodeEmphasis"><b> // attach the XSLT processor to the CSVXMLReader</b></code>
<code class="CodeEmphasis"><b> csvReader.setContentHandler(transHand);</b></code>
<code class="CodeEmphasis"><b> csvReader.parse(csvInputSrc);</b></code>
<code class="Code">        } else {</code>
<code class="Code">            System.err.println("SAXTransformerFactory is not supported.");</code>
<code class="Code">            System.exit(1);</code>
<code class="Code">        }</code>
<code class="Code">    }</code>
<code class="Code">}</code>
</pre> 
   <p class="Body">As mentioned earlier in this chapter, the <code class="Literal">TransformerHandler</code> is provided by JAXP and is an implementation of the <code class="Literal">org.xml.sax.ContentHandler</code> interface. It is constructed by the <code class="Literal">SAXTransformerFactory</code> as follows: </p>
   <pre><code class="Code">TransformerHandler transHand = null;</code>
<code class="Code">if (xsltFileName == null) {</code>
<code class="Code">    transHand = saxTransFact.newTransformerHandler(  );</code>
<code class="Code">} else {</code>
<code class="Code">    transHand = saxTransFact.newTransformerHandler(</code>
<code class="Code">            new StreamSource(new File(xsltFileName)));</code>
<code class="Code">}</code>
</pre> 
   <p class="Body">When the XSLT stylesheet is not specified, the transformer performs an identity transformation. This is useful when you just want to see the raw XML output without applying a stylesheet. You will probably want to do this first to see how your XSLT will need to be written. If a stylesheet is provided, however, it is used for the transformation. </p>
   <p class="Body">The custom parser is then constructed as follows: </p>
   <pre><code class="Code">CSVXMLReader csvReader = new CSVXMLReader(  );</code>
</pre> 
   <p class="Body">The location of the CSV file is then converted into a SAX <code class="Literal">InputSource</code>: </p>
   <pre><code class="Code">InputSource csvInputSrc = new InputSource(</code>
<code class="Code">        new FileReader(csvFileName));</code>
</pre> 
   <p class="Body">And finally, the XSLT processor is attached to our custom parser. This is accomplished by registering the <code class="Literal">TransformerHandler</code> as the <code class="Literal">ContentHandler</code> on <code class="Literal">csvReader</code>. A single call to the <code class="Literal">parse</code> method causes the parsing and transformation to occur: </p>
   <pre><code class="Code">// attach the XSLT processor to the CSVXMLReader</code>
<code class="Code">csvReader.setContentHandler(transHand);</code>
<code class="Code">csvReader.parse(csvInputSrc);</code>
</pre> 
   <p class="Body">For a simple test, assume that a list of presidents is available in CSV format: </p>
   <pre><code class="Code">Washington,George,,</code>
<code class="Code">Adams,John,,</code>
<code class="Code">Jefferson,Thomas,,</code>
<code class="Code">Madison,James,,</code>
<code class="Code">  etc...</code>
<code class="Code">Bush,George,Herbert,Walker</code>
<code class="Code">Clinton,William,Jefferson,</code>
<code class="Code">Bush,George,W,</code>
</pre> 
   <p class="Body">To see what the XML looks like, invoke the program as follows: </p>
   <pre><code class="Code">java com.oreilly.javaxslt.util.SimpleCSVProcessor presidents.csv</code>
</pre> 
   <p class="Body">This will parse the CSV file and apply the identity transformation stylesheet, sending the following output to the console: </p>
   <pre><code class="Code">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</code>
<code class="Code">&lt;csvFile&gt;</code>
<code class="Code">  &lt;line&gt;</code>
<code class="Code">    &lt;value&gt;Washington&lt;/value&gt;</code>
<code class="Code">    &lt;value&gt;George&lt;/value&gt;</code>
<code class="Code">    &lt;value/&gt;</code>
<code class="Code">    &lt;value/&gt;</code>
<code class="Code">  &lt;/line&gt;</code>
<code class="Code">  &lt;line&gt;</code>
<code class="Code">    etc...</code>
<code class="Code">&lt;/csvFile&gt;</code>
</pre> 
   <p class="Body">Actually, the output is crammed onto a single long line, but it is broken up here to make it more readable. Any good XML editor application should provide a feature to pretty-print the XML as shown. In order to transform this into something useful, a stylesheet is required. The XSLT stylesheet shown in <a href="http://www.oreilly.com/catalog/javaxslt/chapter/ch05.html#59032" class="XRef">Example 5-9</a> takes any output from this program and converts it into an HTML table. </p>
   <p> <b class="ExampleLabel"><a name="59032">Example 5-9:</a></b> <b class="ExampleTitle">csvToHTMLTable.xslt </b> </p>
   <pre><code class="Code">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</code>
<code class="Code">&lt;xsl:stylesheet</code>
<code class="Code">    version="1.0"</code>
<code class="Code">    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;</code>
<code class="Code">  &lt;xsl:output method="html"/&gt;</code>
<code class="Code">?</code>
<code class="Code">  &lt;xsl:template match="/"&gt;</code>
<code class="Code">    &lt;table border="1"&gt;</code>
<code class="Code">      &lt;xsl:apply-templates select="csvFile/line"/&gt;</code>
<code class="Code">    &lt;/table&gt;</code>
<code class="Code">  &lt;/xsl:template&gt;</code>
<code class="Code">?</code>
<code class="Code">  &lt;xsl:template match="line"&gt;</code>
<code class="Code">    &lt;tr&gt;</code>
<code class="Code">      &lt;xsl:apply-templates select="value"/&gt;</code>
<code class="Code">    &lt;/tr&gt;</code>
<code class="Code">  &lt;/xsl:template&gt;</code>
<code class="Code">?</code>
<code class="Code">  &lt;xsl:template match="value"&gt;</code>
<code class="Code">    &lt;td&gt;</code>
<code class="Code">      &lt;!-- If a value is empty, print a non-breaking space</code>
<code class="Code">           so the HTML table looks OK --&gt;</code>
<code class="Code">      &lt;xsl:if test=".=''"&gt;</code>
<code class="Code">        &lt;xsl:text&gt; disable-output-escaping="yes"&gt;&amp;amp;nbsp;&lt;/xsl:text&gt;</code>
<code class="Code">      &lt;/xsl:if&gt;</code>
<code class="Code">      &lt;xsl:value-of select="."/&gt;</code>
<code class="Code">    &lt;/td&gt;</code>
<code class="Code">  &lt;/xsl:template&gt;</code>
<code class="Code">&lt;/xsl:stylesheet&gt;</code>
</pre> 
   <p class="Body">In order to apply this stylesheet, type the following command: </p>
   <pre><code class="Code">java com.oreilly.javaxslt.util.SimpleCSVProcessor presidents.csv csvToHTMLTable.xslt</code>
</pre> 
   <p class="Body">As before, the results are sent to <code class="Literal">System.out</code> and contain code for an HTML table. This stylesheet will work with any CSV file parsed with <code class="Literal">SimpleCSVProcessor</code>, not just <em class="Filename">presidents.xml</em>. Now that the concept has been proved, you can add fancy formatting and custom output to the resulting HTML without altering any Java code--just edit the stylesheet or write a new one. </p>
   <h4 class="HeadC">Conclusion</h4> 
   <p class="Body">Although writing a SAX parser and connecting it to JAXP does involve quite a few interrelated classes, the resulting application requires only two command-line arguments and will work with any CSV or XSLT file. What makes this example interesting is that the same approach will work with essentially any data source. The steps are broken down as follows: </p>
   <ol> 
    <li class="ListNumber">Create a custom SAX parser by implementing <code class="Literal">org.xml.sax.XMLReader</code> or extending <code class="Literal">com.oreilly.javaxslt.util.AbstractXMLReader</code>.</li> 
    <p> </p>
    <li class="ListNumber">In your parser, emit the appropriate SAX events as you read your data.</li> 
    <p> </p>
    <li class="ListNumber">Modify <code class="Literal">SimpleCSVProcessor</code> to utilize your custom parser instead of <code class="Literal">CSVXMLReader</code>.</li> 
    <p> </p>
   </ol> 
   <p class="Body">For example, you might want to write a custom parser that accepts a SQL statement as input rather than a CSV file. Your parser could then connect to a database, issue the query, and fire SAX events for each row in the <code class="Literal">ResultSet</code>. This makes it very easy to extract data from any relational database without writing a lot of custom code. This also eliminates the intermediate step of JDOM or DOM production because the SAX events are fed directly into JAXP for transformation. </p>
   <h3 class="HeadB">Feeding JDOM Output into JAXP</h3> 
   <p class="Body">The DOM API is tedious to use, so many Java programmers opt for JDOM instead. The typical usage pattern is to generate XML dynamically using JDOM and then somehow transform that into a web page using XSLT. This presents a problem because JAXP does not provide any direct implementation of the <code class="Literal">javax.xml.Source</code> interface that integrates with JDOM.<a href="#footnote-5" title="Footnote" class="footnote">[5]</a> There are at least three available options: </p>
   <ul> 
    <li class="ListBullet">Use <code class="Literal">org.jdom.output.SAXOutputter</code> to <code class="Literal"></code>pipe SAX 2 events from JDOM to JAXP.</li> 
    <p> </p>
    <li class="ListBullet">Use <code class="Literal">org.jdom.output.DOMOutputter</code> to <code class="Literal"></code>convert the JDOM tree to a DOM tree, and then use <code class="Literal">javax.xml.transform.dom.DOMSource</code> to read the data into JAXP.</li> 
    <p> </p>
    <li class="ListBullet">Use <code class="Literal">org.jdom.output.XMLOutputter</code> to <code class="Literal"></code>serialize the JDOM tree to XML text, and then use <code class="Literal">java.xml.transform.stream.StreamSource</code> to parse the XML back into JAXP.</li> 
    <p> </p>
   </ul> 
   <h4 class="HeadC">JDOM to SAX approach</h4> 
   <p class="Body">The SAX approach is generally preferable to other approaches. Its primary advantage is that it does not require an intermediate transformation to convert the JDOM tree into a DOM tree or text. This offers the lowest memory utilization and potentially the fastest performance. </p>
   <p class="Body">In support of SAX, JDOM offers the <code class="Literal">org.jdom.output.SAXOutputter</code> <code class="Literal"></code>class. The following code fragment demonstrates its usage: </p>
   <pre><code class="Code">TransformerFactory transFact = TransformerFactory.newInstance(  );</code>
<code class="Code">if (transFact.getFeature(SAXTransformerFactory.FEATURE)) {</code>
<code class="Code">    SAXTransformerFactory stf = (SAXTransformerFactory) transFact;</code>
<code class="Code">    // the 'stylesheet' parameter is an instance of JAXP's</code>
<code class="Code">    // javax.xml.transform.Templates interface</code>
<code class="Code">    TransformerHandler transHand = stf.newTransformerHandler(stylesheet);</code>
<code class="Code">?</code>
<code class="Code">    // result is a Result instance</code>
<code class="Code">    transHand.setResult(result);</code>
<code class="CodeEmphasis"><b> SAXOutputter saxOut = new SAXOutputter(transHand);</b></code>
<code class="Code">    // the 'jdomDoc' parameter is an instance of JDOM's</code>
<code class="Code">    // org.jdom.Document class. In contains the XML data</code>
<code class="Code">    saxOut.output(jdomDoc);</code>
<code class="Code">} else {</code>
<code class="Code">    System.err.println("SAXTransformerFactory is not supported");</code>
<code class="Code">}</code>
</pre> 
   <h4 class="HeadC">JDOM to DOM approach</h4> 
   <p class="Body">The DOM approach is generally a little slower and will not work if JDOM uses a different DOM implementation than JAXP. JDOM, like JAXP, can utilize different DOM implementations behind the scenes. If JDOM refers to a different version of DOM than JAXP, you will encounter exceptions when you try to perform the transformation. Since JAXP uses Apache's Crimson parser by default, you can configure JDOM to use Crimson with the <code class="Literal">org.jdom.adapters.CrimsonDOMAdapter</code> class. The following code shows how to convert a JDOM Document into a DOM Document: </p>
   <pre><code class="Code">org.jdom.Document jdomDoc = createJDOMDocument(  );</code>
<code class="Code">// add data to the JDOM Document</code>
<code class="Code"> ...</code>
<code class="Code">?</code>
<code class="Code">// convert the JDOM Document into a DOM Document</code>
<code class="CodeEmphasis"><b>org.jdom.output.DOMOutputter domOut = new org.jdom.output.DOMOutputter(</b></code>
<code class="CodeEmphasis"><b> "org.jdom.adapters.CrimsonDOMAdapter");</b></code>
<code class="Code">org.w3c.dom.Document domDoc = domOut.output(jdomDoc);</code>
</pre> 
   <p class="Body">The second line is highlighted because it is likely to give you the most problems. When JDOM converts its internal object tree into a DOM object tree, it must use some underlying DOM implementation. In many respects, JDOM is similar to JAXP because it delegates many tasks to underlying implementation classes. The <code class="Literal">DOMOutputter</code> constructors are overloaded as follows: </p>
   <pre><code class="Code">// use the default adapter class</code>
<code class="Code">public DOMOutputter(  )</code>
<code class="Code">?</code>
<code class="Code">// use the specified adapter class</code>
<code class="Code">public DOMOutputter(String adapterClass)</code>
</pre> 
   <p class="Body">The first constructor shown here will use JDOM's default DOM parser, which is not necessarily the same DOM parser that JAXP uses. The second method allows you to specify the name of an adapter class, which must implement the <code class="Literal">org.jdom.adapters.DOMAdapter</code> interface. JDOM includes standard adapters for all of the widely used DOM implementations, or you could write your own adapter class. </p>
   <h4 class="HeadC">JDOM to text approach</h4> 
   <p class="Body">In the final approach listed earlier, you can utilize <code class="Literal">java.io.StringWriter</code> <code class="Literal"></code>and <code class="Literal">java.io.StringReader</code>. First create the JDOM data as usual, then use <code class="Literal">org.jdom.output.XMLOutputter</code> to <code class="Literal"></code>convert the data into a <code class="Literal">String</code> of XML: </p>
   <pre><code class="Code">StringWriter sw = new StringWriter(  );</code>
<code class="Code">org.jdom.output.XMLOutputter xmlOut</code>
<code class="Code">        = new org.jdom.output.XMLOutputter("", false);</code>
<code class="Code">xmlOut.output(jdomDoc, sw);</code>
</pre> 
   <p class="Body">The parameters for <code class="Literal">XMLOutputter</code> allow you to specify the amount of indentation for the output along with a <code class="Literal">boolean</code> flag indicating whether or not linefeeds should be included in the output. In the code example, no spaces or linefeeds are specified in order to minimize the size of the XML that is produced. Now that the <code class="Literal">StringWriter</code> contains your XML, you can use a <code class="Literal">StringReader</code> along with <code class="Literal">javax.xml.transform.stream.StreamSource</code> to read the data into JAXP: </p>
   <pre><code class="Code">StringReader sr = new StringReader(sw.toString(  ));</code>
<code class="Code">Source xmlSource = new javax.xml.transform.stream.StreamSource(sr);</code>
</pre> 
   <p class="Body">The transformation can then proceed just as it did in <a href="http://www.oreilly.com/catalog/javaxslt/chapter/ch05.html#86289" class="XRef">Example 5-4</a>. The main drawback to this approach is that the XML, once converted to text form, must then be parsed back in by JAXP before the transformation can be applied. </p>
   <h2 class="HeadA">Stylesheet Compilation</h2> 
   <p class="Body">XSLT is a programming language, expressed using XML syntax. This is not for the benefit of the computer, but rather for human interpretation. Before the stylesheet can be processed, it must be converted into some internal machine-readable format. This process should sound familiar, because it is the same process used for every high-level programming language. You, the programmer, work in terms of the high-level language, and an interpreter or compiler converts this language into some machine format that can be executed by the computer. </p>
   <p class="Body">Interpreters analyze source code and translate it into machine code with each execution. In this case of XSLT, this requires that the stylesheet be read into memory using an XML parser, translated into machine format, and then applied to your XML data. Performance is the obvious problem, particularly when you consider that stylesheets rarely change. Typically, the stylesheets are defined early on in the development process and remain static, while XML data is generated dynamically with each client request. </p>
   <p class="Body">A better approach is to parse the XSLT stylesheet into memory once, compile it to machine-format, and then preserve that machine representation in memory for repeated use. This is called stylesheet compilation and is no different in concept than the compilation of any programming language. </p>
   <h3 class="HeadB">Templates API</h3> 
   <p class="Body">Different XSLT processors implement stylesheet compilation differently, so JAXP includes the <code class="Literal">javax.xml.transform.Templates</code> interface to provide consistency. This is a relatively simple interface with the following API: </p>
   <pre><code class="Code">public interface Templates {</code>
<code class="Code">    java.util.Properties getOutputProperties(  );</code>
<code class="Code">    javax.xml.transform.Transformer newTransformer(  )</code>
<code class="Code">            throws TransformerConfigurationException;</code>
<code class="Code">}</code>
</pre> 
   <p class="Body">The <code class="Literal">getOutputProperties( )</code> method returns a clone of the properties associated with the <code class="Literal">&lt;xsl:output&gt;</code> element, such as <code class="Literal">method="xml"</code>, <code class="Literal">indent="yes"</code>, and <code class="Literal">encoding="UTF-8"</code>. You might recall that <code class="Literal">java.util.Properties</code> (a subclass of <code class="Literal">java.util.Hashtable</code>) provides key/value mappings from property names to property values. Since a clone, or deep copy, is returned, you can safely modify the <code class="Literal">Properties</code> instance and apply it to a future transformation without affecting the compiled stylesheet that the instance of <code class="Literal">Templates</code> represents. </p>
   <p class="Body">The <code class="Literal">newTransformer( )</code> method is more commonly used and allows you to obtain a new instance of a class that implements the <code class="Literal">Transformer</code> interface. It is this <code class="Literal">Transformer</code> object that actually allows you to perform XSLT transformations. Since the implementation of the <code class="Literal">Templates</code> interface is hidden by JAXP, it must be created by the following method on <code class="Literal">javax.xml.transform.TransformerFactory</code>: </p>
   <pre><code class="Code">public Templates newTemplates(Source source)</code>
<code class="Code">        throws TransformerConfigurationException</code>
</pre> 
   <p class="Body">As in earlier examples, the <code class="Literal">Source</code> may obtain the XSLT stylesheet from one of many locations, including a filename, a system identifier, or even a DOM tree. Regardless of the original location, the XSLT processor is supposed to compile the stylesheet into an optimized internal representation. </p>
   <p class="Body">Whether the stylesheet is actually compiled is up to the implementation, but a safe bet is that performance will continually improve over the next several years as these tools stabilize and vendors have time to apply optimizations. </p>
   <p class="Body"><a href="http://www.oreilly.com/catalog/javaxslt/chapter/ch05.html#31931" class="XRef">Figure 5-6</a> illustrates the relationship between <code class="Literal">Templates</code> and <code class="Literal">Transformer</code> instances. </p>
   <p> </p>
   <table> 
    <caption> 
     <b class="FigureLabel"><a name="31931"></a>Figure 5-6.</b> 
     <b class="FigureTitle">Relationship between Templates and Transformer</b> 
    </caption> 
    <tbody>
     <tr> 
      <td rowspan="1" colspan="1"> <p class="FigureHolder"><img src="Ch05_files/jxt_0506.gif" align="bottom"> ? </p></td> 
     </tr> 
    </tbody>
   </table> 
   <p></p>
   <p class="Body">Thread safety is an important issue in any Java application, particularly in a web context where many users share the same stylesheet. As <a href="http://www.oreilly.com/catalog/javaxslt/chapter/ch05.html#31931" class="XRef">Figure 5-6</a> illustrates, an instance of <code class="Literal">Templates</code> is thread-safe and represents a single stylesheet. During the transformation process, however, the XSLT processor must maintain state information and output properties specific to the current client. For this reason, a separate <code class="Literal">Transformer</code> instance must be used for each concurrent transformation. </p>
   <p class="Body"><code class="Literal">Transformer</code> is an abstract class in JAXP, and implementations should be lightweight. This is an important goal because you will typically create many copies of <code class="Literal">Transformer</code>, while the number of <code class="Literal">Templates</code> is relatively small. <code class="Literal">Transformer</code> instances are not thread-safe, primarily because they hold state information about the current transformation. Once the transformation is complete, however, these objects can be reused. </p>
   <h3 class="HeadB">A Stylesheet Cache</h3> 
   <p class="Body">XSLT transformations commonly occur on a shared web server with a large number of concurrent users, so it makes sense to use <code class="Literal">Templates</code> whenever possible to optimize performance. Since each instance of <code class="Literal">Templates</code> is thread-safe, it is desirable to maintain a single copy shared by many clients. This reduces the number of times your stylesheets have to be parsed into memory and compiled, as well as the overall memory footprint of your application. </p>
   <p class="Body">The code shown in <a href="http://www.oreilly.com/catalog/javaxslt/chapter/ch05.html#80995" class="XRef">Example 5-10</a> illustrates a custom XSLT stylesheet cache that automates the mundane tasks associated with creating <code class="Literal">Templates</code> instances and storing them in memory. This cache has the added benefit of checking the <code class="Literal">lastModified</code> flag on the underlying file, so it will reload itself whenever the XSLT stylesheet is modified. This is highly useful in a web-application development environment because you can make changes to the stylesheet and simply click on Reload on your web browser to see the results of the latest edits. </p>
   <p> <b class="ExampleLabel"><a name="80995">Example 5-10:</a></b> <b class="ExampleTitle">StylesheetCache.java </b> </p>
   <pre><code class="Code">package com.oreilly.javaxslt.util;</code>
<code class="Code">?</code>
<code class="Code">import java.io.*;</code>
<code class="Code">import java.util.*;</code>
<code class="Code">import javax.xml.transform.*;</code>
<code class="Code">import javax.xml.transform.stream.*;</code>
<code class="Code">?</code>
<code class="Code">/**</code>
<code class="Code"> * A utility class that caches XSLT stylesheets in memory.</code>
<code class="Code"> *</code>
<code class="Code"> */</code>
<code class="Code">public class StylesheetCache {</code>
<code class="Code">    // map xslt file names to MapEntry instances</code>
<code class="Code">    // (MapEntry is defined below)</code>
<code class="Code">    private static Map cache = new HashMap(  );</code>
<code class="Code">?</code>
<code class="Code">    /**</code>
<code class="Code">     * Flush all cached stylesheets from memory, emptying the cache.</code>
<code class="Code">     */</code>
<code class="Code">    public static synchronized void flushAll(  ) {</code>
<code class="Code">        cache.clear(  );</code>
<code class="Code">    }</code>
<code class="Code">?</code>
<code class="Code">    /**</code>
<code class="Code">     * Flush a specific cached stylesheet from memory.</code>
<code class="Code">     *</code>
<code class="Code">     * @param xsltFileName the file name of the stylesheet to remove.</code>
<code class="Code">     */</code>
<code class="Code">    public static synchronized void flush(String xsltFileName) {</code>
<code class="Code">        cache.remove(xsltFileName);</code>
<code class="Code">    }</code>
<code class="Code">?</code>
<code class="Code">    /**</code>
<code class="Code">     * Obtain a new Transformer instance for the specified XSLT file name.</code>
<code class="Code">     * A new entry will be added to the cache if this is the first request</code>
<code class="Code">     * for the specified file name.</code>
<code class="Code">     *</code>
<code class="Code">     * @param xsltFileName the file name of an XSLT stylesheet.</code>
<code class="Code">     * @return a transformation context for the given stylesheet.</code>
<code class="Code">     */</code>
<code class="Code">    public static synchronized Transformer newTransformer(String xsltFileName)</code>
<code class="Code">            throws TransformerConfigurationException {</code>
<code class="Code">        File xsltFile = new File(xsltFileName);</code>
<code class="Code">?</code>
ermine when the file was last modified on disk
<code class="Code">        long xslLastModified = xsltFile.lastModified(  );</code>
<code class="Code">        MapEntry entry = (MapEntry) cache.get(xsltFileName);</code>
<code class="Code">?</code>
<code class="Code">        if (entry != null) {</code>
<code class="Code">            // if the file has been modified more recently than the</code>
<code class="Code">            // cached stylesheet, remove the entry reference</code>
<code class="Code">            if (xslLastModified &gt; entry.lastModified) {</code>
<code class="Code">                entry = null;</code>
<code class="Code">            }</code>
<code class="Code">        }</code>
<code class="Code">?</code>
<code class="Code">        // create a new entry in the cache if necessary</code>
<code class="Code">        if (entry == null) {</code>
<code class="Code">            Source xslSource = new StreamSource(xsltFile);</code>
<code class="Code">?</code>
<code class="Code">            TransformerFactory transFact = TransformerFactory.newInstance(  );</code>
<code class="Code">            Templates templates = transFact.newTemplates(xslSource);</code>
<code class="Code">?</code>
<code class="Code">            entry = new MapEntry(xslLastModified, templates);</code>
<code class="Code">            cache.put(xsltFileName, entry);</code>
<code class="Code">        }</code>
<code class="Code">?</code>
<code class="Code">        return entry.templates.newTransformer(  );</code>
<code class="Code">    }</code>
<code class="Code">?</code>
<code class="Code">    // prevent instantiation of this class</code>
<code class="Code">    private StylesheetCache(  ) {</code>
<code class="Code">    }</code>
<code class="Code">?</code>
<code class="Code">    /**</code>
<code class="Code">     * This class represents a value in the cache Map.</code>
<code class="Code">     */</code>
<code class="Code">    static class MapEntry {</code>
<code class="Code">        long lastModified;  // when the file was modified</code>
<code class="Code">        Templates templates;</code>
<code class="Code">?</code>
<code class="Code">        MapEntry(long lastModified, Templates templates) {</code>
<code class="Code">            this.lastModified = lastModified;</code>
<code class="Code">            this.templates = templates;</code>
<code class="Code">        }</code>
<code class="Code">    }</code>
<code class="Code">}</code>
</pre> 
   <p class="Body">Because this class is a singleton, it has a private constructor and uses only static methods. Furthermore, each method is declared as <code class="Literal">synchronized</code> in an effort to avoid potential threading problems. </p>
   <p class="Body">The heart of this class is the cache itself, which is implemented using <code class="Literal">java.util.Map</code>: </p>
   <pre><code class="Code">private static Map cache = new HashMap(  );</code>
</pre> 
   <p class="Body">Although <code class="Literal">HashMap</code> is not thread-safe, the fact that all of our methods are <code class="Literal">synchronized</code> basically eliminates any concurrency issues. Each entry in the map contains a key/value pair, mapping from an XSLT stylesheet filename to an instance of the <code class="Literal">MapEntry</code> class. <code class="Literal">MapEntry</code> is a nested class that keeps track of the compiled stylesheet along with when its file was last modified: </p>
   <pre><code class="Code">static class MapEntry {</code>
<code class="Code">    long lastModified;  // when the file was modified</code>
<code class="Code">    Templates templates;</code>
<code class="Code">?</code>
<code class="Code">    MapEntry(long lastModified, Templates templates) {</code>
<code class="Code">        this.lastModified = lastModified;</code>
<code class="Code">        this.templates = templates;</code>
<code class="Code">    }</code>
<code class="Code">}</code>
</pre> 
   <p class="Body">Removing entries from the cache is accomplished by one of two methods: </p>
   <pre><code class="Code">public static synchronized void flushAll(  ) {</code>
<code class="Code">    cache.clear(  );</code>
<code class="Code">}</code>
<code class="Code">?</code>
<code class="Code">public static synchronized void flush(String xsltFileName) {</code>
<code class="Code">    cache.remove(xsltFileName);</code>
<code class="Code">}</code>
</pre> 
   <p class="Body">The first method merely removes everything from the <code class="Literal">Map</code>, while the second removes a single stylesheet. Whether you use these methods is up to you. The <code class="Literal">flushAll</code> method, for instance, should probably be called from a servlet's <code class="Literal">destroy( )</code> method to ensure proper cleanup. If you have many servlets in a web application, each servlet may wish to flush specific stylesheets it uses via the <code class="Literal">flush(...)</code> method. If the <code class="Literal">xsltFileName</code> parameter is not found, the <code class="Literal">Map</code> implementation silently ignores this request. </p>
   <p class="Body">The majority of interaction with this class occurs via the <code class="Literal">newTransformer</code> method, which has the following signature: </p>
   <pre><code class="Code">public static synchronized Transformer newTransformer(String xsltFileName)</code>
<code class="Code">        throws TransformerConfigurationException {</code>
</pre> 
   <p class="Body">The parameter, an XSLT stylesheet filename, was chosen to facilitate the "last accessed" feature. We use the <code class="Literal">java.io.File</code> class to determine when the file was last modified, which allows the cache to automatically reload itself as edits are made to the stylesheets. Had we used a system identifier or <code class="Literal">InputStream</code> instead of a filename, the auto-reload feature could not have been implemented. Next, the <code class="Literal">File</code> object is created and its <code class="Literal">lastModified</code> flag is checked: </p>
   <pre><code class="Code">File xsltFile = new File(xsltFileName);</code>
<code class="Code">?</code>
<code class="Code">// determine when the file was last modified on disk</code>
<code class="Code">long xslLastModified = xsltFile.lastModified(  );</code>
</pre> 
   <p class="Body">The compiled stylesheet, represented by an instance of <code class="Literal">MapEntry</code>, is then retrieved from the <code class="Literal">Map</code>. If the entry is found, its timestamp is compared against the current file's timestamp, thus allowing auto-reload: </p>
   <pre><code class="Code">MapEntry entry = (MapEntry) cache.get(xsltFileName);</code>
<code class="Code">?</code>
<code class="Code">if (entry != null) {</code>
<code class="Code">    // if the file has been modified more recently than the</code>
<code class="Code">    // cached stylesheet, remove the entry reference</code>
<code class="Code">    if (xslLastModified &gt; entry.lastModified) {</code>
<code class="Code">        entry = null;</code>
<code class="Code">    }</code>
<code class="Code">}</code>
</pre> 
   <p class="Body">Next, we create a new entry in the cache if the entry object reference is still <code class="Literal">null</code>. This is accomplished by wrapping a <code class="Literal">StreamSource</code> around the <code class="Literal">File</code> object, instantiating a <code class="Literal">TransformerFactory</code> instance, and using that factory to create our <code class="Literal">Templates</code> object. The <code class="Literal">Templates</code> object is then stored in the cache so it can be reused by the next client of the cache: </p>
   <pre><code class="Code">// create a new entry in the cache if necessary</code>
<code class="Code">if (entry == null) {</code>
<code class="Code">    Source xslSource = new StreamSource(xsltFile);</code>
<code class="Code">?</code>
<code class="Code">    TransformerFactory transFact = TransformerFactory.newInstance(  );</code>
<code class="Code">    Templates templates = transFact.newTemplates(xslSource);</code>
<code class="Code">?</code>
<code class="Code">    entry = new MapEntry(xslLastModified, templates);</code>
<code class="Code">    cache.put(xsltFileName, entry);</code>
<code class="Code">}</code>
</pre> 
   <p class="Body">Finally, a brand new <code class="Literal">Transformer</code> is created and returned to the caller: </p>
   <pre><code class="Code">return entry.templates.newTransformer(  );</code>
</pre> 
   <p class="Body">Returning a new <code class="Literal">Transformer</code> is critical because, although the <code class="Literal">Templates</code> object is thread-safe, the <code class="Literal">Transformer</code> implementation is not. Each caller gets its own copy of <code class="Literal">Transformer</code> so multiple clients do not collide with one another. </p>
   <p class="Body">One potential improvement on this design could be to add a <code class="Literal">lastAccessed</code> timestamp to each <code class="Literal">MapEntry</code> object. Another thread could then execute every couple of hours to flush map entries from memory if they have not been accessed for a period of time. In most web applications, this will not be an issue, but if you have a large number of pages and some are seldom accessed, this could be a way to reduce the memory usage of the cache. </p>
   <p class="Body">Another potential modification is to allow <code class="Literal">javax.xml.transform.Source</code> objects to be passed as a parameter to the <code class="Literal">newTransformer</code> method instead of as a filename. However, this would make the auto-reload feature impossible to implement for all <code class="Literal">Source</code> types. </p>
   <p> </p>
   <hr size="1" noshade> 
   <p class="Footnote"><a name="footnote-1"></a>1. Crimson and Xalan. </p>
   <p class="Footnote"><a name="footnote-2"></a>2. System properties can also be specified in Ant build files. </p>
   <p class="Footnote"><a name="footnote-3"></a>3. The exact definition of a "compiled" stylesheet is vague. XSLT processors are free to optimize cached stylesheets however they see fit. </p>
   <p class="Footnote"><a name="footnote-4"></a>4. Our examples use SAX 2. </p>
   <p class="Footnote"><a name="footnote-5"></a>5. As this is being written, members of the JDOM community are writing a JDOM implementation of <code class="Literal">javax.xml.Source</code> that will directly integrate with JAXP. </p>
  </blockquote> 
  <!-- End of sample chapter --> 
  <p><b>Back to: <a href="http://www.oreilly.com/catalog/javaxslt/">Java and XSLT</a></b></p> 
  <!-- O'Reilly Footer Begins Here --> 
  <center> 
   <hr size="1" noshade> 
   <font size="1" face="Verdana, Arial, Helvetica"> <a href="http://www.oreilly.com/"> <b>oreilly.com?Home</b></a> <b> | </b> <a href="http://www.oreilly.com/sales/bookstores"> <b>O'Reilly?Bookstores</b></a> <b> | </b> <a href="http://www.oreilly.com/order_new/"> <b>How?to?Order</b></a> <b> | </b> <a href="http://www.oreilly.com/oreilly/contact.html"> <b>O'Reilly?Contacts<br></b></a> <a href="http://www.oreilly.com/international/"> <b>International</b></a> <b> | </b> <a href="http://www.oreilly.com/oreilly/about.html"> <b>About?O'Reilly</b></a> <b> | </b> <a href="http://www.oreilly.com/affiliates.html"> <b>Affiliated?Companies</b></a> <b> | </b> <a href="http://www.oreilly.com/privacy_policy.html"> <b>Privacy?Policy</b></a><p> <em>? 2001, O'Reilly &amp; Associates, Inc.</em><br> <a href="mailto:webmaster@oreilly.com"><i>webmaster@oreilly.com</i></a></p> </font> 
  </center> 
  <!-- O'Reilly Footer Ends Here --> 
 </body>
</html>