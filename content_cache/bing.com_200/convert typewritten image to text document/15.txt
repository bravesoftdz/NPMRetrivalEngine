<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- code.jsp -->
<html>
 <head> 
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> 
  <title>com.lowagie.text: Image.java</title> 
 </head> 
 <body style="padding:0 0 0 0;margin:0 0 0 0"> 
  <div style="width:100%;background-color:#ddeeff;border:1px solid #ccddee;margin:0 0 0 0;padding:2px 2px 2px 2px"> 
   <div style="float:right">
    <a href="http://del.icio.us/post" onclick="window.open('http://del.icio.us/post?v=4&amp;noui&amp;jump=close&amp;url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title), 'delicious','toolbar=no,width=700,height=400'); return false;"><img src="http://images.del.icio.us/static/img/delicious.small.gif" border="0"> Save This Page</a>
   </div> 
   <a href="/">Home</a> » 
   <a href="/projects/iText-2.1.7-code.html">iText-2.1.7</a> » com.lowagie » 
   <a href="/docs/api/com/lowagie/text/package-index.html">text</a> » [
   <a href="/docs/api/com/lowagie/text/Image.html">javadoc</a> | source] 
  </div> 
  <pre>
<a name="1">    1 &nbsp; /*
    2 &nbsp;  * $Id: Image.java 3941 2009-05-28 14:52:26Z blowagie $
    3 &nbsp;  *
    4 &nbsp;  * Copyright 1999, 2000, 2001, 2002 by Bruno Lowagie.
    5 &nbsp;  *
    6 &nbsp;  * The contents of this file are subject to the Mozilla Public License Version 1.1
    7 &nbsp;  * (the "License"); you may not use this file except in compliance with the License.
    8 &nbsp;  * You may obtain a copy of the License at http://www.mozilla.org/MPL/
    9 &nbsp;  *
   10 &nbsp;  * Software distributed under the License is distributed on an "AS IS" basis,
</a><a name="11">   11 &nbsp;  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   12 &nbsp;  * for the specific language governing rights and limitations under the License.
   13 &nbsp;  *
   14 &nbsp;  * The Original Code is 'iText, a free JAVA-PDF library'.
   15 &nbsp;  *
   16 &nbsp;  * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
   17 &nbsp;  * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
   18 &nbsp;  * All Rights Reserved.
   19 &nbsp;  * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
   20 &nbsp;  * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
</a><a name="21">   21 &nbsp;  *
   22 &nbsp;  * Contributor(s): all the names of the contributors are added in the source code
   23 &nbsp;  * where applicable.
   24 &nbsp;  *
   25 &nbsp;  * Alternatively, the contents of this file may be used under the terms of the
   26 &nbsp;  * LGPL license (the "GNU LIBRARY GENERAL PUBLIC LICENSE"), in which case the
   27 &nbsp;  * provisions of LGPL are applicable instead of those above.  If you wish to
   28 &nbsp;  * allow use of your version of this file only under the terms of the LGPL
   29 &nbsp;  * License and not to allow others to use your version of this file under
   30 &nbsp;  * the MPL, indicate your decision by deleting the provisions above and
</a><a name="31">   31 &nbsp;  * replace them with the notice and other provisions required by the LGPL.
   32 &nbsp;  * If you do not delete the provisions above, a recipient may use your version
   33 &nbsp;  * of this file under either the MPL or the GNU LIBRARY GENERAL PUBLIC LICENSE.
   34 &nbsp;  *
   35 &nbsp;  * This library is free software; you can redistribute it and/or modify it
   36 &nbsp;  * under the terms of the MPL as stated above or under the terms of the GNU
   37 &nbsp;  * Library General Public License as published by the Free Software Foundation;
   38 &nbsp;  * either version 2 of the License, or any later version.
   39 &nbsp;  *
   40 &nbsp;  * This library is distributed in the hope that it will be useful, but WITHOUT
</a><a name="41">   41 &nbsp;  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   42 &nbsp;  * FOR A PARTICULAR PURPOSE. See the GNU Library general Public License for more
   43 &nbsp;  * details.
   44 &nbsp;  *
   45 &nbsp;  * If you didn't download this code from the following link, you should check if
   46 &nbsp;  * you aren't using an obsolete version:
   47 &nbsp;  * http://www.lowagie.com/iText/
   48 &nbsp;  */
   49 &nbsp; 
   50 &nbsp; <span class="kw">package</span> </a><a href="/docs/api/com/lowagie/text/package-index.html">com.lowagie.text</a>;
<a name="51">   51 &nbsp; 
   52 &nbsp; <span class="kw">import</span> </a><a href="/docs/api/java/awt/Graphics2D.html">java.awt.Graphics2D</a>;
   53 &nbsp; <span class="kw">import</span> <a href="/docs/api/java/awt/color/ICC_Profile.html">java.awt.color.ICC_Profile</a>;
   54 &nbsp; <span class="kw">import</span> <a href="/docs/api/java/awt/image/BufferedImage.html">java.awt.image.BufferedImage</a>;
   55 &nbsp; <span class="kw">import</span> <a href="/docs/api/java/io/IOException.html">java.io.IOException</a>;
   56 &nbsp; <span class="kw">import</span> <a href="/docs/api/java/io/InputStream.html">java.io.InputStream</a>;
   57 &nbsp; <span class="kw">import</span> <a href="/docs/api/java/lang/reflect/Constructor.html">java.lang.reflect.Constructor</a>;
   58 &nbsp; <span class="kw">import</span> <a href="/docs/api/java/net/MalformedURLException.html">java.net.MalformedURLException</a>;
   59 &nbsp; <span class="kw">import</span> <a href="/docs/api/java/net/URL.html">java.net.URL</a>;
   60 &nbsp; 
<a name="61">   61 &nbsp; <span class="kw">import</span> </a><a href="/docs/api/com/lowagie/text/pdf/PRIndirectReference.html">com.lowagie.text.pdf.PRIndirectReference</a>;
   62 &nbsp; <span class="kw">import</span> <a href="/docs/api/com/lowagie/text/pdf/PdfArray.html">com.lowagie.text.pdf.PdfArray</a>;
   63 &nbsp; <span class="kw">import</span> <a href="/docs/api/com/lowagie/text/pdf/PdfContentByte.html">com.lowagie.text.pdf.PdfContentByte</a>;
   64 &nbsp; <span class="kw">import</span> <a href="/docs/api/com/lowagie/text/pdf/PdfDictionary.html">com.lowagie.text.pdf.PdfDictionary</a>;
   65 &nbsp; <span class="kw">import</span> <a href="/docs/api/com/lowagie/text/pdf/PdfIndirectReference.html">com.lowagie.text.pdf.PdfIndirectReference</a>;
   66 &nbsp; <span class="kw">import</span> <a href="/docs/api/com/lowagie/text/pdf/PdfName.html">com.lowagie.text.pdf.PdfName</a>;
   67 &nbsp; <span class="kw">import</span> <a href="/docs/api/com/lowagie/text/pdf/PdfNumber.html">com.lowagie.text.pdf.PdfNumber</a>;
   68 &nbsp; <span class="kw">import</span> <a href="/docs/api/com/lowagie/text/pdf/PdfOCG.html">com.lowagie.text.pdf.PdfOCG</a>;
   69 &nbsp; <span class="kw">import</span> <a href="/docs/api/com/lowagie/text/pdf/PdfObject.html">com.lowagie.text.pdf.PdfObject</a>;
   70 &nbsp; <span class="kw">import</span> <a href="/docs/api/com/lowagie/text/pdf/PdfReader.html">com.lowagie.text.pdf.PdfReader</a>;
<a name="71">   71 &nbsp; <span class="kw">import</span> </a><a href="/docs/api/com/lowagie/text/pdf/PdfStream.html">com.lowagie.text.pdf.PdfStream</a>;
   72 &nbsp; <span class="kw">import</span> <a href="/docs/api/com/lowagie/text/pdf/PdfTemplate.html">com.lowagie.text.pdf.PdfTemplate</a>;
   73 &nbsp; <span class="kw">import</span> <a href="/docs/api/com/lowagie/text/pdf/PdfWriter.html">com.lowagie.text.pdf.PdfWriter</a>;
   74 &nbsp; <span class="kw">import</span> <a href="/docs/api/com/lowagie/text/pdf/RandomAccessFileOrArray.html">com.lowagie.text.pdf.RandomAccessFileOrArray</a>;
   75 &nbsp; <span class="kw">import</span> <a href="/docs/api/com/lowagie/text/pdf/codec/BmpImage.html">com.lowagie.text.pdf.codec.BmpImage</a>;
   76 &nbsp; <span class="kw">import</span> <a href="/docs/api/com/lowagie/text/pdf/codec/CCITTG4Encoder.html">com.lowagie.text.pdf.codec.CCITTG4Encoder</a>;
   77 &nbsp; <span class="kw">import</span> <a href="/docs/api/com/lowagie/text/pdf/codec/GifImage.html">com.lowagie.text.pdf.codec.GifImage</a>;
   78 &nbsp; <span class="kw">import</span> <a href="/docs/api/com/lowagie/text/pdf/codec/JBIG2Image.html">com.lowagie.text.pdf.codec.JBIG2Image</a>;
   79 &nbsp; <span class="kw">import</span> <a href="/docs/api/com/lowagie/text/pdf/codec/PngImage.html">com.lowagie.text.pdf.codec.PngImage</a>;
   80 &nbsp; <span class="kw">import</span> <a href="/docs/api/com/lowagie/text/pdf/codec/TiffImage.html">com.lowagie.text.pdf.codec.TiffImage</a>;
<a name="81">   81 &nbsp; 
   82 &nbsp; /**
   83 &nbsp;  * An &lt;CODE&gt;Image&lt;/CODE&gt; is the representation of a graphic element (JPEG, PNG
   84 &nbsp;  * or GIF) that has to be inserted into the document
   85 &nbsp;  * 
   86 &nbsp;  * @see Element
   87 &nbsp;  * @see Rectangle
   88 &nbsp;  */
   89 &nbsp; 
   90 &nbsp; public abstract class Image extends Rectangle {
</a><a name="91">   91 &nbsp; 
   92 &nbsp; 	// static final membervariables
   93 &nbsp; 
   94 &nbsp; 	/** this is a kind of image alignment. */
   95 &nbsp; 	public static final int DEFAULT = 0;
   96 &nbsp; 
   97 &nbsp; 	/** this is a kind of image alignment. */
   98 &nbsp; 	public static final int RIGHT = 2;
   99 &nbsp; 
  100 &nbsp; 	/** this is a kind of image alignment. */
</a><a name="101">  101 &nbsp; 	public static final int LEFT = 0;
  102 &nbsp; 
  103 &nbsp; 	/** this is a kind of image alignment. */
  104 &nbsp; 	public static final int MIDDLE = 1;
  105 &nbsp; 
  106 &nbsp; 	/** this is a kind of image alignment. */
  107 &nbsp; 	public static final int TEXTWRAP = 4;
  108 &nbsp; 
  109 &nbsp; 	/** this is a kind of image alignment. */
  110 &nbsp; 	public static final int UNDERLYING = 8;
</a><a name="111">  111 &nbsp; 
  112 &nbsp; 	/** This represents a coordinate in the transformation matrix. */
  113 &nbsp; 	public static final int AX = 0;
  114 &nbsp; 
  115 &nbsp; 	/** This represents a coordinate in the transformation matrix. */
  116 &nbsp; 	public static final int AY = 1;
  117 &nbsp; 
  118 &nbsp; 	/** This represents a coordinate in the transformation matrix. */
  119 &nbsp; 	public static final int BX = 2;
  120 &nbsp; 
</a><a name="121">  121 &nbsp; 	/** This represents a coordinate in the transformation matrix. */
  122 &nbsp; 	public static final int BY = 3;
  123 &nbsp; 
  124 &nbsp; 	/** This represents a coordinate in the transformation matrix. */
  125 &nbsp; 	public static final int CX = 4;
  126 &nbsp; 
  127 &nbsp; 	/** This represents a coordinate in the transformation matrix. */
  128 &nbsp; 	public static final int CY = 5;
  129 &nbsp; 
  130 &nbsp; 	/** This represents a coordinate in the transformation matrix. */
</a><a name="131">  131 &nbsp; 	public static final int DX = 6;
  132 &nbsp; 
  133 &nbsp; 	/** This represents a coordinate in the transformation matrix. */
  134 &nbsp; 	public static final int DY = 7;
  135 &nbsp; 
  136 &nbsp; 	/** type of image */
  137 &nbsp; 	public static final int ORIGINAL_NONE = 0;
  138 &nbsp; 
  139 &nbsp; 	/** type of image */
  140 &nbsp; 	public static final int ORIGINAL_JPEG = 1;
</a><a name="141">  141 &nbsp; 
  142 &nbsp; 	/** type of image */
  143 &nbsp; 	public static final int ORIGINAL_PNG = 2;
  144 &nbsp; 
  145 &nbsp; 	/** type of image */
  146 &nbsp; 	public static final int ORIGINAL_GIF = 3;
  147 &nbsp; 
  148 &nbsp; 	/** type of image */
  149 &nbsp; 	public static final int ORIGINAL_BMP = 4;
  150 &nbsp; 
</a><a name="151">  151 &nbsp; 	/** type of image */
  152 &nbsp; 	public static final int ORIGINAL_TIFF = 5;
  153 &nbsp; 
  154 &nbsp; 	/** type of image */
  155 &nbsp; 	public static final int ORIGINAL_WMF = 6;
  156 &nbsp; 
  157 &nbsp; 	/** type of image */
  158 &nbsp;     public static final int ORIGINAL_PS = 7;
  159 &nbsp; 
  160 &nbsp; 	/** type of image */
</a><a name="161">  161 &nbsp; 	public static final int ORIGINAL_JPEG2000 = 8;
  162 &nbsp; 
  163 &nbsp; 	/**
  164 &nbsp; 	 * type of image
  165 &nbsp; 	 * @since	2.1.5
  166 &nbsp; 	 */
  167 &nbsp; 	public static final int ORIGINAL_JBIG2 = 9;
  168 &nbsp; 	
  169 &nbsp;     // member variables
  170 &nbsp; 
</a><a name="171">  171 &nbsp; 	/** The image type. */
  172 &nbsp; 	protected int type;
  173 &nbsp; 
  174 &nbsp; 	/** The URL of the image. */
  175 &nbsp; 	protected URL url;
  176 &nbsp; 
  177 &nbsp; 	/** The raw data of the image. */
  178 &nbsp; 	protected byte rawData[];
  179 &nbsp; 
  180 &nbsp; 	/** The bits per component of the raw image. It also flags a CCITT image. */
</a><a name="181">  181 &nbsp; 	protected int bpc = 1;
  182 &nbsp; 	
  183 &nbsp; 	/** The template to be treated as an image. */
  184 &nbsp; 	protected PdfTemplate template[] = new PdfTemplate[1];
  185 &nbsp; 
  186 &nbsp; 	/** The alignment of the Image. */
  187 &nbsp; 	protected int alignment;
  188 &nbsp; 
  189 &nbsp; 	/** Text that can be shown instead of the image. */
  190 &nbsp; 	protected String alt;
</a><a name="191">  191 &nbsp; 
  192 &nbsp; 	/** This is the absolute X-position of the image. */
  193 &nbsp; 	protected float absoluteX = Float.NaN;
  194 &nbsp; 
  195 &nbsp; 	/** This is the absolute Y-position of the image. */
  196 &nbsp; 	protected float absoluteY = Float.NaN;
  197 &nbsp; 
  198 &nbsp; 	/** This is the width of the image without rotation. */
  199 &nbsp; 	protected float plainWidth;
  200 &nbsp; 
</a><a name="201">  201 &nbsp; 	/** This is the width of the image without rotation. */
  202 &nbsp; 	protected float plainHeight;
  203 &nbsp; 
  204 &nbsp; 	/** This is the scaled width of the image taking rotation into account. */
  205 &nbsp; 	protected float scaledWidth;
  206 &nbsp; 
  207 &nbsp; 	/** This is the original height of the image taking rotation into account. */
  208 &nbsp; 	protected float scaledHeight;
  209 &nbsp; 	
  210 &nbsp;     /**
</a><a name="211">  211 &nbsp;      * The compression level of the content streams.
  212 &nbsp;      * @since	2.1.3
  213 &nbsp;      */
  214 &nbsp;     protected int compressionLevel = PdfStream.DEFAULT_COMPRESSION;
  215 &nbsp; 
  216 &nbsp; 	/** an iText attributed unique id for this image. */
  217 &nbsp; 	protected Long mySerialId = getSerialId();
  218 &nbsp; 
  219 &nbsp; 	// image from file or URL
  220 &nbsp; 	
</a><a name="221">  221 &nbsp; 	/**
  222 &nbsp; 	 * Constructs an &lt;CODE&gt;Image&lt;/CODE&gt; -object, using an &lt;VAR&gt;url &lt;/VAR&gt;.
  223 &nbsp; 	 * 
  224 &nbsp; 	 * @param url
  225 &nbsp; 	 *            the &lt;CODE&gt;URL&lt;/CODE&gt; where the image can be found.
  226 &nbsp; 	 */
  227 &nbsp; 	public Image(URL url) {
  228 &nbsp; 		super(0, 0);
  229 &nbsp; 		this.url = url;
  230 &nbsp; 		this.alignment = DEFAULT;
</a><a name="231">  231 &nbsp; 		rotationRadians = 0;
  232 &nbsp; 	}
  233 &nbsp; 
  234 &nbsp; 	/**
  235 &nbsp; 	 * Gets an instance of an Image.
  236 &nbsp; 	 * 
  237 &nbsp; 	 * @param url
  238 &nbsp; 	 *            an URL
  239 &nbsp; 	 * @return an Image
  240 &nbsp; 	 * @throws BadElementException
</a><a name="241">  241 &nbsp; 	 * @throws MalformedURLException
  242 &nbsp; 	 * @throws IOException
  243 &nbsp; 	 */
  244 &nbsp; 	public static Image getInstance(URL url) throws BadElementException,
  245 &nbsp; 			MalformedURLException, IOException {
  246 &nbsp; 		InputStream is = null;
  247 &nbsp; 		try {
  248 &nbsp; 			is = url.openStream();
  249 &nbsp; 			int c1 = is.read();
  250 &nbsp; 			int c2 = is.read();
</a><a name="251">  251 &nbsp; 			int c3 = is.read();
  252 &nbsp; 			int c4 = is.read();
  253 &nbsp; 			// jbig2
  254 &nbsp; 			int c5 = is.read();
  255 &nbsp; 			int c6 = is.read();
  256 &nbsp; 			int c7 = is.read();
  257 &nbsp; 			int c8 = is.read();
  258 &nbsp; 			is.close();
  259 &nbsp; 
  260 &nbsp; 			is = null;
</a><a name="261">  261 &nbsp; 			if (c1 == 'G' &amp;&amp; c2 == 'I' &amp;&amp; c3 == 'F') {
  262 &nbsp; 				GifImage gif = new GifImage(url);
  263 &nbsp; 				Image img = gif.getImage(1);
  264 &nbsp; 				return img;
  265 &nbsp; 			}
  266 &nbsp; 			if (c1 == 0xFF &amp;&amp; c2 == 0xD8) {
  267 &nbsp; 				return new Jpeg(url);
  268 &nbsp; 			}
  269 &nbsp; 			if (c1 == 0x00 &amp;&amp; c2 == 0x00 &amp;&amp; c3 == 0x00 &amp;&amp; c4 == 0x0c) {
  270 &nbsp; 				return new Jpeg2000(url);
</a><a name="271">  271 &nbsp; 			}
  272 &nbsp; 			if (c1 == 0xff &amp;&amp; c2 == 0x4f &amp;&amp; c3 == 0xff &amp;&amp; c4 == 0x51) {
  273 &nbsp; 				return new Jpeg2000(url);
  274 &nbsp; 			}
  275 &nbsp; 			if (c1 == PngImage.PNGID[0] &amp;&amp; c2 == PngImage.PNGID[1]
  276 &nbsp; 					&amp;&amp; c3 == PngImage.PNGID[2] &amp;&amp; c4 == PngImage.PNGID[3]) {
  277 &nbsp; 				return PngImage.getImage(url);
  278 &nbsp; 			}
  279 &nbsp; 			if (c1 == 0xD7 &amp;&amp; c2 == 0xCD) {
  280 &nbsp; 				return new ImgWMF(url);
</a><a name="281">  281 &nbsp; 			}
  282 &nbsp; 			if (c1 == 'B' &amp;&amp; c2 == 'M') {
  283 &nbsp; 				return  BmpImage.getImage(url);
  284 &nbsp; 			}
  285 &nbsp; 			if ((c1 == 'M' &amp;&amp; c2 == 'M' &amp;&amp; c3 == 0 &amp;&amp; c4 == 42)
  286 &nbsp; 					|| (c1 == 'I' &amp;&amp; c2 == 'I' &amp;&amp; c3 == 42 &amp;&amp; c4 == 0)) {
  287 &nbsp; 				RandomAccessFileOrArray ra = null;
  288 &nbsp; 				try {
  289 &nbsp; 					if (url.getProtocol().equals("file")) {
  290 &nbsp; 						String file = url.getFile();
</a><a name="291">  291 &nbsp;                         file = Utilities.unEscapeURL(file);
  292 &nbsp; 						ra = new RandomAccessFileOrArray(file);
  293 &nbsp; 					} else
  294 &nbsp; 						ra = new RandomAccessFileOrArray(url);
  295 &nbsp; 					Image img = TiffImage.getTiffImage(ra, 1);
  296 &nbsp; 					img.url = url;
  297 &nbsp; 					return img;
  298 &nbsp; 				} finally {
  299 &nbsp; 					if (ra != null)
  300 &nbsp; 						ra.close();
</a><a name="301">  301 &nbsp; 				}
  302 &nbsp; 
  303 &nbsp; 			}
  304 &nbsp; 			if ( c1 == 0x97 &amp;&amp; c2 == 'J' &amp;&amp; c3 == 'B' &amp;&amp; c4 == '2' &amp;&amp;
  305 &nbsp; 					c5 == '\r' &amp;&amp; c6 == '\n' &amp;&amp; c7 == 0x1a &amp;&amp; c8 == '\n' ) {
  306 &nbsp; 				RandomAccessFileOrArray ra = null;
  307 &nbsp; 				try {
  308 &nbsp; 					if (url.getProtocol().equals("file")) {
  309 &nbsp; 						String file = url.getFile();
  310 &nbsp; 						file = Utilities.unEscapeURL(file);
</a><a name="311">  311 &nbsp; 			            ra = new RandomAccessFileOrArray(file);
  312 &nbsp; 					} else
  313 &nbsp; 						ra = new RandomAccessFileOrArray(url);
  314 &nbsp; 					Image img = JBIG2Image.getJbig2Image(ra, 1);
  315 &nbsp; 					img.url = url;
  316 &nbsp; 					return img;
  317 &nbsp; 				} finally {
  318 &nbsp; 						if (ra != null)
  319 &nbsp; 							ra.close();
  320 &nbsp; 				}
</a><a name="321">  321 &nbsp; 			}
  322 &nbsp; 			throw new IOException(url.toString()
  323 &nbsp; 					+ " is not a recognized imageformat.");
  324 &nbsp; 		} finally {
  325 &nbsp; 			if (is != null) {
  326 &nbsp; 				is.close();
  327 &nbsp; 			}
  328 &nbsp; 		}
  329 &nbsp; 	}
  330 &nbsp; 
</a><a name="331">  331 &nbsp; 	/**
  332 &nbsp; 	 * Gets an instance of an Image.
  333 &nbsp; 	 * 
  334 &nbsp; 	 * @param filename
  335 &nbsp; 	 *            a filename
  336 &nbsp; 	 * @return an object of type &lt;CODE&gt;Gif&lt;/CODE&gt;,&lt;CODE&gt;Jpeg&lt;/CODE&gt; or
  337 &nbsp; 	 *         &lt;CODE&gt;Png&lt;/CODE&gt;
  338 &nbsp; 	 * @throws BadElementException
  339 &nbsp; 	 * @throws MalformedURLException
  340 &nbsp; 	 * @throws IOException
</a><a name="341">  341 &nbsp; 	 */
  342 &nbsp; 	public static Image getInstance(String filename)
  343 &nbsp; 			throws BadElementException, MalformedURLException, IOException {
  344 &nbsp; 		return getInstance(Utilities.toURL(filename));
  345 &nbsp; 	}
  346 &nbsp;     
  347 &nbsp; 	/**
  348 &nbsp; 	 * gets an instance of an Image
  349 &nbsp; 	 * 
  350 &nbsp; 	 * @param imgb
</a><a name="351">  351 &nbsp; 	 *            raw image date
  352 &nbsp; 	 * @return an Image object
  353 &nbsp; 	 * @throws BadElementException
  354 &nbsp; 	 * @throws MalformedURLException
  355 &nbsp; 	 * @throws IOException
  356 &nbsp; 	 */
  357 &nbsp; 	public static Image getInstance(byte imgb[]) throws BadElementException,
  358 &nbsp; 			MalformedURLException, IOException {
  359 &nbsp; 		InputStream is = null;
  360 &nbsp; 		try {
</a><a name="361">  361 &nbsp; 			is = new java.io.ByteArrayInputStream(imgb);
  362 &nbsp; 			int c1 = is.read();
  363 &nbsp; 			int c2 = is.read();
  364 &nbsp; 			int c3 = is.read();
  365 &nbsp; 			int c4 = is.read();
  366 &nbsp; 			is.close();
  367 &nbsp; 
  368 &nbsp; 			is = null;
  369 &nbsp; 			if (c1 == 'G' &amp;&amp; c2 == 'I' &amp;&amp; c3 == 'F') {
  370 &nbsp; 				GifImage gif = new GifImage(imgb);
</a><a name="371">  371 &nbsp; 				return gif.getImage(1);
  372 &nbsp; 			}
  373 &nbsp; 			if (c1 == 0xFF &amp;&amp; c2 == 0xD8) {
  374 &nbsp; 				return new Jpeg(imgb);
  375 &nbsp; 			}
  376 &nbsp; 			if (c1 == 0x00 &amp;&amp; c2 == 0x00 &amp;&amp; c3 == 0x00 &amp;&amp; c4 == 0x0c) {
  377 &nbsp; 				return new Jpeg2000(imgb);
  378 &nbsp; 			}
  379 &nbsp; 			if (c1 == 0xff &amp;&amp; c2 == 0x4f &amp;&amp; c3 == 0xff &amp;&amp; c4 == 0x51) {
  380 &nbsp; 				return new Jpeg2000(imgb);
</a><a name="381">  381 &nbsp; 			}
  382 &nbsp; 			if (c1 == PngImage.PNGID[0] &amp;&amp; c2 == PngImage.PNGID[1]
  383 &nbsp; 					&amp;&amp; c3 == PngImage.PNGID[2] &amp;&amp; c4 == PngImage.PNGID[3]) {
  384 &nbsp; 				return PngImage.getImage(imgb);
  385 &nbsp; 			}
  386 &nbsp; 			if (c1 == 0xD7 &amp;&amp; c2 == 0xCD) {
  387 &nbsp; 				return new ImgWMF(imgb);
  388 &nbsp; 			}
  389 &nbsp; 			if (c1 == 'B' &amp;&amp; c2 == 'M') {
  390 &nbsp; 				return BmpImage.getImage(imgb);
</a><a name="391">  391 &nbsp; 			}
  392 &nbsp; 			if ((c1 == 'M' &amp;&amp; c2 == 'M' &amp;&amp; c3 == 0 &amp;&amp; c4 == 42)
  393 &nbsp; 					|| (c1 == 'I' &amp;&amp; c2 == 'I' &amp;&amp; c3 == 42 &amp;&amp; c4 == 0)) {
  394 &nbsp; 				RandomAccessFileOrArray ra = null;
  395 &nbsp; 				try {
  396 &nbsp; 					ra = new RandomAccessFileOrArray(imgb);
  397 &nbsp; 					Image img = TiffImage.getTiffImage(ra, 1);
  398 &nbsp;                     if (img.getOriginalData() == null)
  399 &nbsp;                         img.setOriginalData(imgb);
  400 &nbsp; 					return img;
</a><a name="401">  401 &nbsp; 				} finally {
  402 &nbsp; 					if (ra != null)
  403 &nbsp; 						ra.close();
  404 &nbsp; 				}
  405 &nbsp; 
  406 &nbsp; 			}
  407 &nbsp; 			if ( c1 == 0x97 &amp;&amp; c2 == 'J' &amp;&amp; c3 == 'B' &amp;&amp; c4 == '2' ) {
  408 &nbsp; 				is = new java.io.ByteArrayInputStream(imgb);
  409 &nbsp; 				is.skip(4);
  410 &nbsp; 				int c5 = is.read();
</a><a name="411">  411 &nbsp; 				int c6 = is.read();
  412 &nbsp; 				int c7 = is.read();
  413 &nbsp; 				int c8 = is.read();
  414 &nbsp; 				if ( c5 == '\r' &amp;&amp; c6 == '\n' &amp;&amp; c7 == 0x1a &amp;&amp; c8 == '\n' ) {
  415 &nbsp; 					int file_header_flags = is.read();
  416 &nbsp; 					int number_of_pages = -1;
  417 &nbsp; 					if ( (file_header_flags &amp; 0x2) == 0x2 ) {
  418 &nbsp; 						number_of_pages = (is.read() &lt;&lt; 24) | (is.read() &lt;&lt; 16) | (is.read() &lt;&lt; 8) | is.read();
  419 &nbsp; 					}
  420 &nbsp; 					is.close();
</a><a name="421">  421 &nbsp; 					// a jbig2 file with a file header.  the header is the only way we know here.                                                           
  422 &nbsp; 					// embedded jbig2s don't have a header, have to create them by explicit use of Jbig2Image?
  423 &nbsp; 					// nkerr, 2008-12-05  see also the getInstance(URL)
  424 &nbsp; 					RandomAccessFileOrArray ra = null;
  425 &nbsp; 					try {
  426 &nbsp; 						ra = new RandomAccessFileOrArray(imgb);
  427 &nbsp; 						Image img = JBIG2Image.getJbig2Image(ra, 1);
  428 &nbsp; 						if (img.getOriginalData() == null)
  429 &nbsp; 							img.setOriginalData(imgb);
  430 &nbsp; 						return img;
</a><a name="431">  431 &nbsp; 					} finally {
  432 &nbsp; 						if (ra != null)
  433 &nbsp; 							ra.close();
  434 &nbsp; 					}
  435 &nbsp; 				}
  436 &nbsp; 			}
  437 &nbsp; 			throw new IOException(
  438 &nbsp; 					"The byte array is not a recognized imageformat.");
  439 &nbsp; 		} finally {
  440 &nbsp; 			if (is != null) {
</a><a name="441">  441 &nbsp; 				is.close();
  442 &nbsp; 			}
  443 &nbsp; 		}
  444 &nbsp; 	}
  445 &nbsp; 
  446 &nbsp; 	/**
  447 &nbsp; 	 * Gets an instance of an Image in raw mode.
  448 &nbsp; 	 * 
  449 &nbsp; 	 * @param width
  450 &nbsp; 	 *            the width of the image in pixels
</a><a name="451">  451 &nbsp; 	 * @param height
  452 &nbsp; 	 *            the height of the image in pixels
  453 &nbsp; 	 * @param components
  454 &nbsp; 	 *            1,3 or 4 for GrayScale, RGB and CMYK
  455 &nbsp; 	 * @param data
  456 &nbsp; 	 *            the image data
  457 &nbsp; 	 * @param bpc
  458 &nbsp; 	 *            bits per component
  459 &nbsp; 	 * @return an object of type &lt;CODE&gt;ImgRaw&lt;/CODE&gt;
  460 &nbsp; 	 * @throws BadElementException
</a><a name="461">  461 &nbsp; 	 *             on error
  462 &nbsp; 	 */
  463 &nbsp; 	public static Image getInstance(int width, int height, int components,
  464 &nbsp; 			int bpc, byte data[]) throws BadElementException {
  465 &nbsp; 		return Image.getInstance(width, height, components, bpc, data, null);
  466 &nbsp; 	}
  467 &nbsp; 
  468 &nbsp; 	/**
  469 &nbsp; 	 * Creates a JBIG2 Image.
  470 &nbsp; 	 * @param	width	the width of the image
</a><a name="471">  471 &nbsp; 	 * @param	height	the height of the image
  472 &nbsp; 	 * @param	data	the raw image data
  473 &nbsp; 	 * @param	globals	JBIG2 globals
  474 &nbsp; 	 * @since	2.1.5
  475 &nbsp; 	 */
  476 &nbsp; 	public static Image getInstance(int width, int height, byte[] data, byte[] globals) {
  477 &nbsp; 		Image img = new ImgJBIG2(width, height, data, globals);
  478 &nbsp; 		return img;
  479 &nbsp; 	}
  480 &nbsp; 	
</a><a name="481">  481 &nbsp; 	/**
  482 &nbsp; 	 * Creates an Image with CCITT G3 or G4 compression. It assumes that the
  483 &nbsp; 	 * data bytes are already compressed.
  484 &nbsp; 	 * 
  485 &nbsp; 	 * @param width
  486 &nbsp; 	 *            the exact width of the image
  487 &nbsp; 	 * @param height
  488 &nbsp; 	 *            the exact height of the image
  489 &nbsp; 	 * @param reverseBits
  490 &nbsp; 	 *            reverses the bits in &lt;code&gt;data&lt;/code&gt;. Bit 0 is swapped
</a><a name="491">  491 &nbsp; 	 *            with bit 7 and so on
  492 &nbsp; 	 * @param typeCCITT
  493 &nbsp; 	 *            the type of compression in &lt;code&gt;data&lt;/code&gt;. It can be
  494 &nbsp; 	 *            CCITTG4, CCITTG31D, CCITTG32D
  495 &nbsp; 	 * @param parameters
  496 &nbsp; 	 *            parameters associated with this stream. Possible values are
  497 &nbsp; 	 *            CCITT_BLACKIS1, CCITT_ENCODEDBYTEALIGN, CCITT_ENDOFLINE and
  498 &nbsp; 	 *            CCITT_ENDOFBLOCK or a combination of them
  499 &nbsp; 	 * @param data
  500 &nbsp; 	 *            the image data
</a><a name="501">  501 &nbsp; 	 * @return an Image object
  502 &nbsp; 	 * @throws BadElementException
  503 &nbsp; 	 *             on error
  504 &nbsp; 	 */
  505 &nbsp; 	public static Image getInstance(int width, int height, boolean reverseBits,
  506 &nbsp; 			int typeCCITT, int parameters, byte[] data)
  507 &nbsp; 			throws BadElementException {
  508 &nbsp; 		return Image.getInstance(width, height, reverseBits, typeCCITT,
  509 &nbsp; 				parameters, data, null);
  510 &nbsp; 	}
</a><a name="511">  511 &nbsp; 
  512 &nbsp; 	/**
  513 &nbsp; 	 * Creates an Image with CCITT G3 or G4 compression. It assumes that the
  514 &nbsp; 	 * data bytes are already compressed.
  515 &nbsp; 	 * 
  516 &nbsp; 	 * @param width
  517 &nbsp; 	 *            the exact width of the image
  518 &nbsp; 	 * @param height
  519 &nbsp; 	 *            the exact height of the image
  520 &nbsp; 	 * @param reverseBits
</a><a name="521">  521 &nbsp; 	 *            reverses the bits in &lt;code&gt;data&lt;/code&gt;. Bit 0 is swapped
  522 &nbsp; 	 *            with bit 7 and so on
  523 &nbsp; 	 * @param typeCCITT
  524 &nbsp; 	 *            the type of compression in &lt;code&gt;data&lt;/code&gt;. It can be
  525 &nbsp; 	 *            CCITTG4, CCITTG31D, CCITTG32D
  526 &nbsp; 	 * @param parameters
  527 &nbsp; 	 *            parameters associated with this stream. Possible values are
  528 &nbsp; 	 *            CCITT_BLACKIS1, CCITT_ENCODEDBYTEALIGN, CCITT_ENDOFLINE and
  529 &nbsp; 	 *            CCITT_ENDOFBLOCK or a combination of them
  530 &nbsp; 	 * @param data
</a><a name="531">  531 &nbsp; 	 *            the image data
  532 &nbsp; 	 * @param transparency
  533 &nbsp; 	 *            transparency information in the Mask format of the image
  534 &nbsp; 	 *            dictionary
  535 &nbsp; 	 * @return an Image object
  536 &nbsp; 	 * @throws BadElementException
  537 &nbsp; 	 *             on error
  538 &nbsp; 	 */
  539 &nbsp; 	public static Image getInstance(int width, int height, boolean reverseBits,
  540 &nbsp; 			int typeCCITT, int parameters, byte[] data, int transparency[])
</a><a name="541">  541 &nbsp; 			throws BadElementException {
  542 &nbsp; 		if (transparency != null &amp;&amp; transparency.length != 2)
  543 &nbsp; 			throw new BadElementException(
  544 &nbsp; 					"Transparency length must be equal to 2 with CCITT images");
  545 &nbsp; 		Image img = new ImgCCITT(width, height, reverseBits, typeCCITT,
  546 &nbsp; 				parameters, data);
  547 &nbsp; 		img.transparency = transparency;
  548 &nbsp; 		return img;
  549 &nbsp; 	}
  550 &nbsp; 
</a><a name="551">  551 &nbsp; 	/**
  552 &nbsp; 	 * Gets an instance of an Image in raw mode.
  553 &nbsp; 	 * 
  554 &nbsp; 	 * @param width
  555 &nbsp; 	 *            the width of the image in pixels
  556 &nbsp; 	 * @param height
  557 &nbsp; 	 *            the height of the image in pixels
  558 &nbsp; 	 * @param components
  559 &nbsp; 	 *            1,3 or 4 for GrayScale, RGB and CMYK
  560 &nbsp; 	 * @param data
</a><a name="561">  561 &nbsp; 	 *            the image data
  562 &nbsp; 	 * @param bpc
  563 &nbsp; 	 *            bits per component
  564 &nbsp; 	 * @param transparency
  565 &nbsp; 	 *            transparency information in the Mask format of the image
  566 &nbsp; 	 *            dictionary
  567 &nbsp; 	 * @return an object of type &lt;CODE&gt;ImgRaw&lt;/CODE&gt;
  568 &nbsp; 	 * @throws BadElementException
  569 &nbsp; 	 *             on error
  570 &nbsp; 	 */
</a><a name="571">  571 &nbsp; 	public static Image getInstance(int width, int height, int components,
  572 &nbsp; 			int bpc, byte data[], int transparency[])
  573 &nbsp; 			throws BadElementException {
  574 &nbsp; 		if (transparency != null &amp;&amp; transparency.length != components * 2)
  575 &nbsp; 			throw new BadElementException(
  576 &nbsp; 					"Transparency length must be equal to (componentes * 2)");
  577 &nbsp; 		if (components == 1 &amp;&amp; bpc == 1) {
  578 &nbsp; 			byte g4[] = CCITTG4Encoder.compress(data, width, height);
  579 &nbsp; 			return Image.getInstance(width, height, false, Image.CCITTG4,
  580 &nbsp; 					Image.CCITT_BLACKIS1, g4, transparency);
</a><a name="581">  581 &nbsp; 		}
  582 &nbsp; 		Image img = new ImgRaw(width, height, components, bpc, data);
  583 &nbsp; 		img.transparency = transparency;
  584 &nbsp; 		return img;
  585 &nbsp; 	}
  586 &nbsp; 
  587 &nbsp; 	// images from a PdfTemplate
  588 &nbsp; 	
  589 &nbsp; 	/**
  590 &nbsp; 	 * gets an instance of an Image
</a><a name="591">  591 &nbsp; 	 * 
  592 &nbsp; 	 * @param template
  593 &nbsp; 	 *            a PdfTemplate that has to be wrapped in an Image object
  594 &nbsp; 	 * @return an Image object
  595 &nbsp; 	 * @throws BadElementException
  596 &nbsp; 	 */
  597 &nbsp; 	public static Image getInstance(PdfTemplate template)
  598 &nbsp; 			throws BadElementException {
  599 &nbsp; 		return new ImgTemplate(template);
  600 &nbsp; 	}
</a><a name="601">  601 &nbsp;     
  602 &nbsp;     // images from a java.awt.Image
  603 &nbsp;     
  604 &nbsp; 	/**
  605 &nbsp; 	 * Gets an instance of an Image from a java.awt.Image.
  606 &nbsp; 	 * 
  607 &nbsp; 	 * @param image
  608 &nbsp; 	 *            the &lt;CODE&gt;java.awt.Image&lt;/CODE&gt; to convert
  609 &nbsp; 	 * @param color
  610 &nbsp; 	 *            if different from &lt;CODE&gt;null&lt;/CODE&gt; the transparency pixels
</a><a name="611">  611 &nbsp; 	 *            are replaced by this color
  612 &nbsp; 	 * @param forceBW
  613 &nbsp; 	 *            if &lt;CODE&gt;true&lt;/CODE&gt; the image is treated as black and white
  614 &nbsp; 	 * @return an object of type &lt;CODE&gt;ImgRaw&lt;/CODE&gt;
  615 &nbsp; 	 * @throws BadElementException
  616 &nbsp; 	 *             on error
  617 &nbsp; 	 * @throws IOException
  618 &nbsp; 	 *             on error
  619 &nbsp; 	 */
  620 &nbsp; 	public static Image getInstance(java.awt.Image image, java.awt.Color color,
</a><a name="621">  621 &nbsp; 			boolean forceBW) throws BadElementException, IOException {
  622 &nbsp; 		
  623 &nbsp; 		if(image instanceof BufferedImage){
  624 &nbsp; 			BufferedImage bi = (BufferedImage) image;
  625 &nbsp; 			if(bi.getType()==BufferedImage.TYPE_BYTE_BINARY) {
  626 &nbsp; 				forceBW=true;
  627 &nbsp; 			}
  628 &nbsp; 		}
  629 &nbsp; 		
  630 &nbsp; 		java.awt.image.PixelGrabber pg = new java.awt.image.PixelGrabber(image,
</a><a name="631">  631 &nbsp; 				0, 0, -1, -1, true);
  632 &nbsp; 		try {
  633 &nbsp; 			pg.grabPixels();
  634 &nbsp; 		} catch (InterruptedException e) {
  635 &nbsp; 			throw new IOException(
  636 &nbsp; 					"java.awt.Image Interrupted waiting for pixels!");
  637 &nbsp; 		}
  638 &nbsp; 		if ((pg.getStatus() &amp; java.awt.image.ImageObserver.ABORT) != 0) {
  639 &nbsp; 			throw new IOException("java.awt.Image fetch aborted or errored");
  640 &nbsp; 		}
</a><a name="641">  641 &nbsp; 		int w = pg.getWidth();
  642 &nbsp; 		int h = pg.getHeight();
  643 &nbsp; 		int[] pixels = (int[]) pg.getPixels();
  644 &nbsp; 		if (forceBW) {
  645 &nbsp; 			int byteWidth = (w / 8) + ((w &amp; 7) != 0 ? 1 : 0);
  646 &nbsp; 			byte[] pixelsByte = new byte[byteWidth * h];
  647 &nbsp; 
  648 &nbsp; 			int index = 0;
  649 &nbsp; 			int size = h * w;
  650 &nbsp; 			int transColor = 1;
</a><a name="651">  651 &nbsp; 			if (color != null) {
  652 &nbsp; 				transColor = (color.getRed() + color.getGreen()
  653 &nbsp; 						+ color.getBlue() &lt; 384) ? 0 : 1;
  654 &nbsp; 			}
  655 &nbsp; 			int transparency[] = null;
  656 &nbsp; 			int cbyte = 0x80;
  657 &nbsp; 			int wMarker = 0;
  658 &nbsp; 			int currByte = 0;
  659 &nbsp; 			if (color != null) {
  660 &nbsp; 				for (int j = 0; j &lt; size; j++) {
</a><a name="661">  661 &nbsp; 					int alpha = (pixels[j] &gt;&gt; 24) &amp; 0xff;
  662 &nbsp; 					if (alpha &lt; 250) {
  663 &nbsp; 						if (transColor == 1)
  664 &nbsp; 							currByte |= cbyte;
  665 &nbsp; 					} else {
  666 &nbsp; 						if ((pixels[j] &amp; 0x888) != 0)
  667 &nbsp; 							currByte |= cbyte;
  668 &nbsp; 					}
  669 &nbsp; 					cbyte &gt;&gt;= 1;
  670 &nbsp; 					if (cbyte == 0 || wMarker + 1 &gt;= w) {
</a><a name="671">  671 &nbsp; 						pixelsByte[index++] = (byte) currByte;
  672 &nbsp; 						cbyte = 0x80;
  673 &nbsp; 						currByte = 0;
  674 &nbsp; 					}
  675 &nbsp; 					++wMarker;
  676 &nbsp; 					if (wMarker &gt;= w)
  677 &nbsp; 						wMarker = 0;
  678 &nbsp; 				}
  679 &nbsp; 			} else {
  680 &nbsp; 				for (int j = 0; j &lt; size; j++) {
</a><a name="681">  681 &nbsp; 					if (transparency == null) {
  682 &nbsp; 						int alpha = (pixels[j] &gt;&gt; 24) &amp; 0xff;
  683 &nbsp; 						if (alpha == 0) {
  684 &nbsp; 							transparency = new int[2];
  685 &nbsp; 							/* bugfix by M.P. Liston, ASC, was: ... ? 1: 0; */
  686 &nbsp; 							transparency[0] = transparency[1] = ((pixels[j] &amp; 0x888) != 0) ? 0xff : 0;
  687 &nbsp; 						}
  688 &nbsp; 					}
  689 &nbsp; 					if ((pixels[j] &amp; 0x888) != 0)
  690 &nbsp; 						currByte |= cbyte;
</a><a name="691">  691 &nbsp; 					cbyte &gt;&gt;= 1;
  692 &nbsp; 					if (cbyte == 0 || wMarker + 1 &gt;= w) {
  693 &nbsp; 						pixelsByte[index++] = (byte) currByte;
  694 &nbsp; 						cbyte = 0x80;
  695 &nbsp; 						currByte = 0;
  696 &nbsp; 					}
  697 &nbsp; 					++wMarker;
  698 &nbsp; 					if (wMarker &gt;= w)
  699 &nbsp; 						wMarker = 0;
  700 &nbsp; 				}
</a><a name="701">  701 &nbsp; 			}
  702 &nbsp; 			return Image.getInstance(w, h, 1, 1, pixelsByte, transparency);
  703 &nbsp; 		} else {
  704 &nbsp; 			byte[] pixelsByte = new byte[w * h * 3];
  705 &nbsp; 			byte[] smask = null;
  706 &nbsp; 
  707 &nbsp; 			int index = 0;
  708 &nbsp; 			int size = h * w;
  709 &nbsp; 			int red = 255;
  710 &nbsp; 			int green = 255;
</a><a name="711">  711 &nbsp; 			int blue = 255;
  712 &nbsp; 			if (color != null) {
  713 &nbsp; 				red = color.getRed();
  714 &nbsp; 				green = color.getGreen();
  715 &nbsp; 				blue = color.getBlue();
  716 &nbsp; 			}
  717 &nbsp; 			int transparency[] = null;
  718 &nbsp; 			if (color != null) {
  719 &nbsp; 				for (int j = 0; j &lt; size; j++) {
  720 &nbsp; 					int alpha = (pixels[j] &gt;&gt; 24) &amp; 0xff;
</a><a name="721">  721 &nbsp; 					if (alpha &lt; 250) {
  722 &nbsp; 						pixelsByte[index++] = (byte) red;
  723 &nbsp; 						pixelsByte[index++] = (byte) green;
  724 &nbsp; 						pixelsByte[index++] = (byte) blue;
  725 &nbsp; 					} else {
  726 &nbsp; 						pixelsByte[index++] = (byte) ((pixels[j] &gt;&gt; 16) &amp; 0xff);
  727 &nbsp; 						pixelsByte[index++] = (byte) ((pixels[j] &gt;&gt; 8) &amp; 0xff);
  728 &nbsp; 						pixelsByte[index++] = (byte) ((pixels[j]) &amp; 0xff);
  729 &nbsp; 					}
  730 &nbsp; 				}
</a><a name="731">  731 &nbsp; 			} else {
  732 &nbsp; 				int transparentPixel = 0;
  733 &nbsp; 				smask = new byte[w * h];
  734 &nbsp; 				boolean shades = false;
  735 &nbsp; 				for (int j = 0; j &lt; size; j++) {
  736 &nbsp; 					byte alpha = smask[j] = (byte) ((pixels[j] &gt;&gt; 24) &amp; 0xff);
  737 &nbsp; 					/* bugfix by Chris Nokleberg */
  738 &nbsp; 					if (!shades) {
  739 &nbsp; 						if (alpha != 0 &amp;&amp; alpha != -1) {
  740 &nbsp; 							shades = true;
</a><a name="741">  741 &nbsp; 						} else if (transparency == null) {
  742 &nbsp; 							if (alpha == 0) {
  743 &nbsp; 								transparentPixel = pixels[j] &amp; 0xffffff;
  744 &nbsp; 								transparency = new int[6];
  745 &nbsp; 								transparency[0] = transparency[1] = (transparentPixel &gt;&gt; 16) &amp; 0xff;
  746 &nbsp; 								transparency[2] = transparency[3] = (transparentPixel &gt;&gt; 8) &amp; 0xff;
  747 &nbsp; 								transparency[4] = transparency[5] = transparentPixel &amp; 0xff;
  748 &nbsp; 							}
  749 &nbsp; 						} else if ((pixels[j] &amp; 0xffffff) != transparentPixel) {
  750 &nbsp; 							shades = true;
</a><a name="751">  751 &nbsp; 						}
  752 &nbsp; 					}
  753 &nbsp; 					pixelsByte[index++] = (byte) ((pixels[j] &gt;&gt; 16) &amp; 0xff);
  754 &nbsp; 					pixelsByte[index++] = (byte) ((pixels[j] &gt;&gt; 8) &amp; 0xff);
  755 &nbsp; 					pixelsByte[index++] = (byte) ((pixels[j]) &amp; 0xff);
  756 &nbsp; 				}
  757 &nbsp; 				if (shades)
  758 &nbsp; 					transparency = null;
  759 &nbsp; 				else
  760 &nbsp; 					smask = null;
</a><a name="761">  761 &nbsp; 			}
  762 &nbsp; 			Image img = Image.getInstance(w, h, 3, 8, pixelsByte, transparency);
  763 &nbsp; 			if (smask != null) {
  764 &nbsp; 				Image sm = Image.getInstance(w, h, 1, 8, smask);
  765 &nbsp; 				try {
  766 &nbsp; 					sm.makeMask();
  767 &nbsp; 					img.setImageMask(sm);
  768 &nbsp; 				} catch (DocumentException de) {
  769 &nbsp; 					throw new ExceptionConverter(de);
  770 &nbsp; 				}
</a><a name="771">  771 &nbsp; 			}
  772 &nbsp; 			return img;
  773 &nbsp; 		}
  774 &nbsp; 	}
  775 &nbsp; 
  776 &nbsp; 	/**
  777 &nbsp; 	 * Gets an instance of an Image from a java.awt.Image.
  778 &nbsp; 	 * 
  779 &nbsp; 	 * @param image
  780 &nbsp; 	 *            the &lt;CODE&gt;java.awt.Image&lt;/CODE&gt; to convert
</a><a name="781">  781 &nbsp; 	 * @param color
  782 &nbsp; 	 *            if different from &lt;CODE&gt;null&lt;/CODE&gt; the transparency pixels
  783 &nbsp; 	 *            are replaced by this color
  784 &nbsp; 	 * @return an object of type &lt;CODE&gt;ImgRaw&lt;/CODE&gt;
  785 &nbsp; 	 * @throws BadElementException
  786 &nbsp; 	 *             on error
  787 &nbsp; 	 * @throws IOException
  788 &nbsp; 	 *             on error
  789 &nbsp; 	 */
  790 &nbsp; 	public static Image getInstance(java.awt.Image image, java.awt.Color color)
</a><a name="791">  791 &nbsp; 			throws BadElementException, IOException {
  792 &nbsp; 		return Image.getInstance(image, color, false);
  793 &nbsp; 	}
  794 &nbsp; 	
  795 &nbsp; 	/**
  796 &nbsp; 	 * Gets an instance of a Image from a java.awt.Image.
  797 &nbsp; 	 * The image is added as a JPEG with a user defined quality.
  798 &nbsp; 	 * 
  799 &nbsp; 	 * @param writer
  800 &nbsp; 	 *            the &lt;CODE&gt;PdfWriter&lt;/CODE&gt; object to which the image will be added
</a><a name="801">  801 &nbsp; 	 * @param awtImage
  802 &nbsp; 	 *            the &lt;CODE&gt;java.awt.Image&lt;/CODE&gt; to convert
  803 &nbsp; 	 * @param quality
  804 &nbsp; 	 *            a float value between 0 and 1
  805 &nbsp; 	 * @return an object of type &lt;CODE&gt;PdfTemplate&lt;/CODE&gt;
  806 &nbsp; 	 * @throws BadElementException
  807 &nbsp; 	 *             on error
  808 &nbsp; 	 * @throws IOException
  809 &nbsp; 	 */
  810 &nbsp; 	public static Image getInstance(PdfWriter writer, java.awt.Image awtImage, float quality) throws BadElementException, IOException {
</a><a name="811">  811 &nbsp; 		return getInstance(new PdfContentByte(writer), awtImage, quality);
  812 &nbsp; 	}
  813 &nbsp; 	
  814 &nbsp;     /**
  815 &nbsp;      * Gets an instance of a Image from a java.awt.Image.
  816 &nbsp;      * The image is added as a JPEG with a user defined quality.
  817 &nbsp;      *
  818 &nbsp;      * @param cb
  819 &nbsp;      *            the &lt;CODE&gt;PdfContentByte&lt;/CODE&gt; object to which the image will be added
  820 &nbsp;      * @param awtImage
</a><a name="821">  821 &nbsp;      *            the &lt;CODE&gt;java.awt.Image&lt;/CODE&gt; to convert
  822 &nbsp;      * @param quality
  823 &nbsp;      *            a float value between 0 and 1
  824 &nbsp;      * @return an object of type &lt;CODE&gt;PdfTemplate&lt;/CODE&gt;
  825 &nbsp;      * @throws BadElementException
  826 &nbsp;      *             on error
  827 &nbsp;      * @throws IOException
  828 &nbsp;      */
  829 &nbsp;     public static Image getInstance(PdfContentByte cb, java.awt.Image awtImage, float quality) throws BadElementException, IOException {
  830 &nbsp;         java.awt.image.PixelGrabber pg = new java.awt.image.PixelGrabber(awtImage,
</a><a name="831">  831 &nbsp;                 0, 0, -1, -1, true);
  832 &nbsp;         try {
  833 &nbsp;             pg.grabPixels();
  834 &nbsp;         } catch (InterruptedException e) {
  835 &nbsp;             throw new IOException(
  836 &nbsp;                     "java.awt.Image Interrupted waiting for pixels!");
  837 &nbsp;         }
  838 &nbsp;         if ((pg.getStatus() &amp; java.awt.image.ImageObserver.ABORT) != 0) {
  839 &nbsp;             throw new IOException("java.awt.Image fetch aborted or errored");
  840 &nbsp;         }
</a><a name="841">  841 &nbsp;         int w = pg.getWidth();
  842 &nbsp;         int h = pg.getHeight();
  843 &nbsp;         PdfTemplate tp = cb.createTemplate(w, h);
  844 &nbsp;         Graphics2D g2d = tp.createGraphics(w, h, true, quality);
  845 &nbsp;         g2d.drawImage(awtImage, 0, 0, null);
  846 &nbsp;         g2d.dispose();
  847 &nbsp;         return getInstance(tp);
  848 &nbsp;     }
  849 &nbsp; 
  850 &nbsp;     // image from indirect reference
</a><a name="851">  851 &nbsp;     
  852 &nbsp;     /**
  853 &nbsp;      * Holds value of property directReference.
  854 &nbsp;      * An image is embedded into a PDF as an Image XObject.
  855 &nbsp;      * This object is referenced by a PdfIndirectReference object.
  856 &nbsp;      */
  857 &nbsp;     private PdfIndirectReference directReference;
  858 &nbsp;     
  859 &nbsp;     /**
  860 &nbsp;      * Getter for property directReference.
</a><a name="861">  861 &nbsp;      * @return Value of property directReference.
  862 &nbsp;      */
  863 &nbsp;     public PdfIndirectReference getDirectReference() {
  864 &nbsp;         return this.directReference;
  865 &nbsp;     }
  866 &nbsp;     
  867 &nbsp;     /**
  868 &nbsp;      * Setter for property directReference.
  869 &nbsp;      * @param directReference New value of property directReference.
  870 &nbsp;      */
</a><a name="871">  871 &nbsp;     public void setDirectReference(PdfIndirectReference directReference) {
  872 &nbsp;         this.directReference = directReference;
  873 &nbsp;     }
  874 &nbsp;     
  875 &nbsp;     /**
  876 &nbsp;      * Reuses an existing image.
  877 &nbsp;      * @param ref the reference to the image dictionary
  878 &nbsp;      * @throws BadElementException on error
  879 &nbsp;      * @return the image
  880 &nbsp;      */    
</a><a name="881">  881 &nbsp;     public static Image getInstance(PRIndirectReference ref) throws BadElementException {
  882 &nbsp;         PdfDictionary dic = (PdfDictionary)PdfReader.getPdfObjectRelease(ref);
  883 &nbsp;         int width = ((PdfNumber)PdfReader.getPdfObjectRelease(dic.get(PdfName.WIDTH))).intValue();
  884 &nbsp;         int height = ((PdfNumber)PdfReader.getPdfObjectRelease(dic.get(PdfName.HEIGHT))).intValue();
  885 &nbsp;         Image imask = null;
  886 &nbsp;         PdfObject obj = dic.get(PdfName.SMASK);
  887 &nbsp;         if (obj != null &amp;&amp; obj.isIndirect()) {
  888 &nbsp;             imask = getInstance((PRIndirectReference)obj);
  889 &nbsp;         }
  890 &nbsp;         else {
</a><a name="891">  891 &nbsp;             obj = dic.get(PdfName.MASK);
  892 &nbsp;             if (obj != null &amp;&amp; obj.isIndirect()) {
  893 &nbsp;                 PdfObject obj2 = PdfReader.getPdfObjectRelease(obj);
  894 &nbsp;                 if (obj2 instanceof PdfDictionary)
  895 &nbsp;                     imask = getInstance((PRIndirectReference)obj);
  896 &nbsp;             }
  897 &nbsp;         }
  898 &nbsp;         Image img = new ImgRaw(width, height, 1, 1, null);
  899 &nbsp;         img.imageMask = imask;
  900 &nbsp;         img.directReference = ref;
</a><a name="901">  901 &nbsp;         return img;
  902 &nbsp;     }
  903 &nbsp; 
  904 &nbsp;     // copy constructor
  905 &nbsp;     
  906 &nbsp; 	/**
  907 &nbsp; 	 * Constructs an &lt;CODE&gt;Image&lt;/CODE&gt; -object, using an &lt;VAR&gt;url &lt;/VAR&gt;.
  908 &nbsp; 	 * 
  909 &nbsp; 	 * @param image
  910 &nbsp; 	 *            another Image object.
</a><a name="911">  911 &nbsp; 	 */
  912 &nbsp; 	protected Image(Image image) {
  913 &nbsp; 		super(image);
  914 &nbsp; 		this.type = image.type;
  915 &nbsp; 		this.url = image.url;
  916 &nbsp; 		this.rawData = image.rawData;
  917 &nbsp; 		this.bpc = image.bpc;
  918 &nbsp; 		this.template = image.template;
  919 &nbsp; 		this.alignment = image.alignment;
  920 &nbsp; 		this.alt = image.alt;
</a><a name="921">  921 &nbsp; 		this.absoluteX = image.absoluteX;
  922 &nbsp; 		this.absoluteY = image.absoluteY;
  923 &nbsp; 		this.plainWidth = image.plainWidth;
  924 &nbsp; 		this.plainHeight = image.plainHeight;
  925 &nbsp; 		this.scaledWidth = image.scaledWidth;
  926 &nbsp; 		this.scaledHeight = image.scaledHeight;
  927 &nbsp; 		this.mySerialId = image.mySerialId;
  928 &nbsp; 
  929 &nbsp;         this.directReference = image.directReference;
  930 &nbsp;         
</a><a name="931">  931 &nbsp; 		this.rotationRadians = image.rotationRadians;
  932 &nbsp;         this.initialRotation = image.initialRotation;
  933 &nbsp;         this.indentationLeft = image.indentationLeft;
  934 &nbsp;         this.indentationRight = image.indentationRight;
  935 &nbsp; 		this.spacingBefore = image.spacingBefore;
  936 &nbsp; 		this.spacingAfter = image.spacingAfter;
  937 &nbsp; 
  938 &nbsp; 		this.widthPercentage = image.widthPercentage;
  939 &nbsp; 		this.annotation = image.annotation;
  940 &nbsp; 		this.layer = image.layer;
</a><a name="941">  941 &nbsp; 		this.interpolation = image.interpolation;
  942 &nbsp; 		this.originalType = image.originalType;
  943 &nbsp; 		this.originalData = image.originalData;
  944 &nbsp; 		this.deflated = image.deflated;
  945 &nbsp; 		this.dpiX = image.dpiX;
  946 &nbsp; 		this.dpiY = image.dpiY;
  947 &nbsp; 		this.XYRatio = image.XYRatio;
  948 &nbsp; 		
  949 &nbsp; 		this.colorspace = image.colorspace;
  950 &nbsp; 		this.invert = image.invert;
</a><a name="951">  951 &nbsp; 		this.profile = image.profile;
  952 &nbsp; 		this.additional = image.additional;
  953 &nbsp; 		this.mask = image.mask;
  954 &nbsp; 		this.imageMask = image.imageMask;
  955 &nbsp; 		this.smask = image.smask;
  956 &nbsp; 		this.transparency = image.transparency;
  957 &nbsp; 	}
  958 &nbsp; 
  959 &nbsp; 	/**
  960 &nbsp; 	 * gets an instance of an Image
</a><a name="961">  961 &nbsp; 	 * 
  962 &nbsp; 	 * @param image
  963 &nbsp; 	 *            an Image object
  964 &nbsp; 	 * @return a new Image object
  965 &nbsp; 	 */
  966 &nbsp; 	public static Image getInstance(Image image) {
  967 &nbsp; 		if (image == null)
  968 &nbsp; 			return null;
  969 &nbsp; 		try {
  970 &nbsp; 			Class cs = image.getClass();
</a><a name="971">  971 &nbsp; 			Constructor constructor = cs
  972 &nbsp; 					.getDeclaredConstructor(new Class[] { Image.class });
  973 &nbsp; 			return (Image) constructor.newInstance(new Object[] { image });
  974 &nbsp; 		} catch (Exception e) {
  975 &nbsp; 			throw new ExceptionConverter(e);
  976 &nbsp; 		}
  977 &nbsp; 	}
  978 &nbsp; 
  979 &nbsp; 	// implementation of the Element interface
  980 &nbsp; 	
</a><a name="981">  981 &nbsp; 	/**
  982 &nbsp; 	 * Returns the type.
  983 &nbsp; 	 * 
  984 &nbsp; 	 * @return a type
  985 &nbsp; 	 */
  986 &nbsp; 
  987 &nbsp; 	public int type() {
  988 &nbsp; 		return type;
  989 &nbsp; 	}
  990 &nbsp; 
</a><a name="991">  991 &nbsp; 	/**
  992 &nbsp; 	 * @see com.lowagie.text.Element#isNestable()
  993 &nbsp; 	 * @since	iText 2.0.8
  994 &nbsp; 	 */
  995 &nbsp; 	public boolean isNestable() {
  996 &nbsp; 		return true;
  997 &nbsp; 	}
  998 &nbsp; 
  999 &nbsp; 	// checking the type of Image
 1000 &nbsp; 
</a><a name="1001"> 1001 &nbsp; 	/**
 1002 &nbsp; 	 * Returns &lt;CODE&gt;true&lt;/CODE&gt; if the image is a &lt;CODE&gt;Jpeg&lt;/CODE&gt;
 1003 &nbsp; 	 * -object.
 1004 &nbsp; 	 * 
 1005 &nbsp; 	 * @return a &lt;CODE&gt;boolean&lt;/CODE&gt;
 1006 &nbsp; 	 */
 1007 &nbsp; 
 1008 &nbsp; 	public boolean isJpeg() {
 1009 &nbsp; 		return type == JPEG;
 1010 &nbsp; 	}
</a><a name="1011"> 1011 &nbsp; 
 1012 &nbsp; 	/**
 1013 &nbsp; 	 * Returns &lt;CODE&gt;true&lt;/CODE&gt; if the image is a &lt;CODE&gt;ImgRaw&lt;/CODE&gt;
 1014 &nbsp; 	 * -object.
 1015 &nbsp; 	 * 
 1016 &nbsp; 	 * @return a &lt;CODE&gt;boolean&lt;/CODE&gt;
 1017 &nbsp; 	 */
 1018 &nbsp; 
 1019 &nbsp; 	public boolean isImgRaw() {
 1020 &nbsp; 		return type == IMGRAW;
</a><a name="1021"> 1021 &nbsp; 	}
 1022 &nbsp; 
 1023 &nbsp; 	/**
 1024 &nbsp; 	 * Returns &lt;CODE&gt;true&lt;/CODE&gt; if the image is an &lt;CODE&gt;ImgTemplate&lt;/CODE&gt;
 1025 &nbsp; 	 * -object.
 1026 &nbsp; 	 * 
 1027 &nbsp; 	 * @return a &lt;CODE&gt;boolean&lt;/CODE&gt;
 1028 &nbsp; 	 */
 1029 &nbsp; 
 1030 &nbsp; 	public boolean isImgTemplate() {
</a><a name="1031"> 1031 &nbsp; 		return type == IMGTEMPLATE;
 1032 &nbsp; 	}
 1033 &nbsp; 	
 1034 &nbsp; 	// getters and setters
 1035 &nbsp; 
 1036 &nbsp; 	/**
 1037 &nbsp; 	 * Gets the &lt;CODE&gt;String&lt;/CODE&gt; -representation of the reference to the
 1038 &nbsp; 	 * image.
 1039 &nbsp; 	 * 
 1040 &nbsp; 	 * @return a &lt;CODE&gt;String&lt;/CODE&gt;
</a><a name="1041"> 1041 &nbsp; 	 */
 1042 &nbsp; 
 1043 &nbsp; 	public URL getUrl() {
 1044 &nbsp; 		return url;
 1045 &nbsp; 	}
 1046 &nbsp; 
 1047 &nbsp; 	/**
 1048 &nbsp; 	 * Sets the url of the image
 1049 &nbsp; 	 * 
 1050 &nbsp; 	 * @param url
</a><a name="1051"> 1051 &nbsp; 	 *            the url of the image
 1052 &nbsp; 	 */
 1053 &nbsp; 	public void setUrl(URL url) {
 1054 &nbsp; 		this.url = url;
 1055 &nbsp; 	}
 1056 &nbsp; 
 1057 &nbsp; 	/**
 1058 &nbsp; 	 * Gets the raw data for the image.
 1059 &nbsp; 	 * &lt;P&gt;
 1060 &nbsp; 	 * Remark: this only makes sense for Images of the type &lt;CODE&gt;RawImage
</a><a name="1061"> 1061 &nbsp; 	 * &lt;/CODE&gt;.
 1062 &nbsp; 	 * 
 1063 &nbsp; 	 * @return the raw data
 1064 &nbsp; 	 */
 1065 &nbsp; 	public byte[] getRawData() {
 1066 &nbsp; 		return rawData;
 1067 &nbsp; 	}
 1068 &nbsp; 
 1069 &nbsp; 	/**
 1070 &nbsp; 	 * Gets the bpc for the image.
</a><a name="1071"> 1071 &nbsp; 	 * &lt;P&gt;
 1072 &nbsp; 	 * Remark: this only makes sense for Images of the type &lt;CODE&gt;RawImage
 1073 &nbsp; 	 * &lt;/CODE&gt;.
 1074 &nbsp; 	 * 
 1075 &nbsp; 	 * @return a bpc value
 1076 &nbsp; 	 */
 1077 &nbsp; 	public int getBpc() {
 1078 &nbsp; 		return bpc;
 1079 &nbsp; 	}
 1080 &nbsp; 
</a><a name="1081"> 1081 &nbsp; 	/**
 1082 &nbsp; 	 * Gets the template to be used as an image.
 1083 &nbsp; 	 * &lt;P&gt;
 1084 &nbsp; 	 * Remark: this only makes sense for Images of the type &lt;CODE&gt;ImgTemplate
 1085 &nbsp; 	 * &lt;/CODE&gt;.
 1086 &nbsp; 	 * 
 1087 &nbsp; 	 * @return the template
 1088 &nbsp; 	 */
 1089 &nbsp; 	public PdfTemplate getTemplateData() {
 1090 &nbsp; 		return template[0];
</a><a name="1091"> 1091 &nbsp; 	}
 1092 &nbsp; 
 1093 &nbsp; 	/**
 1094 &nbsp; 	 * Sets data from a PdfTemplate
 1095 &nbsp; 	 * 
 1096 &nbsp; 	 * @param template
 1097 &nbsp; 	 *            the template with the content
 1098 &nbsp; 	 */
 1099 &nbsp; 	public void setTemplateData(PdfTemplate template) {
 1100 &nbsp; 		this.template[0] = template;
</a><a name="1101"> 1101 &nbsp; 	}
 1102 &nbsp; 
 1103 &nbsp; 	/**
 1104 &nbsp; 	 * Gets the alignment for the image.
 1105 &nbsp; 	 * 
 1106 &nbsp; 	 * @return a value
 1107 &nbsp; 	 */
 1108 &nbsp; 	public int getAlignment() {
 1109 &nbsp; 		return alignment;
 1110 &nbsp; 	}
</a><a name="1111"> 1111 &nbsp; 
 1112 &nbsp; 	/**
 1113 &nbsp; 	 * Sets the alignment for the image.
 1114 &nbsp; 	 * 
 1115 &nbsp; 	 * @param alignment
 1116 &nbsp; 	 *            the alignment
 1117 &nbsp; 	 */
 1118 &nbsp; 
 1119 &nbsp; 	public void setAlignment(int alignment) {
 1120 &nbsp; 		this.alignment = alignment;
</a><a name="1121"> 1121 &nbsp; 	}
 1122 &nbsp; 
 1123 &nbsp; 	/**
 1124 &nbsp; 	 * Gets the alternative text for the image.
 1125 &nbsp; 	 * 
 1126 &nbsp; 	 * @return a &lt;CODE&gt;String&lt;/CODE&gt;
 1127 &nbsp; 	 */
 1128 &nbsp; 
 1129 &nbsp; 	public String getAlt() {
 1130 &nbsp; 		return alt;
</a><a name="1131"> 1131 &nbsp; 	}
 1132 &nbsp; 
 1133 &nbsp; 	/**
 1134 &nbsp; 	 * Sets the alternative information for the image.
 1135 &nbsp; 	 * 
 1136 &nbsp; 	 * @param alt
 1137 &nbsp; 	 *            the alternative information
 1138 &nbsp; 	 */
 1139 &nbsp; 
 1140 &nbsp; 	public void setAlt(String alt) {
</a><a name="1141"> 1141 &nbsp; 		this.alt = alt;
 1142 &nbsp; 	}
 1143 &nbsp; 
 1144 &nbsp; 	/**
 1145 &nbsp; 	 * Sets the absolute position of the &lt;CODE&gt;Image&lt;/CODE&gt;.
 1146 &nbsp; 	 * 
 1147 &nbsp; 	 * @param absoluteX
 1148 &nbsp; 	 * @param absoluteY
 1149 &nbsp; 	 */
 1150 &nbsp; 
</a><a name="1151"> 1151 &nbsp; 	public void setAbsolutePosition(float absoluteX, float absoluteY) {
 1152 &nbsp; 		this.absoluteX = absoluteX;
 1153 &nbsp; 		this.absoluteY = absoluteY;
 1154 &nbsp; 	}
 1155 &nbsp; 
 1156 &nbsp; 	/**
 1157 &nbsp; 	 * Checks if the &lt;CODE&gt;Images&lt;/CODE&gt; has to be added at an absolute X
 1158 &nbsp; 	 * position.
 1159 &nbsp; 	 * 
 1160 &nbsp; 	 * @return a boolean
</a><a name="1161"> 1161 &nbsp; 	 */
 1162 &nbsp; 	public boolean hasAbsoluteX() {
 1163 &nbsp; 		return !Float.isNaN(absoluteX);
 1164 &nbsp; 	}
 1165 &nbsp; 
 1166 &nbsp; 	/**
 1167 &nbsp; 	 * Returns the absolute X position.
 1168 &nbsp; 	 * 
 1169 &nbsp; 	 * @return a position
 1170 &nbsp; 	 */
</a><a name="1171"> 1171 &nbsp; 	public float getAbsoluteX() {
 1172 &nbsp; 		return absoluteX;
 1173 &nbsp; 	}
 1174 &nbsp; 
 1175 &nbsp; 	/**
 1176 &nbsp; 	 * Checks if the &lt;CODE&gt;Images&lt;/CODE&gt; has to be added at an absolute
 1177 &nbsp; 	 * position.
 1178 &nbsp; 	 * 
 1179 &nbsp; 	 * @return a boolean
 1180 &nbsp; 	 */
</a><a name="1181"> 1181 &nbsp; 	public boolean hasAbsoluteY() {
 1182 &nbsp; 		return !Float.isNaN(absoluteY);
 1183 &nbsp; 	}
 1184 &nbsp; 
 1185 &nbsp; 	/**
 1186 &nbsp; 	 * Returns the absolute Y position.
 1187 &nbsp; 	 * 
 1188 &nbsp; 	 * @return a position
 1189 &nbsp; 	 */
 1190 &nbsp; 	public float getAbsoluteY() {
</a><a name="1191"> 1191 &nbsp; 		return absoluteY;
 1192 &nbsp; 	}
 1193 &nbsp; 
 1194 &nbsp; 	// width and height
 1195 &nbsp; 
 1196 &nbsp; 	/**
 1197 &nbsp; 	 * Gets the scaled width of the image.
 1198 &nbsp; 	 * 
 1199 &nbsp; 	 * @return a value
 1200 &nbsp; 	 */
</a><a name="1201"> 1201 &nbsp; 	public float getScaledWidth() {
 1202 &nbsp; 		return scaledWidth;
 1203 &nbsp; 	}
 1204 &nbsp; 
 1205 &nbsp; 	/**
 1206 &nbsp; 	 * Gets the scaled height of the image.
 1207 &nbsp; 	 * 
 1208 &nbsp; 	 * @return a value
 1209 &nbsp; 	 */
 1210 &nbsp; 	public float getScaledHeight() {
</a><a name="1211"> 1211 &nbsp; 		return scaledHeight;
 1212 &nbsp; 	}
 1213 &nbsp; 
 1214 &nbsp; 	/**
 1215 &nbsp; 	 * Gets the plain width of the image.
 1216 &nbsp; 	 * 
 1217 &nbsp; 	 * @return a value
 1218 &nbsp; 	 */
 1219 &nbsp; 	public float getPlainWidth() {
 1220 &nbsp; 		return plainWidth;
</a><a name="1221"> 1221 &nbsp; 	}
 1222 &nbsp; 
 1223 &nbsp; 	/**
 1224 &nbsp; 	 * Gets the plain height of the image.
 1225 &nbsp; 	 * 
 1226 &nbsp; 	 * @return a value
 1227 &nbsp; 	 */
 1228 &nbsp; 	public float getPlainHeight() {
 1229 &nbsp; 		return plainHeight;
 1230 &nbsp; 	}
</a><a name="1231"> 1231 &nbsp; 	
 1232 &nbsp; 	/**
 1233 &nbsp; 	 * Scale the image to an absolute width and an absolute height.
 1234 &nbsp; 	 * 
 1235 &nbsp; 	 * @param newWidth
 1236 &nbsp; 	 *            the new width
 1237 &nbsp; 	 * @param newHeight
 1238 &nbsp; 	 *            the new height
 1239 &nbsp; 	 */
 1240 &nbsp; 	public void scaleAbsolute(float newWidth, float newHeight) {
</a><a name="1241"> 1241 &nbsp; 		plainWidth = newWidth;
 1242 &nbsp; 		plainHeight = newHeight;
 1243 &nbsp; 		float[] matrix = matrix();
 1244 &nbsp; 		scaledWidth = matrix[DX] - matrix[CX];
 1245 &nbsp; 		scaledHeight = matrix[DY] - matrix[CY];
 1246 &nbsp; 		setWidthPercentage(0);
 1247 &nbsp; 	}
 1248 &nbsp; 
 1249 &nbsp; 	/**
 1250 &nbsp; 	 * Scale the image to an absolute width.
</a><a name="1251"> 1251 &nbsp; 	 * 
 1252 &nbsp; 	 * @param newWidth
 1253 &nbsp; 	 *            the new width
 1254 &nbsp; 	 */
 1255 &nbsp; 	public void scaleAbsoluteWidth(float newWidth) {
 1256 &nbsp; 		plainWidth = newWidth;
 1257 &nbsp; 		float[] matrix = matrix();
 1258 &nbsp; 		scaledWidth = matrix[DX] - matrix[CX];
 1259 &nbsp; 		scaledHeight = matrix[DY] - matrix[CY];
 1260 &nbsp; 		setWidthPercentage(0);
</a><a name="1261"> 1261 &nbsp; 	}
 1262 &nbsp; 
 1263 &nbsp; 	/**
 1264 &nbsp; 	 * Scale the image to an absolute height.
 1265 &nbsp; 	 * 
 1266 &nbsp; 	 * @param newHeight
 1267 &nbsp; 	 *            the new height
 1268 &nbsp; 	 */
 1269 &nbsp; 	public void scaleAbsoluteHeight(float newHeight) {
 1270 &nbsp; 		plainHeight = newHeight;
</a><a name="1271"> 1271 &nbsp; 		float[] matrix = matrix();
 1272 &nbsp; 		scaledWidth = matrix[DX] - matrix[CX];
 1273 &nbsp; 		scaledHeight = matrix[DY] - matrix[CY];
 1274 &nbsp; 		setWidthPercentage(0);
 1275 &nbsp; 	}
 1276 &nbsp; 
 1277 &nbsp; 	/**
 1278 &nbsp; 	 * Scale the image to a certain percentage.
 1279 &nbsp; 	 * 
 1280 &nbsp; 	 * @param percent
</a><a name="1281"> 1281 &nbsp; 	 *            the scaling percentage
 1282 &nbsp; 	 */
 1283 &nbsp; 	public void scalePercent(float percent) {
 1284 &nbsp; 		scalePercent(percent, percent);
 1285 &nbsp; 	}
 1286 &nbsp; 
 1287 &nbsp; 	/**
 1288 &nbsp; 	 * Scale the width and height of an image to a certain percentage.
 1289 &nbsp; 	 * 
 1290 &nbsp; 	 * @param percentX
</a><a name="1291"> 1291 &nbsp; 	 *            the scaling percentage of the width
 1292 &nbsp; 	 * @param percentY
 1293 &nbsp; 	 *            the scaling percentage of the height
 1294 &nbsp; 	 */
 1295 &nbsp; 	public void scalePercent(float percentX, float percentY) {
 1296 &nbsp; 		plainWidth = (getWidth() * percentX) / 100f;
 1297 &nbsp; 		plainHeight = (getHeight() * percentY) / 100f;
 1298 &nbsp; 		float[] matrix = matrix();
 1299 &nbsp; 		scaledWidth = matrix[DX] - matrix[CX];
 1300 &nbsp; 		scaledHeight = matrix[DY] - matrix[CY];
</a><a name="1301"> 1301 &nbsp; 		setWidthPercentage(0);
 1302 &nbsp; 	}
 1303 &nbsp; 
 1304 &nbsp; 	/**
 1305 &nbsp; 	 * Scales the image so that it fits a certain width and height.
 1306 &nbsp; 	 * 
 1307 &nbsp; 	 * @param fitWidth
 1308 &nbsp; 	 *            the width to fit
 1309 &nbsp; 	 * @param fitHeight
 1310 &nbsp; 	 *            the height to fit
</a><a name="1311"> 1311 &nbsp; 	 */
 1312 &nbsp; 	public void scaleToFit(float fitWidth, float fitHeight) {
 1313 &nbsp;         scalePercent(100);
 1314 &nbsp; 		float percentX = (fitWidth * 100) / getScaledWidth();
 1315 &nbsp; 		float percentY = (fitHeight * 100) / getScaledHeight();
 1316 &nbsp; 		scalePercent(percentX &lt; percentY ? percentX : percentY);
 1317 &nbsp; 		setWidthPercentage(0);
 1318 &nbsp; 	}
 1319 &nbsp; 
 1320 &nbsp; 	/**
</a><a name="1321"> 1321 &nbsp; 	 * Returns the transformation matrix of the image.
 1322 &nbsp; 	 * 
 1323 &nbsp; 	 * @return an array [AX, AY, BX, BY, CX, CY, DX, DY]
 1324 &nbsp; 	 */
 1325 &nbsp; 	public float[] matrix() {
 1326 &nbsp; 		float[] matrix = new float[8];
 1327 &nbsp; 		float cosX = (float) Math.cos(rotationRadians);
 1328 &nbsp; 		float sinX = (float) Math.sin(rotationRadians);
 1329 &nbsp; 		matrix[AX] = plainWidth * cosX;
 1330 &nbsp; 		matrix[AY] = plainWidth * sinX;
</a><a name="1331"> 1331 &nbsp; 		matrix[BX] = (-plainHeight) * sinX;
 1332 &nbsp; 		matrix[BY] = plainHeight * cosX;
 1333 &nbsp; 		if (rotationRadians &lt; Math.PI / 2f) {
 1334 &nbsp; 			matrix[CX] = matrix[BX];
 1335 &nbsp; 			matrix[CY] = 0;
 1336 &nbsp; 			matrix[DX] = matrix[AX];
 1337 &nbsp; 			matrix[DY] = matrix[AY] + matrix[BY];
 1338 &nbsp; 		} else if (rotationRadians &lt; Math.PI) {
 1339 &nbsp; 			matrix[CX] = matrix[AX] + matrix[BX];
 1340 &nbsp; 			matrix[CY] = matrix[BY];
</a><a name="1341"> 1341 &nbsp; 			matrix[DX] = 0;
 1342 &nbsp; 			matrix[DY] = matrix[AY];
 1343 &nbsp; 		} else if (rotationRadians &lt; Math.PI * 1.5f) {
 1344 &nbsp; 			matrix[CX] = matrix[AX];
 1345 &nbsp; 			matrix[CY] = matrix[AY] + matrix[BY];
 1346 &nbsp; 			matrix[DX] = matrix[BX];
 1347 &nbsp; 			matrix[DY] = 0;
 1348 &nbsp; 		} else {
 1349 &nbsp; 			matrix[CX] = 0;
 1350 &nbsp; 			matrix[CY] = matrix[AY];
</a><a name="1351"> 1351 &nbsp; 			matrix[DX] = matrix[AX] + matrix[BX];
 1352 &nbsp; 			matrix[DY] = matrix[BY];
 1353 &nbsp; 		}
 1354 &nbsp; 		return matrix;
 1355 &nbsp; 	}
 1356 &nbsp; 
 1357 &nbsp; 	// serial stamping
 1358 &nbsp; 
 1359 &nbsp; 	/** a static that is used for attributing a unique id to each image. */
 1360 &nbsp; 	static long serialId = 0;
</a><a name="1361"> 1361 &nbsp; 	
 1362 &nbsp; 	/** Creates a new serial id. */
 1363 &nbsp; 	static protected synchronized Long getSerialId() {
 1364 &nbsp; 		++serialId;
 1365 &nbsp; 		return new Long(serialId);
 1366 &nbsp; 	}
 1367 &nbsp; 
 1368 &nbsp; 	/**
 1369 &nbsp; 	 * Returns a serial id for the Image (reuse the same image more than once)
 1370 &nbsp; 	 * 
</a><a name="1371"> 1371 &nbsp; 	 * @return a serialId
 1372 &nbsp; 	 */
 1373 &nbsp; 	public Long getMySerialId() {
 1374 &nbsp; 		return mySerialId;
 1375 &nbsp; 	}
 1376 &nbsp; 
 1377 &nbsp;     // rotation, note that the superclass also has a rotation value.
 1378 &nbsp; 
 1379 &nbsp; 	/** This is the rotation of the image in radians. */
 1380 &nbsp; 	protected float rotationRadians;
</a><a name="1381"> 1381 &nbsp;     
 1382 &nbsp;     /** Holds value of property initialRotation. */
 1383 &nbsp;     private float initialRotation;
 1384 &nbsp; 
 1385 &nbsp;     /**
 1386 &nbsp;      * Gets the current image rotation in radians.
 1387 &nbsp;      * @return the current image rotation in radians
 1388 &nbsp;      */
 1389 &nbsp;     public float getImageRotation() {
 1390 &nbsp; 		double d = 2.0 * Math.PI;
</a><a name="1391"> 1391 &nbsp; 		float rot = (float) ((rotationRadians - initialRotation) % d);
 1392 &nbsp; 		if (rot &lt; 0) {
 1393 &nbsp; 			rot += d;
 1394 &nbsp; 		}
 1395 &nbsp;         return rot;
 1396 &nbsp;     }
 1397 &nbsp;     
 1398 &nbsp; 	/**
 1399 &nbsp; 	 * Sets the rotation of the image in radians.
 1400 &nbsp; 	 * 
</a><a name="1401"> 1401 &nbsp; 	 * @param r
 1402 &nbsp; 	 *            rotation in radians
 1403 &nbsp; 	 */
 1404 &nbsp; 	public void setRotation(float r) {
 1405 &nbsp; 		double d = 2.0 * Math.PI;
 1406 &nbsp; 		rotationRadians = (float) ((r + initialRotation) % d);
 1407 &nbsp; 		if (rotationRadians &lt; 0) {
 1408 &nbsp; 			rotationRadians += d;
 1409 &nbsp; 		}
 1410 &nbsp; 		float[] matrix = matrix();
</a><a name="1411"> 1411 &nbsp; 		scaledWidth = matrix[DX] - matrix[CX];
 1412 &nbsp; 		scaledHeight = matrix[DY] - matrix[CY];
 1413 &nbsp; 	}
 1414 &nbsp; 
 1415 &nbsp; 	/**
 1416 &nbsp; 	 * Sets the rotation of the image in degrees.
 1417 &nbsp; 	 * 
 1418 &nbsp; 	 * @param deg
 1419 &nbsp; 	 *            rotation in degrees
 1420 &nbsp; 	 */
</a><a name="1421"> 1421 &nbsp; 	public void setRotationDegrees(float deg) {
 1422 &nbsp; 		double d = Math.PI;
 1423 &nbsp; 		setRotation(deg / 180 * (float) d);
 1424 &nbsp; 	}
 1425 &nbsp;     
 1426 &nbsp;     /**
 1427 &nbsp;      * Getter for property initialRotation.
 1428 &nbsp;      * @return Value of property initialRotation.
 1429 &nbsp;      */
 1430 &nbsp;     public float getInitialRotation() {
</a><a name="1431"> 1431 &nbsp;         return this.initialRotation;
 1432 &nbsp;     }
 1433 &nbsp;     
 1434 &nbsp;     /**
 1435 &nbsp;      * Some image formats, like TIFF may present the images rotated that have
 1436 &nbsp;      * to be compensated.
 1437 &nbsp;      * @param initialRotation New value of property initialRotation.
 1438 &nbsp;      */
 1439 &nbsp;     public void setInitialRotation(float initialRotation) {
 1440 &nbsp;         float old_rot = rotationRadians - this.initialRotation;
</a><a name="1441"> 1441 &nbsp;         this.initialRotation = initialRotation;
 1442 &nbsp;         setRotation(old_rot);
 1443 &nbsp;     }
 1444 &nbsp;     
 1445 &nbsp;     // indentations
 1446 &nbsp; 
 1447 &nbsp; 	/** the indentation to the left. */
 1448 &nbsp; 	protected float indentationLeft = 0;
 1449 &nbsp; 
 1450 &nbsp; 	/** the indentation to the right. */
</a><a name="1451"> 1451 &nbsp; 	protected float indentationRight = 0;
 1452 &nbsp; 
 1453 &nbsp; 	/** The spacing before the image. */
 1454 &nbsp; 	protected float spacingBefore;
 1455 &nbsp; 
 1456 &nbsp; 	/** The spacing after the image. */
 1457 &nbsp; 	protected float spacingAfter;
 1458 &nbsp; 
 1459 &nbsp; 	/**
 1460 &nbsp; 	 * Gets the left indentation.
</a><a name="1461"> 1461 &nbsp; 	 * 
 1462 &nbsp; 	 * @return the left indentation
 1463 &nbsp; 	 */
 1464 &nbsp; 	public float getIndentationLeft() {
 1465 &nbsp; 		return indentationLeft;
 1466 &nbsp; 	}
 1467 &nbsp; 
 1468 &nbsp; 	/**
 1469 &nbsp; 	 * Sets the left indentation.
 1470 &nbsp; 	 * 
</a><a name="1471"> 1471 &nbsp; 	 * @param f
 1472 &nbsp; 	 */
 1473 &nbsp; 	public void setIndentationLeft(float f) {
 1474 &nbsp; 		indentationLeft = f;
 1475 &nbsp; 	}
 1476 &nbsp; 
 1477 &nbsp; 	/**
 1478 &nbsp; 	 * Gets the right indentation.
 1479 &nbsp; 	 * 
 1480 &nbsp; 	 * @return the right indentation
</a><a name="1481"> 1481 &nbsp; 	 */
 1482 &nbsp; 	public float getIndentationRight() {
 1483 &nbsp; 		return indentationRight;
 1484 &nbsp; 	}
 1485 &nbsp; 
 1486 &nbsp; 	/**
 1487 &nbsp; 	 * Sets the right indentation.
 1488 &nbsp; 	 * 
 1489 &nbsp; 	 * @param f
 1490 &nbsp; 	 */
</a><a name="1491"> 1491 &nbsp; 	public void setIndentationRight(float f) {
 1492 &nbsp; 		indentationRight = f;
 1493 &nbsp; 	}
 1494 &nbsp; 
 1495 &nbsp; 	/**
 1496 &nbsp; 	 * Gets the spacing before this image.
 1497 &nbsp; 	 * 
 1498 &nbsp; 	 * @return the spacing
 1499 &nbsp; 	 */
 1500 &nbsp; 	public float getSpacingBefore() {
</a><a name="1501"> 1501 &nbsp; 		return spacingBefore;
 1502 &nbsp; 	}
 1503 &nbsp; 
 1504 &nbsp; 	/**
 1505 &nbsp; 	 * Sets the spacing before this image.
 1506 &nbsp; 	 * 
 1507 &nbsp; 	 * @param spacing
 1508 &nbsp; 	 *            the new spacing
 1509 &nbsp; 	 */
 1510 &nbsp; 
</a><a name="1511"> 1511 &nbsp; 	public void setSpacingBefore(float spacing) {
 1512 &nbsp; 		this.spacingBefore = spacing;
 1513 &nbsp; 	}
 1514 &nbsp; 
 1515 &nbsp; 	/**
 1516 &nbsp; 	 * Gets the spacing before this image.
 1517 &nbsp; 	 * 
 1518 &nbsp; 	 * @return the spacing
 1519 &nbsp; 	 */
 1520 &nbsp; 	public float getSpacingAfter() {
</a><a name="1521"> 1521 &nbsp; 		return spacingAfter;
 1522 &nbsp; 	}
 1523 &nbsp; 
 1524 &nbsp; 	/**
 1525 &nbsp; 	 * Sets the spacing after this image.
 1526 &nbsp; 	 * 
 1527 &nbsp; 	 * @param spacing
 1528 &nbsp; 	 *            the new spacing
 1529 &nbsp; 	 */
 1530 &nbsp; 
</a><a name="1531"> 1531 &nbsp; 	public void setSpacingAfter(float spacing) {
 1532 &nbsp; 		this.spacingAfter = spacing;
 1533 &nbsp; 	}
 1534 &nbsp; 
 1535 &nbsp;     // widthpercentage (for the moment only used in ColumnText)
 1536 &nbsp; 
 1537 &nbsp; 	/**
 1538 &nbsp; 	 * Holds value of property widthPercentage.
 1539 &nbsp; 	 */
 1540 &nbsp; 	private float widthPercentage = 100;
</a><a name="1541"> 1541 &nbsp; 	
 1542 &nbsp; 	/**
 1543 &nbsp; 	 * Getter for property widthPercentage.
 1544 &nbsp; 	 * 
 1545 &nbsp; 	 * @return Value of property widthPercentage.
 1546 &nbsp; 	 */
 1547 &nbsp; 	public float getWidthPercentage() {
 1548 &nbsp; 		return this.widthPercentage;
 1549 &nbsp; 	}
 1550 &nbsp; 
</a><a name="1551"> 1551 &nbsp; 	/**
 1552 &nbsp; 	 * Setter for property widthPercentage.
 1553 &nbsp; 	 * 
 1554 &nbsp; 	 * @param widthPercentage
 1555 &nbsp; 	 *            New value of property widthPercentage.
 1556 &nbsp; 	 */
 1557 &nbsp; 	public void setWidthPercentage(float widthPercentage) {
 1558 &nbsp; 		this.widthPercentage = widthPercentage;
 1559 &nbsp; 	}
 1560 &nbsp; 
</a><a name="1561"> 1561 &nbsp;     // annotation
 1562 &nbsp; 
 1563 &nbsp; 	/** if the annotation is not null the image will be clickable. */
 1564 &nbsp; 	protected Annotation annotation = null;
 1565 &nbsp; 	
 1566 &nbsp; 	/**
 1567 &nbsp; 	 * Sets the annotation of this Image.
 1568 &nbsp; 	 * 
 1569 &nbsp; 	 * @param annotation
 1570 &nbsp; 	 *            the annotation
</a><a name="1571"> 1571 &nbsp; 	 */
 1572 &nbsp; 	public void setAnnotation(Annotation annotation) {
 1573 &nbsp; 		this.annotation = annotation;
 1574 &nbsp; 	}
 1575 &nbsp; 
 1576 &nbsp; 	/**
 1577 &nbsp; 	 * Gets the annotation.
 1578 &nbsp; 	 * 
 1579 &nbsp; 	 * @return the annotation that is linked to this image
 1580 &nbsp; 	 */
</a><a name="1581"> 1581 &nbsp; 	public Annotation getAnnotation() {
 1582 &nbsp; 		return annotation;
 1583 &nbsp; 	}
 1584 &nbsp; 
 1585 &nbsp;     // Optional Content
 1586 &nbsp; 
 1587 &nbsp;     /** Optional Content layer to which we want this Image to belong. */
 1588 &nbsp; 	protected PdfOCG layer;
 1589 &nbsp; 	
 1590 &nbsp; 	/**
</a><a name="1591"> 1591 &nbsp; 	 * Gets the layer this image belongs to.
 1592 &nbsp; 	 * 
 1593 &nbsp; 	 * @return the layer this image belongs to or &lt;code&gt;null&lt;/code&gt; for no
 1594 &nbsp; 	 *         layer defined
 1595 &nbsp; 	 */
 1596 &nbsp; 	public PdfOCG getLayer() {
 1597 &nbsp; 		return layer;
 1598 &nbsp; 	}
 1599 &nbsp; 
 1600 &nbsp; 	/**
</a><a name="1601"> 1601 &nbsp; 	 * Sets the layer this image belongs to.
 1602 &nbsp; 	 * 
 1603 &nbsp; 	 * @param layer
 1604 &nbsp; 	 *            the layer this image belongs to
 1605 &nbsp; 	 */
 1606 &nbsp; 	public void setLayer(PdfOCG layer) {
 1607 &nbsp; 		this.layer = layer;
 1608 &nbsp; 	}
 1609 &nbsp; 
 1610 &nbsp; 	// interpolation
</a><a name="1611"> 1611 &nbsp; 
 1612 &nbsp; 	/** Holds value of property interpolation. */
 1613 &nbsp; 	protected boolean interpolation;
 1614 &nbsp; 
 1615 &nbsp; 	/**
 1616 &nbsp; 	 * Getter for property interpolation.
 1617 &nbsp; 	 * 
 1618 &nbsp; 	 * @return Value of property interpolation.
 1619 &nbsp; 	 */
 1620 &nbsp; 	public boolean isInterpolation() {
</a><a name="1621"> 1621 &nbsp; 		return interpolation;
 1622 &nbsp; 	}
 1623 &nbsp; 
 1624 &nbsp; 	/**
 1625 &nbsp; 	 * Sets the image interpolation. Image interpolation attempts to produce a
 1626 &nbsp; 	 * smooth transition between adjacent sample values.
 1627 &nbsp; 	 * 
 1628 &nbsp; 	 * @param interpolation
 1629 &nbsp; 	 *            New value of property interpolation.
 1630 &nbsp; 	 */
</a><a name="1631"> 1631 &nbsp; 	public void setInterpolation(boolean interpolation) {
 1632 &nbsp; 		this.interpolation = interpolation;
 1633 &nbsp; 	}
 1634 &nbsp; 	
 1635 &nbsp; 	// original type and data
 1636 &nbsp; 
 1637 &nbsp; 	/** Holds value of property originalType. */
 1638 &nbsp; 	protected int originalType = ORIGINAL_NONE;
 1639 &nbsp; 
 1640 &nbsp; 	/** Holds value of property originalData. */
</a><a name="1641"> 1641 &nbsp; 	protected byte[] originalData;
 1642 &nbsp; 	
 1643 &nbsp; 	/**
 1644 &nbsp; 	 * Getter for property originalType.
 1645 &nbsp; 	 * 
 1646 &nbsp; 	 * @return Value of property originalType.
 1647 &nbsp; 	 *  
 1648 &nbsp; 	 */
 1649 &nbsp; 	public int getOriginalType() {
 1650 &nbsp; 		return this.originalType;
</a><a name="1651"> 1651 &nbsp; 	}
 1652 &nbsp; 
 1653 &nbsp; 	/**
 1654 &nbsp; 	 * Setter for property originalType.
 1655 &nbsp; 	 * 
 1656 &nbsp; 	 * @param originalType
 1657 &nbsp; 	 *            New value of property originalType.
 1658 &nbsp; 	 *  
 1659 &nbsp; 	 */
 1660 &nbsp; 	public void setOriginalType(int originalType) {
</a><a name="1661"> 1661 &nbsp; 		this.originalType = originalType;
 1662 &nbsp; 	}
 1663 &nbsp; 
 1664 &nbsp; 	/**
 1665 &nbsp; 	 * Getter for property originalData.
 1666 &nbsp; 	 * 
 1667 &nbsp; 	 * @return Value of property originalData.
 1668 &nbsp; 	 *  
 1669 &nbsp; 	 */
 1670 &nbsp; 	public byte[] getOriginalData() {
</a><a name="1671"> 1671 &nbsp; 		return this.originalData;
 1672 &nbsp; 	}
 1673 &nbsp; 
 1674 &nbsp; 	/**
 1675 &nbsp; 	 * Setter for property originalData.
 1676 &nbsp; 	 * 
 1677 &nbsp; 	 * @param originalData
 1678 &nbsp; 	 *            New value of property originalData.
 1679 &nbsp; 	 *  
 1680 &nbsp; 	 */
</a><a name="1681"> 1681 &nbsp; 	public void setOriginalData(byte[] originalData) {
 1682 &nbsp; 		this.originalData = originalData;
 1683 &nbsp; 	}
 1684 &nbsp; 
 1685 &nbsp; 	// the following values are only set for specific types of images.
 1686 &nbsp; 	
 1687 &nbsp; 	/** Holds value of property deflated. */
 1688 &nbsp; 	protected boolean deflated = false;
 1689 &nbsp; 
 1690 &nbsp; 	/**
</a><a name="1691"> 1691 &nbsp; 	 * Getter for property deflated.
 1692 &nbsp; 	 * 
 1693 &nbsp; 	 * @return Value of property deflated.
 1694 &nbsp; 	 *  
 1695 &nbsp; 	 */
 1696 &nbsp; 	public boolean isDeflated() {
 1697 &nbsp; 		return this.deflated;
 1698 &nbsp; 	}
 1699 &nbsp; 
 1700 &nbsp; 	/**
</a><a name="1701"> 1701 &nbsp; 	 * Setter for property deflated.
 1702 &nbsp; 	 * 
 1703 &nbsp; 	 * @param deflated
 1704 &nbsp; 	 *            New value of property deflated.
 1705 &nbsp; 	 */
 1706 &nbsp; 	public void setDeflated(boolean deflated) {
 1707 &nbsp; 		this.deflated = deflated;
 1708 &nbsp; 	}
 1709 &nbsp; 	
 1710 &nbsp; 	// DPI info
</a><a name="1711"> 1711 &nbsp; 	
 1712 &nbsp; 	/** Holds value of property dpiX. */
 1713 &nbsp; 	protected int dpiX = 0;
 1714 &nbsp; 
 1715 &nbsp; 	/** Holds value of property dpiY. */
 1716 &nbsp; 	protected int dpiY = 0;
 1717 &nbsp; 
 1718 &nbsp; 	/**
 1719 &nbsp; 	 * Gets the dots-per-inch in the X direction. Returns 0 if not available.
 1720 &nbsp; 	 * 
</a><a name="1721"> 1721 &nbsp; 	 * @return the dots-per-inch in the X direction
 1722 &nbsp; 	 */
 1723 &nbsp; 	public int getDpiX() {
 1724 &nbsp; 		return dpiX;
 1725 &nbsp; 	}
 1726 &nbsp; 
 1727 &nbsp; 	/**
 1728 &nbsp; 	 * Gets the dots-per-inch in the Y direction. Returns 0 if not available.
 1729 &nbsp; 	 * 
 1730 &nbsp; 	 * @return the dots-per-inch in the Y direction
</a><a name="1731"> 1731 &nbsp; 	 */
 1732 &nbsp; 	public int getDpiY() {
 1733 &nbsp; 		return dpiY;
 1734 &nbsp; 	}
 1735 &nbsp; 
 1736 &nbsp; 	/**
 1737 &nbsp; 	 * Sets the dots per inch value
 1738 &nbsp; 	 * 
 1739 &nbsp; 	 * @param dpiX
 1740 &nbsp; 	 *            dpi for x coordinates
</a><a name="1741"> 1741 &nbsp; 	 * @param dpiY
 1742 &nbsp; 	 *            dpi for y coordinates
 1743 &nbsp; 	 */
 1744 &nbsp; 	public void setDpi(int dpiX, int dpiY) {
 1745 &nbsp; 		this.dpiX = dpiX;
 1746 &nbsp; 		this.dpiY = dpiY;
 1747 &nbsp; 	}
 1748 &nbsp; 	
 1749 &nbsp; 	// XY Ratio
 1750 &nbsp; 	
</a><a name="1751"> 1751 &nbsp; 	/** Holds value of property XYRatio. */
 1752 &nbsp; 	private float XYRatio = 0;
 1753 &nbsp; 
 1754 &nbsp; 	/**
 1755 &nbsp; 	 * Gets the X/Y pixel dimensionless aspect ratio.
 1756 &nbsp; 	 * 
 1757 &nbsp; 	 * @return the X/Y pixel dimensionless aspect ratio
 1758 &nbsp; 	 */
 1759 &nbsp; 	public float getXYRatio() {
 1760 &nbsp; 		return this.XYRatio;
</a><a name="1761"> 1761 &nbsp; 	}
 1762 &nbsp; 
 1763 &nbsp; 	/**
 1764 &nbsp; 	 * Sets the X/Y pixel dimensionless aspect ratio.
 1765 &nbsp; 	 * 
 1766 &nbsp; 	 * @param XYRatio
 1767 &nbsp; 	 *            the X/Y pixel dimensionless aspect ratio
 1768 &nbsp; 	 */
 1769 &nbsp; 	public void setXYRatio(float XYRatio) {
 1770 &nbsp; 		this.XYRatio = XYRatio;
</a><a name="1771"> 1771 &nbsp; 	}
 1772 &nbsp; 	
 1773 &nbsp; 	// color, colorspaces and transparency
 1774 &nbsp; 
 1775 &nbsp; 	/** this is the colorspace of a jpeg-image. */
 1776 &nbsp; 	protected int colorspace = -1;
 1777 &nbsp; 
 1778 &nbsp; 	/**
 1779 &nbsp; 	 * Gets the colorspace for the image.
 1780 &nbsp; 	 * &lt;P&gt;
</a><a name="1781"> 1781 &nbsp; 	 * Remark: this only makes sense for Images of the type &lt;CODE&gt;Jpeg&lt;/CODE&gt;.
 1782 &nbsp; 	 * 
 1783 &nbsp; 	 * @return a colorspace value
 1784 &nbsp; 	 */
 1785 &nbsp; 	public int getColorspace() {
 1786 &nbsp; 		return colorspace;
 1787 &nbsp; 	}
 1788 &nbsp;     
 1789 &nbsp; 	/** Image color inversion */
 1790 &nbsp; 	protected boolean invert = false;
</a><a name="1791"> 1791 &nbsp; 
 1792 &nbsp; 	/**
 1793 &nbsp; 	 * Getter for the inverted value
 1794 &nbsp; 	 * 
 1795 &nbsp; 	 * @return true if the image is inverted
 1796 &nbsp; 	 */
 1797 &nbsp; 	public boolean isInverted() {
 1798 &nbsp; 		return invert;
 1799 &nbsp; 	}
 1800 &nbsp; 
</a><a name="1801"> 1801 &nbsp; 	/**
 1802 &nbsp; 	 * Sets inverted true or false
 1803 &nbsp; 	 * 
 1804 &nbsp; 	 * @param invert
 1805 &nbsp; 	 *            true or false
 1806 &nbsp; 	 */
 1807 &nbsp; 	public void setInverted(boolean invert) {
 1808 &nbsp; 		this.invert = invert;
 1809 &nbsp; 	}
 1810 &nbsp; 
</a><a name="1811"> 1811 &nbsp; 	/** ICC Profile attached */
 1812 &nbsp; 	protected ICC_Profile profile = null;
 1813 &nbsp; 
 1814 &nbsp; 	/**
 1815 &nbsp; 	 * Tags this image with an ICC profile.
 1816 &nbsp; 	 * 
 1817 &nbsp; 	 * @param profile
 1818 &nbsp; 	 *            the profile
 1819 &nbsp; 	 */
 1820 &nbsp; 	public void tagICC(ICC_Profile profile) {
</a><a name="1821"> 1821 &nbsp; 		this.profile = profile;
 1822 &nbsp; 	}
 1823 &nbsp; 
 1824 &nbsp; 	/**
 1825 &nbsp; 	 * Checks is the image has an ICC profile.
 1826 &nbsp; 	 * 
 1827 &nbsp; 	 * @return the ICC profile or &lt;CODE&gt;null&lt;/CODE&gt;
 1828 &nbsp; 	 */
 1829 &nbsp; 	public boolean hasICCProfile() {
 1830 &nbsp; 		return (this.profile != null);
</a><a name="1831"> 1831 &nbsp; 	}
 1832 &nbsp; 
 1833 &nbsp; 	/**
 1834 &nbsp; 	 * Gets the images ICC profile.
 1835 &nbsp; 	 * 
 1836 &nbsp; 	 * @return the ICC profile
 1837 &nbsp; 	 */
 1838 &nbsp; 	public ICC_Profile getICCProfile() {
 1839 &nbsp; 		return profile;
 1840 &nbsp; 	}
</a><a name="1841"> 1841 &nbsp; 
 1842 &nbsp; 	/** a dictionary with additional information */
 1843 &nbsp; 	private PdfDictionary additional = null;
 1844 &nbsp; 	
 1845 &nbsp; 	/**
 1846 &nbsp; 	 * Getter for the dictionary with additional information.
 1847 &nbsp; 	 * 
 1848 &nbsp; 	 * @return a PdfDictionary with additional information.
 1849 &nbsp; 	 */
 1850 &nbsp; 	public PdfDictionary getAdditional() {
</a><a name="1851"> 1851 &nbsp; 		return this.additional;
 1852 &nbsp; 	}
 1853 &nbsp; 
 1854 &nbsp; 	/**
 1855 &nbsp; 	 * Sets the /Colorspace key.
 1856 &nbsp; 	 * 
 1857 &nbsp; 	 * @param additional
 1858 &nbsp; 	 *            a PdfDictionary with additional information.
 1859 &nbsp; 	 */
 1860 &nbsp; 	public void setAdditional(PdfDictionary additional) {
</a><a name="1861"> 1861 &nbsp; 		this.additional = additional;
 1862 &nbsp; 	}
 1863 &nbsp; 
 1864 &nbsp;     /**
 1865 &nbsp;      * Replaces CalRGB and CalGray colorspaces with DeviceRGB and DeviceGray.
 1866 &nbsp;      */    
 1867 &nbsp;     public void simplifyColorspace() {
 1868 &nbsp;         if (additional == null)
 1869 &nbsp;             return;
 1870 &nbsp;         PdfArray value = additional.getAsArray(PdfName.COLORSPACE);
</a><a name="1871"> 1871 &nbsp;         if (value == null)
 1872 &nbsp;             return;
 1873 &nbsp;         PdfObject cs = simplifyColorspace(value);
 1874 &nbsp;         PdfObject newValue;
 1875 &nbsp;         if (cs.isName())
 1876 &nbsp;             newValue = cs;
 1877 &nbsp;         else {
 1878 &nbsp;             newValue = value;
 1879 &nbsp;             PdfName first = value.getAsName(0);
 1880 &nbsp;             if (PdfName.INDEXED.equals(first)) {
</a><a name="1881"> 1881 &nbsp;                 if (value.size() &gt;= 2) {
 1882 &nbsp;                     PdfArray second = value.getAsArray(1);
 1883 &nbsp;                     if (second != null) {
 1884 &nbsp;                         value.set(1, simplifyColorspace(second));
 1885 &nbsp;                     }
 1886 &nbsp;                 }
 1887 &nbsp;             }
 1888 &nbsp;         }
 1889 &nbsp;         additional.put(PdfName.COLORSPACE, newValue);
 1890 &nbsp;     }
</a><a name="1891"> 1891 &nbsp; 	
 1892 &nbsp; 	/**
 1893 &nbsp; 	 * Gets a PDF Name from an array or returns the object that was passed.
 1894 &nbsp; 	 */
 1895 &nbsp;     private PdfObject simplifyColorspace(PdfArray obj) {
 1896 &nbsp;         if (obj == null)
 1897 &nbsp;             return obj;
 1898 &nbsp;         PdfName first = obj.getAsName(0);
 1899 &nbsp;         if (PdfName.CALGRAY.equals(first))
 1900 &nbsp;             return PdfName.DEVICEGRAY;
</a><a name="1901"> 1901 &nbsp;         else if (PdfName.CALRGB.equals(first))
 1902 &nbsp;             return PdfName.DEVICERGB;
 1903 &nbsp;         else
 1904 &nbsp;             return obj;
 1905 &nbsp;     }
 1906 &nbsp; 
 1907 &nbsp; 	/** Is this image a mask? */
 1908 &nbsp; 	protected boolean mask = false;
 1909 &nbsp; 	
 1910 &nbsp; 	/** The image that serves as a mask for this image. */
</a><a name="1911"> 1911 &nbsp; 	protected Image imageMask;
 1912 &nbsp; 
 1913 &nbsp; 	/** Holds value of property smask. */
 1914 &nbsp; 	private boolean smask;
 1915 &nbsp; 
 1916 &nbsp; 	/**
 1917 &nbsp; 	 * Returns &lt;CODE&gt;true&lt;/CODE&gt; if this &lt;CODE&gt;Image&lt;/CODE&gt; is a mask.
 1918 &nbsp; 	 * 
 1919 &nbsp; 	 * @return &lt;CODE&gt;true&lt;/CODE&gt; if this &lt;CODE&gt;Image&lt;/CODE&gt; is a mask
 1920 &nbsp; 	 */
</a><a name="1921"> 1921 &nbsp; 	public boolean isMask() {
 1922 &nbsp; 		return mask;
 1923 &nbsp; 	}
 1924 &nbsp; 
 1925 &nbsp; 	/**
 1926 &nbsp; 	 * Make this &lt;CODE&gt;Image&lt;/CODE&gt; a mask.
 1927 &nbsp; 	 * 
 1928 &nbsp; 	 * @throws DocumentException
 1929 &nbsp; 	 *             if this &lt;CODE&gt;Image&lt;/CODE&gt; can not be a mask
 1930 &nbsp; 	 */
</a><a name="1931"> 1931 &nbsp; 	public void makeMask() throws DocumentException {
 1932 &nbsp; 		if (!isMaskCandidate())
 1933 &nbsp; 			throw new DocumentException("This image can not be an image mask.");
 1934 &nbsp; 		mask = true;
 1935 &nbsp; 	}
 1936 &nbsp; 
 1937 &nbsp; 	/**
 1938 &nbsp; 	 * Returns &lt;CODE&gt;true&lt;/CODE&gt; if this &lt;CODE&gt;Image&lt;/CODE&gt; has the
 1939 &nbsp; 	 * requisites to be a mask.
 1940 &nbsp; 	 * 
</a><a name="1941"> 1941 &nbsp; 	 * @return &lt;CODE&gt;true&lt;/CODE&gt; if this &lt;CODE&gt;Image&lt;/CODE&gt; can be a mask
 1942 &nbsp; 	 */
 1943 &nbsp; 	public boolean isMaskCandidate() {
 1944 &nbsp; 		if (type == IMGRAW) {
 1945 &nbsp; 			if (bpc &gt; 0xff)
 1946 &nbsp; 				return true;
 1947 &nbsp; 		}
 1948 &nbsp; 		return colorspace == 1;
 1949 &nbsp; 	}
 1950 &nbsp; 
</a><a name="1951"> 1951 &nbsp; 	/**
 1952 &nbsp; 	 * Gets the explicit masking.
 1953 &nbsp; 	 * 
 1954 &nbsp; 	 * @return the explicit masking
 1955 &nbsp; 	 */
 1956 &nbsp; 	public Image getImageMask() {
 1957 &nbsp; 		return imageMask;
 1958 &nbsp; 	}
 1959 &nbsp; 
 1960 &nbsp; 	/**
</a><a name="1961"> 1961 &nbsp; 	 * Sets the explicit masking.
 1962 &nbsp; 	 * 
 1963 &nbsp; 	 * @param mask
 1964 &nbsp; 	 *            the mask to be applied
 1965 &nbsp; 	 * @throws DocumentException
 1966 &nbsp; 	 *             on error
 1967 &nbsp; 	 */
 1968 &nbsp; 	public void setImageMask(Image mask) throws DocumentException {
 1969 &nbsp; 		if (this.mask)
 1970 &nbsp; 			throw new DocumentException(
</a><a name="1971"> 1971 &nbsp; 					"An image mask cannot contain another image mask.");
 1972 &nbsp; 		if (!mask.mask)
 1973 &nbsp; 			throw new DocumentException(
 1974 &nbsp; 					"The image mask is not a mask. Did you do makeMask()?");
 1975 &nbsp; 		imageMask = mask;
 1976 &nbsp; 		smask = (mask.bpc &gt; 1 &amp;&amp; mask.bpc &lt;= 8);
 1977 &nbsp; 	}
 1978 &nbsp; 
 1979 &nbsp; 	/**
 1980 &nbsp; 	 * Getter for property smask.
</a><a name="1981"> 1981 &nbsp; 	 * 
 1982 &nbsp; 	 * @return Value of property smask.
 1983 &nbsp; 	 *  
 1984 &nbsp; 	 */
 1985 &nbsp; 	public boolean isSmask() {
 1986 &nbsp; 		return this.smask;
 1987 &nbsp; 	}
 1988 &nbsp; 
 1989 &nbsp; 	/**
 1990 &nbsp; 	 * Setter for property smask.
</a><a name="1991"> 1991 &nbsp; 	 * 
 1992 &nbsp; 	 * @param smask
 1993 &nbsp; 	 *            New value of property smask.
 1994 &nbsp; 	 */
 1995 &nbsp; 	public void setSmask(boolean smask) {
 1996 &nbsp; 		this.smask = smask;
 1997 &nbsp; 	}
 1998 &nbsp; 
 1999 &nbsp; 	/** this is the transparency information of the raw image */
 2000 &nbsp; 	protected int transparency[];
</a><a name="2001"> 2001 &nbsp; 
 2002 &nbsp; 	/**
 2003 &nbsp; 	 * Returns the transparency.
 2004 &nbsp; 	 * 
 2005 &nbsp; 	 * @return the transparency values
 2006 &nbsp; 	 */
 2007 &nbsp; 
 2008 &nbsp; 	public int[] getTransparency() {
 2009 &nbsp; 		return transparency;
 2010 &nbsp; 	}
</a><a name="2011"> 2011 &nbsp; 
 2012 &nbsp; 	/**
 2013 &nbsp; 	 * Sets the transparency values
 2014 &nbsp; 	 * 
 2015 &nbsp; 	 * @param transparency
 2016 &nbsp; 	 *            the transparency values
 2017 &nbsp; 	 */
 2018 &nbsp; 	public void setTransparency(int transparency[]) {
 2019 &nbsp; 		this.transparency = transparency;
 2020 &nbsp; 	}
</a><a name="2021"> 2021 &nbsp; 
 2022 &nbsp; 
 2023 &nbsp; 	/**
 2024 &nbsp; 	 * Returns the compression level used for images written as a compressed stream.
 2025 &nbsp; 	 * @return the compression level (0 = best speed, 9 = best compression, -1 is default)
 2026 &nbsp;      * @since	2.1.3
 2027 &nbsp; 	 */
 2028 &nbsp; 	public int getCompressionLevel() {
 2029 &nbsp; 		return compressionLevel;
 2030 &nbsp; 	}
</a><a name="2031"> 2031 &nbsp; 
 2032 &nbsp; 	/**
 2033 &nbsp; 	 * Sets the compression level to be used if the image is written as a compressed stream.
 2034 &nbsp; 	 * @param compressionLevel a value between 0 (best speed) and 9 (best compression)
 2035 &nbsp;      * @since	2.1.3
 2036 &nbsp; 	 */
 2037 &nbsp; 	public void setCompressionLevel(int compressionLevel) {
 2038 &nbsp; 		if (compressionLevel &lt; PdfStream.NO_COMPRESSION || compressionLevel &gt; PdfStream.BEST_COMPRESSION)
 2039 &nbsp; 			this.compressionLevel = PdfStream.DEFAULT_COMPRESSION;
 2040 &nbsp; 		else
</a><a name="2041"> 2041 &nbsp; 			this.compressionLevel = compressionLevel;
 2042 &nbsp; 	}
 2043 &nbsp; }

</a></pre>
  <a name="2041"> </a>
  <div style="width:100%;background-color:#ddeeff;border:1px solid #ccddee;margin:0 0 0 0;padding:2px 2px 2px 2px">
   <a name="2041"> 
    <div style="float:right">
     <a href="http://del.icio.us/post" onclick="window.open('http://del.icio.us/post?v=4&amp;noui&amp;jump=close&amp;url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title), 'delicious','toolbar=no,width=700,height=400'); return false;"><img src="http://images.del.icio.us/static/img/delicious.small.gif" border="0"> Save This Page</a>
    </div></a> 
   <a href="/">Home</a> » 
   <a href="/projects/iText-2.1.7-code.html">iText-2.1.7</a> » com.lowagie » 
   <a href="/docs/api/com/lowagie/text/package-index.html">text</a> » [
   <a href="/docs/api/com/lowagie/text/Image.html">javadoc</a> | source] 
  </div> 
  <script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script> 
  <script type="text/javascript">
var pageTracker = _gat._getTracker("UA-138120-1");
pageTracker._trackPageview();
</script>   
  <!-- end -->
 </body>
</html>