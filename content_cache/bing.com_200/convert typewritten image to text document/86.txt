<!doctype html>
<html lang="en" class="no-js">
 <head>
  <meta charset="utf-8"> 
  <title>Preview Word files (docx) in HTML using ASP.NET, OpenXML and LINQ to XML - Maarten Balliauw {blog}</title>
  <meta property="og:locale" content="en">
  <meta property="og:site_name" content="Maarten Balliauw {blog}">
  <meta property="og:title" content="Preview Word files (docx) in HTML using ASP.NET, OpenXML and LINQ to XML">
  <link rel="canonical" href="https://blog.maartenballiauw.be/post/2008/01/11/preview-word-files-(docx)-in-html-using-aspnet-openxml-and-linq-to-xml.html">
  <meta property="og:url" content="https://blog.maartenballiauw.be/post/2008/01/11/preview-word-files-(docx)-in-html-using-aspnet-openxml-and-linq-to-xml.html">
  <meta property="og:description" content="Since an image (or even an example) tells&nbsp;more than any text will ever do, here's what I've created in the past few evening hours:Live examples:Test document 1&nbsp;(examples offline)Test document 2&nbsp;(examples offline)Test document 3 (with image)&nbsp;(examples offline)Want the source code? Download it here: WordVisualizer.zip (357.01 kb)Want to know how?If you want to know how I did this, let me first tell you why I created this. After searching Google for something similar, I found a Sharepoint blogger who did the same using a Sharepoint XSL transformation document called DocX2Html.xsl. Great, but this document can not be distributed without a Sharepoint license. The only option for me was to do something similar myself.ASP.NET handlersThe main idea of this project was to be able to type in a URL ending in &quot;.docx&quot;, which would then render a preview of the underlying Word document. Luckily, ASP.NET provides a system of creating HttpHandlers. A HttpHandler is the class instance which is called by the .NET runtime to process an incoming request for a specific extension. So let's trick ASP.NET into believing &quot;.docx&quot; is an extension which should be handled by a custom class...Creating a custom handlerA custom handler can be created quite easily. Just create a new class, and make it implement the IHttpHandler interface:[code:c#]/// <summary> /// Word document HTTP handler /// </summary>public class WordDocumentHandler : IHttpHandler { &nbsp;&nbsp;&nbsp; #region IHttpHandler Members&nbsp;&nbsp;&nbsp; /// <summary> &nbsp;&nbsp;&nbsp; /// Is the handler reusable? &nbsp;&nbsp;&nbsp; /// </summary>&nbsp;&nbsp;&nbsp; public bool IsReusable &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get { return true; } &nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; /// <summary> &nbsp;&nbsp;&nbsp; /// Process request &nbsp;&nbsp;&nbsp; /// </summary> &nbsp;&nbsp;&nbsp; /// <param name=&quot;context&quot;>Current http context</param>&nbsp;&nbsp;&nbsp;&nbsp; public void ProcessRequest(HttpContext context) &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Todo...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; context.Response.Write(&quot;Hello world!&quot;); &nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; #endregion }[/code]Registering a custom handlerFor ASP.NET to recognise our newly created handler, we must register it in Web.config:Now if you are using IIS6, you should also register this extension to be handled by the .NET runtime:In the application configuration, add the extension &quot;.docx&quot; and make it point to the following executable: C:\WINDOWS\Microsoft.NET\Framework\v2.0.50727\aspnet_isapi.dllThis should be it. Fire up your browser, browse to your web site and type anything.docx. You should see &quot;Hello world!&quot; appearing in a nice, white page.OpenXMLAs you may already know, Word 2007 files are OpenXML packages containg WordprocessingML markup. A .docx file can be opened using the System.IO.Packaging.Package class (which is available after adding a project reference to WindowsBase.dll).The Package class is created for accessing any OpenXML package. This includes all Office 2007 file formats, but also custom OpenXML formats which you can implement for yourself. Unfortunately, if you want to use Package to access an Office 2007 file, you'll have to implement a lot of utility functions to get the right parts from the OpenXML container.Luckily, Microsoft released an OpenXML SDK (CTP), which I also used in order to create this Word preview handler.LINQ to XMLAs you know, the latest .NET 3.5 release brought us something new &amp; extremely handy: LINQ (Language Integrated Query). On Doug's blog, I read about Eric White's attempts to use LINQ to XML on OpenXML.LINQ to OpenXMLFor implementing my handler, I basically used similar code to Eric's to run query's on a Word document's contents. Here's an example which fetches all paragraphs in a Word document:[code:c#]using (WordprocessingDocument document = WordprocessingDocument.Open(&quot;test.docx&quot;, false)) { &nbsp;&nbsp;&nbsp; // Register namespace&nbsp;&nbsp;&nbsp; XNamespace w = &quot;http://schemas.openxmlformats.org/wordprocessingml/2006/main&quot;;&nbsp;&nbsp;&nbsp; // Element shortcuts&nbsp;&nbsp;&nbsp; XName w_r = w + &quot;r&quot;; &nbsp;&nbsp;&nbsp; XName w_ins = w + &quot;ins&quot;; &nbsp;&nbsp;&nbsp; XName w_hyperlink = w + &quot;hyperlink&quot;;&nbsp;&nbsp;&nbsp; // Load document's MainDocumentPart (document.xml) in XDocument&nbsp;&nbsp;&nbsp; XDocument xDoc = XDocument.Load( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XmlReader.Create( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new StreamReader(document.MainDocumentPart.GetStream()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ) &nbsp;&nbsp;&nbsp; );&nbsp;&nbsp;&nbsp; // Fetch paragraphs&nbsp;&nbsp;&nbsp; var paragraphs = from l_paragraph in xDoc &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Root &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Element(w + &quot;body&quot;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Descendants(w + &quot;p&quot;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select new &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TextRuns = l_paragraph.Elements().Where(z => z.Name == w_r || z.Name == w_ins || z.Name == w_hyperlink) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };&nbsp;&nbsp;&nbsp; // Write paragraphs&nbsp;&nbsp;&nbsp; foreach (var paragraph in paragraphs) &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Fetch runs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var runs = from l_run in paragraph.Runs &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select new &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Text = l_run.Descendants(w + &quot;t&quot;).StringConcatenate(element => (string)element) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Write runs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (var run in runs) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Use run.Text to fetch a text string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.Write(run.Text); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; } }[/code]Now if you run this code, you will notice a compilation error... This is due to the fact that I used an extension method StringConcatenate.Extension methodsIn the above example, I used an extension method named StringConcatenate. An extension method is, as the name implies, an &quot;extension&quot; to a known class. In the following example, find the extension for all IEnumerable<T> instances:[code:c#]public static class IEnumerableExtensions { &nbsp;&nbsp;&nbsp; /// <summary> &nbsp;&nbsp;&nbsp; /// Concatenate strings &nbsp;&nbsp;&nbsp; /// </summary> &nbsp;&nbsp;&nbsp; /// <typeparam name=&quot;T&quot;>Type</typeparam> &nbsp;&nbsp;&nbsp; /// <param name=&quot;source&quot;>Source</param> &nbsp;&nbsp;&nbsp; /// <param name=&quot;func&quot;>Function delegate</param> &nbsp;&nbsp;&nbsp; /// <returns>Concatenated string</returns>&nbsp;&nbsp;&nbsp; public static string StringConcatenate<T>(this IEnumerable<T> source, Func<T, string> func) &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StringBuilder sb = new StringBuilder(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (T item in source) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sb.Append(func(item)); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return sb.ToString(); &nbsp;&nbsp;&nbsp; } }[/code]Lambda expressionsAnother thing you may have noticed in my example code, is a lambda expression:[code:c#]z => z.Name == w_r || z.Name == w_ins || z.Name == w_hyperlink.[/code]A lambda expression is actually an anonymous method, which is called by the StringConcatenate extension method. Lambda expressions always accept a parameter, and return true/false. In this case, z is instantiated as an XNode, returning true/false depending on its Name property.Wrapping things up...If you read this whole blog post, you may have noticed that I extensively used C# 3.5's new language features. I combined these with OpenXML and ASP.NET to create a useful Word document preview handler. If you want the full source code, download it here: WordVisualizer.zip (357.01 kb). This is an imported post. It was imported from my old blog using an automated tool and may contain formatting errors and/or broken images.">
  <meta name="twitter:site" content="@maartenballiauw">
  <meta name="twitter:title" content="Preview Word files (docx) in HTML using ASP.NET, OpenXML and LINQ to XML">
  <meta name="twitter:description" content="Since an image (or even an example) tells&nbsp;more than any text will ever do, here's what I've created in the past few evening hours:Live examples:Test document 1&nbsp;(examples offline)Test document 2&nbsp;(examples offline)Test document 3 (with image)&nbsp;(examples offline)Want the source code? Download it here: WordVisualizer.zip (357.01 kb)Want to know how?If you want to know how I did this, let me first tell you why I created this. After searching Google for something similar, I found a Sharepoint blogger who did the same using a Sharepoint XSL transformation document called DocX2Html.xsl. Great, but this document can not be distributed without a Sharepoint license. The only option for me was to do something similar myself.ASP.NET handlersThe main idea of this project was to be able to type in a URL ending in &quot;.docx&quot;, which would then render a preview of the underlying Word document. Luckily, ASP.NET provides a system of creating HttpHandlers. A HttpHandler is the class instance which is called by the .NET runtime to process an incoming request for a specific extension. So let's trick ASP.NET into believing &quot;.docx&quot; is an extension which should be handled by a custom class...Creating a custom handlerA custom handler can be created quite easily. Just create a new class, and make it implement the IHttpHandler interface:[code:c#]/// <summary> /// Word document HTTP handler /// </summary>public class WordDocumentHandler : IHttpHandler { &nbsp;&nbsp;&nbsp; #region IHttpHandler Members&nbsp;&nbsp;&nbsp; /// <summary> &nbsp;&nbsp;&nbsp; /// Is the handler reusable? &nbsp;&nbsp;&nbsp; /// </summary>&nbsp;&nbsp;&nbsp; public bool IsReusable &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get { return true; } &nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; /// <summary> &nbsp;&nbsp;&nbsp; /// Process request &nbsp;&nbsp;&nbsp; /// </summary> &nbsp;&nbsp;&nbsp; /// <param name=&quot;context&quot;>Current http context</param>&nbsp;&nbsp;&nbsp;&nbsp; public void ProcessRequest(HttpContext context) &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Todo...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; context.Response.Write(&quot;Hello world!&quot;); &nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; #endregion }[/code]Registering a custom handlerFor ASP.NET to recognise our newly created handler, we must register it in Web.config:Now if you are using IIS6, you should also register this extension to be handled by the .NET runtime:In the application configuration, add the extension &quot;.docx&quot; and make it point to the following executable: C:\WINDOWS\Microsoft.NET\Framework\v2.0.50727\aspnet_isapi.dllThis should be it. Fire up your browser, browse to your web site and type anything.docx. You should see &quot;Hello world!&quot; appearing in a nice, white page.OpenXMLAs you may already know, Word 2007 files are OpenXML packages containg WordprocessingML markup. A .docx file can be opened using the System.IO.Packaging.Package class (which is available after adding a project reference to WindowsBase.dll).The Package class is created for accessing any OpenXML package. This includes all Office 2007 file formats, but also custom OpenXML formats which you can implement for yourself. Unfortunately, if you want to use Package to access an Office 2007 file, you'll have to implement a lot of utility functions to get the right parts from the OpenXML container.Luckily, Microsoft released an OpenXML SDK (CTP), which I also used in order to create this Word preview handler.LINQ to XMLAs you know, the latest .NET 3.5 release brought us something new &amp; extremely handy: LINQ (Language Integrated Query). On Doug's blog, I read about Eric White's attempts to use LINQ to XML on OpenXML.LINQ to OpenXMLFor implementing my handler, I basically used similar code to Eric's to run query's on a Word document's contents. Here's an example which fetches all paragraphs in a Word document:[code:c#]using (WordprocessingDocument document = WordprocessingDocument.Open(&quot;test.docx&quot;, false)) { &nbsp;&nbsp;&nbsp; // Register namespace&nbsp;&nbsp;&nbsp; XNamespace w = &quot;http://schemas.openxmlformats.org/wordprocessingml/2006/main&quot;;&nbsp;&nbsp;&nbsp; // Element shortcuts&nbsp;&nbsp;&nbsp; XName w_r = w + &quot;r&quot;; &nbsp;&nbsp;&nbsp; XName w_ins = w + &quot;ins&quot;; &nbsp;&nbsp;&nbsp; XName w_hyperlink = w + &quot;hyperlink&quot;;&nbsp;&nbsp;&nbsp; // Load document's MainDocumentPart (document.xml) in XDocument&nbsp;&nbsp;&nbsp; XDocument xDoc = XDocument.Load( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XmlReader.Create( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new StreamReader(document.MainDocumentPart.GetStream()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ) &nbsp;&nbsp;&nbsp; );&nbsp;&nbsp;&nbsp; // Fetch paragraphs&nbsp;&nbsp;&nbsp; var paragraphs = from l_paragraph in xDoc &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Root &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Element(w + &quot;body&quot;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Descendants(w + &quot;p&quot;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select new &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TextRuns = l_paragraph.Elements().Where(z => z.Name == w_r || z.Name == w_ins || z.Name == w_hyperlink) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };&nbsp;&nbsp;&nbsp; // Write paragraphs&nbsp;&nbsp;&nbsp; foreach (var paragraph in paragraphs) &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Fetch runs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var runs = from l_run in paragraph.Runs &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select new &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Text = l_run.Descendants(w + &quot;t&quot;).StringConcatenate(element => (string)element) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Write runs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (var run in runs) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Use run.Text to fetch a text string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.Write(run.Text); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; } }[/code]Now if you run this code, you will notice a compilation error... This is due to the fact that I used an extension method StringConcatenate.Extension methodsIn the above example, I used an extension method named StringConcatenate. An extension method is, as the name implies, an &quot;extension&quot; to a known class. In the following example, find the extension for all IEnumerable<T> instances:[code:c#]public static class IEnumerableExtensions { &nbsp;&nbsp;&nbsp; /// <summary> &nbsp;&nbsp;&nbsp; /// Concatenate strings &nbsp;&nbsp;&nbsp; /// </summary> &nbsp;&nbsp;&nbsp; /// <typeparam name=&quot;T&quot;>Type</typeparam> &nbsp;&nbsp;&nbsp; /// <param name=&quot;source&quot;>Source</param> &nbsp;&nbsp;&nbsp; /// <param name=&quot;func&quot;>Function delegate</param> &nbsp;&nbsp;&nbsp; /// <returns>Concatenated string</returns>&nbsp;&nbsp;&nbsp; public static string StringConcatenate<T>(this IEnumerable<T> source, Func<T, string> func) &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StringBuilder sb = new StringBuilder(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (T item in source) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sb.Append(func(item)); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return sb.ToString(); &nbsp;&nbsp;&nbsp; } }[/code]Lambda expressionsAnother thing you may have noticed in my example code, is a lambda expression:[code:c#]z => z.Name == w_r || z.Name == w_ins || z.Name == w_hyperlink.[/code]A lambda expression is actually an anonymous method, which is called by the StringConcatenate extension method. Lambda expressions always accept a parameter, and return true/false. In this case, z is instantiated as an XNode, returning true/false depending on its Name property.Wrapping things up...If you read this whole blog post, you may have noticed that I extensively used C# 3.5's new language features. I combined these with OpenXML and ASP.NET to create a useful Word document preview handler. If you want the full source code, download it here: WordVisualizer.zip (357.01 kb). This is an imported post. It was imported from my old blog using an automated tool and may contain formatting errors and/or broken images.">
  <meta name="twitter:url" content="https://blog.maartenballiauw.be/post/2008/01/11/preview-word-files-(docx)-in-html-using-aspnet-openxml-and-linq-to-xml.html">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="https://blog.maartenballiauw.be/images/splash/1.jpg">
  <meta name="twitter:creator" content="@Maarten Balliauw">
  <meta property="og:image" content="https://blog.maartenballiauw.be/images/splash/1.jpg">
  <meta property="og:type" content="article">
  <meta property="article:published_time" content="2008-01-11T15:12:00+01:00"> 
  <script type="application/ld+json"> { "@context" : "http://schema.org", "@type" : "Person", "name" : "Maarten Balliauw {blog}", "url" : "https://blog.maartenballiauw.be", "sameAs" : ["https://twitter.com/maartenballiauw","https://www.linkedin.com/in/maartenballiauw","https://about.me/maartenballiauw","http://stackoverflow.com/cv/maartenballiauw"] } </script> 
  <link href="https://blog.maartenballiauw.be/feed.xml" type="application/atom+xml" rel="alternate" title="Maarten Balliauw {blog} Feed"> 
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
  <script> document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js '; </script> 
  <link rel="stylesheet" href="https://blog.maartenballiauw.be/assets/css/main.css">
  <meta http-equiv="cleartype" content="on"> 
 </head>
 <body> 
  <!--[if lt IE 9]><div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</div><![endif]-->
  <div class="masthead">
   <div class="masthead__inner-wrap">
    <div class="masthead__menu">
     <nav id="site-nav" class="greedy-nav"> 
      <button>
       <div class="navicon"></div></button>
      <ul class="visible-links">
       <li class="masthead__menu-item masthead__menu-item--lg"><a href="https://blog.maartenballiauw.be/">Maarten Balliauw {blog}</a></li>
       <li class="masthead__menu-item"><a href="https://blog.maartenballiauw.be/about-me.html">About me</a></li>
       <li class="masthead__menu-item"><a href="https://blog.maartenballiauw.be/hire-me.html">Hire me</a></li>
       <li class="masthead__menu-item"><a href="https://blog.maartenballiauw.be/talks-presentations.html">Talks &amp; Presentations</a></li>
       <li class="masthead__menu-item"><a href="https://blog.maartenballiauw.be/contact-me.html">Contact</a></li>
       <li class="masthead__menu-item"><a href="https://blog.maartenballiauw.be/archive/posts-by-year.html">Archive</a></li>
       <li class="masthead__menu-item"><a href="https://blog.maartenballiauw.be/disclaimer.html">Disclaimer</a></li>
      </ul>
      <ul class="hidden-links hidden"></ul>
     </nav>
    </div>
   </div>
  </div>
  <div class="page__hero" style=" "> 
   <img src="https://blog.maartenballiauw.be/images/splash/1.jpg" alt="Preview Word files (docx) in HTML using ASP.NET, OpenXML and LINQ to XML" class="page__hero-image">
  </div>
  <div id="main" role="main">
   <div class="sidebar sticky">
    <div itemscope itemtype="http://schema.org/Person">
     <div class="author__avatar"> 
      <img src="https://blog.maartenballiauw.be/images/bio-photo.jpg" class="author__avatar" alt="Maarten Balliauw">
     </div>
     <div class="author__content">
      <h3 class="author__name">Maarten Balliauw</h3>
      <p class="author__bio">Loves ASP.NET MVC, C#, Microsoft Azure, PHP and application performance. Co-founded <a href="http://www.myget.org">MyGet</a>. Developer Advocate at <a href="http://www.jetbrains.com">JetBrains</a>. Frequent speaker at and organizer of various national and international events. Likes brewing his own beer.</p>
     </div>
     <div class="author__urls-wrapper"> 
      <button class="btn btn--inverse">Follow</button>
      <ul class="author__urls social-icons">
       <li><i class="fa fa-fw fa-map-marker" aria-hidden="true"></i> Antwerp, Belgium</li>
       <li><a href="https://twitter.com/maartenballiauw"><i class="fa fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
       <li><a href="https://www.linkedin.com/in/maartenballiauw"><i class="fa fa-fw fa-linkedin-square" aria-hidden="true"></i> LinkedIn</a></li>
       <li><a href="https://github.com/maartenba"><i class="fa fa-fw fa-github" aria-hidden="true"></i> Github</a></li>
      </ul>
     </div>
    </div>
    <div class="ad ad-left" data-type="ad" data-publisher="lqm.maartenballiauw.site" data-format="160x600" data-zone="side"></div>
   </div>
   <article class="page" itemscope itemtype="http://schema.org/CreativeWork">
    <meta itemprop="headline" content="Preview Word files (docx) in HTML using ASP.NET, OpenXML and LINQ to XML">
    <meta itemprop="description" content="Since an image (or even an example) tells&nbsp;more than any text will ever do, here's what I've created in the past few evening hours:Live examples:Test document 1&nbsp;(examples offline)Test document 2&nbsp;(examples offline)Test document 3 (with image)&nbsp;(examples offline)Want the source code? Download it here: WordVisualizer.zip (357.01 kb)Want to know how?If you want to know how I did this, let me first tell you why I created this. After searching Google for something similar, I found a Sharepoint blogger who did the same using a Sharepoint XSL transformation document called DocX2Html.xsl. Great, but this document can not be distributed without a Sharepoint license. The only option for me was to do something similar myself.ASP.NET handlersThe main idea of this project was to be able to type in a URL ending in &quot;.docx&quot;, which would then render a preview of the underlying Word document. Luckily, ASP.NET provides a system of creating HttpHandlers. A HttpHandler is the class instance which is called by the .NET runtime to process an incoming request for a specific extension. So let's trick ASP.NET into believing &quot;.docx&quot; is an extension which should be handled by a custom class...Creating a custom handlerA custom handler can be created quite easily. Just create a new class, and make it implement the IHttpHandler interface:[code:c#]/// <summary> /// Word document HTTP handler /// </summary>public class WordDocumentHandler : IHttpHandler { &nbsp;&nbsp;&nbsp; #region IHttpHandler Members&nbsp;&nbsp;&nbsp; /// <summary> &nbsp;&nbsp;&nbsp; /// Is the handler reusable? &nbsp;&nbsp;&nbsp; /// </summary>&nbsp;&nbsp;&nbsp; public bool IsReusable &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get { return true; } &nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; /// <summary> &nbsp;&nbsp;&nbsp; /// Process request &nbsp;&nbsp;&nbsp; /// </summary> &nbsp;&nbsp;&nbsp; /// <param name=&quot;context&quot;>Current http context</param>&nbsp;&nbsp;&nbsp;&nbsp; public void ProcessRequest(HttpContext context) &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Todo...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; context.Response.Write(&quot;Hello world!&quot;); &nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; #endregion }[/code]Registering a custom handlerFor ASP.NET to recognise our newly created handler, we must register it in Web.config:Now if you are using IIS6, you should also register this extension to be handled by the .NET runtime:In the application configuration, add the extension &quot;.docx&quot; and make it point to the following executable: C:\WINDOWS\Microsoft.NET\Framework\v2.0.50727\aspnet_isapi.dllThis should be it. Fire up your browser, browse to your web site and type anything.docx. You should see &quot;Hello world!&quot; appearing in a nice, white page.OpenXMLAs you may already know, Word 2007 files are OpenXML packages containg WordprocessingML markup. A .docx file can be opened using the System.IO.Packaging.Package class (which is available after adding a project reference to WindowsBase.dll).The Package class is created for accessing any OpenXML package. This includes all Office 2007 file formats, but also custom OpenXML formats which you can implement for yourself. Unfortunately, if you want to use Package to access an Office 2007 file, you'll have to implement a lot of utility functions to get the right parts from the OpenXML container.Luckily, Microsoft released an OpenXML SDK (CTP), which I also used in order to create this Word preview handler.LINQ to XMLAs you know, the latest .NET 3.5 release brought us something new &amp; extremely handy: LINQ (Language Integrated Query). On Doug's blog, I read about Eric White's attempts to use LINQ to XML on OpenXML.LINQ to OpenXMLFor implementing my handler, I basically used similar code to Eric's to run query's on a Word document's contents. Here's an example which fetches all paragraphs in a Word document:[code:c#]using (WordprocessingDocument document = WordprocessingDocument.Open(&quot;test.docx&quot;, false)) { &nbsp;&nbsp;&nbsp; // Register namespace&nbsp;&nbsp;&nbsp; XNamespace w = &quot;http://schemas.openxmlformats.org/wordprocessingml/2006/main&quot;;&nbsp;&nbsp;&nbsp; // Element shortcuts&nbsp;&nbsp;&nbsp; XName w_r = w + &quot;r&quot;; &nbsp;&nbsp;&nbsp; XName w_ins = w + &quot;ins&quot;; &nbsp;&nbsp;&nbsp; XName w_hyperlink = w + &quot;hyperlink&quot;;&nbsp;&nbsp;&nbsp; // Load document's MainDocumentPart (document.xml) in XDocument&nbsp;&nbsp;&nbsp; XDocument xDoc = XDocument.Load( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XmlReader.Create( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new StreamReader(document.MainDocumentPart.GetStream()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ) &nbsp;&nbsp;&nbsp; );&nbsp;&nbsp;&nbsp; // Fetch paragraphs&nbsp;&nbsp;&nbsp; var paragraphs = from l_paragraph in xDoc &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Root &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Element(w + &quot;body&quot;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Descendants(w + &quot;p&quot;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select new &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TextRuns = l_paragraph.Elements().Where(z => z.Name == w_r || z.Name == w_ins || z.Name == w_hyperlink) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };&nbsp;&nbsp;&nbsp; // Write paragraphs&nbsp;&nbsp;&nbsp; foreach (var paragraph in paragraphs) &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Fetch runs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var runs = from l_run in paragraph.Runs &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select new &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Text = l_run.Descendants(w + &quot;t&quot;).StringConcatenate(element => (string)element) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Write runs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (var run in runs) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Use run.Text to fetch a text string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.Write(run.Text); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp; } }[/code]Now if you run this code, you will notice a compilation error... This is due to the fact that I used an extension method StringConcatenate.Extension methodsIn the above example, I used an extension method named StringConcatenate. An extension method is, as the name implies, an &quot;extension&quot; to a known class. In the following example, find the extension for all IEnumerable<T> instances:[code:c#]public static class IEnumerableExtensions { &nbsp;&nbsp;&nbsp; /// <summary> &nbsp;&nbsp;&nbsp; /// Concatenate strings &nbsp;&nbsp;&nbsp; /// </summary> &nbsp;&nbsp;&nbsp; /// <typeparam name=&quot;T&quot;>Type</typeparam> &nbsp;&nbsp;&nbsp; /// <param name=&quot;source&quot;>Source</param> &nbsp;&nbsp;&nbsp; /// <param name=&quot;func&quot;>Function delegate</param> &nbsp;&nbsp;&nbsp; /// <returns>Concatenated string</returns>&nbsp;&nbsp;&nbsp; public static string StringConcatenate<T>(this IEnumerable<T> source, Func<T, string> func) &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StringBuilder sb = new StringBuilder(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (T item in source) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sb.Append(func(item)); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return sb.ToString(); &nbsp;&nbsp;&nbsp; } }[/code]Lambda expressionsAnother thing you may have noticed in my example code, is a lambda expression:[code:c#]z => z.Name == w_r || z.Name == w_ins || z.Name == w_hyperlink.[/code]A lambda expression is actually an anonymous method, which is called by the StringConcatenate extension method. Lambda expressions always accept a parameter, and return true/false. In this case, z is instantiated as an XNode, returning true/false depending on its Name property.Wrapping things up...If you read this whole blog post, you may have noticed that I extensively used C# 3.5's new language features. I combined these with OpenXML and ASP.NET to create a useful Word document preview handler. If you want the full source code, download it here: WordVisualizer.zip (357.01 kb). This is an imported post. It was imported from my old blog using an automated tool and may contain formatting errors and/or broken images.">
    <meta itemprop="datePublished" content="January 11, 2008">
    <div class="page__inner-wrap">
     <div class="ad" data-type="ad" data-publisher="lqm.maartenballiauw.site" data-format="728x90" data-zone="top"></div>
     <header>
      <h1 class="page__title" itemprop="headline">Preview Word files (docx) in HTML using ASP.NET, OpenXML and LINQ to XML</h1>
     </header>
     <section class="page__content" itemprop="text">
      <p>Since an image (or even an example) tells&nbsp;more than any text will ever do, here's what I've created in the past few evening hours:</p>
      <p style="text-align: center;"><img style="border: 0px;" src="/images/WindowsLiveWriter/PreviewWordfilesd.NETOpenXMLandLINQtoXML_C70E/image_3.png" border="0" alt="image" width="660" height="238"></p>
      <p>Live examples:</p>
      <ul>
       <li><span style="text-decoration: line-through;"><a href="http://examples.maartenballiauw.be/WordVisualizer/Documents/test.docx" target="_blank">Test document 1</a></span>&nbsp;(examples offline)</li>
       <li><span style="text-decoration: line-through;"><a href="http://examples.maartenballiauw.be/WordVisualizer/Documents/test2.docx" target="_blank">Test document 2</a></span>&nbsp;(examples offline)</li>
       <li><span style="text-decoration: line-through;"><a href="http://examples.maartenballiauw.be/WordVisualizer/Documents/test3.docx" target="_blank">Test document 3 (with image)</a></span>&nbsp;(examples offline)</li>
      </ul>
      <p>Want the source code? Download it here: <a href="/files/2012/11/WordVisualizer.zip">WordVisualizer.zip (357.01 kb)</a></p>
      <h2>Want to know how?</h2>
      <p>If you want to know how I did this, let me first tell you why I created this. After searching Google for something similar, I found a <a href="http://blog.thekid.me.uk/archive/2007/10/20/creating-a-docx-html-preview-handler-for-sharepoint.aspx" target="_blank">Sharepoint blogger who did the same</a> using a Sharepoint XSL transformation document called <em>DocX2Html.xsl</em>. Great, but this document can not be distributed without a Sharepoint license. The only option for me was to do something similar myself.</p>
      <h2>ASP.NET handlers</h2>
      <p>The main idea of this project was to be able to type in a URL ending in ".docx", which would then render a preview of the underlying Word document. Luckily, ASP.NET provides a system of creating <em>HttpHandler</em>s. A <em>HttpHandler</em> is the class instance which is called by the .NET runtime to process an incoming request for a specific extension. So let's trick ASP.NET into believing ".docx" is an extension which should be handled by a custom class...</p>
      <h3>Creating a custom handler</h3>
      <p>A custom handler can be created quite easily. Just create a new class, and make it implement the <em>IHttpHandler</em> interface:</p>
      <p>[code:c#]</p>
      <p>/// &lt;summary&gt;<br> /// Word document HTTP handler<br> /// &lt;/summary&gt;</p>
      <p>public class WordDocumentHandler : IHttpHandler<br> {<br> &nbsp;&nbsp;&nbsp; #region IHttpHandler Members</p>
      <p>&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br> &nbsp;&nbsp;&nbsp; /// Is the handler reusable?<br> &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;</p>
      <p>&nbsp;&nbsp;&nbsp; public bool IsReusable<br> &nbsp;&nbsp;&nbsp; {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get { return true; }<br> &nbsp;&nbsp;&nbsp; }</p>
      <p>&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br> &nbsp;&nbsp;&nbsp; /// Process request<br> &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br> &nbsp;&nbsp;&nbsp; /// &lt;param name="context"&gt;Current http context&lt;/param&gt;</p>
      <p>&nbsp;&nbsp;&nbsp;&nbsp; public void ProcessRequest(HttpContext context)<br> &nbsp;&nbsp;&nbsp; {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Todo...</p>
      <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; context.Response.Write("Hello world!");<br> &nbsp;&nbsp;&nbsp; }</p>
      <p>&nbsp;&nbsp;&nbsp; #endregion<br> }</p>
      <p>[/code]</p>
      <h3>Registering a custom handler</h3>
      <p>For ASP.NET to recognise our newly created handler, we must register it in Web.config:</p>
      <p><img style="border: 0px;" src="/images/WindowsLiveWriter/PreviewWordfilesd.NETOpenXMLandLINQtoXML_C70E/image_6.png" border="0" alt="image" width="710" height="218"></p>
      <p>Now if you are using IIS6, you should also register this extension to be handled by the .NET runtime:</p>
      <p><a href="/images/WindowsLiveWriter/PreviewWordfilesd.NETOpenXMLandLINQtoXML_C70E/image_8.png"><img style="border: 0px;" src="/images/WindowsLiveWriter/PreviewWordfilesd.NETOpenXMLandLINQtoXML_C70E/image_thumb_2.png" border="0" alt="image" width="568" height="525"></a></p>
      <p>In the application configuration, add the extension ".docx" and make it point to the following executable: <em>C:\WINDOWS\Microsoft.NET\Framework\v2.0.50727\aspnet_isapi.dll</em></p>
      <p>This should be it. Fire up your browser, browse to your web site and type <em>anything.docx</em>. You should see "Hello world!" appearing in a nice, white page.</p>
      <h2>OpenXML</h2>
      <p>As you may already know, Word 2007 files are <a href="http://en.wikipedia.org/wiki/Office_Open_XML" target="_blank">OpenXML</a> packages containg WordprocessingML markup. A .docx file can be opened using the <em>System.IO.Packaging.Package</em> class (which is available after adding a project reference to WindowsBase.dll).</p>
      <p>The <em>Package</em> class is created for accessing any OpenXML package. This includes all Office 2007 file formats, but also custom OpenXML formats which you can implement for yourself. Unfortunately, if you want to use <em>Package</em> to access an Office 2007 file, you'll have to implement a lot of utility functions to get the right parts from the OpenXML container.</p>
      <p>Luckily, Microsoft released an <a href="http://www.microsoft.com/downloads/details.aspx?familyid=ad0b72fb-4a1d-4c52-bdb5-7dd7e816d046&amp;displaylang=en" target="_blank">OpenXML SDK (CTP)</a>, which I also used in order to create this Word preview handler.</p>
      <h2>LINQ to XML</h2>
      <p>As you know, the latest <a href="http://www.microsoft.com/downloads/details.aspx?FamilyID=333325FD-AE52-4E35-B531-508D977D32A6&amp;displaylang=en" target="_blank">.NET 3.5</a> release brought us something new &amp; extremely handy: <a href="http://msdn2.microsoft.com/en-us/netframework/aa904594.aspx" target="_blank">LINQ</a> (Language Integrated Query). On <a href="http://blogs.msdn.com/dmahugh/archive/2007/12/11/linq-to-xml-code-samples.aspx" target="_blank">Doug's blog</a>, I read about <a href="http://blogs.msdn.com/ericwhite/archive/2007/12/11/Using-LINQ-to-XML-with-Open-XML-Documents.aspx" target="_blank">Eric White's attempts</a> to use LINQ to XML on OpenXML.</p>
      <h3>LINQ to OpenXML</h3>
      <p>For implementing my handler, I basically used similar code to Eric's to run query's on a Word document's contents. Here's an example which fetches all paragraphs in a Word document:</p>
      <p>[code:c#]</p>
      <p>using (WordprocessingDocument document = WordprocessingDocument.Open("test.docx", false))<br> {<br> &nbsp;&nbsp;&nbsp; // Register namespace</p>
      <p>&nbsp;&nbsp;&nbsp; XNamespace w = "<a href="http://schemas.openxmlformats.org/wordprocessingml/2006/main&quot;;">http://schemas.openxmlformats.org/wordprocessingml/2006/main";</a></p>
      <p>&nbsp;&nbsp;&nbsp; // Element shortcuts</p>
      <p>&nbsp;&nbsp;&nbsp; XName w_r = w + "r";<br> &nbsp;&nbsp;&nbsp; XName w_ins = w + "ins";<br> &nbsp;&nbsp;&nbsp; XName w_hyperlink = w + "hyperlink";</p>
      <p>&nbsp;&nbsp;&nbsp; // Load document's MainDocumentPart (document.xml) in XDocument</p>
      <p>&nbsp;&nbsp;&nbsp; XDocument xDoc = XDocument.Load(<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XmlReader.Create(<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new StreamReader(document.MainDocumentPart.GetStream())<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )<br> &nbsp;&nbsp;&nbsp; );</p>
      <p>&nbsp;&nbsp;&nbsp; // Fetch paragraphs</p>
      <p>&nbsp;&nbsp;&nbsp; var paragraphs = from l_paragraph in xDoc<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Root<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Element(w + "body")<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Descendants(w + "p")<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select new<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TextRuns = l_paragraph.Elements().Where(z =&gt; z.Name == w_r || z.Name == w_ins || z.Name == w_hyperlink)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</p>
      <p>&nbsp;&nbsp;&nbsp; // Write paragraphs</p>
      <p>&nbsp;&nbsp;&nbsp; foreach (var paragraph in paragraphs)<br> &nbsp;&nbsp;&nbsp; {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Fetch runs</p>
      <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var runs = from l_run in paragraph.Runs<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select new<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Text = l_run.Descendants(w + "t").StringConcatenate(element =&gt; (string)element)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</p>
      <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Write runs</p>
      <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (var run in runs)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Use run.Text to fetch a text string</p>
      <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.Write(run.Text);<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br> &nbsp;&nbsp;&nbsp; }<br> }</p>
      <p>[/code]</p>
      <p>Now if you run this code, you will notice a compilation error... This is due to the fact that I used an <a href="http://www.developer.com/net/csharp/article.php/3592216" target="_blank">extension method</a> <em>StringConcatenate</em>.</p>
      <h3>Extension methods</h3>
      <p>In the above example, I used an extension method named <em>StringConcatenate</em>. An extension method is, as the name implies, an "extension" to a known class. In the following example, find the extension for all <em>IEnumerable&lt;T&gt;</em> instances:</p>
      <p>[code:c#]</p>
      <p>public static class IEnumerableExtensions<br> {<br> &nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br> &nbsp;&nbsp;&nbsp; /// Concatenate strings<br> &nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br> &nbsp;&nbsp;&nbsp; /// &lt;typeparam name="T"&gt;Type&lt;/typeparam&gt;<br> &nbsp;&nbsp;&nbsp; /// &lt;param name="source"&gt;Source&lt;/param&gt;<br> &nbsp;&nbsp;&nbsp; /// &lt;param name="func"&gt;Function delegate&lt;/param&gt;<br> &nbsp;&nbsp;&nbsp; /// &lt;returns&gt;Concatenated string&lt;/returns&gt;</p>
      <p>&nbsp;&nbsp;&nbsp; public static string StringConcatenate&lt;T&gt;(this IEnumerable&lt;T&gt; source, Func&lt;T, string&gt; func)<br> &nbsp;&nbsp;&nbsp; {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StringBuilder sb = new StringBuilder();<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (T item in source)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sb.Append(func(item));<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return sb.ToString();<br> &nbsp;&nbsp;&nbsp; }<br> }</p>
      <p>[/code]</p>
      <h3>Lambda expressions</h3>
      <p>Another thing you may have noticed in my example code, is a <a href="http://weblogs.asp.net/scottgu/archive/2007/04/08/new-orcas-language-feature-lambda-expressions.aspx" target="_blank">lambda expression</a>:</p>
      <p>[code:c#]</p>
      <p>z =&gt; z.Name == w_r || z.Name == w_ins || z.Name == w_hyperlink.</p>
      <p>[/code]</p>
      <p>A lambda expression is actually an anonymous method, which is called by the <em>StringConcatenate</em> extension method. Lambda expressions always accept a parameter, and return true/false. In this case, <em>z</em> is instantiated as an <em>XNode</em>, returning true/false depending on its Name property.</p>
      <h2>Wrapping things up...</h2>
      <p>If you read this whole blog post, you may have noticed that I extensively used C# 3.5's new language features. I combined these with OpenXML and ASP.NET to create a useful Word document preview handler. If you want the full source code, download it here: <a href="/files/2012/11/WordVisualizer.zip">WordVisualizer.zip (357.01 kb)</a>.</p>
      <p><a href="http://www.dotnetkicks.com/kick/?url=/post/2008/01/Preview-Word-files-(docx)-in-HTML-using-ASPNET-OpenXML-and-LINQ-to-XML.aspx&amp;title=Preview Word files (docx) in HTML using ASP.NET, OpenXML and LINQ to XML"> <img src="http://www.dotnetkicks.com/Services/Images/KickItImageGenerator.ashx?url=/post/2008/01/Preview-Word-files-(docx)-in-HTML-using-ASPNET-OpenXML-and-LINQ-to-XML.aspx" border="0" alt="kick it on DotNetKicks.com"> </a></p>
      <p class="notice--warning"> <strong>This is an imported post.</strong> It was imported from my old blog using an automated tool and may contain formatting errors and/or broken images.</p>
     </section>
     <footer class="page__meta">
      <p class="page__taxonomy"> <strong><i class="fa fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong> <span itemprop="keywords"> <a href="https://blog.maartenballiauw.be/tags/#asp-net" class="page__taxonomy-item" rel="tag">ASP.NET</a><span class="sep">, </span> <a href="https://blog.maartenballiauw.be/tags/#csharp" class="page__taxonomy-item" rel="tag">CSharp</a><span class="sep">, </span> <a href="https://blog.maartenballiauw.be/tags/#general" class="page__taxonomy-item" rel="tag">General</a><span class="sep">, </span> <a href="https://blog.maartenballiauw.be/tags/#linq" class="page__taxonomy-item" rel="tag">LINQ</a><span class="sep">, </span> <a href="https://blog.maartenballiauw.be/tags/#openxml" class="page__taxonomy-item" rel="tag">OpenXML</a><span class="sep">, </span> <a href="https://blog.maartenballiauw.be/tags/#software" class="page__taxonomy-item" rel="tag">Software</a> </span></p>
      <p class="page__date"><strong><i class="fa fa-fw fa-calendar" aria-hidden="true"></i> Updated:</strong> <time datetime="2008-01-11T15:12:00+01:00">January 11, 2008</time></p>
     </footer>
     <section class="page__share">
      <h4 class="page__share-title">Share on</h4>
      <a href="https://twitter.com/intent/tweet?text=https://blog.maartenballiauw.be/post/2008/01/11/preview-word-files-(docx)-in-html-using-aspnet-openxml-and-linq-to-xml.html" class="btn btn--twitter" title="Share on Twitter"><i class="fa fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a> 
      <a href="https://www.facebook.com/sharer/sharer.php?u=https://blog.maartenballiauw.be/post/2008/01/11/preview-word-files-(docx)-in-html-using-aspnet-openxml-and-linq-to-xml.html" class="btn btn--facebook" title="Share on Facebook"><i class="fa fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a> 
      <a href="https://plus.google.com/share?url=https://blog.maartenballiauw.be/post/2008/01/11/preview-word-files-(docx)-in-html-using-aspnet-openxml-and-linq-to-xml.html" class="btn btn--google-plus" title="Share on Google Plus"><i class="fa fa-fw fa-google-plus" aria-hidden="true"></i><span> Google+</span></a> 
      <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://blog.maartenballiauw.be/post/2008/01/11/preview-word-files-(docx)-in-html-using-aspnet-openxml-and-linq-to-xml.html" class="btn btn--linkedin" title="Share on LinkedIn"><i class="fa fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
     </section>
     <nav class="pagination"> 
      <a href="https://blog.maartenballiauw.be/post/2007/12/31/aspnet-mvc-framework-security.html" class="pagination--pager" title="ASP.NET MVC framework - Security ">Previous</a> 
      <a href="https://blog.maartenballiauw.be/post/2008/01/22/linq-for-php-language-integrated-query-for-php.html" class="pagination--pager" title="LINQ for PHP (Language Integrated Query for PHP) ">Next</a>
     </nav>
    </div>
    <div class="page__comments">
     <h4 class="page__comments-title">Leave a Comment</h4>
     <section id="disqus_thread"></section>
    </div>
   </article>
  </div>
  <div class="page__footer">
   <footer> 
    <script type="text/javascript"> function _dmBootstrap(file) { var _dma = document.createElement('script'); _dma.type = 'text/javascript'; _dma.async = true; _dma.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + file; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(_dma); } function _dmFollowup(file) { if (typeof DMAds === 'undefined') _dmBootstrap('cdn2.DeveloperMedia.com/a.min.js'); } (function () { _dmBootstrap('cdn1.DeveloperMedia.com/a.min.js'); setTimeout(_dmFollowup, 2000); })(); </script> 
    <div class="page__footer-follow">
     <ul class="social-icons">
      <li><strong>Follow:</strong></li>
      <li><a href="https://twitter.com/maartenballiauw"><i class="fa fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
      <li><a href="http://github.com/maartenba"><i class="fa fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
      <li><a href="https://blog.maartenballiauw.be/feed.xml"><i class="fa fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
     </ul>
    </div>
    <div class="page__footer-copyright">
      2017 Maarten Balliauw {blog}. Powered by 
     <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; 
     <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.
    </div>
   </footer>
  </div>
  <script src="https://blog.maartenballiauw.be/assets/js/main.min.js"></script> 
  <script type="text/javascript"> var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-576836-3']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })(); </script> 
  <script type="text/javascript"> /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */ var disqus_shortname = 'maartenballiauwblog'; /* * * DON'T EDIT BELOW THIS LINE * * */ (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); /* * * DON'T EDIT BELOW THIS LINE * * */ (function () { var s = document.createElement('script'); s.async = true; s.type = 'text/javascript'; s.src = '//' + disqus_shortname + '.disqus.com/count.js'; (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s); }()); </script> 
  <noscript>
   Please enable JavaScript to view the 
   <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
  </noscript> 
 </body>
</html>