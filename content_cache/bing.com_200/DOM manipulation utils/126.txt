<!doctype html>
<html lang="en">
 <head>
  <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=900">
  <title>General filename and filepath manipulation utilities : Path&nbsp;«&nbsp;File Input Output&nbsp;«&nbsp;Java</title>
  <meta http-equiv="content-style-type" content="text/css">
  <meta name="author" content="" Demo Source and Support Ltd.'>
  <meta name="copyright" content="2015 Demo Source and Support Ltd.">
  <meta name="description" content="General filename and filepath manipulation utilities : Path&nbsp;«&nbsp;File Input Output&nbsp;«&nbsp;Java">
  <meta name="keywords" content="General filename and filepath manipulation utilities : Path&nbsp;«&nbsp;File Input Output&nbsp;«&nbsp;Java">
  <link rel="shortcut icon" href="http://www.java2s.com/style/favicon.ico">
  <link href="http://java2s.com/style/bootstrap.min.css" rel="stylesheet">
  <link href="http://java2s.com/style/longTutorial.css" rel="stylesheet">
  <script src="http://java2s.com/style/jquery-1.11.0.js"></script>
  <script src="http://java2s.com/style/bootstrap.min.js"></script>
  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:-->
  <!--[if lt IE 9]><script src='https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js'></script><script src='https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js'></script><![endif]-->
  <script>$(document).ready(function() {$('[data-toggle=offcanvas]').click(function() {$('.row-offcanvas').toggleClass('active');});});</script> 
 </head>
 <body>
  <div class="container-fluid">
   <div class="row row-offcanvas row-offcanvas-left">
    <div class="col-sm-3 col-md-3 sidebar-offcanvas" id="sidebar" role="navigation">
     <ul style="word-wrap: break-word;" class="nav nav-sidebar">
      <li><a href="http://www.java2s.com">Home</a></li>
      <li><a href="/Code/Java/CatalogJava.htm">Java</a></li>
      <li><a href="/Code/Java/2D-Graphics-GUI/Catalog2D-Graphics-GUI.htm">2D Graphics GUI</a></li>
      <li><a href="/Code/Java/3D/Catalog3D.htm">3D</a></li>
      <li><a href="/Code/Java/Advanced-Graphics/CatalogAdvanced-Graphics.htm">Advanced Graphics</a></li>
      <li><a href="/Code/Java/Ant/CatalogAnt.htm">Ant</a></li>
      <li><a href="/Code/Java/Apache-Common/CatalogApache-Common.htm">Apache Common</a></li>
      <li><a href="/Code/Java/Chart/CatalogChart.htm">Chart</a></li>
      <li><a href="/Code/Java/Class/CatalogClass.htm">Class</a></li>
      <li><a href="/Code/Java/Collections-Data-Structure/CatalogCollections-Data-Structure.htm">Collections Data Structure</a></li>
      <li><a href="/Code/Java/Data-Type/CatalogData-Type.htm">Data Type</a></li>
      <li><a href="/Code/Java/Database-SQL-JDBC/CatalogDatabase-SQL-JDBC.htm">Database SQL JDBC</a></li>
      <li><a href="/Code/Java/Design-Pattern/CatalogDesign-Pattern.htm">Design Pattern</a></li>
      <li><a href="/Code/Java/Development-Class/CatalogDevelopment-Class.htm">Development Class</a></li>
      <li><a href="/Code/Java/EJB3/CatalogEJB3.htm">EJB3</a></li>
      <li><a href="/Code/Java/Email/CatalogEmail.htm">Email</a></li>
      <li><a href="/Code/Java/Event/CatalogEvent.htm">Event</a></li>
      <li class="active"><a href="">File Input Output</a></li>
      <li><a href="/Code/Java/Game/CatalogGame.htm">Game</a></li>
      <li><a href="/Code/Java/Generics/CatalogGenerics.htm">Generics</a></li>
      <li><a href="/Code/Java/GWT/CatalogGWT.htm">GWT</a></li>
      <li><a href="/Code/Java/Hibernate/CatalogHibernate.htm">Hibernate</a></li>
      <li><a href="/Code/Java/I18N/CatalogI18N.htm">I18N</a></li>
      <li><a href="/Code/Java/J2EE/CatalogJ2EE.htm">J2EE</a></li>
      <li><a href="/Code/Java/J2ME/CatalogJ2ME.htm">J2ME</a></li>
      <li><a href="/Code/Java/JavaFX/CatalogJavaFX.htm">JavaFX</a></li>
      <li><a href="/Code/Java/JDK-6/CatalogJDK-6.htm">JDK 6</a></li>
      <li><a href="/Code/Java/JDK-7/CatalogJDK-7.htm">JDK 7</a></li>
      <li><a href="/Code/Java/JNDI-LDAP/CatalogJNDI-LDAP.htm">JNDI LDAP</a></li>
      <li><a href="/Code/Java/JPA/CatalogJPA.htm">JPA</a></li>
      <li><a href="/Code/Java/JSP/CatalogJSP.htm">JSP</a></li>
      <li><a href="/Code/Java/JSTL/CatalogJSTL.htm">JSTL</a></li>
      <li><a href="/Code/Java/Language-Basics/CatalogLanguage-Basics.htm">Language Basics</a></li>
      <li><a href="/Code/Java/Network-Protocol/CatalogNetwork-Protocol.htm">Network Protocol</a></li>
      <li><a href="/Code/Java/PDF-RTF/CatalogPDF-RTF.htm">PDF RTF</a></li>
      <li><a href="/Code/Java/Reflection/CatalogReflection.htm">Reflection</a></li>
      <li><a href="/Code/Java/Regular-Expressions/CatalogRegular-Expressions.htm">Regular Expressions</a></li>
      <li><a href="/Code/Java/Scripting/CatalogScripting.htm">Scripting</a></li>
      <li><a href="/Code/Java/Security/CatalogSecurity.htm">Security</a></li>
      <li><a href="/Code/Java/Servlets/CatalogServlets.htm">Servlets</a></li>
      <li><a href="/Code/Java/Spring/CatalogSpring.htm">Spring</a></li>
      <li><a href="/Code/Java/Swing-Components/CatalogSwing-Components.htm">Swing Components</a></li>
      <li><a href="/Code/Java/Swing-JFC/CatalogSwing-JFC.htm">Swing JFC</a></li>
      <li><a href="/Code/Java/SWT-JFace-Eclipse/CatalogSWT-JFace-Eclipse.htm">SWT JFace Eclipse</a></li>
      <li><a href="/Code/Java/Threads/CatalogThreads.htm">Threads</a></li>
      <li><a href="/Code/Java/Tiny-Application/CatalogTiny-Application.htm">Tiny Application</a></li>
      <li><a href="/Code/Java/Velocity/CatalogVelocity.htm">Velocity</a></li>
      <li><a href="/Code/Java/Web-Services-SOA/CatalogWeb-Services-SOA.htm">Web Services SOA</a></li>
      <li><a href="/Code/Java/XML/CatalogXML.htm">XML</a></li>
     </ul>
    </div>
    <div class="col-sm-9 col-md-9">
     <form class="form-inline pull-right" action="http://www.google.com/cse" id="cse-search-box">
      <fieldset>
       <label class="control-label"><input type="hidden" name="cx" value="partner-pub-1130008796007602:iri8be-v211"><input type="hidden" name="ie" value="ISO-8859-1"><input type="text" size="15" name="q"><input type="submit" name="sa" value="Search"></label>
      </fieldset>
     </form>
     <script type="text/javascript" src="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script>
     <h1>General filename and filepath manipulation utilities : Path&nbsp;«&nbsp;File Input Output&nbsp;«&nbsp;Java</h1>
     <script type="text/javascript"><!--
google_ad_client="pub-1130008796007602";google_ad_width=728;google_ad_height=90;google_ad_format="728x90_as";google_ad_type="text_image";google_ad_channel="";google_color_border="ffffff";google_color_bg="ffffff";google_color_link="003399";google_color_text="000000";google_color_url="75a3ed";
//--></script>
     <script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"></script>
     <br>
     <br>
     <br>
     <br>
     <br>
     <ol class="breadcrumb">
      <li><a href="/Code/Java/CatalogJava.htm">Java</a></li>
      <li><a href="/Code/Java/File-Input-Output/CatalogFile-Input-Output.htm">File Input Output</a></li>
      <li><a href="/Code/Java/File-Input-Output/Path.htm">Path</a></li>
      <li></li>
     </ol>
     <p>General filename and filepath manipulation utilities</p>
     <pre>       
<font color="#3f7f5f">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</font>

<font color="#7f0055"><b>import</b></font> java.io.File;
<font color="#7f0055"><b>import</b></font> java.io.Serializable;
<font color="#7f0055"><b>import</b></font> java.util.ArrayList;
<font color="#7f0055"><b>import</b></font> java.util.Collection;
<font color="#7f0055"><b>import</b></font> java.util.Iterator;
<font color="#7f0055"><b>import</b></font> java.util.Stack;

<font color="#3f7f5f">/**
 * General filename and filepath manipulation utilities.
 * &lt;p&gt;
 * When dealing with filenames you can hit problems when moving from a Windows
 * based development machine to a Unix based production machine.
 * This class aims to help avoid those problems.
 * &lt;p&gt;
 * &lt;b&gt;NOTE&lt;/b&gt;: You may be able to avoid using this class entirely simply by
 * using JDK {@link java.io.File File} objects and the two argument constructor
 * {@link java.io.File#File(java.io.File, java.lang.String) File(File,String)}.
 * &lt;p&gt;
 * Most methods on this class are designed to work the same on both Unix and Windows.
 * Those that don't include 'System', 'Unix' or 'Windows' in their name.
 * &lt;p&gt;
 * Most methods recognise both separators (forward and back), and both
 * sets of prefixes. See the javadoc of each method for details.
 * &lt;p&gt;
 * This class defines six components within a filename
 * (example C:\dev\project\file.txt):
 * &lt;ul&gt;
 * &lt;li&gt;the prefix - C:\&lt;/li&gt;
 * &lt;li&gt;the path - dev\project\&lt;/li&gt;
 * &lt;li&gt;the full path - C:\dev\project\&lt;/li&gt;
 * &lt;li&gt;the name - file.txt&lt;/li&gt;
 * &lt;li&gt;the base name - file&lt;/li&gt;
 * &lt;li&gt;the extension - txt&lt;/li&gt;
 * &lt;/ul&gt;
 * Note that this class works best if directory filenames end with a separator.
 * If you omit the last separator, it is impossible to determine if the filename
 * corresponds to a file or a directory. As a result, we have chosen to say
 * it corresponds to a file.
 * &lt;p&gt;
 * This class only supports Unix and Windows style names.
 * Prefixes are matched as follows:
 * &lt;pre&gt;
 * Windows:
 * a\b\c.txt           --&gt; ""          --&gt; relative
 * \a\b\c.txt          --&gt; "\"         --&gt; current drive absolute
 * C:a\b\c.txt         --&gt; "C:"        --&gt; drive relative
 * C:\a\b\c.txt        --&gt; "C:\"       --&gt; absolute
 * \\server\a\b\c.txt  --&gt; "\\server\" --&gt; UNC
 *
 * Unix:
 * a/b/c.txt           --&gt; ""          --&gt; relative
 * /a/b/c.txt          --&gt; "/"         --&gt; absolute
 * ~/a/b/c.txt         --&gt; "~/"        --&gt; current user
 * ~                   --&gt; "~/"        --&gt; current user (slash added)
 * ~user/a/b/c.txt     --&gt; "~user/"    --&gt; named user
 * ~user               --&gt; "~user/"    --&gt; named user (slash added)
 * &lt;/pre&gt;
 * Both prefix styles are matched always, irrespective of the machine that you are
 * currently running on.
 * &lt;p&gt;
 * Origin of code: Excalibur, Alexandria, Tomcat, Commons-Utils.
 *
 * @author &lt;a href="mailto:burton@relativity.yi.org"&gt;Kevin A. Burton&lt;/A&gt;
 * @author &lt;a href="mailto:sanders@apache.org"&gt;Scott Sanders&lt;/a&gt;
 * @author &lt;a href="mailto:dlr@finemaltcoding.com"&gt;Daniel Rall&lt;/a&gt;
 * @author &lt;a href="mailto:Christoph.Reck@dlr.de"&gt;Christoph.Reck&lt;/a&gt;
 * @author &lt;a href="mailto:peter@apache.org"&gt;Peter Donald&lt;/a&gt;
 * @author &lt;a href="mailto:jefft@apache.org"&gt;Jeff Turner&lt;/a&gt;
 * @author Matthew Hawthorne
 * @author Martin Cooper
 * @author &lt;a href="mailto:jeremias@apache.org"&gt;Jeremias Maerki&lt;/a&gt;
 * @author Stephen Colebourne
 * @version $Id: FilenameUtils.java 609870 2008-01-08 04:46:26Z niallp $
 * @since Commons IO 1.1
 */</font>
<font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>class</b></font> FilenameUtils {

    <font color="#3f7f5f">/**
     * The extension separator character.
     * @since Commons IO 1.4
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>static</b></font> <font color="#7f0055"><b>final</b></font> <font color="#7f0055"><b>char</b></font> EXTENSION_SEPARATOR = <font color="#2a00ff">'.'</font>;

    <font color="#3f7f5f">/**
     * The extension separator String.
     * @since Commons IO 1.4
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>static</b></font> <font color="#7f0055"><b>final</b></font> String EXTENSION_SEPARATOR_STR = (<font color="#7f0055"><b>new</b></font> Character(EXTENSION_SEPARATOR)).toString();

    <font color="#3f7f5f">/**
     * The Unix separator character.
     */</font>
    <font color="#7f0055"><b>private</b></font> <font color="#7f0055"><b>static</b></font> <font color="#7f0055"><b>final</b></font> <font color="#7f0055"><b>char</b></font> UNIX_SEPARATOR = <font color="#2a00ff">'/'</font>;

    <font color="#3f7f5f">/**
     * The Windows separator character.
     */</font>
    <font color="#7f0055"><b>private</b></font> <font color="#7f0055"><b>static</b></font> <font color="#7f0055"><b>final</b></font> <font color="#7f0055"><b>char</b></font> WINDOWS_SEPARATOR = <font color="#2a00ff">'\\'</font>;

    <font color="#3f7f5f">/**
     * The system separator character.
     */</font>
    <font color="#7f0055"><b>private</b></font> <font color="#7f0055"><b>static</b></font> <font color="#7f0055"><b>final</b></font> <font color="#7f0055"><b>char</b></font> SYSTEM_SEPARATOR = File.separatorChar;

    <font color="#3f7f5f">/**
     * The separator character that is the opposite of the system separator.
     */</font>
    <font color="#7f0055"><b>private</b></font> <font color="#7f0055"><b>static</b></font> <font color="#7f0055"><b>final</b></font> <font color="#7f0055"><b>char</b></font> OTHER_SEPARATOR;
    <font color="#7f0055"><b>static</b></font> {
        <font color="#7f0055"><b>if</b></font> (isSystemWindows()) {
            OTHER_SEPARATOR = UNIX_SEPARATOR;
        } <font color="#7f0055"><b>else</b></font> {
            OTHER_SEPARATOR = WINDOWS_SEPARATOR;
        }
    }

    <font color="#3f7f5f">/**
     * Instances should NOT be constructed in standard programming.
     */</font>
    <font color="#7f0055"><b>public</b></font> FilenameUtils() {
        <font color="#7f0055"><b>super</b></font>();
    }

    <font color="#3f7f5f">//-----------------------------------------------------------------------
</font>    <font color="#3f7f5f">/**
     * Determines if Windows file system is in use.
     * 
     * @return true if the system is Windows
     */</font>
    <font color="#7f0055"><b>static</b></font> <font color="#7f0055"><b>boolean</b></font> isSystemWindows() {
        <font color="#7f0055"><b>return</b></font> SYSTEM_SEPARATOR == WINDOWS_SEPARATOR;
    }

    <font color="#3f7f5f">//-----------------------------------------------------------------------
</font>    <font color="#3f7f5f">/**
     * Checks if the character is a separator.
     * 
     * @param ch  the character to check
     * @return true if it is a separator character
     */</font>
    <font color="#7f0055"><b>private</b></font> <font color="#7f0055"><b>static</b></font> <font color="#7f0055"><b>boolean</b></font> isSeparator(<font color="#7f0055"><b>char</b></font> ch) {
        <font color="#7f0055"><b>return</b></font> (ch == UNIX_SEPARATOR) || (ch == WINDOWS_SEPARATOR);
    }

    <font color="#3f7f5f">//-----------------------------------------------------------------------
</font>    <font color="#3f7f5f">/**
     * Normalizes a path, removing double and single dot path steps.
     * &lt;p&gt;
     * This method normalizes a path to a standard format.
     * The input may contain separators in either Unix or Windows format.
     * The output will contain separators in the format of the system.
     * &lt;p&gt;
     * A trailing slash will be retained.
     * A double slash will be merged to a single slash (but UNC names are handled).
     * A single dot path segment will be removed.
     * A double dot will cause that path segment and the one before to be removed.
     * If the double dot has no parent path segment to work with, &lt;code&gt;null&lt;/code&gt;
     * is returned.
     * &lt;p&gt;
     * The output will be the same on both Unix and Windows except
     * for the separator character.
     * &lt;pre&gt;
     * /foo//               --&gt;   /foo/
     * /foo/./              --&gt;   /foo/
     * /foo/../bar          --&gt;   /bar
     * /foo/../bar/         --&gt;   /bar/
     * /foo/../bar/../baz   --&gt;   /baz
     * //foo//./bar         --&gt;   /foo/bar
     * /../                 --&gt;   null
     * ../foo               --&gt;   null
     * foo/bar/..           --&gt;   foo/
     * foo/../../bar        --&gt;   null
     * foo/../bar           --&gt;   bar
     * //server/foo/../bar  --&gt;   //server/bar
     * //server/../bar      --&gt;   null
     * C:\foo\..\bar        --&gt;   C:\bar
     * C:\..\bar            --&gt;   null
     * ~/foo/../bar/        --&gt;   ~/bar/
     * ~/../bar             --&gt;   null
     * &lt;/pre&gt;
     * (Note the file separator returned will be correct for Windows/Unix)
     *
     * @param filename  the filename to normalize, null returns null
     * @return the normalized filename, or null if invalid
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>static</b></font> String normalize(String filename) {
        <font color="#7f0055"><b>return</b></font> doNormalize(filename, true);
    }

    <font color="#3f7f5f">//-----------------------------------------------------------------------
</font>    <font color="#3f7f5f">/**
     * Normalizes a path, removing double and single dot path steps,
     * and removing any final directory separator.
     * &lt;p&gt;
     * This method normalizes a path to a standard format.
     * The input may contain separators in either Unix or Windows format.
     * The output will contain separators in the format of the system.
     * &lt;p&gt;
     * A trailing slash will be removed.
     * A double slash will be merged to a single slash (but UNC names are handled).
     * A single dot path segment will be removed.
     * A double dot will cause that path segment and the one before to be removed.
     * If the double dot has no parent path segment to work with, &lt;code&gt;null&lt;/code&gt;
     * is returned.
     * &lt;p&gt;
     * The output will be the same on both Unix and Windows except
     * for the separator character.
     * &lt;pre&gt;
     * /foo//               --&gt;   /foo
     * /foo/./              --&gt;   /foo
     * /foo/../bar          --&gt;   /bar
     * /foo/../bar/         --&gt;   /bar
     * /foo/../bar/../baz   --&gt;   /baz
     * //foo//./bar         --&gt;   /foo/bar
     * /../                 --&gt;   null
     * ../foo               --&gt;   null
     * foo/bar/..           --&gt;   foo
     * foo/../../bar        --&gt;   null
     * foo/../bar           --&gt;   bar
     * //server/foo/../bar  --&gt;   //server/bar
     * //server/../bar      --&gt;   null
     * C:\foo\..\bar        --&gt;   C:\bar
     * C:\..\bar            --&gt;   null
     * ~/foo/../bar/        --&gt;   ~/bar
     * ~/../bar             --&gt;   null
     * &lt;/pre&gt;
     * (Note the file separator returned will be correct for Windows/Unix)
     *
     * @param filename  the filename to normalize, null returns null
     * @return the normalized filename, or null if invalid
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>static</b></font> String normalizeNoEndSeparator(String filename) {
        <font color="#7f0055"><b>return</b></font> doNormalize(filename, false);
    }

    <font color="#3f7f5f">/**
     * Internal method to perform the normalization.
     *
     * @param filename  the filename
     * @param keepSeparator  true to keep the final separator
     * @return the normalized filename
     */</font>
    <font color="#7f0055"><b>private</b></font> <font color="#7f0055"><b>static</b></font> String doNormalize(String filename, <font color="#7f0055"><b>boolean</b></font> keepSeparator) {
        <font color="#7f0055"><b>if</b></font> (filename == null) {
            <font color="#7f0055"><b>return</b></font> null;
        }
        <font color="#7f0055"><b>int</b></font> size = filename.length();
        <font color="#7f0055"><b>if</b></font> (size == 0) {
            <font color="#7f0055"><b>return</b></font> filename;
        }
        <font color="#7f0055"><b>int</b></font> prefix = getPrefixLength(filename);
        <font color="#7f0055"><b>if</b></font> (prefix &lt; 0) {
            <font color="#7f0055"><b>return</b></font> null;
        }
        
        <font color="#7f0055"><b>char</b></font>[] array = <font color="#7f0055"><b>new</b></font> <font color="#7f0055"><b>char</b></font>[size + 2];  <font color="#3f7f5f">// +1 for possible extra slash, +2 for arraycopy
</font>        filename.getChars(0, filename.length(), array, 0);
        
        <font color="#3f7f5f">// fix separators throughout
</font>        <font color="#7f0055"><b>for</b></font> (<font color="#7f0055"><b>int</b></font> i = 0; i &lt; array.length; i++) {
            <font color="#7f0055"><b>if</b></font> (array[i] == OTHER_SEPARATOR) {
                array[i] = SYSTEM_SEPARATOR;
            }
        }
        
        <font color="#3f7f5f">// add extra separator on the end to simplify code below
</font>        <font color="#7f0055"><b>boolean</b></font> lastIsDirectory = true;
        <font color="#7f0055"><b>if</b></font> (array[size - 1] != SYSTEM_SEPARATOR) {
            array[size++] = SYSTEM_SEPARATOR;
            lastIsDirectory = false;
        }
        
        <font color="#3f7f5f">// adjoining slashes
</font>        <font color="#7f0055"><b>for</b></font> (<font color="#7f0055"><b>int</b></font> i = prefix + 1; i &lt; size; i++) {
            <font color="#7f0055"><b>if</b></font> (array[i] == SYSTEM_SEPARATOR &amp;&amp; array[i - 1] == SYSTEM_SEPARATOR) {
                System.arraycopy(array, i, array, i - 1, size - i);
                size--;
                i--;
            }
        }
        
        <font color="#3f7f5f">// dot slash
</font>        <font color="#7f0055"><b>for</b></font> (<font color="#7f0055"><b>int</b></font> i = prefix + 1; i &lt; size; i++) {
            <font color="#7f0055"><b>if</b></font> (array[i] == SYSTEM_SEPARATOR &amp;&amp; array[i - 1] == <font color="#2a00ff">'.'</font> &amp;&amp;
                    (i == prefix + 1 || array[i - 2] == SYSTEM_SEPARATOR)) {
                <font color="#7f0055"><b>if</b></font> (i == size - 1) {
                    lastIsDirectory = true;
                }
                System.arraycopy(array, i + 1, array, i - 1, size - i);
                size -=2;
                i--;
            }
        }
        
        <font color="#3f7f5f">// double dot slash
</font>        outer:
        <font color="#7f0055"><b>for</b></font> (<font color="#7f0055"><b>int</b></font> i = prefix + 2; i &lt; size; i++) {
            <font color="#7f0055"><b>if</b></font> (array[i] == SYSTEM_SEPARATOR &amp;&amp; array[i - 1] == <font color="#2a00ff">'.'</font> &amp;&amp; array[i - 2] == <font color="#2a00ff">'.'</font> &amp;&amp;
                    (i == prefix + 2 || array[i - 3] == SYSTEM_SEPARATOR)) {
                <font color="#7f0055"><b>if</b></font> (i == prefix + 2) {
                    <font color="#7f0055"><b>return</b></font> null;
                }
                <font color="#7f0055"><b>if</b></font> (i == size - 1) {
                    lastIsDirectory = true;
                }
                <font color="#7f0055"><b>int</b></font> j;
                <font color="#7f0055"><b>for</b></font> (j = i - 4 ; j &gt;= prefix; j--) {
                    <font color="#7f0055"><b>if</b></font> (array[j] == SYSTEM_SEPARATOR) {
                        <font color="#3f7f5f">// remove b/../ from a/b/../c
</font>                        System.arraycopy(array, i + 1, array, j + 1, size - i);
                        size -= (i - j);
                        i = j + 1;
                        <font color="#7f0055"><b>continue</b></font> outer;
                    }
                }
                <font color="#3f7f5f">// remove a/../ from a/../c
</font>                System.arraycopy(array, i + 1, array, prefix, size - i);
                size -= (i + 1 - prefix);
                i = prefix + 1;
            }
        }
        
        <font color="#7f0055"><b>if</b></font> (size &lt;= 0) {  <font color="#3f7f5f">// should never be less than 0
</font>            <font color="#7f0055"><b>return</b></font> <font color="#2a00ff">""</font>;
        }
        <font color="#7f0055"><b>if</b></font> (size &lt;= prefix) {  <font color="#3f7f5f">// should never be less than prefix
</font>            <font color="#7f0055"><b>return</b></font> <font color="#7f0055"><b>new</b></font> String(array, 0, size);
        }
        <font color="#7f0055"><b>if</b></font> (lastIsDirectory &amp;&amp; keepSeparator) {
            <font color="#7f0055"><b>return</b></font> <font color="#7f0055"><b>new</b></font> String(array, 0, size);  <font color="#3f7f5f">// keep trailing separator
</font>        }
        <font color="#7f0055"><b>return</b></font> <font color="#7f0055"><b>new</b></font> String(array, 0, size - 1);  <font color="#3f7f5f">// lose trailing separator
</font>    }

    <font color="#3f7f5f">//-----------------------------------------------------------------------
</font>    <font color="#3f7f5f">/**
     * Concatenates a filename to a base path using normal command line style rules.
     * &lt;p&gt;
     * The effect is equivalent to resultant directory after changing
     * directory to the first argument, followed by changing directory to
     * the second argument.
     * &lt;p&gt;
     * The first argument is the base path, the second is the path to concatenate.
     * The returned path is always normalized via {@link #normalize(String)},
     * thus &lt;code&gt;..&lt;/code&gt; is handled.
     * &lt;p&gt;
     * If &lt;code&gt;pathToAdd&lt;/code&gt; is absolute (has an absolute prefix), then
     * it will be normalized and returned.
     * Otherwise, the paths will be joined, normalized and returned.
     * &lt;p&gt;
     * The output will be the same on both Unix and Windows except
     * for the separator character.
     * &lt;pre&gt;
     * /foo/ + bar          --&gt;   /foo/bar
     * /foo + bar           --&gt;   /foo/bar
     * /foo + /bar          --&gt;   /bar
     * /foo + C:/bar        --&gt;   C:/bar
     * /foo + C:bar         --&gt;   C:bar (*)
     * /foo/a/ + ../bar     --&gt;   foo/bar
     * /foo/ + ../../bar    --&gt;   null
     * /foo/ + /bar         --&gt;   /bar
     * /foo/.. + /bar       --&gt;   /bar
     * /foo + bar/c.txt     --&gt;   /foo/bar/c.txt
     * /foo/c.txt + bar     --&gt;   /foo/c.txt/bar (!)
     * &lt;/pre&gt;
     * (*) Note that the Windows relative drive prefix is unreliable when
     * used with this method.
     * (!) Note that the first parameter must be a path. If it ends with a name, then
     * the name will be built into the concatenated path. If this might be a problem,
     * use {@link #getFullPath(String)} on the base path argument.
     *
     * @param basePath  the base path to attach to, always treated as a path
     * @param fullFilenameToAdd  the filename (or path) to attach to the base
     * @return the concatenated path, or null if invalid
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>static</b></font> String concat(String basePath, String fullFilenameToAdd) {
        <font color="#7f0055"><b>int</b></font> prefix = getPrefixLength(fullFilenameToAdd);
        <font color="#7f0055"><b>if</b></font> (prefix &lt; 0) {
            <font color="#7f0055"><b>return</b></font> null;
        }
        <font color="#7f0055"><b>if</b></font> (prefix &gt; 0) {
            <font color="#7f0055"><b>return</b></font> normalize(fullFilenameToAdd);
        }
        <font color="#7f0055"><b>if</b></font> (basePath == null) {
            <font color="#7f0055"><b>return</b></font> null;
        }
        <font color="#7f0055"><b>int</b></font> len = basePath.length();
        <font color="#7f0055"><b>if</b></font> (len == 0) {
            <font color="#7f0055"><b>return</b></font> normalize(fullFilenameToAdd);
        }
        <font color="#7f0055"><b>char</b></font> ch = basePath.charAt(len - 1);
        <font color="#7f0055"><b>if</b></font> (isSeparator(ch)) {
            <font color="#7f0055"><b>return</b></font> normalize(basePath + fullFilenameToAdd);
        } <font color="#7f0055"><b>else</b></font> {
            <font color="#7f0055"><b>return</b></font> normalize(basePath + <font color="#2a00ff">'/'</font> + fullFilenameToAdd);
        }
    }

    <font color="#3f7f5f">//-----------------------------------------------------------------------
</font>    <font color="#3f7f5f">/**
     * Converts all separators to the Unix separator of forward slash.
     * 
     * @param path  the path to be changed, null ignored
     * @return the updated path
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>static</b></font> String separatorsToUnix(String path) {
        <font color="#7f0055"><b>if</b></font> (path == null || path.indexOf(WINDOWS_SEPARATOR) == -1) {
            <font color="#7f0055"><b>return</b></font> path;
        }
        <font color="#7f0055"><b>return</b></font> path.replace(WINDOWS_SEPARATOR, UNIX_SEPARATOR);
    }

    <font color="#3f7f5f">/**
     * Converts all separators to the Windows separator of backslash.
     * 
     * @param path  the path to be changed, null ignored
     * @return the updated path
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>static</b></font> String separatorsToWindows(String path) {
        <font color="#7f0055"><b>if</b></font> (path == null || path.indexOf(UNIX_SEPARATOR) == -1) {
            <font color="#7f0055"><b>return</b></font> path;
        }
        <font color="#7f0055"><b>return</b></font> path.replace(UNIX_SEPARATOR, WINDOWS_SEPARATOR);
    }

    <font color="#3f7f5f">/**
     * Converts all separators to the system separator.
     * 
     * @param path  the path to be changed, null ignored
     * @return the updated path
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>static</b></font> String separatorsToSystem(String path) {
        <font color="#7f0055"><b>if</b></font> (path == null) {
            <font color="#7f0055"><b>return</b></font> null;
        }
        <font color="#7f0055"><b>if</b></font> (isSystemWindows()) {
            <font color="#7f0055"><b>return</b></font> separatorsToWindows(path);
        } <font color="#7f0055"><b>else</b></font> {
            <font color="#7f0055"><b>return</b></font> separatorsToUnix(path);
        }
    }

    <font color="#3f7f5f">//-----------------------------------------------------------------------
</font>    <font color="#3f7f5f">/**
     * Returns the length of the filename prefix, such as &lt;code&gt;C:/&lt;/code&gt; or &lt;code&gt;~/&lt;/code&gt;.
     * &lt;p&gt;
     * This method will handle a file in either Unix or Windows format.
     * &lt;p&gt;
     * The prefix length includes the first slash in the full filename
     * if applicable. Thus, it is possible that the length returned is greater
     * than the length of the input string.
     * &lt;pre&gt;
     * Windows:
     * a\b\c.txt           --&gt; ""          --&gt; relative
     * \a\b\c.txt          --&gt; "\"         --&gt; current drive absolute
     * C:a\b\c.txt         --&gt; "C:"        --&gt; drive relative
     * C:\a\b\c.txt        --&gt; "C:\"       --&gt; absolute
     * \\server\a\b\c.txt  --&gt; "\\server\" --&gt; UNC
     *
     * Unix:
     * a/b/c.txt           --&gt; ""          --&gt; relative
     * /a/b/c.txt          --&gt; "/"         --&gt; absolute
     * ~/a/b/c.txt         --&gt; "~/"        --&gt; current user
     * ~                   --&gt; "~/"        --&gt; current user (slash added)
     * ~user/a/b/c.txt     --&gt; "~user/"    --&gt; named user
     * ~user               --&gt; "~user/"    --&gt; named user (slash added)
     * &lt;/pre&gt;
     * &lt;p&gt;
     * The output will be the same irrespective of the machine that the code is running on.
     * ie. both Unix and Windows prefixes are matched regardless.
     *
     * @param filename  the filename to find the prefix in, null returns -1
     * @return the length of the prefix, -1 if invalid or null
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>static</b></font> <font color="#7f0055"><b>int</b></font> getPrefixLength(String filename) {
        <font color="#7f0055"><b>if</b></font> (filename == null) {
            <font color="#7f0055"><b>return</b></font> -1;
        }
        <font color="#7f0055"><b>int</b></font> len = filename.length();
        <font color="#7f0055"><b>if</b></font> (len == 0) {
            <font color="#7f0055"><b>return</b></font> 0;
        }
        <font color="#7f0055"><b>char</b></font> ch0 = filename.charAt(0);
        <font color="#7f0055"><b>if</b></font> (ch0 == <font color="#2a00ff">':'</font>) {
            <font color="#7f0055"><b>return</b></font> -1;
        }
        <font color="#7f0055"><b>if</b></font> (len == 1) {
            <font color="#7f0055"><b>if</b></font> (ch0 == <font color="#2a00ff">'~'</font>) {
                <font color="#7f0055"><b>return</b></font> 2;  <font color="#3f7f5f">// return a length greater than the input
</font>            }
            <font color="#7f0055"><b>return</b></font> (isSeparator(ch0) ? 1 : 0);
        } <font color="#7f0055"><b>else</b></font> {
            <font color="#7f0055"><b>if</b></font> (ch0 == <font color="#2a00ff">'~'</font>) {
                <font color="#7f0055"><b>int</b></font> posUnix = filename.indexOf(UNIX_SEPARATOR, 1);
                <font color="#7f0055"><b>int</b></font> posWin = filename.indexOf(WINDOWS_SEPARATOR, 1);
                <font color="#7f0055"><b>if</b></font> (posUnix == -1 &amp;&amp; posWin == -1) {
                    <font color="#7f0055"><b>return</b></font> len + 1;  <font color="#3f7f5f">// return a length greater than the input
</font>                }
                posUnix = (posUnix == -1 ? posWin : posUnix);
                posWin = (posWin == -1 ? posUnix : posWin);
                <font color="#7f0055"><b>return</b></font> Math.min(posUnix, posWin) + 1;
            }
            <font color="#7f0055"><b>char</b></font> ch1 = filename.charAt(1);
            <font color="#7f0055"><b>if</b></font> (ch1 == <font color="#2a00ff">':'</font>) {
                ch0 = Character.toUpperCase(ch0);
                <font color="#7f0055"><b>if</b></font> (ch0 &gt;= <font color="#2a00ff">'A'</font> &amp;&amp; ch0 &lt;= <font color="#2a00ff">'Z'</font>) {
                    <font color="#7f0055"><b>if</b></font> (len == 2 || isSeparator(filename.charAt(2)) == false) {
                        <font color="#7f0055"><b>return</b></font> 2;
                    }
                    <font color="#7f0055"><b>return</b></font> 3;
                }
                <font color="#7f0055"><b>return</b></font> -1;
                
            } <font color="#7f0055"><b>else</b></font> <font color="#7f0055"><b>if</b></font> (isSeparator(ch0) &amp;&amp; isSeparator(ch1)) {
                <font color="#7f0055"><b>int</b></font> posUnix = filename.indexOf(UNIX_SEPARATOR, 2);
                <font color="#7f0055"><b>int</b></font> posWin = filename.indexOf(WINDOWS_SEPARATOR, 2);
                <font color="#7f0055"><b>if</b></font> ((posUnix == -1 &amp;&amp; posWin == -1) || posUnix == 2 || posWin == 2) {
                    <font color="#7f0055"><b>return</b></font> -1;
                }
                posUnix = (posUnix == -1 ? posWin : posUnix);
                posWin = (posWin == -1 ? posUnix : posWin);
                <font color="#7f0055"><b>return</b></font> Math.min(posUnix, posWin) + 1;
            } <font color="#7f0055"><b>else</b></font> {
                <font color="#7f0055"><b>return</b></font> (isSeparator(ch0) ? 1 : 0);
            }
        }
    }

    <font color="#3f7f5f">/**
     * Returns the index of the last directory separator character.
     * &lt;p&gt;
     * This method will handle a file in either Unix or Windows format.
     * The position of the last forward or backslash is returned.
     * &lt;p&gt;
     * The output will be the same irrespective of the machine that the code is running on.
     * 
     * @param filename  the filename to find the last path separator in, null returns -1
     * @return the index of the last separator character, or -1 if there
     * is no such character
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>static</b></font> <font color="#7f0055"><b>int</b></font> indexOfLastSeparator(String filename) {
        <font color="#7f0055"><b>if</b></font> (filename == null) {
            <font color="#7f0055"><b>return</b></font> -1;
        }
        <font color="#7f0055"><b>int</b></font> lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR);
        <font color="#7f0055"><b>int</b></font> lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR);
        <font color="#7f0055"><b>return</b></font> Math.max(lastUnixPos, lastWindowsPos);
    }

    <font color="#3f7f5f">/**
     * Returns the index of the last extension separator character, which is a dot.
     * &lt;p&gt;
     * This method also checks that there is no directory separator after the last dot.
     * To do this it uses {@link #indexOfLastSeparator(String)} which will
     * handle a file in either Unix or Windows format.
     * &lt;p&gt;
     * The output will be the same irrespective of the machine that the code is running on.
     * 
     * @param filename  the filename to find the last path separator in, null returns -1
     * @return the index of the last separator character, or -1 if there
     * is no such character
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>static</b></font> <font color="#7f0055"><b>int</b></font> indexOfExtension(String filename) {
        <font color="#7f0055"><b>if</b></font> (filename == null) {
            <font color="#7f0055"><b>return</b></font> -1;
        }
        <font color="#7f0055"><b>int</b></font> extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR);
        <font color="#7f0055"><b>int</b></font> lastSeparator = indexOfLastSeparator(filename);
        <font color="#7f0055"><b>return</b></font> (lastSeparator &gt; extensionPos ? -1 : extensionPos);
    }

    <font color="#3f7f5f">//-----------------------------------------------------------------------
</font>    <font color="#3f7f5f">/**
     * Gets the prefix from a full filename, such as &lt;code&gt;C:/&lt;/code&gt;
     * or &lt;code&gt;~/&lt;/code&gt;.
     * &lt;p&gt;
     * This method will handle a file in either Unix or Windows format.
     * The prefix includes the first slash in the full filename where applicable.
     * &lt;pre&gt;
     * Windows:
     * a\b\c.txt           --&gt; ""          --&gt; relative
     * \a\b\c.txt          --&gt; "\"         --&gt; current drive absolute
     * C:a\b\c.txt         --&gt; "C:"        --&gt; drive relative
     * C:\a\b\c.txt        --&gt; "C:\"       --&gt; absolute
     * \\server\a\b\c.txt  --&gt; "\\server\" --&gt; UNC
     *
     * Unix:
     * a/b/c.txt           --&gt; ""          --&gt; relative
     * /a/b/c.txt          --&gt; "/"         --&gt; absolute
     * ~/a/b/c.txt         --&gt; "~/"        --&gt; current user
     * ~                   --&gt; "~/"        --&gt; current user (slash added)
     * ~user/a/b/c.txt     --&gt; "~user/"    --&gt; named user
     * ~user               --&gt; "~user/"    --&gt; named user (slash added)
     * &lt;/pre&gt;
     * &lt;p&gt;
     * The output will be the same irrespective of the machine that the code is running on.
     * ie. both Unix and Windows prefixes are matched regardless.
     *
     * @param filename  the filename to query, null returns null
     * @return the prefix of the file, null if invalid
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>static</b></font> String getPrefix(String filename) {
        <font color="#7f0055"><b>if</b></font> (filename == null) {
            <font color="#7f0055"><b>return</b></font> null;
        }
        <font color="#7f0055"><b>int</b></font> len = getPrefixLength(filename);
        <font color="#7f0055"><b>if</b></font> (len &lt; 0) {
            <font color="#7f0055"><b>return</b></font> null;
        }
        <font color="#7f0055"><b>if</b></font> (len &gt; filename.length()) {
            <font color="#7f0055"><b>return</b></font> filename + UNIX_SEPARATOR;  <font color="#3f7f5f">// we know this only happens for unix
</font>        }
        <font color="#7f0055"><b>return</b></font> filename.substring(0, len);
    }

    <font color="#3f7f5f">/**
     * Gets the path from a full filename, which excludes the prefix.
     * &lt;p&gt;
     * This method will handle a file in either Unix or Windows format.
     * The method is entirely text based, and returns the text before and
     * including the last forward or backslash.
     * &lt;pre&gt;
     * C:\a\b\c.txt --&gt; a\b\
     * ~/a/b/c.txt  --&gt; a/b/
     * a.txt        --&gt; ""
     * a/b/c        --&gt; a/b/
     * a/b/c/       --&gt; a/b/c/
     * &lt;/pre&gt;
     * &lt;p&gt;
     * The output will be the same irrespective of the machine that the code is running on.
     * &lt;p&gt;
     * This method drops the prefix from the result.
     * See {@link #getFullPath(String)} for the method that retains the prefix.
     *
     * @param filename  the filename to query, null returns null
     * @return the path of the file, an empty string if none exists, null if invalid
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>static</b></font> String getPath(String filename) {
        <font color="#7f0055"><b>return</b></font> doGetPath(filename, 1);
    }

    <font color="#3f7f5f">/**
     * Gets the path from a full filename, which excludes the prefix, and
     * also excluding the final directory separator.
     * &lt;p&gt;
     * This method will handle a file in either Unix or Windows format.
     * The method is entirely text based, and returns the text before the
     * last forward or backslash.
     * &lt;pre&gt;
     * C:\a\b\c.txt --&gt; a\b
     * ~/a/b/c.txt  --&gt; a/b
     * a.txt        --&gt; ""
     * a/b/c        --&gt; a/b
     * a/b/c/       --&gt; a/b/c
     * &lt;/pre&gt;
     * &lt;p&gt;
     * The output will be the same irrespective of the machine that the code is running on.
     * &lt;p&gt;
     * This method drops the prefix from the result.
     * See {@link #getFullPathNoEndSeparator(String)} for the method that retains the prefix.
     *
     * @param filename  the filename to query, null returns null
     * @return the path of the file, an empty string if none exists, null if invalid
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>static</b></font> String getPathNoEndSeparator(String filename) {
        <font color="#7f0055"><b>return</b></font> doGetPath(filename, 0);
    }

    <font color="#3f7f5f">/**
     * Does the work of getting the path.
     * 
     * @param filename  the filename
     * @param separatorAdd  0 to omit the end separator, 1 to return it
     * @return the path
     */</font>
    <font color="#7f0055"><b>private</b></font> <font color="#7f0055"><b>static</b></font> String doGetPath(String filename, <font color="#7f0055"><b>int</b></font> separatorAdd) {
        <font color="#7f0055"><b>if</b></font> (filename == null) {
            <font color="#7f0055"><b>return</b></font> null;
        }
        <font color="#7f0055"><b>int</b></font> prefix = getPrefixLength(filename);
        <font color="#7f0055"><b>if</b></font> (prefix &lt; 0) {
            <font color="#7f0055"><b>return</b></font> null;
        }
        <font color="#7f0055"><b>int</b></font> index = indexOfLastSeparator(filename);
        <font color="#7f0055"><b>if</b></font> (prefix &gt;= filename.length() || index &lt; 0) {
            <font color="#7f0055"><b>return</b></font> <font color="#2a00ff">""</font>;
        }
        <font color="#7f0055"><b>return</b></font> filename.substring(prefix, index + separatorAdd);
    }

    <font color="#3f7f5f">/**
     * Gets the full path from a full filename, which is the prefix + path.
     * &lt;p&gt;
     * This method will handle a file in either Unix or Windows format.
     * The method is entirely text based, and returns the text before and
     * including the last forward or backslash.
     * &lt;pre&gt;
     * C:\a\b\c.txt --&gt; C:\a\b\
     * ~/a/b/c.txt  --&gt; ~/a/b/
     * a.txt        --&gt; ""
     * a/b/c        --&gt; a/b/
     * a/b/c/       --&gt; a/b/c/
     * C:           --&gt; C:
     * C:\          --&gt; C:\
     * ~            --&gt; ~/
     * ~/           --&gt; ~/
     * ~user        --&gt; ~user/
     * ~user/       --&gt; ~user/
     * &lt;/pre&gt;
     * &lt;p&gt;
     * The output will be the same irrespective of the machine that the code is running on.
     *
     * @param filename  the filename to query, null returns null
     * @return the path of the file, an empty string if none exists, null if invalid
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>static</b></font> String getFullPath(String filename) {
        <font color="#7f0055"><b>return</b></font> doGetFullPath(filename, true);
    }

    <font color="#3f7f5f">/**
     * Gets the full path from a full filename, which is the prefix + path,
     * and also excluding the final directory separator.
     * &lt;p&gt;
     * This method will handle a file in either Unix or Windows format.
     * The method is entirely text based, and returns the text before the
     * last forward or backslash.
     * &lt;pre&gt;
     * C:\a\b\c.txt --&gt; C:\a\b
     * ~/a/b/c.txt  --&gt; ~/a/b
     * a.txt        --&gt; ""
     * a/b/c        --&gt; a/b
     * a/b/c/       --&gt; a/b/c
     * C:           --&gt; C:
     * C:\          --&gt; C:\
     * ~            --&gt; ~
     * ~/           --&gt; ~
     * ~user        --&gt; ~user
     * ~user/       --&gt; ~user
     * &lt;/pre&gt;
     * &lt;p&gt;
     * The output will be the same irrespective of the machine that the code is running on.
     *
     * @param filename  the filename to query, null returns null
     * @return the path of the file, an empty string if none exists, null if invalid
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>static</b></font> String getFullPathNoEndSeparator(String filename) {
        <font color="#7f0055"><b>return</b></font> doGetFullPath(filename, false);
    }

    <font color="#3f7f5f">/**
     * Does the work of getting the path.
     * 
     * @param filename  the filename
     * @param includeSeparator  true to include the end separator
     * @return the path
     */</font>
    <font color="#7f0055"><b>private</b></font> <font color="#7f0055"><b>static</b></font> String doGetFullPath(String filename, <font color="#7f0055"><b>boolean</b></font> includeSeparator) {
        <font color="#7f0055"><b>if</b></font> (filename == null) {
            <font color="#7f0055"><b>return</b></font> null;
        }
        <font color="#7f0055"><b>int</b></font> prefix = getPrefixLength(filename);
        <font color="#7f0055"><b>if</b></font> (prefix &lt; 0) {
            <font color="#7f0055"><b>return</b></font> null;
        }
        <font color="#7f0055"><b>if</b></font> (prefix &gt;= filename.length()) {
            <font color="#7f0055"><b>if</b></font> (includeSeparator) {
                <font color="#7f0055"><b>return</b></font> getPrefix(filename);  <font color="#3f7f5f">// add end slash if necessary
</font>            } <font color="#7f0055"><b>else</b></font> {
                <font color="#7f0055"><b>return</b></font> filename;
            }
        }
        <font color="#7f0055"><b>int</b></font> index = indexOfLastSeparator(filename);
        <font color="#7f0055"><b>if</b></font> (index &lt; 0) {
            <font color="#7f0055"><b>return</b></font> filename.substring(0, prefix);
        }
        <font color="#7f0055"><b>int</b></font> end = index + (includeSeparator ?  1 : 0);
        <font color="#7f0055"><b>return</b></font> filename.substring(0, end);
    }

    <font color="#3f7f5f">/**
     * Gets the name minus the path from a full filename.
     * &lt;p&gt;
     * This method will handle a file in either Unix or Windows format.
     * The text after the last forward or backslash is returned.
     * &lt;pre&gt;
     * a/b/c.txt --&gt; c.txt
     * a.txt     --&gt; a.txt
     * a/b/c     --&gt; c
     * a/b/c/    --&gt; ""
     * &lt;/pre&gt;
     * &lt;p&gt;
     * The output will be the same irrespective of the machine that the code is running on.
     *
     * @param filename  the filename to query, null returns null
     * @return the name of the file without the path, or an empty string if none exists
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>static</b></font> String getName(String filename) {
        <font color="#7f0055"><b>if</b></font> (filename == null) {
            <font color="#7f0055"><b>return</b></font> null;
        }
        <font color="#7f0055"><b>int</b></font> index = indexOfLastSeparator(filename);
        <font color="#7f0055"><b>return</b></font> filename.substring(index + 1);
    }

    <font color="#3f7f5f">/**
     * Gets the base name, minus the full path and extension, from a full filename.
     * &lt;p&gt;
     * This method will handle a file in either Unix or Windows format.
     * The text after the last forward or backslash and before the last dot is returned.
     * &lt;pre&gt;
     * a/b/c.txt --&gt; c
     * a.txt     --&gt; a
     * a/b/c     --&gt; c
     * a/b/c/    --&gt; ""
     * &lt;/pre&gt;
     * &lt;p&gt;
     * The output will be the same irrespective of the machine that the code is running on.
     *
     * @param filename  the filename to query, null returns null
     * @return the name of the file without the path, or an empty string if none exists
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>static</b></font> String getBaseName(String filename) {
        <font color="#7f0055"><b>return</b></font> removeExtension(getName(filename));
    }

    <font color="#3f7f5f">/**
     * Gets the extension of a filename.
     * &lt;p&gt;
     * This method returns the textual part of the filename after the last dot.
     * There must be no directory separator after the dot.
     * &lt;pre&gt;
     * foo.txt      --&gt; "txt"
     * a/b/c.jpg    --&gt; "jpg"
     * a/b.txt/c    --&gt; ""
     * a/b/c        --&gt; ""
     * &lt;/pre&gt;
     * &lt;p&gt;
     * The output will be the same irrespective of the machine that the code is running on.
     *
     * @param filename the filename to retrieve the extension of.
     * @return the extension of the file or an empty string if none exists.
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>static</b></font> String getExtension(String filename) {
        <font color="#7f0055"><b>if</b></font> (filename == null) {
            <font color="#7f0055"><b>return</b></font> null;
        }
        <font color="#7f0055"><b>int</b></font> index = indexOfExtension(filename);
        <font color="#7f0055"><b>if</b></font> (index == -1) {
            <font color="#7f0055"><b>return</b></font> <font color="#2a00ff">""</font>;
        } <font color="#7f0055"><b>else</b></font> {
            <font color="#7f0055"><b>return</b></font> filename.substring(index + 1);
        }
    }

    <font color="#3f7f5f">//-----------------------------------------------------------------------
</font>    <font color="#3f7f5f">/**
     * Removes the extension from a filename.
     * &lt;p&gt;
     * This method returns the textual part of the filename before the last dot.
     * There must be no directory separator after the dot.
     * &lt;pre&gt;
     * foo.txt    --&gt; foo
     * a\b\c.jpg  --&gt; a\b\c
     * a\b\c      --&gt; a\b\c
     * a.b\c      --&gt; a.b\c
     * &lt;/pre&gt;
     * &lt;p&gt;
     * The output will be the same irrespective of the machine that the code is running on.
     *
     * @param filename  the filename to query, null returns null
     * @return the filename minus the extension
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>static</b></font> String removeExtension(String filename) {
        <font color="#7f0055"><b>if</b></font> (filename == null) {
            <font color="#7f0055"><b>return</b></font> null;
        }
        <font color="#7f0055"><b>int</b></font> index = indexOfExtension(filename);
        <font color="#7f0055"><b>if</b></font> (index == -1) {
            <font color="#7f0055"><b>return</b></font> filename;
        } <font color="#7f0055"><b>else</b></font> {
            <font color="#7f0055"><b>return</b></font> filename.substring(0, index);
        }
    }

    <font color="#3f7f5f">//-----------------------------------------------------------------------
</font>    <font color="#3f7f5f">/**
     * Checks whether two filenames are equal exactly.
     * &lt;p&gt;
     * No processing is performed on the filenames other than comparison,
     * thus this is merely a null-safe case-sensitive equals.
     *
     * @param filename1  the first filename to query, may be null
     * @param filename2  the second filename to query, may be null
     * @return true if the filenames are equal, null equals null
     * @see IOCase#SENSITIVE
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>static</b></font> <font color="#7f0055"><b>boolean</b></font> equals(String filename1, String filename2) {
        <font color="#7f0055"><b>return</b></font> equals(filename1, filename2, false, IOCase.SENSITIVE);
    }

    <font color="#3f7f5f">/**
     * Checks whether two filenames are equal using the case rules of the system.
     * &lt;p&gt;
     * No processing is performed on the filenames other than comparison.
     * The check is case-sensitive on Unix and case-insensitive on Windows.
     *
     * @param filename1  the first filename to query, may be null
     * @param filename2  the second filename to query, may be null
     * @return true if the filenames are equal, null equals null
     * @see IOCase#SYSTEM
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>static</b></font> <font color="#7f0055"><b>boolean</b></font> equalsOnSystem(String filename1, String filename2) {
        <font color="#7f0055"><b>return</b></font> equals(filename1, filename2, false, IOCase.SYSTEM);
    }

    <font color="#3f7f5f">//-----------------------------------------------------------------------
</font>    <font color="#3f7f5f">/**
     * Checks whether two filenames are equal after both have been normalized.
     * &lt;p&gt;
     * Both filenames are first passed to {@link #normalize(String)}.
     * The check is then performed in a case-sensitive manner.
     *
     * @param filename1  the first filename to query, may be null
     * @param filename2  the second filename to query, may be null
     * @return true if the filenames are equal, null equals null
     * @see IOCase#SENSITIVE
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>static</b></font> <font color="#7f0055"><b>boolean</b></font> equalsNormalized(String filename1, String filename2) {
        <font color="#7f0055"><b>return</b></font> equals(filename1, filename2, true, IOCase.SENSITIVE);
    }

    <font color="#3f7f5f">/**
     * Checks whether two filenames are equal after both have been normalized
     * and using the case rules of the system.
     * &lt;p&gt;
     * Both filenames are first passed to {@link #normalize(String)}.
     * The check is then performed case-sensitive on Unix and
     * case-insensitive on Windows.
     *
     * @param filename1  the first filename to query, may be null
     * @param filename2  the second filename to query, may be null
     * @return true if the filenames are equal, null equals null
     * @see IOCase#SYSTEM
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>static</b></font> <font color="#7f0055"><b>boolean</b></font> equalsNormalizedOnSystem(String filename1, String filename2) {
        <font color="#7f0055"><b>return</b></font> equals(filename1, filename2, true, IOCase.SYSTEM);
    }

    <font color="#3f7f5f">/**
     * Checks whether two filenames are equal, optionally normalizing and providing
     * control over the case-sensitivity.
     *
     * @param filename1  the first filename to query, may be null
     * @param filename2  the second filename to query, may be null
     * @param normalized  whether to normalize the filenames
     * @param caseSensitivity  what case sensitivity rule to use, null means case-sensitive
     * @return true if the filenames are equal, null equals null
     * @since Commons IO 1.3
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>static</b></font> <font color="#7f0055"><b>boolean</b></font> equals(
            String filename1, String filename2,
            <font color="#7f0055"><b>boolean</b></font> normalized, IOCase caseSensitivity) {
        
        <font color="#7f0055"><b>if</b></font> (filename1 == null || filename2 == null) {
            <font color="#7f0055"><b>return</b></font> filename1 == filename2;
        }
        <font color="#7f0055"><b>if</b></font> (normalized) {
            filename1 = normalize(filename1);
            filename2 = normalize(filename2);
            <font color="#7f0055"><b>if</b></font> (filename1 == null || filename2 == null) {
                <font color="#7f0055"><b>throw</b></font> <font color="#7f0055"><b>new</b></font> NullPointerException(
                    <font color="#2a00ff">"Error normalizing one or both of the file names"</font>);
            }
        }
        <font color="#7f0055"><b>if</b></font> (caseSensitivity == null) {
            caseSensitivity = IOCase.SENSITIVE;
        }
        <font color="#7f0055"><b>return</b></font> caseSensitivity.checkEquals(filename1, filename2);
    }

    <font color="#3f7f5f">//-----------------------------------------------------------------------
</font>    <font color="#3f7f5f">/**
     * Checks whether the extension of the filename is that specified.
     * &lt;p&gt;
     * This method obtains the extension as the textual part of the filename
     * after the last dot. There must be no directory separator after the dot.
     * The extension check is case-sensitive on all platforms.
     *
     * @param filename  the filename to query, null returns false
     * @param extension  the extension to check for, null or empty checks for no extension
     * @return true if the filename has the specified extension
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>static</b></font> <font color="#7f0055"><b>boolean</b></font> isExtension(String filename, String extension) {
        <font color="#7f0055"><b>if</b></font> (filename == null) {
            <font color="#7f0055"><b>return</b></font> false;
        }
        <font color="#7f0055"><b>if</b></font> (extension == null || extension.length() == 0) {
            <font color="#7f0055"><b>return</b></font> (indexOfExtension(filename) == -1);
        }
        String fileExt = getExtension(filename);
        <font color="#7f0055"><b>return</b></font> fileExt.equals(extension);
    }

    <font color="#3f7f5f">/**
     * Checks whether the extension of the filename is one of those specified.
     * &lt;p&gt;
     * This method obtains the extension as the textual part of the filename
     * after the last dot. There must be no directory separator after the dot.
     * The extension check is case-sensitive on all platforms.
     *
     * @param filename  the filename to query, null returns false
     * @param extensions  the extensions to check for, null checks for no extension
     * @return true if the filename is one of the extensions
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>static</b></font> <font color="#7f0055"><b>boolean</b></font> isExtension(String filename, String[] extensions) {
        <font color="#7f0055"><b>if</b></font> (filename == null) {
            <font color="#7f0055"><b>return</b></font> false;
        }
        <font color="#7f0055"><b>if</b></font> (extensions == null || extensions.length == 0) {
            <font color="#7f0055"><b>return</b></font> (indexOfExtension(filename) == -1);
        }
        String fileExt = getExtension(filename);
        <font color="#7f0055"><b>for</b></font> (<font color="#7f0055"><b>int</b></font> i = 0; i &lt; extensions.length; i++) {
            <font color="#7f0055"><b>if</b></font> (fileExt.equals(extensions[i])) {
                <font color="#7f0055"><b>return</b></font> true;
            }
        }
        <font color="#7f0055"><b>return</b></font> false;
    }

    <font color="#3f7f5f">/**
     * Checks whether the extension of the filename is one of those specified.
     * &lt;p&gt;
     * This method obtains the extension as the textual part of the filename
     * after the last dot. There must be no directory separator after the dot.
     * The extension check is case-sensitive on all platforms.
     *
     * @param filename  the filename to query, null returns false
     * @param extensions  the extensions to check for, null checks for no extension
     * @return true if the filename is one of the extensions
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>static</b></font> <font color="#7f0055"><b>boolean</b></font> isExtension(String filename, Collection extensions) {
        <font color="#7f0055"><b>if</b></font> (filename == null) {
            <font color="#7f0055"><b>return</b></font> false;
        }
        <font color="#7f0055"><b>if</b></font> (extensions == null || extensions.isEmpty()) {
            <font color="#7f0055"><b>return</b></font> (indexOfExtension(filename) == -1);
        }
        String fileExt = getExtension(filename);
        <font color="#7f0055"><b>for</b></font> (Iterator it = extensions.iterator(); it.hasNext();) {
            <font color="#7f0055"><b>if</b></font> (fileExt.equals(it.next())) {
                <font color="#7f0055"><b>return</b></font> true;
            }
        }
        <font color="#7f0055"><b>return</b></font> false;
    }

    <font color="#3f7f5f">//-----------------------------------------------------------------------
</font>    <font color="#3f7f5f">/**
     * Checks a filename to see if it matches the specified wildcard matcher,
     * always testing case-sensitive.
     * &lt;p&gt;
     * The wildcard matcher uses the characters '?' and '*' to represent a
     * single or multiple wildcard characters.
     * This is the same as often found on Dos/Unix command lines.
     * The check is case-sensitive always.
     * &lt;pre&gt;
     * wildcardMatch("c.txt", "*.txt")      --&gt; true
     * wildcardMatch("c.txt", "*.jpg")      --&gt; false
     * wildcardMatch("a/b/c.txt", "a/b/*")  --&gt; true
     * wildcardMatch("c.txt", "*.???")      --&gt; true
     * wildcardMatch("c.txt", "*.????")     --&gt; false
     * &lt;/pre&gt;
     * 
     * @param filename  the filename to match on
     * @param wildcardMatcher  the wildcard string to match against
     * @return true if the filename matches the wilcard string
     * @see IOCase#SENSITIVE
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>static</b></font> <font color="#7f0055"><b>boolean</b></font> wildcardMatch(String filename, String wildcardMatcher) {
        <font color="#7f0055"><b>return</b></font> wildcardMatch(filename, wildcardMatcher, IOCase.SENSITIVE);
    }

    <font color="#3f7f5f">/**
     * Checks a filename to see if it matches the specified wildcard matcher
     * using the case rules of the system.
     * &lt;p&gt;
     * The wildcard matcher uses the characters '?' and '*' to represent a
     * single or multiple wildcard characters.
     * This is the same as often found on Dos/Unix command lines.
     * The check is case-sensitive on Unix and case-insensitive on Windows.
     * &lt;pre&gt;
     * wildcardMatch("c.txt", "*.txt")      --&gt; true
     * wildcardMatch("c.txt", "*.jpg")      --&gt; false
     * wildcardMatch("a/b/c.txt", "a/b/*")  --&gt; true
     * wildcardMatch("c.txt", "*.???")      --&gt; true
     * wildcardMatch("c.txt", "*.????")     --&gt; false
     * &lt;/pre&gt;
     * 
     * @param filename  the filename to match on
     * @param wildcardMatcher  the wildcard string to match against
     * @return true if the filename matches the wilcard string
     * @see IOCase#SYSTEM
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>static</b></font> <font color="#7f0055"><b>boolean</b></font> wildcardMatchOnSystem(String filename, String wildcardMatcher) {
        <font color="#7f0055"><b>return</b></font> wildcardMatch(filename, wildcardMatcher, IOCase.SYSTEM);
    }

    <font color="#3f7f5f">/**
     * Checks a filename to see if it matches the specified wildcard matcher
     * allowing control over case-sensitivity.
     * &lt;p&gt;
     * The wildcard matcher uses the characters '?' and '*' to represent a
     * single or multiple wildcard characters.
     * 
     * @param filename  the filename to match on
     * @param wildcardMatcher  the wildcard string to match against
     * @param caseSensitivity  what case sensitivity rule to use, null means case-sensitive
     * @return true if the filename matches the wilcard string
     * @since Commons IO 1.3
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>static</b></font> <font color="#7f0055"><b>boolean</b></font> wildcardMatch(String filename, String wildcardMatcher, IOCase caseSensitivity) {
        <font color="#7f0055"><b>if</b></font> (filename == null &amp;&amp; wildcardMatcher == null) {
            <font color="#7f0055"><b>return</b></font> true;
        }
        <font color="#7f0055"><b>if</b></font> (filename == null || wildcardMatcher == null) {
            <font color="#7f0055"><b>return</b></font> false;
        }
        <font color="#7f0055"><b>if</b></font> (caseSensitivity == null) {
            caseSensitivity = IOCase.SENSITIVE;
        }
        filename = caseSensitivity.convertCase(filename);
        wildcardMatcher = caseSensitivity.convertCase(wildcardMatcher);
        String[] wcs = splitOnTokens(wildcardMatcher);
        <font color="#7f0055"><b>boolean</b></font> anyChars = false;
        <font color="#7f0055"><b>int</b></font> textIdx = 0;
        <font color="#7f0055"><b>int</b></font> wcsIdx = 0;
        Stack backtrack = <font color="#7f0055"><b>new</b></font> Stack();
        
        <font color="#3f7f5f">// loop around a backtrack stack, to handle complex * matching
</font>        <font color="#7f0055"><b>do</b></font> {
            <font color="#7f0055"><b>if</b></font> (backtrack.size() &gt; 0) {
                <font color="#7f0055"><b>int</b></font>[] array = (<font color="#7f0055"><b>int</b></font>[]) backtrack.pop();
                wcsIdx = array[0];
                textIdx = array[1];
                anyChars = true;
            }
            
            <font color="#3f7f5f">// loop whilst tokens and text left to process
</font>            <font color="#7f0055"><b>while</b></font> (wcsIdx &lt; wcs.length) {
      
                <font color="#7f0055"><b>if</b></font> (wcs[wcsIdx].equals(<font color="#2a00ff">"?"</font>)) {
                    <font color="#3f7f5f">// ? so move to next text char
</font>                    textIdx++;
                    anyChars = false;
                    
                } <font color="#7f0055"><b>else</b></font> <font color="#7f0055"><b>if</b></font> (wcs[wcsIdx].equals(<font color="#2a00ff">"*"</font>)) {
                    <font color="#3f7f5f">// set any chars status
</font>                    anyChars = true;
                    <font color="#7f0055"><b>if</b></font> (wcsIdx == wcs.length - 1) {
                        textIdx = filename.length();
                    }
                    
                } <font color="#7f0055"><b>else</b></font> {
                    <font color="#3f7f5f">// matching text token
</font>                    <font color="#7f0055"><b>if</b></font> (anyChars) {
                        <font color="#3f7f5f">// any chars then try to locate text token
</font>                        textIdx = filename.indexOf(wcs[wcsIdx], textIdx);
                        <font color="#7f0055"><b>if</b></font> (textIdx == -1) {
                            <font color="#3f7f5f">// token not found
</font>                            <font color="#7f0055"><b>break</b></font>;
                        }
                        <font color="#7f0055"><b>int</b></font> repeat = filename.indexOf(wcs[wcsIdx], textIdx + 1);
                        <font color="#7f0055"><b>if</b></font> (repeat &gt;= 0) {
                            backtrack.push(<font color="#7f0055"><b>new</b></font> <font color="#7f0055"><b>int</b></font>[] {wcsIdx, repeat});
                        }
                    } <font color="#7f0055"><b>else</b></font> {
                        <font color="#3f7f5f">// matching from current position
</font>                        <font color="#7f0055"><b>if</b></font> (!filename.startsWith(wcs[wcsIdx], textIdx)) {
                            <font color="#3f7f5f">// couldnt match token
</font>                            <font color="#7f0055"><b>break</b></font>;
                        }
                    }
      
                    <font color="#3f7f5f">// matched text token, move text index to end of matched token
</font>                    textIdx += wcs[wcsIdx].length();
                    anyChars = false;
                }
      
                wcsIdx++;
            }
            
            <font color="#3f7f5f">// full match
</font>            <font color="#7f0055"><b>if</b></font> (wcsIdx == wcs.length &amp;&amp; textIdx == filename.length()) {
                <font color="#7f0055"><b>return</b></font> true;
            }
            
        } <font color="#7f0055"><b>while</b></font> (backtrack.size() &gt; 0);
  
        <font color="#7f0055"><b>return</b></font> false;
    }

    <font color="#3f7f5f">/**
     * Splits a string into a number of tokens.
     * 
     * @param text  the text to split
     * @return the tokens, never null
     */</font>
    <font color="#7f0055"><b>static</b></font> String[] splitOnTokens(String text) {
        <font color="#3f7f5f">// used by wildcardMatch
</font>        <font color="#3f7f5f">// package level so a unit test may run on this
</font>        
        <font color="#7f0055"><b>if</b></font> (text.indexOf(<font color="#2a00ff">"?"</font>) == -1 &amp;&amp; text.indexOf(<font color="#2a00ff">"*"</font>) == -1) {
            <font color="#7f0055"><b>return</b></font> <font color="#7f0055"><b>new</b></font> String[] { text };
        }

        <font color="#7f0055"><b>char</b></font>[] array = text.toCharArray();
        ArrayList list = <font color="#7f0055"><b>new</b></font> ArrayList();
        StringBuffer buffer = <font color="#7f0055"><b>new</b></font> StringBuffer();
        <font color="#7f0055"><b>for</b></font> (<font color="#7f0055"><b>int</b></font> i = 0; i &lt; array.length; i++) {
            <font color="#7f0055"><b>if</b></font> (array[i] == <font color="#2a00ff">'?'</font> || array[i] == <font color="#2a00ff">'*'</font>) {
                <font color="#7f0055"><b>if</b></font> (buffer.length() != 0) {
                    list.add(buffer.toString());
                    buffer.setLength(0);
                }
                <font color="#7f0055"><b>if</b></font> (array[i] == <font color="#2a00ff">'?'</font>) {
                    list.add(<font color="#2a00ff">"?"</font>);
                } <font color="#7f0055"><b>else</b></font> <font color="#7f0055"><b>if</b></font> (list.size() == 0 ||
                        (i &gt; 0 &amp;&amp; list.get(list.size() - 1).equals(<font color="#2a00ff">"*"</font>) == false)) {
                    list.add(<font color="#2a00ff">"*"</font>);
                }
            } <font color="#7f0055"><b>else</b></font> {
                buffer.append(array[i]);
            }
        }
        <font color="#7f0055"><b>if</b></font> (buffer.length() != 0) {
            list.add(buffer.toString());
        }

        <font color="#7f0055"><b>return</b></font> (String[]) list.toArray( <font color="#7f0055"><b>new</b></font> String[ list.size() ] );
    }

}

<font color="#3f7f5f">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</font>


<font color="#3f7f5f">/**
 * Enumeration of IO case sensitivity.
 * &lt;p&gt;
 * Different filing systems have different rules for case-sensitivity.
 * Windows is case-insensitive, Unix is case-sensitive.
 * &lt;p&gt;
 * This class captures that difference, providing an enumeration to
 * control how filename comparisons should be performed. It also provides
 * methods that use the enumeration to perform comparisons.
 * &lt;p&gt;
 * Wherever possible, you should use the &lt;code&gt;check&lt;/code&gt; methods in this
 * class to compare filenames.
 *
 * @author Stephen Colebourne
 * @version $Id: IOCase.java 606345 2007-12-21 23:43:01Z ggregory $
 * @since Commons IO 1.3
 */</font>
 <font color="#7f0055"><b>final</b></font> <font color="#7f0055"><b>class</b></font> IOCase <font color="#7f0055"><b>implements</b></font> Serializable {

    <font color="#3f7f5f">/**
     * The constant for case sensitive regardless of operating system.
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>static</b></font> <font color="#7f0055"><b>final</b></font> IOCase SENSITIVE = <font color="#7f0055"><b>new</b></font> IOCase(<font color="#2a00ff">"Sensitive"</font>, true);
    
    <font color="#3f7f5f">/**
     * The constant for case insensitive regardless of operating system.
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>static</b></font> <font color="#7f0055"><b>final</b></font> IOCase INSENSITIVE = <font color="#7f0055"><b>new</b></font> IOCase(<font color="#2a00ff">"Insensitive"</font>, false);
    
    <font color="#3f7f5f">/**
     * The constant for case sensitivity determined by the current operating system.
     * Windows is case-insensitive when comparing filenames, Unix is case-sensitive.
     * &lt;p&gt;
     * If you derialize this constant of Windows, and deserialize on Unix, or vice
     * versa, then the value of the case-sensitivity flag will change.
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>static</b></font> <font color="#7f0055"><b>final</b></font> IOCase SYSTEM = <font color="#7f0055"><b>new</b></font> IOCase(<font color="#2a00ff">"System"</font>, !FilenameUtils.isSystemWindows());

    <font color="#3f7f5f">/** Serialization version. */</font>
    <font color="#7f0055"><b>private</b></font> <font color="#7f0055"><b>static</b></font> <font color="#7f0055"><b>final</b></font> <font color="#7f0055"><b>long</b></font> serialVersionUID = -6343169151696340687L;

    <font color="#3f7f5f">/** The enumeration name. */</font>
    <font color="#7f0055"><b>private</b></font> <font color="#7f0055"><b>final</b></font> String name;
    
    <font color="#3f7f5f">/** The sensitivity flag. */</font>
    <font color="#7f0055"><b>private</b></font> <font color="#7f0055"><b>final</b></font> <font color="#7f0055"><b>transient</b></font> <font color="#7f0055"><b>boolean</b></font> sensitive;

    <font color="#3f7f5f">//-----------------------------------------------------------------------
</font>    <font color="#3f7f5f">/**
     * Factory method to create an IOCase from a name.
     * 
     * @param name  the name to find
     * @return the IOCase object
     * @throws IllegalArgumentException if the name is invalid
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>static</b></font> IOCase forName(String name) {
        <font color="#7f0055"><b>if</b></font> (IOCase.SENSITIVE.name.equals(name)){
            <font color="#7f0055"><b>return</b></font> IOCase.SENSITIVE;
        }
        <font color="#7f0055"><b>if</b></font> (IOCase.INSENSITIVE.name.equals(name)){
            <font color="#7f0055"><b>return</b></font> IOCase.INSENSITIVE;
        }
        <font color="#7f0055"><b>if</b></font> (IOCase.SYSTEM.name.equals(name)){
            <font color="#7f0055"><b>return</b></font> IOCase.SYSTEM;
        }
        <font color="#7f0055"><b>throw</b></font> <font color="#7f0055"><b>new</b></font> IllegalArgumentException(<font color="#2a00ff">"Invalid IOCase name: "</font> + name);
    }

    <font color="#3f7f5f">//-----------------------------------------------------------------------
</font>    <font color="#3f7f5f">/**
     * Private constructor.
     * 
     * @param name  the name
     * @param sensitive  the sensitivity
     */</font>
    <font color="#7f0055"><b>private</b></font> IOCase(String name, <font color="#7f0055"><b>boolean</b></font> sensitive) {
        this.name = name;
        this.sensitive = sensitive;
    }

    <font color="#3f7f5f">/**
     * Replaces the enumeration from the stream with a real one.
     * This ensures that the correct flag is set for SYSTEM.
     * 
     * @return the resolved object
     */</font>
    <font color="#7f0055"><b>private</b></font> Object readResolve() {
        <font color="#7f0055"><b>return</b></font> forName(name);
    }

    <font color="#3f7f5f">//-----------------------------------------------------------------------
</font>    <font color="#3f7f5f">/**
     * Gets the name of the constant.
     * 
     * @return the name of the constant
     */</font>
    <font color="#7f0055"><b>public</b></font> String getName() {
        <font color="#7f0055"><b>return</b></font> name;
    }

    <font color="#3f7f5f">/**
     * Does the object represent case sensitive comparison.
     * 
     * @return true if case sensitive
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>boolean</b></font> isCaseSensitive() {
        <font color="#7f0055"><b>return</b></font> sensitive;
    }

    <font color="#3f7f5f">//-----------------------------------------------------------------------
</font>    <font color="#3f7f5f">/**
     * Compares two strings using the case-sensitivity rule.
     * &lt;p&gt;
     * This method mimics {@link String#compareTo} but takes case-sensitivity
     * into account.
     * 
     * @param str1  the first string to compare, not null
     * @param str2  the second string to compare, not null
     * @return true if equal using the case rules
     * @throws NullPointerException if either string is null
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>int</b></font> checkCompareTo(String str1, String str2) {
        <font color="#7f0055"><b>if</b></font> (str1 == null || str2 == null) {
            <font color="#7f0055"><b>throw</b></font> <font color="#7f0055"><b>new</b></font> NullPointerException(<font color="#2a00ff">"The strings must not be null"</font>);
        }
        <font color="#7f0055"><b>return</b></font> sensitive ? str1.compareTo(str2) : str1.compareToIgnoreCase(str2);
    }

    <font color="#3f7f5f">/**
     * Compares two strings using the case-sensitivity rule.
     * &lt;p&gt;
     * This method mimics {@link String#equals} but takes case-sensitivity
     * into account.
     * 
     * @param str1  the first string to compare, not null
     * @param str2  the second string to compare, not null
     * @return true if equal using the case rules
     * @throws NullPointerException if either string is null
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>boolean</b></font> checkEquals(String str1, String str2) {
        <font color="#7f0055"><b>if</b></font> (str1 == null || str2 == null) {
            <font color="#7f0055"><b>throw</b></font> <font color="#7f0055"><b>new</b></font> NullPointerException(<font color="#2a00ff">"The strings must not be null"</font>);
        }
        <font color="#7f0055"><b>return</b></font> sensitive ? str1.equals(str2) : str1.equalsIgnoreCase(str2);
    }

    <font color="#3f7f5f">/**
     * Checks if one string starts with another using the case-sensitivity rule.
     * &lt;p&gt;
     * This method mimics {@link String#startsWith(String)} but takes case-sensitivity
     * into account.
     * 
     * @param str  the string to check, not null
     * @param start  the start to compare against, not null
     * @return true if equal using the case rules
     * @throws NullPointerException if either string is null
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>boolean</b></font> checkStartsWith(String str, String start) {
        <font color="#7f0055"><b>return</b></font> str.regionMatches(!sensitive, 0, start, 0, start.length());
    }

    <font color="#3f7f5f">/**
     * Checks if one string ends with another using the case-sensitivity rule.
     * &lt;p&gt;
     * This method mimics {@link String#endsWith} but takes case-sensitivity
     * into account.
     * 
     * @param str  the string to check, not null
     * @param end  the end to compare against, not null
     * @return true if equal using the case rules
     * @throws NullPointerException if either string is null
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>boolean</b></font> checkEndsWith(String str, String end) {
        <font color="#7f0055"><b>int</b></font> endLen = end.length();
        <font color="#7f0055"><b>return</b></font> str.regionMatches(!sensitive, str.length() - endLen, end, 0, endLen);
    }

    <font color="#3f7f5f">/**
     * Checks if one string contains another at a specific index using the case-sensitivity rule.
     * &lt;p&gt;
     * This method mimics parts of {@link String#regionMatches(boolean, int, String, int, int)} 
     * but takes case-sensitivity into account.
     * 
     * @param str  the string to check, not null
     * @param strStartIndex  the index to start at in str
     * @param search  the start to search for, not null
     * @return true if equal using the case rules
     * @throws NullPointerException if either string is null
     */</font>
    <font color="#7f0055"><b>public</b></font> <font color="#7f0055"><b>boolean</b></font> checkRegionMatches(String str, <font color="#7f0055"><b>int</b></font> strStartIndex, String search) {
        <font color="#7f0055"><b>return</b></font> str.regionMatches(!sensitive, strStartIndex, search, 0, search.length());
    }

    <font color="#3f7f5f">/**
     * Converts the case of the input String to a standard format.
     * Subsequent operations can then use standard String methods.
     * 
     * @param str  the string to convert, null returns null
     * @return the lower-case version if case-insensitive
     */</font>
    String convertCase(String str) {
        <font color="#7f0055"><b>if</b></font> (str == null) {
            <font color="#7f0055"><b>return</b></font> null;
        }
        <font color="#7f0055"><b>return</b></font> sensitive ? str : str.toLowerCase();
    }

    <font color="#3f7f5f">//-----------------------------------------------------------------------
</font>    <font color="#3f7f5f">/**
     * Gets a string describing the sensitivity.
     * 
     * @return a string describing the sensitivity
     */</font>
    <font color="#7f0055"><b>public</b></font> String toString() {
        <font color="#7f0055"><b>return</b></font> name;
    }

}

   
    
    
    
    
    
    
  
</pre>
     <table class="table"></table>
     <table>
      <tbody> 
       <tr>
        <td align="left"><br><br><br><br><script type="text/javascript"><!--
google_ad_client="pub-1130008796007602";google_ad_width=300;google_ad_height=250;google_ad_format="300x250_as";google_ad_type="text_image";google_ad_channel="";google_color_border="ffffff";google_color_bg="FFFFFF";google_color_link="0077cc";google_color_url="0077cc";google_color_text="000000";
//--></script><script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"></script></td> 
       </tr>
       <tr>
        <td><script type="text/javascript"><!--
google_ad_client="pub-1130008796007602";google_ad_width=300;google_ad_height=250;google_ad_format="300x250_as";google_ad_type="text_image";google_ad_channel="";google_color_border="ffffff";google_color_bg="FFFFFF";google_color_link="0077cc";google_color_url="0077cc";google_color_text="000000";
//--></script><script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"></script><br><br><br><br></td>
       </tr>
      </tbody>
     </table>
     <h3>Related examples in the same category</h3>
     <table class="table">
      <tbody>
       <tr class="even">
        <td>1.</td>
        <td align="left"><a href="/Code/Java/File-Input-Output/Returnsthepathofthegivenresource.htm">Returns the path of the given resource.</a></td>
        <td width="32"></td>
        <td width="200" align="right"></td>
       </tr>
       <tr class="odd">
        <td>2.</td>
        <td align="left"><a href="/Code/Java/File-Input-Output/Removepathandfileinformationfromafilenamereturningonlyitsextensioncomponent.htm">Remove path and file information from a filename returning only its extension component</a></td>
        <td width="32"></td>
        <td width="200" align="right"></td>
       </tr>
       <tr class="even">
        <td>3.</td>
        <td align="left"><a href="/Code/Java/File-Input-Output/Absolutizearelativeresourcepathonthegivenabsolutebasepath.htm">Absolutize a relative resource path on the given absolute base path.</a></td>
        <td width="32"></td>
        <td width="200" align="right"></td>
       </tr>
       <tr class="odd">
        <td>4.</td>
        <td align="left"><a href="/Code/Java/File-Input-Output/RemoveFileNameSuffix.htm">Remove File Name Suffix</a></td>
        <td width="32"></td>
        <td width="200" align="right"><a href="/Code/Java/File-Input-Output/RemoveFileNameSuffix.htm"><img border="0" alt="Remove File Name Suffix" src="http://www.java2s.com/Code/JavaImages/Utilities.PNG" width="200" height="40"></a></td>
       </tr>
       <tr class="even">
        <td>5.</td>
        <td align="left"><a href="/Code/Java/File-Input-Output/Autilityclassformanipulatingpaths.htm">A utility class for manipulating paths</a></td>
        <td width="32"></td>
        <td width="200" align="right"></td>
       </tr>
       <tr class="odd">
        <td>6.</td>
        <td align="left"><a href="/Code/Java/File-Input-Output/StripFileExtension.htm">Strip File Extension</a></td>
        <td width="32"></td>
        <td width="200" align="right"></td>
       </tr>
       <tr class="even">
        <td>7.</td>
        <td align="left"><a href="/Code/Java/File-Input-Output/Getrelativepath.htm">Get relative path</a></td>
        <td width="32"></td>
        <td width="200" align="right"></td>
       </tr>
       <tr class="odd">
        <td>8.</td>
        <td align="left"><a href="/Code/Java/File-Input-Output/Fixesthefilesperatorcharforthetargetplatformusingthefollowingreplacement.htm">Fixes the file sperator char for the target platform using the following replacement.</a></td>
        <td width="32"></td>
        <td width="200" align="right"></td>
       </tr>
       <tr class="even">
        <td>9.</td>
        <td align="left"><a href="/Code/Java/File-Input-Output/Concatenatesanarrayofstringusingaseperator.htm">Concatenates an array of string using a seperator.</a></td>
        <td width="32"></td>
        <td width="200" align="right"></td>
       </tr>
       <tr class="odd">
        <td>10.</td>
        <td align="left"><a href="/Code/Java/File-Input-Output/RenameToTemporaryName.htm">Rename To Temporary Name</a></td>
        <td width="32"></td>
        <td width="200" align="right"></td>
       </tr>
       <tr class="even">
        <td>11.</td>
        <td align="left"><a href="/Code/Java/File-Input-Output/Matchapathwhichmaycontainawildcard.htm">Match a path which may contain a wildcard</a></td>
        <td width="32"></td>
        <td width="200" align="right"></td>
       </tr>
       <tr class="odd">
        <td>12.</td>
        <td align="left"><a href="/Code/Java/File-Input-Output/Mergesthetwopathstocreateavalidversionofthesecondpath.htm">Merges the two paths to create a valid version of the second path</a></td>
        <td width="32"></td>
        <td width="200" align="right"></td>
       </tr>
       <tr class="even">
        <td>13.</td>
        <td align="left"><a href="/Code/Java/File-Input-Output/ExtractFileExtension.htm">Extract File Extension</a></td>
        <td width="32"></td>
        <td width="200" align="right"></td>
       </tr>
       <tr class="odd">
        <td>14.</td>
        <td align="left"><a href="/Code/Java/File-Input-Output/GetFileNameSuffix.htm">Get File Name Suffix</a></td>
        <td width="32"></td>
        <td width="200" align="right"><a href="/Code/Java/File-Input-Output/GetFileNameSuffix.htm"><img border="0" alt="Get File Name Suffix" src="http://www.java2s.com/Code/JavaImages/Utilities.PNG" width="200" height="40"></a></td>
       </tr>
       <tr class="even">
        <td>15.</td>
        <td align="left"><a href="/Code/Java/File-Input-Output/Extractthepagepathfromthegivenrequestpath.htm">Extract the page path from the given request path</a></td>
        <td width="32"></td>
        <td width="200" align="right"></td>
       </tr>
       <tr class="odd">
        <td>16.</td>
        <td align="left"><a href="/Code/Java/File-Input-Output/FilenameUtils.htm">File name Utils</a></td>
        <td width="32"></td>
        <td width="200" align="right"></td>
       </tr>
       <tr class="even">
        <td>17.</td>
        <td align="left"><a href="/Code/Java/File-Input-Output/Convertalistofpathelementstoaplatformspecificpath.htm">Convert a list of path elements to a platform-specific path.</a></td>
        <td width="32"></td>
        <td width="200" align="right"></td>
       </tr>
       <tr class="odd">
        <td>18.</td>
        <td align="left"><a href="/Code/Java/File-Input-Output/ChangeFileNameToClassName.htm">Change File Name To Class Name</a></td>
        <td width="32"></td>
        <td width="200" align="right"><a href="/Code/Java/File-Input-Output/ChangeFileNameToClassName.htm"><img border="0" alt="Change File Name To Class Name" src="http://www.java2s.com/Code/JavaImages/Utilities.PNG" width="200" height="40"></a></td>
       </tr>
       <tr class="even">
        <td>19.</td>
        <td align="left"><a href="/Code/Java/File-Input-Output/stripExtensionname.htm">strip Extension name</a></td>
        <td width="32"></td>
        <td width="200" align="right"></td>
       </tr>
       <tr class="odd">
        <td>20.</td>
        <td align="left"><a href="/Code/Java/File-Input-Output/CreateFileNamewithspecifiedwhitespacecharacter.htm">Create File Name with specified white space character</a></td>
        <td width="32"></td>
        <td width="200" align="right"></td>
       </tr>
       <tr class="even">
        <td>21.</td>
        <td align="left"><a href="/Code/Java/File-Input-Output/Buildarelativepathtothegivenbasepath.htm">Build a relative path to the given base path</a></td>
        <td width="32"></td>
        <td width="200" align="right"></td>
       </tr>
       <tr class="odd">
        <td>22.</td>
        <td align="left"><a href="/Code/Java/File-Input-Output/Checkswhetherthechilddirectoryisasubdirectoryofthebasedirectory.htm">Checks, whether the child directory is a subdirectory of the base directory.</a></td>
        <td width="32"></td>
        <td width="200" align="right"></td>
       </tr>
       <tr class="even">
        <td>23.</td>
        <td align="left"><a href="/Code/Java/File-Input-Output/Returnacontextrelativepathbeginningwithathatrepresentsthecanonicalversionofthespecifiedpathafterandelementsareresolvedout.htm">Return a context-relative path, beginning with a "/", that represents the canonical version of the specified path after ".." and "." elements are resolved out.</a></td>
        <td width="32"></td>
        <td width="200" align="right"></td>
       </tr>
       <tr class="odd">
        <td>24.</td>
        <td align="left"><a href="/Code/Java/File-Input-Output/Returnthepathwithinabasedirectory.htm">Return the path within a base directory</a></td>
        <td width="32"></td>
        <td width="200" align="right"></td>
       </tr>
       <tr class="even">
        <td>25.</td>
        <td align="left"><a href="/Code/Java/File-Input-Output/Decodeapath.htm">Decode a path.</a></td>
        <td width="32"></td>
        <td width="200" align="right"></td>
       </tr>
       <tr class="odd">
        <td>26.</td>
        <td align="left"><a href="/Code/Java/File-Input-Output/Convertapathtoacananonicalform.htm">Convert a path to a cananonical form</a></td>
        <td width="32"></td>
        <td width="200" align="right"></td>
       </tr>
       <tr class="even">
        <td>27.</td>
        <td align="left"><a href="/Code/Java/File-Input-Output/Extractfilenamewithoutpathandsuffixfromfilenamewithpathandsuffix.htm">Extract file name (without path and suffix) from file name with path and suffix</a></td>
        <td width="32"></td>
        <td width="200" align="right"></td>
       </tr>
       <tr class="odd">
        <td>28.</td>
        <td align="left"><a href="/Code/Java/File-Input-Output/Extractfilenamewithoutpathbutwithsuffixfromfilenamewithpathandsuffix.htm">Extract file name (without path but with suffix) from file name with path and suffix</a></td>
        <td width="32"></td>
        <td width="200" align="right"></td>
       </tr>
       <tr class="even">
        <td>29.</td>
        <td align="left"><a href="/Code/Java/File-Input-Output/Buildapathbutdonotcreateit.htm">Build a path, but do not create it</a></td>
        <td width="32"></td>
        <td width="200" align="right"></td>
       </tr>
       <tr class="odd">
        <td>30.</td>
        <td align="left"><a href="/Code/Java/File-Input-Output/Buildadirectorypathcreatingdirectoriesifneccesary.htm">Build a directory path - creating directories if neccesary</a></td>
        <td width="32"></td>
        <td width="200" align="right"></td>
       </tr>
       <tr class="even">
        <td>31.</td>
        <td align="left"><a href="/Code/Java/File-Input-Output/Collectionoffilepathrelatedstuff.htm">Collection of file path related stuff</a></td>
        <td width="32"></td>
        <td width="200" align="right"></td>
       </tr>
       <tr class="odd">
        <td>32.</td>
        <td align="left"><a href="/Code/Java/File-Input-Output/PathUtil.htm">Path Util</a></td>
        <td width="32"></td>
        <td width="200" align="right"></td>
       </tr>
       <tr class="even">
        <td>33.</td>
        <td align="left"><a href="/Code/Java/File-Input-Output/Getthefirstlasttokenfromapath.htm">Get the first/last token from a path</a></td>
        <td width="32"></td>
        <td width="200" align="right"></td>
       </tr>
       <tr class="odd">
        <td>34.</td>
        <td align="left"><a href="/Code/Java/File-Input-Output/Calculatestherelativepathbetweenaspecifiedrootdirectoryandatargetpath.htm">Calculates the relative path between a specified root directory and a target path.</a></td>
        <td width="32"></td>
        <td width="200" align="right"></td>
       </tr>
       <tr class="even">
        <td>35.</td>
        <td align="left"><a href="/Code/Java/File-Input-Output/GetrelativePath.htm">Get relative Path</a></td>
        <td width="32"></td>
        <td width="200" align="right"></td>
       </tr>
      </tbody>
     </table>
    </div>
   </div>
   <footer>
    <p class="pull-right"><a href="http://www.java2s.com/">java2s.com</a> &nbsp;|&nbsp;Email:info at java2s.com&nbsp;|&nbsp;© Demo Source and Support. All rights reserved.</p>
   </footer>
  </div>
 </body>
</html>