<html>
 <head> 
  <title> RESTful Web Services with Java and Jersey </title> 
  <link rel="stylesheet" type="text/css" href="styles.css"> 
  <script type="text/javascript" src="scripts/shBrushBash.js"></script> 
  <script type="text/javascript" src="scripts/shBrushJava.js"></script> 
  <script type="text/javascript" src="scripts/shBrushPlain.js"></script> 
  <script type="text/javascript" src="scripts/shBrushXml.js"></script> 
  <link type="text/css" rel="stylesheet" href="styles/shCore.css"> 
  <link type="text/css" rel="stylesheet" href="styles/shThemeDefault.css"> 
  <script type="text/javascript">
    SyntaxHighlighter.config.clipboardSwf = 'scripts/clipboard.swf';
    SyntaxHighlighter.all();
  </script> 
 </head> 
 <body> 
  <table style="margin-bottom: -20"> 
   <tbody>
    <tr> 
     <td valign="top"> 
      <center> 
       <img width="40" src="tut-images/java-logo.gif">
       <br>
       <br> 
       <img src="tut-images/jersey-yellow.png"> 
      </center> </td> 
     <td width="20"> &nbsp; </td> 
     <td valign="top"> <h2 class="title"> Companion Notes<br> on RESTful Web Services<br> with Java and Jersey </h2> <p><small>Russell Bateman<br>8 July 2010<br>last update: <script type="text/javascript">
				document.write( document.lastModified );
			</script> </small></p> </td> 
    </tr> 
   </tbody>
  </table> 
  <table style="margin-top: 0"> 
   <tbody>
    <tr>
     <td valign="top" width="400"> <h3> Table of Contents </h3> 
      <dl> 
       <dd class="toc"> 
        <a class="toc" href="#intro"> Introduction </a>
       </dd> 
       <dd class="toc"> 
        <a class="toc" href="#http"> HTTP: a naturally RESTful protocol</a> 
        <dl> 
         <dd class="toc"> 
          <a class="toc" href="#biblio"> Other books worth reading... </a>
         </dd> 
        </dl> 
       </dd> 
       <dd class="toc"> 
        <a class="toc" href="#2"> 2. Installation </a>
       </dd> 
       <dd class="toc"> 
        <a class="toc" href="#lib-copy">Copy the Jersey JARs to <i>WEB-INF/lib</i></a>
       </dd> 
       <dd class="toc"> 
        <a class="toc" href="#actual-libs">Actual library use </a>
       </dd> 
       <dd class="toc"> 
        <a class="toc" href="#32"> 3.2. Java class </a> 
        <dl> 
         <dd class="toc"> 
          <a class="toc" href="#annotate"> Annotations </a>
         </dd> 
         <dd class="toc"> 
          <a class="toc" href="#magic"> Black magic </a>
         </dd> 
        </dl> 
       </dd> 
       <dd class="toc"> 
        <a class="toc" href="#33"> 3.3. Define Jersey servlet dispatcher (web.xml)</a>
       </dd> 
       <dd class="toc"> 
        <a class="toc" href="#34"> 3.4. Run your REST service </a> 
        <dl> 
         <dd class="toc"> 
          <a class="toc" href="#34"> Start Tomcat </a>
         </dd> 
         <dd class="toc"> 
          <a class="toc" href="#34"> Service URI </a>
         </dd> 
         <dd class="toc"> 
          <a class="toc" href="#404"> Did you get an HTTP Status 404? </a>
         </dd> 
        </dl> 
       </dd> 
       <dd class="toc"> 
        <a class="toc" href="#35"> 3.5. Create a client </a>
       </dd> 
       <dd class="toc"> 
        <a class="toc" href="#excursus"> Organization of a JAX-RS RESTful service </a>
       </dd> 
       <dd class="toc"> 
        <a class="toc" href="#41"> 4.1. Create (a new REST service) project</a>
       </dd> 
       <dd class="toc"> 
        <a class="toc" href="#44"> 4.4. Test your REST service </a>
       </dd> 
       <dd class="toc"> 
        <a class="toc" href="#45"> 4.5. Create a client </a>
       </dd> 
       <dd class="toc"> 
        <a class="toc" href="#5"> 5. CRUD RESTful web service </a> 
        <dl> 
         <dd class="toc"> 
          <a class="toc" href="#inject"> A note on JAX-RS injection  </a>
         </dd>
        </dl>
        <a class="toc" href="#inject"> </a>
       </dd>
       <a class="toc" href="#inject"> </a>
       <dd class="toc">
        <a class="toc" href="#inject"> </a>
        <a class="toc" href="#54"> 5.4. Run (CRUD RESTful web service)</a>
       </dd> 
       <dd class="toc"> 
        <a class="toc" href="#55"> 5.5. Create a client </a>
       </dd> 
       <dd class="toc"> 
        <a class="toc" href="#56"> 5.6. Use the REST service via HTML page</a>
       </dd> 
       <dd class="toc"> 
        <a class="toc" href="#links"> Additional links </a>
       </dd> 
       <dd>
         &nbsp; 
       </dd> 
       <!-- ===================================================================== --> 
       <dd>
         Appendices 
       </dd> 
       <dd class="toc"> 
        <a class="toc" href="#webxml">Appendix: The secret of <i>web.xml</i></a>
       </dd> 
       <dd class="toc"> 
        <a class="toc" href="#app"> Appendix: Notes on the Java and XML Tutorial</a>
       </dd> 
       <dl> 
        <dd class="toc"> 
         <a class="toc" href="#a133">Comments </a>
        </dd> 
        <dd class="toc"> 
         <a class="toc" href="#a21"> Domain Object Model (DOM) </a>
        </dd> 
        <dd class="toc"> 
         <a class="toc" href="#a22"> Simple API for XML (SAX) </a>
        </dd> 
        <dd class="toc"> 
         <a class="toc" href="#a23"> Streaming API for XML (StaX) </a>
        </dd> 
        <dd class="toc"> 
         <a class="toc" href="#a24"> 2.4. Java Architecture for XML Binding</a>
        </dd> 
        <dd class="toc"> 
         <a class="toc" href="#a3"> 3. Streaming API for XML </a> 
         <dl> 
          <dd class="toc"> 
           <a class="toc" href="#a33"> 3.3. XMLEventReader—Read XML Example</a>
          </dd> 
          <dd class="toc"> 
           <a class="toc" href="#a34"> 3.4. XMLEventReader—Write XML Example</a>
          </dd> 
         </dl> 
        </dd> 
        <dd class="toc"> 
         <a class="toc" href="#a41"> 4.1. JAXB 2—Java Architecture for XML Binding</a>
        </dd> 
        <dd class="toc"> 
         <a class="toc" href="#a51"> 5.1. XPath </a>
        </dd> 
        <dd class="toc"> 
         <a class="toc" href="#jax"> Other JAX things </a>
        </dd> 
       </dl>  
       <dd class="toc"> 
        <a class="toc" href="#webxml2">Appendix: More <i>web.xml</i></a>
       </dd> 
       <dd class="toc"> 
        <a class="toc" href="#tomcat">Appendix: Random notes on Tomcat, Eclipse and Jersey</a>
       </dd> 
      </dl> </td> 
     <td> <a name="intro"></a> <h3> Introduction </h3> <p> I decided to follow a <a href="http://www.vogella.de/articles/REST/article.html"> tutorial on REST</a> by Lars Vogel. As in others he's written, there is much that he has left unsaid. This is my attempt to help out the dummies among whom I am the foremost. Where I recognize there is need and where I can, I answer questions about it. Besides, it proves to me that I understand what Lars is teaching. </p> <p> Use the section numbers to keep pace with the tutorial. Don't just read what I say here. I'm not rewriting Lars' tutorial. You must read what he has to say in order to learn something. I hope my additional notes a) help you get more easily through the tutorial and b) learn just a bit more. </p> <p> Remember, accomplishing the tutorial exercises and getting them working isn't going to teach you much. You must read and assimilate what Lars is saying. As his expression is succinct and lacking in much explanation, you may be reading and re-reading it, plus examining and perhaps stepping through the code before you begin to seize fully what he's saying. </p> <p> I suggest you do the exercises in an Eclipse workspace with a special name—separate from your usual work. That way, you don't encumber anything serious you're using Eclipse for and can refer back to them and to the source code therein. </p> <p> First, some notes on HTTP, our RESTful protocol... </p> </td> 
    </tr> 
   </tbody>
  </table> 
  <a name="http"></a> 
  <h3 style="margin-top: 0"> HTTP: a naturally RESTful protocol </h3> 
  <img align="right" width="120" src="tut-images/restful-book.png"> 
  <p> HTTP includes several operations (or methods) and it's important to structure one's server and application to supply or request data based on careful compartmentalization per operation and data. See excellent book (this is a shameless plug): </p> 
  <p class="biblio" style="margin-left: 60px"> Allamaraju, Subbu, <a href="http://www.amazon.com/s?url=search-alias%3Daps&amp;field-keywords=RESTful-Web-Services-Cookbook-Scalability"> <i>RESTful Web Services Cookbook: Solutions for Improving Scalability and Simplicity</i></a>, 320 pages, O'Reilly/Yahoo Press, March, 2010. </p> 
  <table> 
   <tbody>
    <tr>
     <td width="20"> &nbsp; </td>
     <td></td>
     <td width="10"></td>
     <td></td>
    </tr> 
    <tr>
     <td></td>
     <td> <b>HEAD</b> </td>
     <td></td> 
     <td> Request response identical to what corresponds to a GET request, but without the body. Used for retrieving metadata associated with a resource without having to transport the entire resource. </td> 
    </tr> 
    <tr>
     <td> &nbsp; </td>
    </tr> 
    <tr>
     <td></td>
     <td> <b>GET</b> </td>
     <td></td> 
     <td> Request representation of resource; must be idempotent, i.e.: without side effect. </td> 
    </tr> 
    <tr>
     <td> &nbsp; </td>
    </tr> 
    <tr>
     <td></td>
     <td> <b>POST</b> </td>
     <td></td> 
     <td> Submit data to be processed, i.e.: into a new (see <tt>PUT</tt>) resource or modification of an existing resource. Idempotency is a complex problem that must be resolved in order to remain RESTful. See Allamaraju. </td> 
    </tr> 
    <tr>
     <td> &nbsp; </td>
    </tr> 
    <tr>
     <td></td>
     <td> <b>PUT</b> </td>
     <td></td> 
     <td> Create new resource; resource; must be idempotent, i.e.: without side effect. </td> 
    </tr> 
    <tr>
     <td> &nbsp; </td>
    </tr> 
    <tr>
     <td></td>
     <td> <b>DELETE</b> </td>
     <td></td> 
     <td> Delete resource; must be idempotent, i.e.: without side effect. </td> 
    </tr> 
    <tr>
     <td> &nbsp; </td>
    </tr> 
    <tr>
     <td></td>
     <td> <b>TRACE</b> </td>
     <td></td> 
     <td> Echoes back request in order that client may see what (if any) changes or additions have been made by server (including "intermediate" servers). </td> 
    </tr> 
    <tr>
     <td> &nbsp; </td>
    </tr> 
    <tr>
     <td></td>
     <td> <b>OPTIONS</b> </td>
     <td></td> 
     <td> Return list of HTTP methods (the operations listed above) supported by the server. This is useful for examining the functionality of a server before performing a (real) operation. </td> 
    </tr> 
   </tbody>
  </table> 
  <p> The point is that when you code up your service, you must carefully respect this tight definition of HTTP operations in order to be truly RESTful. </p> 
  <a name="biblio"></a> 
  <h4> Other books worth reading... </h4> 
  <p> There are other books to be sure. These two are available from Google for free perusal. <i>RESTful Java with JAX-RS</i> is recent (2010). <i>RESTful Web Services</i> dates to 2007. </p> 
  <p style="text-align: center"> <a href="http://books.google.com/books?id=_jQtCL5_vAcC"> <img border="1" height="150" src="tut-images/restful-java.jpg"></a> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="http://books.google.com/books?id=XUaErakHsoAC"> <img border="1" height="150" src="tut-images/restful-web-services.jpg"></a> </p> 
  <br> 
  <p> Here's a comparison table about HTTP-based protocols: <a href="restful-addendum.html"><i>RESTful addendum</i></a>. </p> 
  <br> 
  <p> And now, on with my review of and notes on the tutorial... </p> 
  <a name="2"></a> 
  <h3> 2. Installation </h3> 
  <p> Go to the link Lars gives for the <a href="https://jersey.dev.java.net/"> Jersey homepage</a>, click the big, green down-arrow, then scroll down to find a sentence like: </p> 
  <p style="margin-left: 40px"> "A <a href="http://download.java.net/maven/2/com/sun/jersey/jersey-archive/1.3/jersey-archive-1.3.zip"> zip of Jersey</a> containing the Jersey jars, core dependencies (it does not provide dependencies for third party jars beyond the those for JSON support) and JavaDoc." </p> 
  <p> I have reproduced both links above so you don't have to go to Lars' page. </p> 
  <p> Use this zip file. Also, I linked up the JARs to the <i>apidocs</i> subdirectories extracted from the zip (but this doesn't seem to work). </p> 
  <p> (Javadoc for Jersey APIs can be found both in the Jersey download and on-line at <a href="https://jersey.dev.java.net/nonav/apidocs/latest/jersey/index.html"> <i>jersey-bundle 1.3 API</i></a>.) </p> 
  <a name="lib-copy"></a> 
  <h4> Copy the Jersey JARs to <i>WEB-INF/lib</i>! </h4> 
  <p> You can, of course, create an Eclipse <tt>User Library</tt> to hold these JARs. It's a neat solution and very self documenting. However, Lars is right. You should copy the JARs to this subdirectory for several reasons, not the least of which is that if you are collaborating with others, you'll want these libraries to be easily available to them. This cannot be done using the <tt>User Library</tt> since that involves full paths in the project <i>.classpath</i> that are not compatible with the other development hosts, usernames, etc. when code is checked out. </p> 
  <p> One way you can ensure the "documentary convenience" of the <tt>User Library</tt>, however, is to place these JARs down under the <i>lib</i> subdirectory underneath a deeper subdirectory named, for example, <i>Jersey</i>. I works well and retains a division between what's Jersey, what's Hibernate, what's Apache Commons, etc.—all the libraries that you may add to your project. </p> 
  <p> Of course, if you're building with Maven, that's a different matter altogether, but we're not discussing that in this tutorial. </p> 
  <p> However you add these libraries to your project, you will need to pay attention to the discussion of the Java EE module dependencies (also called <tt>Deployment Assembly</tt> beginning with Eclipse Helios). </p> 
  <p> For my tutorial exercises, I copied the following JARs: </p> 
  <ul> 
   <li> <i>asm-3.1.jar</i> </li> 
   <li> <i>jackson-core-asl-1.1.1</i> </li> 
   <li> <i>jersey-client-1.3.jar</i> </li> 
   <li> <i>jersey-core-1.3.jar</i> </li> 
   <li> <i>jersey-json-1.3.jar</i> </li> 
   <li> <i>jersey-server-1.3.jar</i> </li> 
   <li> <i>jettison-1.1.jar</i> </li> 
   <li> <i>jsr311-api.1.1.1.jar</i> </li> 
  </ul> 
  <p> ...which I added (only to the Dynamic Web Projects) using <tt>Build Path</tt> each time I created a new project. Also, when I add the library to a project, before dismissing the <tt>Properties</tt> dialog (that comes up when modifying <tt>Java Build Path</tt>), I add the library to the <tt>Java EE Module Dependencies</tt> list. </p> 
  <a name="actual-libs"></a> 
  <h4> Actual library use </h4> 
  <p> Experimenting with these libraries, I reach the following conclusion that may be of interest once you've completed Lars' tutorial and feel comfortable about moving on in REST. My experimentation used much later versions than those I used to perform this tutorial originally. Often, packages come with a great deal more in them than is really necessary and the final tally also depends on what functionality you really consume. </p> 
  <p> The following JARs are sufficient to do the server examples: </p> 
  <ul> 
   <li> <i>asm-3.1.jar</i> </li> 
   <li> <i>jersey-core-1.6.jar</i> </li> 
   <li> <i>jersey-server-1.6.jar</i> </li> 
  </ul> 
  <p> If interested in getting Javadoc, simply link <i>jersey-core-1.6.jar</i> up with apidocs/jersey under the download. This will introduce, however, full paths into <i>.classpath</i> rendering it non-transportable to other computers. </p> 
  <p> Client examples: </p> 
  <ul> 
   <li> <i>jersey-client-1.6.jar</i> </li> 
   <li> <i>jersey-core-1.6.jar</i> </li> 
   <li> <i>jsr311-api-1.1.1.jar</i> </li> 
  </ul> 
  <a name="32"></a> 
  <h3> 3.2. Java class </h3> 
  <p> Run through the tutorial performing all the steps as outlined. Come back here as you feel you need to. </p> 
  <p> At first, I had got the wrong set of libraries due to the confusion in the Jersey web site. I resorted to the general Java questions forum at <a href="http://www.javaranch.com">Java Ranch</a>. Getting the correct download got rid of all my compilation errors up to the point of this first source file. </p> 
  <p> I redid the source code slightly to comment it and to demonstrate that the browser response is the HTML one by saying so. I also added some unused code here showing how to obtain the <tt>ServletContext</tt> we'd be dealing with if we were doing this the old-fashioned way without Jersey. There's a special annotation to get it. </p> 
  <pre><pre class="brush: java">package de.vogella.jersey.first;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

// POJO, no interface no extends

/**
 * This is Lars' REST server application described at http://www.vogella.de/articles/REST/article.html
 * 3.2. Java class
 *
 * The class registers itself using @GET. using the @Produces, it defines that it delivers two MIME types,
 * text and HTML. The browser always requests the HTML MIME type. Also shown is how to get a hold of
 * the HTTP ServletContext you'd have if you weren't using Jersey and all of this nice annotation.
 *
 */
// Sets the path to base URL + /hello
@Path( "/hello" )
public class Hello
{
	@Context ServletContext context;

	// This method is called if request is TEXT_PLAIN
	@GET
	@Produces( MediaType.TEXT_PLAIN )
	public String sayPlainTextHello()
	{
		// (we don't really want to use ServletContext, just show that we could:)
		ServletContext ctx = context;

		return "Hello Jersey in plain text";
	}

	// This method is called if request is HTML
	@GET
	@Produces( MediaType.TEXT_HTML )
	public String sayHtmlHello()
	{
		return "&lt;html&gt; "
			+ "&lt;title&gt;" + "Hello Jersey" + "&lt;/title&gt;"
			+ "&lt;body&gt;&lt;h1&gt;"
			+ "Hello Jersey in HTML"
			+ "&lt;/body&gt;&lt;/h1&gt;"
			+ "&lt;/html&gt; ";
	}

	// This method is called if request is XML
	@GET
	@Produces( MediaType.TEXT_XML )
	public String sayXMLHello()
	{
		return "&lt;?xml version=\"1.0\"?&gt;" + "&lt;hello&gt; Hello Jersey in XML" + "&lt;/hello&gt;";
	}
}
</pre></pre> 
  <a name="annotate"></a> 
  <h4> Annotations </h4> 
  <p> As noted, JAX-RS uses annotations to guide the behavior of code, something that might have been done using XML configuration files prior to Java 5. You should get used to seeing the following: </p> 
  <table cellpadding="5"> 
   <tbody>
    <tr>
     <td width="20"> &nbsp; </td> 
     <td width="200"></td> 
     <td width="10"> &nbsp; </td>
    </tr> 
    <tr>
     <td></td>
     <td> <small><b><tt>@Path</tt></b></small> </td> 
     <td></td> 
     <td> Specifies what is added to the base path plus the servlet mapping to obtain the methods (operations) of the class thus annotated. The base path is given by <tt>&lt;display-name&gt;</tt>, the servlet mapping by <tt>&lt;servlet-mapping&gt;</tt>'s <tt>&lt;url-pattern&gt;</tt>, both from the project's <i>web.xml</i> configuration file. See <a href="http://download.oracle.com/docs/cd/E17410_01/javaee/6/tutorial/doc/gilik.html#ginpw"> @Path Annotation and URI Path Templates</a>. </td> 
    </tr> 
    <tr>
     <td></td>
     <td> <small><b><tt>@Produces( type<br> &nbsp; &nbsp; [, more-types ] )</tt></b></small> </td> 
     <td></td> 
     <td> Specifies the MIME media types an object can produce and send back to the client, for example, "text/plain" and "application/xml". </td> 
    </tr> 
    <tr>
     <td></td>
     <td> <small><b><tt>@Consumes( type<br> &nbsp; &nbsp; [, more-types ] )</tt></b></small> </td> 
     <td></td> 
     <td> Specifies the MIME media types an object can consume from the client, for example, "application/x-www-form-urlencoded". </td> 
    </tr> 
    <tr>
     <td></td>
     <td> <small><b><tt>@XmlRootElement<br> &nbsp; &nbsp; [( element-name )]</tt></b></small> </td> 
     <td></td> 
     <td> Belongs to Java Architecture for XML Binding (JAXB) which maps Java classes to XML representation. This mapping has two features, the ability to "marshall" Java objects to XML and the converse ability. This annotation maps the class to an XML element, using the class name as the element name or, if an attribute is present, that name as the element name. <p></p> <p> The sense in which anything actually occurs is in the passing back of a <tt>Todo</tt> from a method in the resource part of the application: it comes back in XML with the appropriate values. See <a href="#output4">output</a> from second project. </p> </td> 
    </tr> 
    <tr>
     <td></td>
     <td> <small><b><tt>@Context</tt></b></small> </td> 
     <td></td> 
     <td> Used to inject information into a class field, bean property or method parameter. <p> The following classes are available using <tt>@Context</tt>: <tt>ServletConfig</tt>, <tt>ServletContext</tt>, <tt>HttpServletRequest</tt> and <tt>HttpServletResponse</tt>. </p> </td> 
    </tr> 
    <tr>
     <td></td>
     <td> <small><b><tt>@PathParam</tt></b></small> </td> 
     <td></td> 
     <td> Used to inject the value of a URI named in (the previous <tt>@Path()</tt>). For example, <pre>    @Path( "/todo" )
    public class TodosResource
    {
      .
      .
      .
      @Path( "{id}" )
      public TodoResource getTodo( @PathParam( "id" ) int id )
      {
        .
        .
        .
		</pre> results in any reference to <tt>id</tt> in the Java code being for the base path plus the infix (such as "/rest") from <i>web.xml</i> plus whatever <tt>id</tt> is (a number) as if "/todo/rest/2". See <a href="http://books.google.com/books?id=_jQtCL5_vAcC&amp;pg=PA56&amp;lpg=PA56&amp;dq=%40pathparam+annotation&amp;source=bl&amp;ots=cJev6eZV1Y&amp;sig=lQlxxiXgxnBcmj_u8tPC6FHGEgE&amp;hl=en&amp;ei=02g8TI-tOIP-8AbX4oSnBg&amp;sa=X&amp;oi=book_result&amp;ct=result&amp;resnum=3&amp;ved=0CBwQ6AEwAg#v=onepage&amp;q=%40pathparam%20annotation&amp;f=false"> @PathParam</a> in <i>RESTful Java</i>, chapter 5, "JAX-RS Injection". </td> 
    </tr> 
    <tr>
     <td></td>
     <td> <small><b><tt>@FormParam</tt></b></small> </td> 
     <td></td> 
     <td> Used to access "application/x-www-form-urlencoded" request bodies, posted by an HTML form. See <a href="http://books.google.com/books?id=_jQtCL5_vAcC&amp;pg=PA61#v=onepage&amp;q&amp;f=false"> @FormParam</a> in <i>RESTful Java</i>, chapter 5, "JAX-RS Injection". </td> 
    </tr> 
    <tr>
     <td></td>
     <td> <small><b><tt>@GET</tt></b></small> </td> 
     <td></td> 
     <td> A request method designator that corresponds, obviously, to the HTTP GET method. With this annotation, you designate which method(s) will process HTTP GET requests (regardless of any name you give the method). </td> 
    </tr> 
    <tr>
     <td></td>
     <td> <small><b><tt>@PUT</tt></b></small> </td> 
     <td></td> 
     <td> Ibid for HTTP PUT. </td> 
    </tr> 
    <tr>
     <td></td>
     <td> <small><b><tt>@DELETE</tt></b></small> </td> 
     <td></td> 
     <td> Ibid for HTTP DELETE. </td> 
    </tr> 
    <tr>
     <td></td>
     <td> <small><b><tt>@POST</tt></b></small> </td> 
     <td></td> 
     <td> Ibid for HTTP POST. </td> 
    </tr> 
   </tbody>
  </table> 
  <a name="magic"></a> 
  <h4> Black magic </h4> 
  <p> But, how does this annotation stuff work? It's black magic, right? Yes, sort of, but it's easier to understand than you might think. </p> 
  <p> The secret lies in the fact that your coded method isn't called directly. That's the sleight of hand. What's called is a "hidden" Jersey controller method that uses reflection to examine which of your coded methods are appropriate for the (<tt>GET</tt>, <tt>PUT</tt>, <tt>POST</tt>, <tt>DELETE</tt>, etc.) call, then chooses which one based on the expected MIME type and performs other work on context, path, etc. Then it calls your method which magically just works. </p> 
  <p> (Think of all the explicit coding you did back in the days of C to make something like this work.) </p> 
  <a name="33"></a> 
  <h3> 3.3. Define Jersey servlet dispatcher (<i>web.xml</i>) </h3> 
  <a name="331"></a> 
  <p> The super important bit in this exercise is, as is often the case, what's going on in <i>web.xml</i>. In particular, a server init parameter must be defined named <i>com.sun.jersey.config.property.package</i> with a value corresponding to the path to the resource classes in a specific package. Note that we're talking about a package and not merely one class from that package (even if, in this first project, there is only one class). </p> 
  <p> This phenomenon reoccurs in every Jersey REST project in this tutorial. </p> 
  <p> Also, the URL pattern (in <font color="green">green</font>) is important and corresponds to an element in the path you used to run this service. </p> 
  <p> Please look for these two settings in the remainder of this tutorial. </p> 
  <pre class="code">
   <div id="code">
    
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns="http://java.sun.com/xml/ns/javaee"
            xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
            xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
                                http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
            id="WebApp_ID"
            version="2.5"&gt;
  &lt;display-name&gt;de.vogella.jersey.first&lt;/display-name&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;Jersey REST Service&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com.sun.jersey.spi.container.servlet.ServletContainer&lt;/servlet-class&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;
    <font color="maroon"><b>com.sun.jersey.config.property.packages</b></font>&lt;/param-name&gt;
      &lt;param-value&gt;
    <font color="blue"><b>de.vogella.jersey.first</b></font>&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;Jersey REST Service&lt;/servlet-name&gt;
    &lt;url-pattern&gt;
    <font color="green"><b>/rest/*</b></font>&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
&lt;/web-app&gt;

   </div></pre> 
  <br> 
  <p> See more on <i>web.xml</i> if you're confused <a href="#webxml">here</a>. </p> 
  <a name="34"></a> 
  <h3> 3.4. Run your REST service </h3> 
  <p> To tell you to look at a sibling tutorial, <i>Servlet and JSP Development with Eclipse WTP</i>, is a bit misleading. What the author is really trying to is to say that you need some experience with Eclipse Dynamic Web Projects and Tomcat before feeling at home with running JAX-RS applications. I'm going to boil this down to the following steps for you. Assuming you've made no mistakes in the previous steps (Java and <i>web.xml</i> sources), ... </p> 
  <ol> 
   <dd>
     &nbsp; 
    <h4 class="bullet">Start Tomcat</h4> 
   </dd> 
   <li> Start your server by right-clicking on <i>Tomcat v6.0 Server at localhost</i> in the <tt>Servers</tt> view (probably in the bottom pane of the workbench). When you set up your Dynamic Web Project, you needed to set up a new Tomcat server if your workspace didn't already have one (see <a href="use-eclipse.html#a_tomcat"><i>Using containers like Tomcat</i></a>). </li> 
   <dd>
     &nbsp; 
    <h4 class="bullet">Service URI</h4> 
   </dd> 
   <li> Use a browser to launch a page accessing it via <a href="http://localhost:8080/de.vogella.jersey.first/rest/hello" target="server"> <i>http://localhost:8080/de.vogella.jersey.first/rest/hello</i></a>. <a name="uri"></a> <p> The tutorial doesn't make abundantly clear why this is the path. It is derived from <i>web.xml</i>'s <tt>displayname</tt>, augmented with what is suggested by the <tt>servlet-mapping</tt> <tt>url-pattern</tt> and, from <i>Hello.java</i>, the <tt>@Path</tt> annotation ("hello"). </p> <p> Also, the tutorial arbitrarily chooses to name the project and the package by the same name. This is confusing and must be sorted out: Note that, in the URL to type, it is <b>the display name</b> and not the package name that is the first bit (in <font color="blue">blue</font>). </p> <pre class="code">
     <div id="code">
      
http://
      <i>domain-name</i>:
      <i>port-number</i>/
      <font color="blue"><i>display-name</i></font>/
      <font color="green"><i>url-pattern</i></font>/
      <i>path</i>
http://localhost:8080/
      <font color="blue">de.vogella.jersey.first</font>/
      <font color="green">rest</font>/hello
     </div></pre> <a name="404"></a> </li> 
   <dd>
     &nbsp; 
    <h4 class="bullet">HTTP Status 404</h4> 
   </dd> 
   <li> Did you get an HTTP Status 404 (or, perhaps, another HTTP error)? <p> This is the most frustrating thing about getting a Dynamic Web Project tutorial to work because you're not only up against the possibility that the tutorial has a mistake (least likely), but that you've made a mistake duplicating the project (possible) or that there's something amiss with the server you're using (fairly likely), or with your <i>web.xml</i> file (highly likely). Let's start by fixing the server. Do one, more or all of these steps just before launching the project in the browser as noted above. </p> 
    <ol type="a"> 
     <li> Find the <tt>Servers</tt> view, usually across the bottom of the Eclipse workbench. </li> 
     <li> Right-click and <tt>Stop</tt> the server if running. </li> 
     <li> <tt>Clean</tt> the server. </li> 
     <li> Via <tt>Add and Remove...</tt>, clean out the server's configuration (by removing all projects). </li> 
     <li> Re-add the project you want to run (via <tt>Add and Remove...</tt>). </li> 
     <li> <tt>Start</tt> (or <tt>Debug</tt>) the server. </li> 
     <dd>
       &nbsp; 
     </dd> 
     <li> As a last-ditch, ... 
      <ol type="i"> 
       <li> Right-click and <tt>Delete</tt> the server. </li> 
       <li> Right-click and delete the <i>Server</i> project in the <tt>Project Explorer</tt> view (the left-hand pane of the Eclipse workbench). </li> 
       <li> Re-create the <i>Server</i> project (right-click in empty part of <tt>Project Explorer</tt> pane, choose <tt>New</tt>, etc.). </li> 
       <li> Finally, return to the <tt>Servers</tt> view, add the tutorial project and <tt>Start</tt> (<tt>Debug</tt>) the server. </li> 
       <li> Launch the browser on the URL in question. </li> 
      </ol> </li> 
    </ol> <br> <p> Next, study the <a href="#webxml">appendix on <i>web.xml</i></a> for greater enlightement by comparison. <i>web.xml</i> is a tricky thing. </p> <p> Last note: Lars' project names are sometimes surprising. I've more than once helped someone overcome a 404 error when the only thing that was wrong was that he named his project with a "usual" name (no dots) and yet kept Lars' "package name"-looking project name in <i>web.xml</i>. </p> <p> Indeed, <i>web.xml</i>'s <tt>display-name</tt> and the Eclipse project name must match or the result will be 404 every time. </p> </li> 
  </ol> 
  <a name="35"></a> 
  <h3> 3.5. Create a client </h3> 
  <p> Be sure to create a brand-new Dynamic Web Project here. Piece it together just as you did the one for the server. </p> 
  <p> The tutorial abandons this client project without running or discussing it further. The purpose of this client is to demonstrate creating a real-life client application that talks to the Hello service just developed (in 3.4.). It tries all three MIME types as the output demonstrates. </p> 
  <pre class="code">
   <div id="code">
    
GET http://localhost:8080/de.vogella.jersey.first/rest/hello returned a response status of 200
Hello Jersey in plain text
&lt;?xml version="1.0"?&gt;&lt;hello&gt; Hello Jersey in XML&lt;/hello&gt;
&lt;html&gt; &lt;title&gt;Hello Jersey&lt;/title&gt;&lt;body&gt;&lt;h1&gt;Hello Jersey in
HTML&lt;/body&gt;&lt;/h1&gt;&lt;/html&gt;

   </div></pre> 
  <br> 
  <br> 
  <a name="return"></a> 
  <p style="margin-left: 80px" class="cartouche"> At this point, I did the <a href="#app"><i>Java and XML</i></a> tutorial as the RESTful web services tutorial suggests, just to avoid missing anything. I found it a nice introduction to XML work in Java. I found nothing critically relevant to the present tutorial, so if you skip it you may do just fine. </p> 
  <a name="excursus"></a> 
  <h3> Organization of a JAX-RS RESTful service </h3> 
  <p> In the tutorial, you'll see some division between Java sources. This is by design. </p> 
  <p> The application consists of a data or domain class that defines the representation of the application data. For example, it might be a customer with name, address and consumer predilections, or it might be, as here, a todo with a description, its priority, etc. </p> 
  <p> Next, the application must have a resource definition by which (remote) clients can interact with the application data via HTTP requests. For historical reasons, JAX-RS is able to integrate with Enterprise Java Beans (EJBs). It can also be used with JBoss Seam and Spring. However, it does define its own, lightweight model. </p> 
  <p> JAX-RS services deal often in singletons, only one of which is ever created, or per-request objects, meaning the object is created as the result of a request, processed, then discarded as soon as the request has been completed. In section 5 of this tutorial, you'll see a singleton implementation. </p> 
  <p> The remaining two sample projects are coded in conformance to this prescribed JAX-RS organization. </p> 
  <a name="41"></a> 
  <h3> 4.1. Create (a new REST service) project </h3> 
  <p> You know the drill by now: create and prepare a new Dynamic Web Project. This is a nascent "todo" service that services either XML or HTML requests to create one todo. </p> 
  <ol> 
   <li> Create project and add the <i>JSR 311 (Jersey)</i> library. Be sure also to check this library as a <tt>Java EE Module Dependency</tt>. </li> 
   <dd>
     &nbsp; 
   </dd> 
   <li> Create package, <i>de.vogella.jersey.jaxb.model</i>. </li> 
   <dd>
     &nbsp; 
   </dd> 
   <li> Create domain class, <i>Todo.java</i>. This is the logic part of the service that does the actual work. In fact, however, it only creates and maintains one, single todo at a time. </li> 
   <dd>
     &nbsp; 
   </dd> 
   <li> Create resource class, <i>TodoResource.java</i>. In this source, you'll recognize some of the guys out of the project in 3., specifically the <tt>Hello</tt> service. A call into this from the client causes a todo to be created. </li> 
   <dd>
     &nbsp; 
   </dd> 
   <li> Modify <i>web.xml</i>. <a href="#331">As noted higher up</a>, this is the critical wiring of the service. </li> 
  </ol> 
  <a name="44"></a> 
  <h3> 4.4. Test your REST service </h3> 
  <p> Run the web application (server) via <a href="http://localhost:8080/de.vogella.jersey.jaxb/rest/todo" target="server"> <i>http://localhost:8080/de.vogella.jersey.jaxb/rest/todo</i></a> or see <a href="#uri">here</a>. </p> 
  <p> Did you get an HTTP Status 404? </p> 
  <p> Did you stop, clean and use <tt>Add and Remove</tt> to take away the firest service (from Lars' tutorial section 3 work) and add this new server application? Then, see <a href="#404">above</a>. </p> 
  <a name="output4"></a> 
  <p> The output I see when I run this: </p> 
  <pre class="code">
   <div id="code">
    
This XML file does not appear to have any style information associated with
it. The document tree is shown below.

- &lt;todo&gt;
      &lt;description&gt;This is my first todo&lt;/description&gt;
      &lt;summary&gt;This is my first todo&lt;/summary&gt;
  &lt;/todo&gt;

   </div></pre> 
  <p> While not obvious from the output, this response is from <tt>TodoResource.getXML()</tt> (rather than from its companion method). Why is this when the request is from a browser? (I'll come back to comment when I figure it out.) Note, however, the demonstration of the effect of the <tt>@XmlRootElement</tt> JAXB mapping annotation: what is sent back to the browser is XML. If you remove this annotation from <i>Todo.java</i>, you get an HTTP Status 500 error. </p> 
  <a name="45"></a> 
  <h3> 4.5. Create client </h3> 
  <ol> 
   <li> Create project and add the <i>JSR 311 (Jersey)</i> library. Be sure also to check this library as a <tt>Java EE Module Dependency</tt>. </li> 
   <dd>
     &nbsp; 
   </dd> 
   <li> Create package, <i>de.vogella.jersey.jaxb.client</i>. </li> 
   <dd>
     &nbsp; 
   </dd> 
   <li> Create the <i>Test.java</i> class. </li> 
  </ol> 
  <p> Just as for the first project pair, the tutorial abandons this project without running it. But, this is no different than that first service/client pair. Here's the output obtained when you right-click on <i>Test.java</i> and choose <tt>Run As -&gt; Java Application</tt>: </p> 
  <pre class="code">
   <div id="code">
    
&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;&lt;todo&gt;&lt;description&gt;This is my first todo&lt;/description&gt;&lt;summary&gt;This is my first todo&lt;/summary&gt;&lt;/todo&gt;
{"description":"This is my first todo","summary":"This is my first todo"}
&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;&lt;todo&gt;&lt;description&gt;This is my first todo&lt;/description&gt;&lt;summary&gt;This is my first todo&lt;/summary&gt;&lt;/todo&gt;

   </div></pre> 
  <a name="5"></a> 
  <h3> 5. CRUD RESTful web service </h3> 
  <p> HTTP methods <tt>PUT</tt>, <tt>GET</tt>, <tt>POST</tt> and <tt>DELETE</tt> correspond to a more neutral parlance often used in REST discussions, <i>create</i>, <i>read</i>, <i>update</i> and <i>delete</i> (CRUD). There is some debate against using this term (CRUD) since HTTP methods are more document- than database-oriented. Architecturally, however, CRUD and often does imply state change or dependence which is inappropriate in a REST setting. REST seeks to make the state of the protocol operationg explicit and addressable by URI. Arcs lead from state through operation to state. </p> 
  <p> Despite this debate, and without comment or judgment, this section covers what it calls CRUD RESTful web services. </p> 
  <p> This is the crowning project for this tutorial, a functioning todo manager that will manage more than one todo. It more or less fully implements the <tt>PUT</tt>, <tt>GET</tt> and <tt>DELETE</tt> operations (methods). It does not demonstrate a <tt>POST</tt> (modfiy) method since that would be rather more complex to design and implement. Support inside the service straddles both browser and application clients. </p> 
  <p> Note on <tt>TodoDao</tt>: this code may appear strange at first to someone who's not used the Singleton pattern per se, or is used to rolling his own and hasn't seen Joshua Bloch's method described in <i>More Effective Java</i>, pages 29-31, "The Right Way to Implement a Serializable Singleton". </p> 
  <p> <tt>instance</tt> isn't a new keyword to Java, it's just the (only) enumerated item (or field) in an enumeration which is otherwise used to instantiate one and only one <tt>TodoDao</tt>, consisting of two <tt>Todo</tt>s in a single entry <tt>Map</tt>. </p> 
  <p> Everywhere an instance is needed, the expression <tt>TodoDao.instance</tt> is used along with <tt>getModel()</tt>. </p> 
  <a name="inject"></a> 
  <h4> A note on JAX-RS injection </h4> 
  <p> At the end of this section there is a note that the "<tt>TodoResource</tt> uses <tt>@PathParam</tt> annotation to use the parameter <tt>id</tt> to forward the request to the class <tt>TodoResource</tt>". </p> 
  <a name="54"></a> 
  <h3> 5.4. Run (CRUD RESTful web service) </h3> 
  <p> Run using <a href="http://localhost:8080/de.vogella.jersey.todo/rest/todos" target="server"> <i>http://localhost:8080/de.vogella.jersey.todo/rest/todos</i></a>. Be sure to start the server with the project first. </p> 
  <p> The output appeared for me thus: </p> 
  <pre class="code">
   <div id="code">
    
This XML file does not appear to have any style information associated with
it. The document tree is shown below.

- &lt;todoes&gt;
    - &lt;todo&gt;
          &lt;description&gt;Read complete http://www.vogella.de&lt;/description&gt;
          &lt;id&gt;2&lt;/id&gt;
          &lt;summary&gt;Do something&lt;/summary&gt;
      &lt;/todo&gt;
    - &lt;todo&gt;
      - &lt;description&gt;
            Read http://www.vogella.de/articles/REST/article.html
        &lt;/description&gt;
        &lt;id&gt;1&lt;/id&gt;
        &lt;summary&gt;Learn REST&lt;/summary&gt;
      &lt;/todo&gt;
&lt;/todoes&gt;

   </div></pre> 
  <p> Also, try <a href="http://localhost:8080/de.vogella.jersey.todo/rest/todos/count" target="server"> <i>http://localhost:8080/de.vogella.jersey.todo/rest/todos/count</i></a>. You'll see a <tt>2</tt> corresponding to the number of todos (see output above to confirm that there are two todos. </p> 
  <p> Finally, try also <a href="http://localhost:8080/de.vogella.jersey.todo/rest/todos/1" target="server"> <i>http://localhost:8080/de.vogella.jersey.todo/rest/todos/1</i></a> to see this output: </p> 
  <pre class="code">
   <div id="code">
    
This XML file does not appear to have any style information associated
with it. The document tree is shown below.

- &lt;todo&gt;
    - &lt;description&gt;
          Read http://www.vogella.de/articles/REST/article.html
      &lt;/description&gt;
      &lt;id&gt;1&lt;/id&gt;
      &lt;summary&gt;Learn REST&lt;/summary&gt;
  &lt;/todo&gt;

   </div></pre> 
  <p> If you typed a <tt>0</tt> or a <tt>3</tt> instead of <tt></tt>1, you'd get an HTTP Status 500 error. Typing a <tt>2</tt> gets you the other todo. </p> 
  <a name="55"></a> 
  <h3> 5.5. Create a client </h3> 
  <p> I thought the tutorial was serious about the client project being a simple Java Project (and not a Dynamic Web Project) until the very end when it offered an HTML form. </p> 
  <p> The (new) challenge here is to consume class, <tt>Todo</tt> from project <i>de.vogella.jersey.todo</i>. These instructions were created first assuming that this was to be a Java Project. When it became a Dynamic Web Project, I simply refactored to move the library down under the new project's <i>Web Content/WEB-INF/lib</i> subdirectory. </p> 
  <p> To create a JAR of the latter, do this: </p> 
  <ol start="0"> 
   <li> (This can, and should in production mode, be automated using <tt>ant</tt>.) </li> 
   <dd>
     &nbsp; 
   </dd> 
   <li> Open the project that supplies this class. </li> 
   <dd>
     &nbsp; 
   </dd> 
   <li> Right-click the project, choose <tt>Export</tt>. </li> 
   <dd>
     &nbsp; 
   </dd> 
   <li> Expand the <tt>Java</tt> tab, then choose <tt>Java file</tt>. </li> 
   <dd>
     &nbsp; 
   </dd> 
   <li> Uncheck <i>.classpath</i> and <i>.project</i>; these are Eclipse configuration files that aren't useful when providing mere Java classe(s). </li> 
   <dd>
     &nbsp; 
   </dd> 
   <li> Check <tt>Export generated class files and resources</tt>. This will ensure the actual class gets into the JAR, which is primarily what we want. </li> 
   <dd>
     &nbsp; 
   </dd> 
   <li> Check also <tt>Export Java source files and resourses</tt>. You don't need these, but doing this demonstrates how you can include sources especially if you want your Javadoc/source code available to the consumer of your JAR. </li> 
   <dd>
     &nbsp; 
   </dd> 
   <li> If you name the file <i>todo.jar</i>, it will simply appear at the root of your current workspace after clicking <tt>Finish</tt>. <p> A better idea is to destinate it to land in the directory where you want it. To do this, <tt>Browse</tt> to <i>de.vogella.jersey.todo.dlient</i>, create a <i>lib</i> directory at the root (as suggested by the tutorial) and drop it there. </p> </li> 
   <dd>
     &nbsp; 
   </dd> 
   <li> Click <tt>Next</tt> if you like; this next dialog will give you the option of JARring up code that has errors or warnings if any. This isn't our case here. Otherwise, you can just click... </li> 
   <dd>
     &nbsp; 
   </dd> 
   <li> <tt>Finish</tt>. </li> 
  </ol> 
  <p> Now you've got a new JAR inside the client project. You must set it up. In project <i>de.vogella.jersey.todo.client</i>... </p> 
  <ol> 
   <li> Click on the project in the <tt>Package Explorer</tt> window and press <tt>F5</tt> (or right-click and choose <tt>Refresh</tt>). 
    <dd>
      &nbsp; 
    </dd> </li>
   <li> Right-click to open the <tt>Java Build Path</tt> dialog. </li> 
   <dd>
     &nbsp; 
   </dd> 
   <li> Add the JAR to the project: Click the <tt>Libraries</tt> tab, click <tt>Add JARs...</tt> and navigate to add <i>todo.jar</i> located in the <i>lib</i> subdirectory. Click <tt>OK</tt>. </li> 
   <dd>
     &nbsp; 
   </dd> 
   <li> Because we included source code in the JARring, we can expand the new <i>todo.jar</i> in the <tt>Libraries</tt> tab and edit the <tt>Javadoc location</tt> thus. <p style="margin-left: 40px"> <img src="tut-images/eclipse-jar-javadoc.png"> </p> </li> 
   <dd>
     &nbsp; 
   </dd> 
   <li> Click <tt>OK</tt> to dismiss <tt>Java Build Path</tt>. </li> 
   <dd>
     &nbsp; 
   </dd> 
   <li> You should not be missing the <i>de.vogella.jersey.todo.model.Todo</i> import now. Also, hovering with the mouse over <tt>Todo</tt> in the <tt>main()</tt> method of <i>Tester.java</i> should reveal any Javadoc in the code for the <tt>Todo</tt> class. (In fact, it won't unless like me you put some Javadoc inside the code when you copied it out of the tutorial.) </li> 
  </ol> 
  <p> When I ran the <tt>Tester</tt> class, I got this output on the console: </p> 
  <pre class="code">
   <div id="code">
    
201

&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;todoes&gt;
  &lt;todo&gt;
    &lt;id&gt;3&lt;/id&gt;&lt;summary&gt;Blabla&lt;/summary&gt;
  &lt;/todo&gt;
  &lt;todo&gt;
    &lt;description&gt;Read complete http://www.vogella.de&lt;/description&gt;
    &lt;id&gt;2&lt;/id&gt;&lt;summary&gt;Do something&lt;/summary&gt;
  &lt;/todo&gt;
  &lt;todo&gt;
    &lt;description&gt;Read http://www.vogella.de/articles/REST/article.html&lt;/description&gt;
    &lt;id&gt;1&lt;/id&gt;
    &lt;summary&gt;Learn REST&lt;/summary&gt;
  &lt;/todo&gt;
&lt;/todoes&gt;

{"todo":[{"id":"3","summary":"Blabla"},{"description":"Read complete http://www.vogella.de","id":"2","summary":"Do something"},
{"description":"Read http://www.vogella.de/articles/REST/article.html","id":"1","summary":"Learn REST"}]}

&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;todoes&gt;
  &lt;todo&gt;
    &lt;id&gt;3&lt;/id&gt;
    &lt;summary&gt;Blabla&lt;/summary&gt;
  &lt;/todo&gt;
  &lt;todo&gt;
    &lt;description&gt;Read complete http://www.vogella.de&lt;/description&gt;
    &lt;id&gt;2&lt;/id&gt;
    &lt;summary&gt;Do something&lt;/summary&gt;
  &lt;/todo&gt;
  &lt;todo&gt;
    &lt;description&gt;Read http://www.vogella.de/articles/REST/article.html&lt;/description&gt;
    &lt;id&gt;1&lt;/id&gt;
    &lt;summary&gt;Learn REST&lt;/summary&gt;
  &lt;/todo&gt;
&lt;/todoes&gt;

&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;todo&gt;
  &lt;description&gt;Read http://www.vogella.de/articles/REST/article.html&lt;/description&gt;
  &lt;id&gt;1&lt;/id&gt;
  &lt;summary&gt;Learn REST&lt;/summary&gt;
&lt;/todo&gt;

&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;todoes&gt;
  &lt;todo&gt;
    &lt;description&gt;Read complete http://www.vogella.de&lt;/description&gt;
    &lt;id&gt;2&lt;/id&gt;
    &lt;summary&gt;Do something&lt;/summary&gt;
  &lt;/todo&gt;
  &lt;todo&gt;
    &lt;description&gt;Read http://www.vogella.de/articles/REST/article.html&lt;/description&gt;
    &lt;id&gt;1&lt;/id&gt;
    &lt;summary&gt;Learn REST&lt;/summary&gt;
  &lt;/todo&gt;
&lt;/todoes&gt;

Form response &lt;html&gt;&lt;head&gt;&lt;title&gt;Apache Tomcat/6.0.26 - Error report&lt;/title&gt;
&lt;style&gt;
&lt;!--
  H1 {font-family:Tahoma,Arial,sans-serif;color:white;background-color:#525D76;font-size:22px;}
  H2 {font-family:Tahoma,Arial,sans-serif;color:white;background-color:#525D76;font-size:16px;}
  H3 {font-family:Tahoma,Arial,sans-serif;color:white;background-color:#525D76;font-size:14px;}
  BODY {font-family:Tahoma,Arial,sans-serif;color:black;background-color:white;}
  B {font-family:Tahoma,Arial,sans-serif;color:white;background-color:#525D76;}
  P {font-family:Tahoma,Arial,sans-serif;background:white;color:black;font-size:12px;}
  A {color : black;}
  A.name {color : black;}
  HR {color : #525D76;}
 --&gt;
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;HTTP Status 404 - /de.vogella.jersey.todo/rest/../create_todo.html&lt;/h1&gt;
&lt;HR size="1" noshade="noshade"&gt;
&lt;p&gt;&lt;b&gt;type&lt;/b&gt; Status report&lt;/p&gt;
&lt;p&gt;&lt;b&gt;message&lt;/b&gt; &lt;u&gt;/de.vogella.jersey.todo/rest/../create_todo.html&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;description&lt;/b&gt; &lt;u&gt;The requested resource (/de.vogella.jersey.todo/rest/../create_todo.html) is not available.&lt;/u&gt;&lt;/p&gt;
&lt;HR size="1" noshade="noshade"&gt;
&lt;h3&gt;Apache Tomcat/6.0.26&lt;/h3&gt;
&lt;/body&gt;
&lt;/html&gt;

&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;todoes&gt;
  &lt;todo&gt;
    &lt;description&gt;Read complete http://www.vogella.de&lt;/description&gt;&lt;id&gt;2&lt;/id&gt;&lt;summary&gt;Do something&lt;/summary&gt;
  &lt;/todo&gt;
  &lt;todo&gt;
    &lt;description&gt;Read http://www.vogella.de/articles/REST/article.html&lt;/description&gt;&lt;id&gt;1&lt;/id&gt;&lt;summary&gt;Learn REST&lt;/summary&gt;
  &lt;/todo&gt;
  &lt;todo&gt;
    &lt;id&gt;4&lt;/id&gt;&lt;summary&gt;Demonstration of the client lib for forms&lt;/summary&gt;
  &lt;/todo&gt;
&lt;/todoes&gt;

   </div></pre> 
  <p> On studying the form response which, among other lines, I've re-wrapped here for clarity, it's clear that this test isn't working correctly. The problem appears to be a missing <i>create_todo.html</i> file. This will be resolved in the next section. </p> 
  <a name="56"></a> 
  <h3> 5.6. Use the REST service via an HTML page </h3> 
  <p> The HTML source is given, but no name for the file is advised. However, this is the missing <i>create_todo.html</i>; the tutorial just doesn't call it that nor does it say where to create it. Here's what the <tt>Tester</tt> class looks like when run after this file is created and located in the appropriate place. I've added (to <i>Tester.java</i>) some comments and vertical spacing to reach and clean up the console output. </p> 
  <p><strong><font color="maroon"> Experimentation resulted in learning that the HTML file, <i>create_todo.html</i>, should be placed on the path <i>de.vogella.jersey.todo/WebContent</i>.</font></strong> </p> 
  <p> With this done, here's the new output from <tt>Tester</tt>, wrapped to fit on this page: </p> 
  <pre class="code">
   <div id="code">
    
201

Get the Todos...
&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;todoes&gt;
  &lt;todo&gt;
    &lt;id&gt;3&lt;/id&gt;
    &lt;summary&gt;Blabla&lt;/summary&gt;
  &lt;/todo&gt;
  &lt;todo&gt;
    &lt;description&gt;Read complete http://www.vogella.de&lt;/description&gt;
    &lt;id&gt;2&lt;/id&gt;
    &lt;summary&gt;Do something&lt;/summary&gt;
  &lt;/todo&gt;
  &lt;todo&gt;
    &lt;description&gt;Read http://www.vogella.de/articles/REST/article.html&lt;/description&gt;
    &lt;id&gt;1&lt;/id&gt;
    &lt;summary&gt;Learn REST&lt;/summary&gt;
  &lt;/todo&gt;
&lt;/todoes&gt;

Get XML for application...
{"todo":[{"id":"3","summary":"Blabla"},{"description":"Read complete http://www.vogella.de","id":"2","summary":"Do something"},
{"description":"Read http://www.vogella.de/articles/REST/article.html","id":"1","summary":"Learn REST"}]}

Get JSON for application...
&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;todoes&gt;
  &lt;todo&gt;
    &lt;id&gt;3&lt;/id&gt;
    &lt;summary&gt;Blabla&lt;/summary&gt;
  &lt;/todo&gt;
  &lt;todo&gt;
    &lt;description&gt;Read complete http://www.vogella.de&lt;/description&gt;
    &lt;id&gt;2&lt;/id&gt;
    &lt;summary&gt;Do something&lt;/summary&gt;
  &lt;/todo&gt;
  &lt;todo&gt;
    &lt;description&gt;Read http://www.vogella.de/articles/REST/article.html&lt;/description&gt;
    &lt;id&gt;1&lt;/id&gt;
    &lt;summary&gt;Learn REST&lt;/summary&gt;
  &lt;/todo&gt;
&lt;/todoes&gt;

Get the Todo with id 1...
&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;todo&gt;
  &lt;description&gt;Read http://www.vogella.de/articles/REST/article.html&lt;/description&gt;
  &lt;id&gt;1&lt;/id&gt;
  &lt;summary&gt;Learn REST&lt;/summary&gt;
&lt;/todo&gt;

Get Todo with id 1...

Get the all todos, id 1 should be deleted...
&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;todoes&gt;
  &lt;todo&gt;
    &lt;description&gt;Read complete http://www.vogella.de&lt;/description&gt;
    &lt;id&gt;2&lt;/id&gt;
    &lt;summary&gt;Do something&lt;/summary&gt;
  &lt;/todo&gt;
  &lt;todo&gt;
    &lt;description&gt;Read http://www.vogella.de/articles/REST/article.html&lt;/description&gt;
    &lt;id&gt;1&lt;/id&gt;
    &lt;summary&gt;Learn REST&lt;/summary&gt;
  &lt;/todo&gt;
&lt;/todoes&gt;

Create a Todo...
Form response &lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Form to create a new resource&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;form action="../de.vogella.jersey.todo/rest/todos" method="POST"&gt;
    &lt;label for="id"&gt;ID&lt;/label&gt;
    &lt;input name="id" /&gt;
    &lt;br/&gt;
    &lt;label for="summary"&gt;Summary&lt;/label&gt;
    &lt;input name="summary" /&gt;
    &lt;br/&gt;
    Description:
    &lt;TEXTAREA NAME="description" COLS=40 ROWS=6&gt;&lt;/TEXTAREA&gt;
    &lt;br/&gt;
    &lt;input type="submit" value="Submit" /&gt;
  &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;


Get the all todos; id 4 should be deleted...
&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;todoes&gt;
  &lt;todo&gt;
    &lt;description&gt;Read complete http://www.vogella.de&lt;/description&gt;
    &lt;id&gt;2&lt;/id&gt;
    &lt;summary&gt;Do something&lt;/summary&gt;
  &lt;/todo&gt;
  &lt;todo&gt;
    &lt;description&gt;Read http://www.vogella.de/articles/REST/article.html&lt;/description&gt;
    &lt;id&gt;1&lt;/id&gt;
    &lt;summary&gt;Learn REST&lt;/summary&gt;
  &lt;/todo&gt;
  &lt;todo&gt;
    &lt;id&gt;4&lt;/id&gt;
    &lt;summary&gt;Demonstration of the client lib for forms&lt;/summary&gt;
  &lt;/todo&gt;
&lt;/todoes&gt;

   </div></pre> 
  <p> To run the Todo application, click <a href="http://localhost:8080/de.vogella.jersey.todo/create_todo.html" target="server"> <i>http://localhost:8080/de.vogella.jersey.todo/create_todo.html</i></a>. You'll see: </p> 
  <p style="margin-left: 80px"> <img src="tut-images/create-todo.png"> </p> 
  <a name="links"></a> 
  <h3> Additional links </h3> 
  <ul> 
   <li> <i>The Java EE 6 Tutorial</i>, <a href="http://download.oracle.com/docs/cd/E17410_01/javaee/6/tutorial/doc/giepu.html"> Building RESTful Web Services with JAX-RS and Jersey</a>. </li> 
   <li> The tutorial under review here was itself lifted in great part from <a href="http://www.ibm.com/developerworks/web/library/wa-aj-tomcat/index.html"> <i>Build a RESTful Web service using Jersey and Apache Tomcat</i></a>, a most excellent article. </li> 
   <li> <a href="http://jcalcote.wordpress.com/2009/08/06/restful-transactions/"> <i>RESTful Transactions</i></a>, a blog post by John Calcote. </li> 
   <li> <a href="http://jcalcote.wordpress.com/2009/08/10/restful-authentication/"> <i>RESTful Authentication</i></a>, a blog post by John Calcote. </li> 
   <li> <a href="http://jcalcote.wordpress.com/2008/10/16/put-or-post-the-rest-of-the-story/"> <i>PUT or POST: the REST of the Story</i></a>, a blog post by John Calcote. </li> 
  </ul> 
  <!-- ======================================================================= --> 
  <!-- ======================================================================= --> 
  <!-- ======================================================================= --> 
  <!-- ======================================================================= --> 
  <br> 
  <br> 
  <hr width="90%"> 
  <a name="webxml"></a> 
  <h3> Appendix: The secret of <i>web.xml</i> </h3> 
  <p> <i>web.xml</i> has in fact been my bane for many years. I'm forever screwing it up and having to pull my hair out over it before it starts working. It is almost always the source of HTTP Status 404 when first you begin running and debugging your application. </p> 
  <p> For this reason, I think it's useful to give a second example of a project's <i>web.xml</i>. Always, always show the reader the entrance to the rabbit hole from two separate angles so that he can find it later on his own. </p> 
  <p> (Note: you might also find my article, <a href="http://www.javahotchocolate.com/webxml.html"><i>That </i>web.xml<i> Mess</i></a>, useful.) </p> 
  <p> What was confusing about this tutorial's <i>web.xml</i>? Especially the use of package names for project names and for the <i>web.xml</i> display-name. This made it hard to figure out what was going on in that file. This appendix seeks to clarify this. </p> 
  <p> This <i>web.xml</i> incorporates a servlet definition (and its mapping) so that you can run the tutorial's <i>de.vogella.jersey.first</i> example. It also contains a second definition for my own hello world example. By giving two, even trivial examples in the same server, a great number of questions are answered about just how <i>web.xml</i> works. </p> 
  <p> <i>Fun</i> is my project name (not important, but shows you where I got my <tt>display-name</tt>). </p> 
  <p> The crucial bits of information that must be accurately specified are the following. Please refer to <i>web.xml</i> as you take note of these. </p> 
  <ol> 
   <li> The display name. It can be anything, but it's what goes first thing in the URL (browser address line) after the protocol (<i>http</i>) and domain-name:port-number. Note that I'm not using anything that looks like a package name here. I don't even have to use the Eclipse project name. Obviously, it cannot contain a space. </li> 
   <dd>
     &nbsp; 
   </dd> 
   <li> The servlet name. It can have spaces in it, but it's used in another place and the two must be identical. The servlet name doesn't show up outside this file, but this file uses it to find the appropriate mapping definition. </li> 
   <dd>
     &nbsp; 
   </dd> 
   <li> The servlet container class. This pertains to the framework you're using. Here, we're using Jersey, so we're sure to name that class which comes out of the user library (set of Jersey JARs) we used. </li> 
   <dd>
     &nbsp; 
   </dd> 
   <li> The servlet container class parameter name, as dictated (in this instance) by the REST servlet container or framework in use. </li> 
   <dd>
     &nbsp; 
   </dd> 
   <li> The value of the preceding parameter. It must be the package name that contains at least and at most one (JAXB) servlet (<i>.java</i> file). There may be more than one such servlet, but if so, the other(s) must be in a different Java package. </li> 
   <dd>
     &nbsp; 
   </dd> 
   <li> The servlet name must be identical to the one already specified above. As noted, if there are two servlets, there are two servlet definitions and two, separate servlet mapping definitions. </li> 
   <dd>
     &nbsp; 
   </dd> 
   <li> The URL pattern. It starts with '/' and ends with '/*' and can be any legitimate directory-like identifier (without spaces). It is the penultimate element of the URL, just before the class name path. </li> 
  </ol> 
  <h5> <i>web.xml</i>: </h5> 
  <pre><pre class="brush: xml; auto-links: false">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns="http://java.sun.com/xml/ns/javaee" xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
    xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
    id="WebApp_ID" version="2.5"&gt;
    &lt;display-name&gt;Fun&lt;/display-name&gt;

	&lt;!-- First servlet --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;Jersey REST Service&lt;/servlet-name&gt;
        &lt;servlet-class&gt;com.sun.jersey.spi.container.servlet.ServletContainer&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;com.sun.jersey.config.property.packages&lt;/param-name&gt;
            &lt;param-value&gt;de.vogella.jersey.first&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

	&lt;!-- Second servlet --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;Fun with REST&lt;/servlet-name&gt;
        &lt;servlet-class&gt;com.sun.jersey.spi.container.servlet.ServletContainer&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;com.sun.jersey.config.property.packages&lt;/param-name&gt;
            &lt;param-value&gt;com.etretatlogiciels.fun&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

	&lt;!-- Mappings --&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;Jersey REST Service&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/rest/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;Fun with REST&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/fun/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</pre></pre> 
  <br> 
  <p> This is more or less from the very first project in the tutorial. Once running, reach this servlet from a browser with the URL <i>http://localhost:8080/Fun/rest/hello</i>. </p> 
  <h5> <i>Hello.java</i>: </h5> 
  <pre><pre class="brush: java">package de.vogella.jersey.first;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

@Path( "/hello" )
public class Hello
{
	@GET
	@Produces( MediaType.TEXT_PLAIN )
	public String sayPlainTextHello()
	{
		return "Hello, Jersey--in plain text";
	}

	@GET
	@Produces( MediaType.TEXT_HTML )
	public String sayHtmlHello()
	{
		return "&lt;html&gt;\n"
				+ "&lt;head&gt;\n"
					+ "&lt;title&gt; " + "Hello, Jersey" + " &lt;/title&gt;\n"
				+ "&lt;/head&gt;\n"
			+ "&lt;body&gt;\n"
				+ "&lt;h2&gt; " + "Hello, Jersey—HTML" + " &lt;/h2&gt;\n"
			+ "&lt;/body&gt;\n"
			+ "&lt;/html&gt; ";
	}
}
</pre></pre> 
  <br> 
  <p> This is little more than a copy of that first Java file with names including package names changed: you can only field ONE REST servlet from any one package. This servlet is reached via <i>http://localhost:8080/Fun/fun/havefun</i>. It would be possible to keep <i>rest</i> as the URL pattern (so that both servlets use the same <tt>url-pattern</tt>). </p> 
  <h5> <i>Fun.java</i>: </h5> 
  <pre><pre class="brush: java">package com.etretatlogiciels.fun;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

@Path( "/havefun" )
public class Fun
{
	@GET
	@Produces( MediaType.TEXT_PLAIN )
	public String sayPlainTextHello()
	{
		return "Fun with REST--in plain text";
	}

	@GET
	@Produces( MediaType.TEXT_HTML )
	public String sayHtmlHello()
	{
		return "&lt;html&gt;\n"
				+ "&lt;head&gt;\n"
					+ "&lt;title&gt; " + "Fun with REST" + " &lt;/title&gt;\n"
				+ "&lt;/head&gt;\n"
			+ "&lt;body&gt;\n"
				+ "&lt;h2&gt; " + "Fun with REST—HTML" + " &lt;/h2&gt;\n"
			+ "&lt;/body&gt;\n"
			+ "&lt;/html&gt; ";
	}
}
</pre></pre> 
  <br> 
  <hr width="90%"> 
  <a name="app"></a> 
  <h3> Appendix: Notes on the <i>Java and XML</i> Tutorial </h3> 
  <p> (Return to <a href="#return"><i>RESTful Web Services with Java and Jersey</i></a>.) </p> 
  <a name="a133"></a> 
  <h3> 1.3.3. Comments </h3> 
  <p> In fact, I don't think <code>&lt;! COMMENT&gt;</code> is valid in XML. Instead, it's <code>&lt;!-- ...comment... --&gt;</code>. </p> 
  <a name="a21"></a> 
  <h3> 2.1. Domain Object Model (DOM) </h3> 
  <p> Lars recommends not using the W2C Standard API. He probably knows what he's talking about. </p> 
  <a name="a22"></a> 
  <h3> 2.2. Simple API for XML (SAX) </h3> 
  <p> Lars recommends not using SAX either. </p> 
  <a name="a23"></a> 
  <h3> 2.3. Streaming API for XML (StaX) </h3> 
  <p> Lars recommends not using this unless you must control the XML flow. </p> 
  <a name="a24"></a> 
  <h3> 2.4. Java Architecture for XML Binding (JAXB) </h3> 
  <p> Lars recommends using JAXB. </p> 
  <a name="a3"></a> 
  <h3> 3. Streaming API for XML (StaX projects) </h3> 
  <a name="a33"></a> 
  <h4> 3.3. XMLEventReader—Read XML Example </h4> 
  <p> Here are the projects. You're not told exactly how to set up the Eclipse projects to do this. Here's how I did it. </p> 
  <ol> 
   <li> Create a new Java Project named <i>de.vogella.xml.stax.reader</i>. </li> 
   <dd>
     &nbsp; 
   </dd> 
   <li> Create the XML file to be tested just inside the project (not <i>src</i>) directory, name it <i>config.xml</i>. </li> 
   <dd>
     &nbsp; 
   </dd> 
   <li> Create two packages under <i>src</i>: 
    <ul> 
     <li> <i>de.vogella.xml.stax.model</i> </li> 
     <li> <i>de.vogella.xml.stax.read</i> </li> 
    </ul> </li> 
   <dd>
     &nbsp; 
   </dd> 
   <li> Create and copy in the Java source code for 
    <ul> 
     <li> <i>Item.java</i> </li> 
     <li> <i>StaxParser.java</i> </li> 
     <li> <i>TestRead.java</i> </li> 
    </ul> </li>
  </ol> 
  <p> When you run the project, by right-clicking the <i>TestRead.java</i> file and choosing <tt>Run As -&gt; Java application</tt>, you will see: </p> 
  <pre class="code">
   <div id="code">
    
Item [current=1, date=January 2009, interactive=1, mode=1, unit=900]
Item [current=2, date=February 2009, interactive=5, mode=2, unit=400]
Item [current=100, date=December 2009, interactive=3, mode=9, unit=5]

   </div></pre> 
  <a name="a34"></a> 
  <h4> 3.4. XMLEventReader—Write XML Example </h4> 
  <ol> 
   <li> Create a new package under <i>src</i> named <i>de.vogella.xml.stax.writer</i>. </li> 
   <dd>
     &nbsp; 
   </dd> 
   <li> Create and copy the source code to <i>StaxWriter</i>. </li> 
   <dd>
     &nbsp; 
   </dd> 
   <li> Create and copy the test code to <i>TestWrite</i>. </li> 
  </ol> 
  <p> When you run the test, <i>TestWrite.java</i>, a new file, <i>config2.xml</i> is created alongside the <i>config.xml</i> used in the Read XML test. You will see no output on the console. </p> 
  <a name="a41"></a> 
  <h3> 4.1. JAXB 2—Java Architecture for XML Binding </h3> 
  <p> Create yet a new Java Project, <i>de.vogella.xml.jaxb</i>. </p> 
  <ol> 
   <li> Create a new package, <i>de.vogella.xml.jaxb.model</i>. </li> 
   <dd>
     &nbsp; 
   </dd> 
   <li> Create and copy the source to <i>Book.java</i> and <i>Bookstore.java</i>. </li> 
   <dd>
     &nbsp; 
   </dd> 
   <li> Create and copy the test code, <i>BookMain</i>, in a new package, <i>test</i>. (Yup, this lack of orthogonality is total laziness on Lars' part.) </li> 
  </ol> 
  <p> Run <i>BookMain.java</i> to see the following in the console: </p> 
  <pre class="code">
   <div id="code">
    
&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;ns2:bookstore xmlns:ns2="de.vogella.xml.jaxb.model"&gt;
    &lt;bookList&gt;
        &lt;book&gt;
            &lt;author&gt;Neil Strauss&lt;/author&gt;
            &lt;bookName&gt;The Game&lt;/bookName&gt;
            &lt;publisher&gt;Harpercollins&lt;/publisher&gt;
            &lt;isbn&gt;978-0060554736&lt;/isbn&gt;
        &lt;/book&gt;
        &lt;book&gt;
            &lt;author&gt;Charlotte Roche&lt;/author&gt;
            &lt;bookName&gt;Feuchtgebiete&lt;/bookName&gt;
            &lt;publisher&gt;Dumont Buchverlag&lt;/publisher&gt;
            &lt;isbn&gt;978-3832180577&lt;/isbn&gt;
        &lt;/book&gt;
    &lt;/bookList&gt;
    &lt;location&gt;Frankfurt Airport&lt;/location&gt;
    &lt;name&gt;Fraport Bookstore&lt;/name&gt;
&lt;/ns2:bookstore&gt;

Output from our XML File:
Book 1: The Game from Neil Strauss
Book 2: Feuchtgebiete from Charlotte Roche

   </div></pre> 
  <p> ...as well as an XML file at the root of the project named, <i>bookstore-jaxb.xml</i>, containing the XML part that came out in the console. </p> 
  <a name="a51"></a> 
  <h3> 5.1. XPath </h3> 
  <p> Create yet a new Java Project, <i>UsingXPath</i>. </p> 
  <ol> 
   <li> Create and copy content for <i>person.xml</i> at root of project. </li> 
   <li> Create new package <i>myxml</i>. </li> 
   <li> Create and copy source for <i>QueryXML</i>. </li> 
  </ol> 
  <p> Run the lone Java file as an application. You'll see: </p> 
  <pre class="code">
   <div id="code">
    
Vogel
Strangelastname
Tim
Number of objects 3.0
true

   </div></pre> 
  <a name="jax"></a> 
  <h3> Other JAX things </h3> 
  <p> There's a wealth of web services behind all these <i>Java API for XML</i> (JAX) technologies. There are Java API for XML... </p> 
  <ul> 
   <li> Processing, or JAXP (validation and parsing including DOM, SAX and StAX) </li> 
   <li> Messaging, or JAXM (communcation using XML, especially SOAP) </li> 
   <li> RPC, or JAX-RPC (evolved into JAX-WS 2.0) </li> 
   <li> Registries, or JAXR (metadata) </li> 
   <li> Web Services, or JAX-WS (WSDL, SOAP) </li> 
   <li> RESTful Web Services, or JAX-RS </li> 
   <li> and Java Architecture for XML Binding, or JAXB (mapping classes to XML and back). </li> 
  </ul> 
  <p> Not covered in this document, JAX-WS creates a traditional WSDL-based SOAP service. SOAP, <i>Simple Object Access Protocol</i>, is a specification for exchanging structured information relying on XML. The Web Service Description Language (WSDL) specifies an XML format that describes a service as a set of endpoints that operates on messages. The conveyance is SOAP (in HTTP). </p> 
  <p> Two good references to JAX-WS are: </p> 
  <ul> 
   <li> <a href="http://download.oracle.com/javaee/5/tutorial/doc/bnayn.html"> <i>The Java EE 5 Tutorial: Creating a Simple Web Service and Client with JAX-WS</i></a> </li> 
   <li> <a href="http://www.vogella.de/articles/JavaWebservice/article.html"> <i>Web Services with Java 1.6—Tutorial</i></a> </li> 
  </ul> 
  <br> 
  <hr width="60%"> 
  <a name="webxml2"></a> 
  <h3> Appendix: More <i>web.xml</i>... </h3> 
  <p> In a RESTful service setting, <i>web.xml</i> and the URI to use in the browser or client application appear to work thus: </p>
  <ul> 
   <li> <i>http://hostname:port/application-context/rest/thing</i> </li>
   <li> <i>http://localhost:8080/rest-server/rest/ping</i> </li>
  </ul> 
  <p> This is how Eclipse does things with Tomcat in the absence of any <i>META-INF/context.xml</i>. In the copy of <i>web.xml</i> below, compare what's bold-faced with the explanations given here. </p> 
  <ul> 
   <li> The application context appears given by &lt;display-name&gt; in <i>web.xml</i>. I've been told this isn't true. However, it's what works for me. </li> 
   <li> <i>/rest/</i> is specified by &lt;servlet-mapping&gt; in <i>web.xml</i>. </li> 
   <li> thing is specified by the <tt>@Path</tt> annotation at the top of the relevant class in the source code; the package in which this class is found is specified in 
    <servlet>
     <init-param>
       in 
      <i>web.xml</i>. This wiring appears crucial. It's how the servlet contain is able to find its way. 
     </init-param>
    </servlet></li> 
  </ul> 
  <h5> <i>web.xml</i>: </h5> 
  <pre><pre class="brush: xml; auto-link: false">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns="http://java.sun.com/xml/ns/javaee"
        xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
        xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
                            http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
        id="WebApp_ID"
        version="2.5"&gt;

    &lt;display-name&gt;rest-server&lt;/display-name&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;Jersey REST Service&lt;/servlet-name&gt;
        &lt;servlet-class&gt;com.sun.jersey.spi.container.servlet.ServletContainer&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;com.sun.jersey.config.property.packages&lt;/param-name&gt;
            &lt;param-value&gt;com.hp.webplatform.restful.server&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;Jersey REST Service&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/rest/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</pre></pre> 
  <br> 
  <hr width="90%"> 
  <a name="tomcat"></a> 
  <h3> Appendix: Random notes on Tomcat, Eclipse and Jersey </h3> 
  <p> This section is only for your interest if, like me, you entertain a morbid fascination with the inner workings of Eclipse and Tomcat on Eclipse. It's easier for me to figure out how to make something work (or fix it) if I grok the guts than if I trust to Eclipse and blindly follow what are very weakly defined practices in the first place. (Eclipse's lack of best practice is what makes MyEclipse something its owners can actually sell for money.) </p> 
  <p> The following is admittedly a bit random and follows from problems I've had re-casting our server project in Git for the second time. Working on a project by committee results in the former being wired up using different practices such that, alone in this exercise, I had to transcend all of them to get back to a working state. </p> 
  <h4> Web Deployment Assembly problems </h4> 
  <p> So, what to do when Tomcat won't start because <tt>ServletContainer</tt> has gone missing? </p> 
  <p> The problem might arise by how you do library JARs. If you're using a <i>lib</i> subdirectory at the project root and adding them with <tt>Build Path -&gt; Configure Build Path -&gt; Libraries -&gt; Add JARs</tt> versus the usual Eclipse practice of putting the JARs on the path <i>WebContent/WEB-INF/lib</i> and creating a <tt>User Library</tt>. (There's absolutely nothing wrong with this; it's just not what's "taught" in the Eclipse forums by those who answer questions there, one of which is me, but I just parrot what I've already heard.) </p> 
  <p> In the Web Deployment Assembly dialog (right-click the project, choose Properties, then look for this down the left side of the Properties dialog), use <tt>Add -&gt; Java Build Path Entries</tt> to find and add all the libraries and not <tt>Folder</tt> (<i>/lib</i>). You should end up with a deployment assembly list that's rather long—consisting of every single JAR you expect—no convenient "groups" like <tt>User Libraries</tt>. </p>
  <h4> How Jersey works </h4> 
  <p> When Tomcat is started with </p> 
  <pre class="code">
   <div id="code">
    
&lt;servlet&gt;
    &lt;servlet-name&gt;Jersey REST Service&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com.sun.jersey.spi.container.servlet.ServletContainer&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;com.sun.jersey.config.property.packages&lt;/param-name&gt;
        &lt;param-value&gt;com.acme.webplatform.ws&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

   </div></pre> 
  <p> in <i>web.xml</i>, Jersey scans for classes in the package noted as the value of com.sun.jersey.config.property.packages. These classes are the ones with annotations in them like <tt>@Path</tt>, <tt>@GET</tt>, <tt>@PUT</tt>, etc. and <tt>@Produces</tt>. You see the following during Tomcat start: </p> 
  <pre class="code">
   <div id="code">
    <font color="red"> INFO: Scanning for root resource and provider classes in the packages: com.hp.webplatform.ws Aug 4, 2011 4:20:37 PM com.sun.jersey.api.core.ScanningResourceConfig logClasses INFO: Root resource classes found: class com.acme.webplatform.ws.UserWS class com.acme.webplatform.ws.PingWS class com.acme.webplatform.ws.PartnerWS</font>

   </div></pre> 
  <p> This is a list of those classes, in this case, the ping service, the user management service and the partner management service. If your intended one isn't on the list, chances are <i>web.xml</i> is at fault in specifying the right package, or your class isn't in the right package. </p> 
  <h4> Unimportant warnings </h4> 
  <p> These do not have to be fixed. Starting Tomcat, you get this: </p> 
  <pre class="code">
   <div id="code">
    <font color="red"> WARNING: [SetPropertiesRule]{Server/Service/Engine/Host/Context} Setting property 'source' to 'org.eclipse.jst.jee.server: (project name)' did not find a matching property.</font>
   </div></pre> 
  <p> This was added sometime early in Tomcat 6.x. It's eliminated by opening the server (<tt>Server</tt> tab -&gt; double-click your Tomcat server <tt>-&gt; Server Options -&gt;</tt> check <tt>Publish module contexts to separate XML files</tt> (whatever that means—sometimes I think interface designers use random word-sequence generators). </p> 
  <p> Or this: </p> 
  <pre class="code">
   <div id="code">
    <font color="red"> INFO: The APR based Apache Tomcat Native library which allows optimal performance in production environments was not found on the java.library.path: /home/russ/dev/jdk1.6.0_24/jre/lib/amd64/server: /home/russ/dev/jdk1.6.0_24/jre/lib/amd64: /home/russ/dev/jdk1.6.0_24/jre/../lib/amd64: /usr/java/packages/lib/amd64:/usr/lib64:/lib64:/lib:/usr/lib</font>
   </div></pre> 
  <p> The answer here is that an optional library is missing. This involves: </p> 
  <ol> 
   <li> Build and install OpenSSL </li> 
   <li> Build and install the Apache Portable Runtime library (APR) </li> 
   <li> Build and install the Tomcat Native Wrapper </li> 
  </ol> 
  <p> Presumably, for doing this, you get: </p> 
  <ol> 
   <li> Faster (optimized) performance </li> 
   <li> Secure session-ID generation by default on all platforms </li> 
   <li> OS-level statistics on memory and CPU usage displayed by the status servlet (in the manager application) </li> 
  </ol> 
  <p> as explained here: <a href="http://mattfleming.com/node/247"> <i>http://mattfleming.com/node/247</i></a> </p> 
  <p> This is mostly for your gee-whiz collection. I've never done it, I just looked into it once in case I wanted to rid myself of every last warning during Tomcat start-up. </p> 
  <br> 
  <hr width="20%"> 
  <div id="footer"> 
   <p class="footer"> Copyright ©2010 by Russell Bateman and Etretat Logiciels, LLC.<br><br> Permission is granted for any derivational use. You are forbidden only from reposting the texts and any sources of this article without express permission of the author. </p> 
  </div>   
  <!-- vim: set tabstop=2 shiftwidth=2 noexpandtab: --> 
 </body>
</html>