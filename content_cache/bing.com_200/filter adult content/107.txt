<!doctype html>
<html lang="en">
 <head> 
  <meta charset="utf-8"> 
  <meta http-equiv="X-UA-Compatible" content="IE=edge"> 
  <meta name="viewport" content="width=device-width, initial-scale=1"> 
  <title>Package Manifests</title> 
  <link href="/favicon.ico" rel="shortcut icon" type="image/x-icon"> 
  <link href="https://uhf.microsoft.com/mscc/statics/mscc-0.3.6.min.css" rel="stylesheet"> 
  <link href="/Content/gallery/css/bootstrap.css" rel="stylesheet"> 
  <link href="/Content/gallery/css/bootstrap-theme.css" rel="stylesheet"> 
  <link href="/Content/gallery/css/fabric.css" rel="stylesheet"> 
  <script src="https://uhf.microsoft.com/mscc/statics/mscc-0.3.6.min.js"></script> 
  <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries --> 
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// --> 
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
  <![endif]--> 
  <style type="text/css">
    .cc-banner {
      font-size: 16px;
    }
  </style> 
 </head> 
 <body> 
  <div id="msccBanner" dir="ltr" data-site-name="uhf-blog.nuget.org" data-mscc-version="0.3.6" data-nver="aspnet-2.0.5" data-sver="0.1.2" class="cc-banner container-fluid banner banner-notice text-center" role="alert"> 
   <div class="row" style="padding: 5px;"> 
    <div class="col-sm-12" role="alert"> 
     <i class="ms-Icon ms-Icon--Warning" aria-hidden="true"></i> 
     <span class="cc-text">This site uses cookies for analytics, personalized content and ads. By continuing to browse this site, you agree to this use.</span> 
     <a href="https://go.microsoft.com/fwlink/?linkid=845480" aria-label="Learn more about Microsoft’s Cookie Policy" id="msccLearnMore" class="cc-link" data-mscc-ic="false">Learn more</a> 
    </div> 
   </div> 
  </div> 
  <nav class="navbar navbar-inverse" role="navigation"> 
   <div class="container"> 
    <div class="row"> 
     <div class="col-sm-12"> 
      <div class="navbar-header"> 
       <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button> 
       <a href="https://www.nuget.org/"><img class="navbar-logo" width="94" height="28" alt="NuGet home" src="/Content/gallery/img/logo.svg" onerror="this.src='/Content/gallery/img/logo-94x28.png'; this.onerror = null;"></a> 
      </div> 
      <div id="navbar" class="navbar-collapse collapse" role="menubar"> 
       <ul class="nav navbar-nav" role="menu"> 
        <li class="" aria-selected="false" role="presentation"> <a role="menuitem" href="https://www.nuget.org/packages"> <span>Packages</span> </a> </li> 
        <li class="" aria-selected="false" role="presentation"> <a role="menuitem" href="https://www.nuget.org/packages/manage/upload"> <span>Upload</span> </a> </li> 
        <li class="" aria-selected="false" role="presentation"> <a role="menuitem" href="https://www.nuget.org/stats"> <span>Statistics</span> </a> </li> 
        <li class="" aria-selected="false" role="presentation"> <a role="menuitem" href="https://docs.microsoft.com/en-us/nuget/"> <span>Documentation</span> </a> </li> 
        <li class="" aria-selected="false" role="presentation"> <a role="menuitem" href="https://www.nuget.org/downloads"> <span>Downloads</span> </a> </li> 
        <li class="active" aria-selected="true" role="presentation"> <a role="menuitem" href="/"> <span>Blog</span> </a> </li> 
       </ul> 
      </div> 
     </div> 
    </div> 
   </div> 
  </nav> 
  <section role="main" class="container main-container page-blog-post"> 
   <article class="row"> 
    <div class="col-xs-12"> 
     <h1>Package Manifests</h1> 
     <p class="ms-fontSize-xl">October 23, 2014 by Jeff Handley </p> 
     <div class="post-content"> 
      <p>As we work on the designs for getting <a href="/20141014/in-the-platform.html">NuGet in the platform</a>, it has become clear that <strong>NuGet needs better support for carrying arbitrary artifacts in packages and exposing them for consumption after the initial package installation</strong>.</p> 
      <h2 id="conventional-manifests">Conventional Manifests</h2> 
      <p>Since NuGet’s initial release, it has supported conventional manifests and only a few concepts.</p> 
      <ol> 
       <li>Assembly references from the <code class="highlighter-rouge">\lib</code> folder</li> 
       <li>Content files from the <code class="highlighter-rouge">\content</code> folder</li> 
       <li>PowerShell scripts from the <code class="highlighter-rouge">\tools</code> folder</li> 
       <li>MSBuild props/targets imports from the <code class="highlighter-rouge">\build</code> folder</li> 
       <li>A <code class="highlighter-rouge">README.txt</code> file at the root of the package to be opened automatically after installation</li> 
      </ol> 
      <p>All other files inside the package are completely ignored and NuGet’s existing design makes it difficult to expand on these concepts or introduce new ones.</p> 
      <p>Before we dive into where we think NuGet is going, let’s look closer at what NuGet supports today within its manifests. These are all implemented based on conventions for how the package is laid out–the manifests are not explicitly declared within the <code class="highlighter-rouge">nuspec</code>.</p> 
      <h3 id="assembly-references">Assembly References</h3> 
      <p>The <code class="highlighter-rouge">\lib</code> folder is reserved for assemblies that will get referenced by the project. During installation, NuGet gets the list of assemblies in the <code class="highlighter-rouge">\lib</code> folder and calls the Visual Studio API for adding an assembly reference to each.</p> 
      <p>There are a couple of additional features this folder supports.</p> 
      <h4 id="target-framework-selection">Target Framework Selection</h4> 
      <p>If you provide a subfolder under <code class="highlighter-rouge">\lib</code> that matches a framework name we recognize, we use that as an applicability filter. When finding references from the package, we’ll choose the best <code class="highlighter-rouge">\lib</code> folder for the project; if none of the folders match, then installation fails.</p> 
      <h4 id="deployment-only-assemblies">Deployment-Only Assemblies</h4> 
      <p>If your package needs to carry assemblies that are used only for deployment and don’t need actual Visual Studio/MSBuild references, then you can provide additional configuration within your <code class="highlighter-rouge">nuspec</code> to specific which set of assemblies actually do need references.</p> 
      <h3 id="content-files">Content Files</h3> 
      <p>The <code class="highlighter-rouge">\content</code> folder includes content files that will be copied into the project, putting those files directly into the project itself. This is how jQuery and other JavaScript/CSS files get into your project from a NuGet package.</p> 
      <p>This scenario has come under debate for a couple reasons. Many developers don’t like that <a href="http://nuget.codeplex.com/workitem/1914">NuGet packages get to specify where</a> in the project the content items will be placed. Others want to prevent the content files from getting copied into the project at all and <a href="http://nuget.codeplex.com/workitem/1239">have Package Restore do the work instead</a>.</p> 
      <p>Content files also support target framework filtering, XML <a href="http://docs.nuget.org/docs/creating-packages/configuration-file-and-source-code-transformations#Configuration_File_Transformations">transformations for app configuration</a>, and <a href="http://docs.nuget.org/docs/creating-packages/configuration-file-and-source-code-transformations#Specifying_Source_Code_Transformations">source code transformations</a> for replacing tokens with project properties.</p> 
      <h3 id="powershell-scripts">PowerShell Scripts</h3> 
      <p>When a package carries an <code class="highlighter-rouge">install.ps1</code> file within its <code class="highlighter-rouge">\tools</code> folder, the script will be run after package installation. An <code class="highlighter-rouge">uninstall.ps1</code> is executed before uninstallation. Lastly, <code class="highlighter-rouge">init.ps1</code> is executed every time the solution is opened (assuming the NuGet PowerShell Console is open). Target framework filters apply to this folder too.</p> 
      <p>The mere existence of this feature is a blocker for allowing package installation outside the Visual Studio context. These scripts are executed through our PowerShell Console within Visual Studio, they reference Visual Studio DTE API, and they rely on the MSBuild project being loaded and available.</p> 
      <p>This PowerShell capability has always been an escape hatch to allow a package to express something beyond the capabilities NuGet had for assembly references and content files. NuGet has no way of knowing whether these scripts are optional or if they are truly required for the package to work.</p> 
      <h3 id="msbuild-imports">MSBuild Imports</h3> 
      <p>NuGet looks in the <code class="highlighter-rouge">\build</code> folder for props and targets files where the filename matches the package id. These are automatically imported into the project (at the top or bottom, respectively) using Visual Studio’s DTE API and applying the target framework filtering. We add the imports in a way that is friendly for Package Restore, but the workflow still isn’t great.</p> 
      <p>This props/targets feature was added after we observed it was the most common use of PowerShell <code class="highlighter-rouge">install.ps1</code> scripts. But oddly enough, this feature itself is another escape hatch to allow a package to express something beyond the capabilities NuGet had for assembly references and content files!</p> 
      <h3 id="readmetxt">README.txt</h3> 
      <p>If the package has a <code class="highlighter-rouge">README.txt</code> file at the root of the package, NuGet will automatically open this file when the package is installed (directly, not as a dependency). This is the only file we recognize for this feature–we don’t recognize Markdown or HTML files, and there are no conventions for determining applicability of showing this file. We’ve seen requests for conditionally opening this file in certain configurations, but we’ve had to tell those authors just to use PowerShell.</p> 
      <h2 id="nuget-package-capabilities">NuGet Package Capabilities</h2> 
      <p>If you were paying attention, you noticed that two of NuGet’s five package conventions exist solely to augment NuGet’s built-in functionality.</p> 
      <p><strong>Something’s wrong there.</strong></p> 
      <p>Merging the two extensibility points into one, let’s recap the <em>actual</em> features NuGet packages offer:</p> 
      <ol> 
       <li>Assemblies: either referenced or deployed</li> 
       <li>Content files: copied into your project</li> 
       <li>Extensibility points for other types of artifacts</li> 
       <li>A readme experience that is too restrictive</li> 
      </ol> 
      <p>That’s it. If you think about it, it’s pretty amazing that NuGet has had the adoption it has with its functionality boiling down to that.</p> 
      <h2 id="revisiting-fundamentals">Revisiting Fundamentals</h2> 
      <p>When we look at the feedback we get from people who have invested heavily in using NuGet, we hear two common themes:</p> 
      <ol> 
       <li>NuGet should resolve the assemblies at build-time instead of install-time</li> 
       <li>NuGet should let package consumers <a href="http://nuget.codeplex.com/workitem/1914">control how content files are brought in</a> from packages, or <a href="http://nuget.codeplex.com/workitem/1239">not bring them in</a> at all</li> 
      </ol> 
      <p>The feedback on the install-time actions goes all the way back to <a href="/20141010/nuget-is-broken.html">NuGet’s initial design</a> and this is being revisited as we move into the platform, at least for the handling of assemblies from the <code class="highlighter-rouge">\lib</code> folder.</p> 
      <p>It’s time to revisit the fundamentals of what is carried inside a NuGet package and design a new package manifest.</p> 
      <h3 id="goals">Goals</h3> 
      <p>There are several salient goals for creating a new package manifest design.</p> 
      <ol> 
       <li>Enable build-time manifest discovery and selection</li> 
       <li>Make NuGet ignorant of target frameworks so that it doesn’t have to be updated every time Xamarin or Microsoft adds a new framework</li> 
       <li>Allow applicability filters beyond target framework, including configuration, architecture, etc., and allow them to be nested</li> 
       <li>Make NuGet ignorant of the filters to make NuGet reusable in new domains and scenarios</li> 
       <li>Make NuGet ignorant of <em>the manifest artifacts themselves</em> to make NuGet reusable in new domains and scenarios</li> 
       <li>Ensure that the gallery and feed both expose all of the manifest information so that tools don’t have to download and unpack <code class="highlighter-rouge">nupkg</code> files (pronounced “NUP-KEG” by the way) to discover what artifacts are in the package</li> 
       <li>Switch from XML-formatted <code class="highlighter-rouge">nuspec</code> files to JSON (because people like authoring and reading JSON better, it’s consistent with the direction we’re taking the feed, and it could potentially align with <a href="https://github.com/aspnet/Home/wiki/Project.json-file">ASP.NET vNext’s project.json file</a>)</li> 
      </ol> 
      <h3 id="separating-authoring-from-protocol">Separating Authoring from Protocol</h3> 
      <p>The <code class="highlighter-rouge">nuspec</code> has always been NuGet’s “protocol”. It is how packages are understood. Except it is incomplete because it doesn’t include the package manifest–that part was just based on the files within the package itself. This approach allowed the files within the package to be self-describing and the single source of truth. But it has caused us some problems.</p> 
      <p>Just to name a few of the issues we’ve faced:</p> 
      <ol> 
       <li>The package contents are required to get the manifest</li> 
       <li>The manifest is needed to determine target framework compatibility</li> 
       <li>Since conventions are applied at package installation time (rather than pack time), adding new conventions is a backwards-compatibility nightmare!</li> 
      </ol> 
      <p>We want NuGet packages to have a clean authoring experience; you shouldn’t have to author the file manifest if it can be gleaned from conventions. But we need to reduce the protocol down to a single source of information (a package manifest) rather than requiring both the <code class="highlighter-rouge">nuspec</code> and the package contents. We will also benefit greatly from applying any conventions at pack time and making packages’ behavior deterministic rather than vulnerable to the client’s understanding of conventions.</p> 
      <h3 id="backwards-compatibility">Backwards Compatibility</h3> 
      <p>As we explore producing an authoritative package manifest at the time of packing, we have to be thoughtful of the NuGet clients that exist today–the ones that wouldn’t know to look for this new manifest. We want newly created packages to contain both the authoritative manifest and also be backwards compatible–except for when the packages use <em>new</em> features.</p> 
      <h3 id="proposal">Proposal</h3> 
      <p>The most common scenario for packing today is when you have a <code class="highlighter-rouge">nuspec</code> file and then artifacts on disk. You run <code class="highlighter-rouge">nuget.exe pack</code> against your nuspec and you get the following result (ignoring the actual package contents):</p> 
      <ul> 
       <li><code class="highlighter-rouge">id.version.nupkg</code> 
        <ul> 
         <li><code class="highlighter-rouge">id.nuspec</code></li> 
        </ul> </li> 
      </ul> 
      <p>With the proposal, the result would be changed to the following:</p> 
      <ul> 
       <li><code class="highlighter-rouge">id.version.nupkg</code> 
        <ul> 
         <li><code class="highlighter-rouge">id.nuspec</code></li> 
         <li><code class="highlighter-rouge">nuget.manifest.json</code></li> 
        </ul> </li> 
      </ul> 
      <h4 id="keeping-the-nuspec">Keeping the nuspec</h4> 
      <p>The <code class="highlighter-rouge">nuspec</code> file inside the package would still be XML-based and it would contain the following critical components:</p> 
      <ol> 
       <li>Id</li> 
       <li>Version</li> 
       <li>Authors</li> 
       <li>Description</li> 
       <li>NuGet minClientVersion attribute</li> 
      </ol> 
      <p>If the package does not use any new NuGet features, then all of the rest of the <code class="highlighter-rouge">nuspec</code> would be filled in too (including fields such as <code class="highlighter-rouge">Dependencies</code> and <code class="highlighter-rouge">References</code>), and the <code class="highlighter-rouge">minClientVersion</code> would not be set to require NuGet 3.0. That provides backwards-compatibility with old NuGet clients.</p> 
      <p>If the package does use new NuGet features, then no other fields would be provided in the <code class="highlighter-rouge">nuspec</code> and the <code class="highlighter-rouge">minClientVersion</code> would be set to 3.0 (or newer). This compromise allows old NuGet clients to still load the package for display purposes but then respect the <code class="highlighter-rouge">minClientVersion</code> when the user tries to install the package.</p> 
      <h4 id="introducing-the-manifest">Introducing the Manifest</h4> 
      <p>The <code class="highlighter-rouge">nuget.manifest.json</code> file would contain all of the information carried in the <code class="highlighter-rouge">nuspec</code> but it would also carry the important artifact manifest. The conventions that NuGet applies at install-time today would be applied at pack time and then persisted into this manifest.</p> 
      <p>When a NuGet 3.0 client reads a package that contains a manifest, the manifest would win and explicitly state what should be done with the package contents–no conventions would be applied at package installation time.</p> 
      <h4 id="authoring-a-manifest-directly">Authoring a Manifest Directly</h4> 
      <p>Are you tired of maintaining an XML-based <code class="highlighter-rouge">nuspec</code> file? Do you prefer JSON? Do you want to use new manifest features that we’ll be introducing? Great; you can author the manifest directly!</p> 
      <blockquote class="twitter-tweet" lang="en">
       <p>Conventions are an awesome way to imply configuration. But make sure you also allow explicit configuration to deviate from conventions.</p>— Jeff Handley (@JeffHandley) 
       <a href="https://twitter.com/JeffHandley/status/522981703842021376">October 17, 2014</a>
      </blockquote> 
      <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script> 
      <p>If you want to take over manifest authoring, you’ll be able to. Instead of creating a <code class="highlighter-rouge">nuspec</code> file, you would author a <code class="highlighter-rouge">nuget.json</code> file (or perhaps use ASP.NET’s <code class="highlighter-rouge">project.json</code> file). Authoring in this format allows you to either retain the pack-time conventions that NuGet will apply or override them as needed. When the package would be created, it would then have the following files in it:</p> 
      <ul> 
       <li><code class="highlighter-rouge">id.version.nupkg</code> 
        <ul> 
         <li><code class="highlighter-rouge">id.nuspec</code></li> 
         <li><code class="highlighter-rouge">nuget.json</code></li> 
         <li><code class="highlighter-rouge">nuget.manifest.json</code></li> 
        </ul> </li> 
      </ul> 
      <p>Three things happened here. First, the original <code class="highlighter-rouge">nuget.json</code> file was brought into the package. Second, a <code class="highlighter-rouge">nuget.manifest.json</code> file was created. And third, the <code class="highlighter-rouge">id.nuspec</code> file was also created.</p> 
      <p>We’d create the <code class="highlighter-rouge">nuspec</code> file for backwards-compatibility reasons stated above. We’d create the <code class="highlighter-rouge">nuget.manifest.json</code> file as a result of your author-time <code class="highlighter-rouge">nuget.json</code> and the authoritative manifest. That allows for your author-time <code class="highlighter-rouge">nuget.json</code> file to take some shortcuts and still use conventions as you desire, while retaining the authoritative nature of the manifest file. We’d also include your author-time <code class="highlighter-rouge">nuget.json</code> file to still provide the nice package editing features that you get with tools like <a href="http://npe.codeplex.com">NuGet Package Explorer</a>–that allows the <code class="highlighter-rouge">nupkg</code> to remain a unit that can be copied around, edited, re-packed, and consumed. It could however be an option to omit the <code class="highlighter-rouge">nuget.json</code> file from the package if you don’t want to ship your author-time format.</p> 
      <p><em>Side-note… We’re also thinking that the <code class="highlighter-rouge">nuget.manifest.json</code> file will utilize <a href="http://json-ld.org">JSON-LD</a> the same way our API v3 work does.</em></p> 
      <h4 id="relying-only-on-the-manifest">Relying only on the Manifest</h4> 
      <p>It’s critical to note that at package consumption time, NuGet 3.0 would <em>only</em> use the <code class="highlighter-rouge">nuget.manifest.json</code> file. Even though the package still contains the <code class="highlighter-rouge">nuspec</code> and potentially the author-time <code class="highlighter-rouge">nuget.json</code> file, the <em>protocol</em> for consuming packages would be based on the <code class="highlighter-rouge">nuget.manifest.json</code> file.</p> 
      <p>We’d end up with a simple if block in the NuGet code:</p> 
      <ol> 
       <li>If the package contains a <code class="highlighter-rouge">nuget.manifest.json</code> file then use <strong>only</strong> that file for understanding the manifest and don’t apply any conventions at consumption time</li> 
       <li>Otherwise, read the <code class="highlighter-rouge">nuspec</code> and the file list like NuGet always has, applying conventions at consumption time</li> 
      </ol> 
      <h2 id="more-to-discuss">More to Discuss</h2> 
      <p>We have a lot more to discuss about the plans for NuGet 3.0. We need to talk about what these arbitrary package manifests look like, how they’re configurable, how NuGet-based tools would read and understand the information, and more. We’ll keep working on writing up our thoughts on these topics, but please let us know what you think so far.</p> 
     </div> 
     <div id="disqus_thread"></div> 
     <script>
          function appendDisqus() {
            var element = document.getElementById("placeholderMessage");
            if (element != null) {
              element.parentNode.removeChild(element);
            }

            var disqus_config = function () {
              this.page.url = "http://blog.nuget.org/20141023/package-manifests.html";
              this.page.identifier = "/20141023/package-manifests";
            };
            (function() {
              var d = document, s = d.createElement('script');                
              s.src = 'https://nuget.disqus.com/embed.js';                
              s.setAttribute('data-timestamp', +new Date());
              (d.head || d.body).appendChild(s);
            })();
          }
          
          if (window.mscc.hasConsent()) {
            appendDisqus();
          } else {
            var d = document.getElementById("disqus_thread"), s = document.createElement('a');
            s.id = 'placeholderMessage';
            s.href = 'javascript::void(0);';
            s.textContent = 'Display Comments';
            d.appendChild(s);
            window.mscc.on("consent", appendDisqus);
          }
        </script> 
     <noscript>
      Please enable JavaScript to view the 
      <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
     </noscript> 
    </div> 
   </article> 
  </section> 
  <footer class="footer"> 
   <div class="container"> 
    <div class="row"> 
     <div class="col-sm-4"> 
      <h4><a href="https://www.nuget.org/policies/Contact">Contact</a></h4> 
      <p> Got questions about NuGet or the NuGet Gallery? </p> 
     </div> 
     <div class="col-sm-4"> 
      <h4><a href="https://status.nuget.org/">Status</a></h4> 
      <p> Find out the service status of NuGet.org and its related services. </p> 
     </div> 
     <div class="col-sm-4"> 
      <h4> <a href="https://docs.microsoft.com/en-us/nuget/policies/nuget-faq"> <abbr title="Frequently Asked Questions">FAQ</abbr> </a> </h4> 
      <p> Read the Frequently Asked Questions about NuGet and see if your question made the list. </p> 
     </div> 
    </div> 
    <div class="row"> 
     <div class="col-md-3 row-gap"> 
      <img alt="" aria-hidden="true" width="184" height="55" src="/Content/gallery/img/logo.svg" onerror="this.src='/Content/gallery/img/logo-184x55.png'; this.onerror = null;"> 
     </div> 
     <div class="col-md-9 row-gap"> 
      <div class="row"> 
       <div class="col-md-12 footer-release-info"> 
        <p> © Microsoft 2017 - <a href="https://www.nuget.org/policies/About">About</a> - <a href="https://www.nuget.org/policies/Terms">Terms of Use</a> - <a href="https://go.microsoft.com/fwlink/?LinkId=521839">Privacy Policy</a> - <a href="https://www.microsoft.com/trademarks">Trademarks</a> </p> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
  </footer> 
  <script src="/Scripts/gallery/jquery-1.12.4.js"></script> 
  <script src="/Scripts/gallery/jquery.validate-1.16.0.js"></script> 
  <script src="/Scripts/gallery/jquery.validate.unobtrusive-3.2.6.js"></script> 
  <script src="/Scripts/gallery/knockout-3.4.2.js"></script> 
  <script src="/Scripts/gallery/bootstrap.js"></script> 
  <script src="/Scripts/gallery/moment-2.18.1.js"></script> 
  <script src="/Scripts/gallery/common.js"></script>  
 </body>
</html>