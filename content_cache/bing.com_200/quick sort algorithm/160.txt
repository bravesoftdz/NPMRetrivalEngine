<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head> 
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
  <title>10.4. Sorting Algorithms — Introductory Programming in C# 1.0 documentation</title> 
  <link rel="stylesheet" href="_static/default.css" type="text/css"> 
  <link rel="stylesheet" href="_static/pygments.css" type="text/css"> 
  <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script> 
  <script type="text/javascript" src="_static/jquery.js"></script> 
  <script type="text/javascript" src="_static/underscore.js"></script> 
  <script type="text/javascript" src="_static/doctools.js"></script> 
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> 
  <script type="text/javascript" src="_static/sidebar.js"></script> 
  <link rel="top" title="Introductory Programming in C# 1.0 documentation" href="index.html"> 
  <link rel="up" title="10. Arrays" href="arrays.html"> 
  <link rel="next" title="10.5. Binary Searching" href="binarysearching.html"> 
  <link rel="prev" title="10.3. Linear Searching" href="searching.html"> 
 </head> 
 <body> 
  <div class="related"> 
   <h3>Navigation</h3> 
   <ul> 
    <li class="right" style="margin-right: 10px"> <a href="genindex.html" title="General Index" accesskey="I">index</a></li> 
    <li class="right"> <a href="binarysearching.html" title="10.5. Binary Searching" accesskey="N">next</a> |</li> 
    <li class="right"> <a href="searching.html" title="10.3. Linear Searching" accesskey="P">previous</a> |</li> 
    <li><a href="index.html">COMP 170</a> »</li> 
    <li><a href="arrays.html" accesskey="U">10. Arrays</a> »</li> 
   </ul> 
  </div> 
  <div class="document"> 
   <div class="documentwrapper"> 
    <div class="bodywrapper"> 
     <div class="body"> 
      <div class="section" id="sorting-algorithms"> 
       <span id="sorting"></span>
       <span id="index-0"></span>
       <h1>10.4. Sorting Algorithms<a class="headerlink" href="#sorting-algorithms" title="Permalink to this headline">¶</a></h1> 
       <p>Sorting algorithms represent foundational knowledge that every computer scientist and IT professional should at least know at a basic level. And it turns out to be a great way of learning about why arrays are important well beyond mathematics.</p> 
       <p>In this section, we’re going to take a look at a number of well-known sorting algorithms with the hope of sensitizing you to the notion of <em>performance</em>–a topic that is covered in greater detail in courses such as algorithms and data structures.</p> 
       <p>This is not intended to be a comprehensive reference at all. The idea is to learn how these classic algorithms are coded in the teaching language for this course, C#, and to understand the essentials of analyzing their performance, both theoretically and experimentally. For a full theoretical treatment, we recommend the outstanding textbook by Niklaus Wirth <a class="reference internal" href="#wirthadp">[WirthADP]</a>, who invented the Pascal language. (We have also adapted some examples from Thomas W. Christopher’s <a class="reference internal" href="#tcsortingjava">[TCSortingJava]</a> animated sorting algorithms page.</p> 
       <div class="section" id="exchanging-array-elements"> 
        <h2>10.4.1. Exchanging Array Elements<a class="headerlink" href="#exchanging-array-elements" title="Permalink to this headline">¶</a></h2> 
        <p>We’ll begin by introducing you to a simple method, whose only purpose in life is to swap two data values at positions <tt class="docutils literal"><span class="pre">m</span></tt> and <tt class="docutils literal"><span class="pre">n</span></tt> in a given integer array:</p> 
        <div class="highlight-csharp">
         <table class="highlighttable">
          <tbody>
           <tr>
            <td class="linenos">
             <div class="linenodiv">
              <pre>1
2
3
4
5
6
7
8</pre>
             </div></td>
            <td class="code">
             <div class="highlight">
              <pre>      <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">exchange</span> <span class="p">(</span><span class="kt">int</span><span class="p">[]</span> <span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
      <span class="p">{</span>
         <span class="kt">int</span> <span class="n">temporary</span><span class="p">;</span>

         <span class="n">temporary</span> <span class="p">=</span> <span class="n">data</span> <span class="p">[</span><span class="n">m</span><span class="p">];</span>
         <span class="n">data</span> <span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="p">=</span> <span class="n">data</span> <span class="p">[</span><span class="n">n</span><span class="p">];</span>
         <span class="n">data</span> <span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="p">=</span> <span class="n">temporary</span><span class="p">;</span>
      <span class="p">}</span>
</pre>
             </div> </td>
           </tr>
          </tbody>
         </table>
        </div> 
        <p>In general, swapping two values in an array is no different than swapping any two integers. Suppose we have the following integers <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt>:</p> 
        <div class="highlight-csharp">
         <div class="highlight">
          <pre><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">t</span><span class="p">;</span>

<span class="n">a</span> <span class="p">=</span> <span class="m">25</span><span class="p">;</span>
<span class="n">b</span> <span class="p">=</span> <span class="m">35</span><span class="p">;</span>
<span class="n">t</span> <span class="p">=</span> <span class="n">a</span><span class="p">;</span>
<span class="n">a</span> <span class="p">=</span> <span class="n">b</span><span class="p">;</span>
<span class="n">b</span> <span class="p">=</span> <span class="n">t</span><span class="p">;</span>
</pre>
         </div> 
        </div> 
        <p>After this code does its job, the value of <tt class="docutils literal"><span class="pre">a</span></tt> would be 35 and the value of <tt class="docutils literal"><span class="pre">b</span></tt> would be 25.</p> 
        <p>So in the <tt class="docutils literal"><span class="pre">exchange()</span></tt> function above, if we have two different array elements at positions <tt class="docutils literal"><span class="pre">m</span></tt> and <tt class="docutils literal"><span class="pre">n</span></tt>, we are basically getting each value at these positions, e.g. <tt class="docutils literal"><span class="pre">data[m]</span></tt> and <tt class="docutils literal"><span class="pre">data[n]</span></tt> and treating them as if they were <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> in the above code.</p> 
        <p>You might find it helpful at this time to verify that the above code does what we’re saying it does, and a good way is to type it directly into the C# interpreter (csharp) so you can see it for yourself.</p> 
        <p>The <tt class="docutils literal"><span class="pre">exchange()</span></tt> function is vital to all of the sorting algorithms in the following way. It is used whenever two items are found to be out of order. When this occurs, they will be <em>swapped</em>. This doesn’t mean that the item comes to its final resting place in the array. It just means that for the moment, the items have been reordered so we’ll get closer to having a sorted array.</p> 
        <p>Let’s now take a look at the various sorting algorithms.</p> 
       </div> 
       <div class="section" id="bubble-sort"> 
        <span id="index-1"></span>
        <h2>10.4.2. Bubble Sort<a class="headerlink" href="#bubble-sort" title="Permalink to this headline">¶</a></h2> 
        <p>The Bubble Sort algorithm works by repeatedly scanning through the array exchanging adjacent elements that are out of order. Watching this work with a strategically-placed <tt class="docutils literal"><span class="pre">Console.WriteLine()</span></tt> in the outer loop, you will see that the sorted array grows right to left. Each sweep picks up the largest remaining element and moves to the right as far as it can go. It is therefore not necessary to scan through the entire array each sweep, but only to the beginning of the sorted portion.</p> 
        <p>We define the number of <em>inversions</em> as the number of element pairs that are out of order. They needn’t be adjacent. If <tt class="docutils literal"><span class="pre">data[7]</span> <span class="pre">&gt;</span> <span class="pre">data[16]</span></tt>, that’s an inversion. Every time an inversion is required, we also say that there is corresponding data <em>movement</em>. If you look at the <tt class="docutils literal"><span class="pre">exchange()</span></tt> code, you’ll observe that a swap requires three movements to take place, which happens very quickly on most processors but still amounts to a significant cost.</p> 
        <p>There can be at most <span class="math">\(N \cdot \frac{N-1}{2}\)</span> inversions in the array of length <span class="math">\(N\)</span>. The maximum number of inversions occurs when the array is sorted in reverse order and has no equal elements.</p> 
        <p>Each exchange in Bubble Sort removes precisely one inversion; therefore, Bubble Sort requires <span class="math">\(O(N^2)\)</span> exchanges.</p> 
        <div class="highlight-csharp">
         <table class="highlighttable">
          <tbody>
           <tr>
            <td class="linenos">
             <div class="linenodiv">
              <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre>
             </div></td>
            <td class="code">
             <div class="highlight">
              <pre>      <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">IntArrayBubbleSort</span> <span class="p">(</span><span class="kt">int</span><span class="p">[]</span> <span class="n">data</span><span class="p">)</span>
      <span class="p">{</span>
         <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
         <span class="kt">int</span> <span class="n">N</span> <span class="p">=</span> <span class="n">data</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span>

         <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="p">=</span><span class="n">N</span><span class="p">-</span><span class="m">1</span><span class="p">;</span> <span class="n">j</span><span class="p">&gt;</span><span class="m">0</span><span class="p">;</span> <span class="n">j</span><span class="p">--)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">=</span><span class="m">0</span><span class="p">;</span> <span class="n">i</span><span class="p">&lt;</span><span class="n">j</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
               <span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="n">data</span> <span class="p">[</span><span class="n">i</span> <span class="p">+</span> <span class="m">1</span><span class="p">])</span>
                  <span class="n">exchange</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="p">+</span> <span class="m">1</span><span class="p">);</span>
            <span class="p">}</span>
         <span class="p">}</span>
      <span class="p">}</span>
</pre>
             </div> </td>
           </tr>
          </tbody>
         </table>
        </div> 
       </div> 
       <div class="section" id="selection-sort"> 
        <span id="index-2"></span>
        <h2>10.4.3. Selection Sort<a class="headerlink" href="#selection-sort" title="Permalink to this headline">¶</a></h2> 
        <p>The Selection Sort algorithm works to minimize the amount of data movement, hence the number of <tt class="docutils literal"><span class="pre">exchange()</span></tt> calls.</p> 
        <div class="highlight-csharp">
         <table class="highlighttable">
          <tbody>
           <tr>
            <td class="linenos">
             <div class="linenodiv">
              <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre>
             </div></td>
            <td class="code">
             <div class="highlight">
              <pre>      <span class="k">public</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">IntArrayMin</span> <span class="p">(</span><span class="kt">int</span><span class="p">[]</span> <span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">)</span>
      <span class="p">{</span>
         <span class="kt">int</span> <span class="n">minPos</span> <span class="p">=</span> <span class="n">start</span><span class="p">;</span> 
         <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">=</span><span class="n">start</span><span class="p">+</span><span class="m">1</span><span class="p">;</span> <span class="n">pos</span> <span class="p">&lt;</span> <span class="n">data</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">pos</span><span class="p">++)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="p">&lt;</span> <span class="n">data</span> <span class="p">[</span><span class="n">minPos</span><span class="p">])</span>
               <span class="n">minPos</span> <span class="p">=</span> <span class="n">pos</span><span class="p">;</span>
         <span class="k">return</span> <span class="n">minPos</span><span class="p">;</span> 
      <span class="p">}</span>

      <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">IntArraySelectionSort</span> <span class="p">(</span><span class="kt">int</span><span class="p">[]</span> <span class="n">data</span><span class="p">)</span>
      <span class="p">{</span>
         <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
         <span class="kt">int</span> <span class="n">N</span> <span class="p">=</span> <span class="n">data</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span>

         <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">=</span><span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">N</span><span class="p">-</span><span class="m">1</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">k</span> <span class="p">=</span> <span class="n">IntArrayMin</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="p">!=</span> <span class="n">k</span><span class="p">)</span>
               <span class="n">exchange</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
         <span class="p">}</span>
      <span class="p">}</span>
</pre>
             </div> </td>
           </tr>
          </tbody>
         </table>
        </div> 
        <p>It’s a remarkably simple algorithm to explain. As shown in the code, the actual sorting is done by a function, <tt class="docutils literal"><span class="pre">IntArraySelectionSort()</span></tt>, which takes an array of data as its only parameter, like Bubble sort. The way Selection Sort works is as follows:</p> 
        <ol class="arabic simple"> 
         <li>An outer loop visits each item in the array to find out whether it is the minimum of all the elements after it. If it is not the minimum, it is going to be swapped with whatever item in the rest of the array is the minimum.</li> 
         <li>We use a helper function, <tt class="docutils literal"><span class="pre">IntArrayMin()</span></tt> to find the position of the minimum value in the rest of the array. This function has a parameter, <tt class="docutils literal"><span class="pre">start</span></tt> to indicate where we wish to begin the search. So as you can see from the loop in <tt class="docutils literal"><span class="pre">IntArraySelectionSort()</span></tt>, when we are looking at position <tt class="docutils literal"><span class="pre">i</span></tt>, we are searching for the minimum from position <tt class="docutils literal"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">1</span></tt> to the end of the array.</li> 
        </ol> 
        <p>As a concrete example, if you have an array of 10 elements, this means that <tt class="docutils literal"><span class="pre">i</span></tt> goes from 0 to 9. When we are looking at position 0, we check to find the position of the minimum element in positions 1..9. If the minimum is not already at position <tt class="docutils literal"><span class="pre">i</span></tt>, we swap the minimum into place. Then we consider <tt class="docutils literal"><span class="pre">i=1</span></tt> and look at positions 2..9. And so on.</p> 
        <p>We won’t do the full algorithmic analysis here. Selection Sort is interesting because it does most of its work through <em>comparisons</em>, which is always the same regardless of how the data are ordered, <span class="math">\(N \cdot \frac{N-1}{2}\)</span>, which is <span class="math">\(O(N^2)\)</span> The number of <em>exchanges</em> is O(N ). The comparisons are a non-trivial cost, however, and do show in our own performance experiments with randomly-generated data.</p> 
       </div> 
       <div class="section" id="insertion-sort"> 
        <span id="index-3"></span>
        <h2>10.4.4. Insertion Sort<a class="headerlink" href="#insertion-sort" title="Permalink to this headline">¶</a></h2> 
        <p>In the Insertion Sort algorithm, we build a sorted list from the bottom of the array. We repeatedly insert the next element into the sorted part of the array by sliding it down (using our familiar <tt class="docutils literal"><span class="pre">exchange()</span></tt> method) to its proper position.</p> 
        <p>This will require as many exchanges as Bubble Sort, since only one inversion is removed per exchange. So Insertion Sort also requires <span class="math">\(O(N^2)\)</span> exchanges. On average Insertion Sort requires only half as many comparisons as Bubble Sort, since the average distance an element must move for random input is one-half the length of the sorted portion.</p> 
        <div class="highlight-csharp">
         <table class="highlighttable">
          <tbody>
           <tr>
            <td class="linenos">
             <div class="linenodiv">
              <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre>
             </div></td>
            <td class="code">
             <div class="highlight">
              <pre>      <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">IntArrayInsertionSort</span> <span class="p">(</span><span class="kt">int</span><span class="p">[]</span> <span class="n">data</span><span class="p">)</span>
      <span class="p">{</span>
         <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
         <span class="kt">int</span> <span class="n">N</span> <span class="p">=</span> <span class="n">data</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span>

         <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="p">=</span><span class="m">1</span><span class="p">;</span> <span class="n">j</span><span class="p">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="p">++)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">=</span><span class="n">j</span><span class="p">;</span> <span class="n">i</span><span class="p">&gt;</span><span class="m">0</span> <span class="p">&amp;&amp;</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">-</span><span class="m">1</span><span class="p">];</span> <span class="n">i</span><span class="p">--)</span> <span class="p">{</span>
               <span class="n">exchange</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="p">-</span> <span class="m">1</span><span class="p">);</span>
            <span class="p">}</span>
         <span class="p">}</span>
      <span class="p">}</span>
</pre>
             </div> </td>
           </tr>
          </tbody>
         </table>
        </div> 
       </div> 
       <div class="section" id="shell-sort"> 
        <span id="index-4"></span>
        <h2>10.4.5. Shell Sort<a class="headerlink" href="#shell-sort" title="Permalink to this headline">¶</a></h2> 
        <p>Shell Sort is basically a trick to make Insertion Sort run faster. If you take a quick glance at the code and look beyond the presence of two additional <em>outer loops</em>, you’ll notice that the code looks very similar.</p> 
        <p>Since Insertion Sort removes one inversion per exchange, it cannot run faster than the number of inversions in the data, which in worst case is <span class="math">\(O(N^2)\)</span>. Of course, it can’t run faster than N, either, because it must look at each element, whether or not the element is out of position. We can’t do any thing about the lower bound O(N), but we can do something about the number of steps to remove inversions.</p> 
        <p>The trick in Shell Sort is to start off swapping elements that are further apart. While this may remove only one inversion sometimes, often many more inversions are removed with intervening elements. Shell Sort considers the subsequences of elements spaced k elements apart. There are k such sequences starting at positions 0 through k-1 in the array. In these sorts, elements k positions apart are exchanged, removing between 1 and 2(k-1)+1 inversions.</p> 
        <p>Swapping elements far apart is not sufficient, generally, so a Shell Sort will do several passes with decreasing values of k, ending with k=1. The following examples experiment with different series of values of k.</p> 
        <p>In this first example, we sort all subsequences of elements 8 apart, then 4, 2, and 1. Please note that these intervals are to show how the method works–not how the method works <em>best</em>.</p> 
        <div class="highlight-csharp">
         <table class="highlighttable">
          <tbody>
           <tr>
            <td class="linenos">
             <div class="linenodiv">
              <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre>
             </div></td>
            <td class="code">
             <div class="highlight">
              <pre>      <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">IntArrayShellSort</span> <span class="p">(</span><span class="kt">int</span><span class="p">[]</span> <span class="n">data</span><span class="p">,</span> <span class="kt">int</span><span class="p">[]</span> <span class="n">intervals</span><span class="p">)</span>
      <span class="p">{</span>
         <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
         <span class="kt">int</span> <span class="n">N</span> <span class="p">=</span> <span class="n">data</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span>

         <span class="c1">// The intervals for the shell sort must be sorted, ascending</span>

         <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">=</span><span class="n">intervals</span><span class="p">.</span><span class="n">Length</span><span class="p">-</span><span class="m">1</span><span class="p">;</span> <span class="n">k</span><span class="p">&gt;=</span><span class="m">0</span><span class="p">;</span> <span class="n">k</span><span class="p">--)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">interval</span> <span class="p">=</span> <span class="n">intervals</span> <span class="p">[</span><span class="n">k</span><span class="p">];</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">m</span><span class="p">=</span><span class="m">0</span><span class="p">;</span> <span class="n">m</span><span class="p">&lt;</span><span class="n">interval</span><span class="p">;</span> <span class="n">m</span><span class="p">++)</span> <span class="p">{</span>
               <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="p">=</span><span class="n">m</span><span class="p">+</span><span class="n">interval</span><span class="p">;</span> <span class="n">j</span><span class="p">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="p">+=</span><span class="n">interval</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">=</span><span class="n">j</span><span class="p">;</span> <span class="n">i</span><span class="p">&gt;=</span><span class="n">interval</span> <span class="p">&amp;&amp;</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]&lt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">-</span><span class="n">interval</span><span class="p">];</span> <span class="n">i</span><span class="p">-=</span><span class="n">interval</span><span class="p">)</span> <span class="p">{</span>
                     <span class="n">exchange</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="p">-</span> <span class="n">interval</span><span class="p">);</span>
                  <span class="p">}</span>
               <span class="p">}</span>
            <span class="p">}</span>
         <span class="p">}</span>
      <span class="p">}</span>
</pre>
             </div> </td>
           </tr>
          </tbody>
         </table>
        </div> 
        <div class="highlight-csharp">
         <table class="highlighttable">
          <tbody>
           <tr>
            <td class="linenos">
             <div class="linenodiv">
              <pre>1
2
3
4
5</pre>
             </div></td>
            <td class="code">
             <div class="highlight">
              <pre>      <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">IntArrayShellSortNaive</span> <span class="p">(</span><span class="kt">int</span><span class="p">[]</span> <span class="n">data</span><span class="p">)</span>
      <span class="p">{</span>
         <span class="kt">int</span><span class="p">[]</span> <span class="n">intervals</span> <span class="p">=</span> <span class="p">{</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">8</span> <span class="p">};</span>
         <span class="n">IntArrayShellSort</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">intervals</span><span class="p">);</span>
      <span class="p">}</span>
</pre>
             </div> </td>
           </tr>
          </tbody>
         </table>
        </div> 
        <p>In general, shell sort with sequences of jump sizes that are powers of one another doesn’t do as well as one where most jump sizes are not multiples of others, mixing up the data more. In addition, the number of intervals must be increased as the size of the array to be sorted increases, which explains why we allow an <em>arbitrary</em> array of intervals to be specified.</p> 
        <p>Without too much explanation, we show how you can choose the intervals differently in an <em>improved</em> shell sort, where the intervals have been chosen so as not to be multiples of one another.</p> 
        <p>Donald Knuth has suggested a couple of methods for computing the intervals:</p> 
        <div class="math">
          \[h_0 = 1\]\[h_{k+1} = 3 h_k + 1\]\[t = \lfloor log_3 n \rfloor - 1\]
        </div> 
        <p>Here we are using notation for the <em>floor</em> function <span class="math">\(\lfloor x \rfloor\)</span> means the largest integer <span class="math">\(\le x\)</span>.</p> 
        <p>This results in a sequence 1, 4, 13, 40, 121.... You stop computing values in the sequence when <span class="math">\(t = log_3 n - 1\)</span>. (So for n=50,000, you should have about 9-10 intervals.)</p> 
        <p>For completeness, we note that <span class="math">\(log_3 n\)</span> must be sufficiently large (and &gt; 2) for this method to work. Our code ensures this by taking the <em>maximum</em> of <span class="math">\(log_3 n\)</span> and 1.</p> 
        <p>Knuth also suggests:</p> 
        <div class="math">
          \[h_0 = 1\]\[h_{k+1} = 2 h_k + 1\]\[t = \lfloor log_2 n \rfloor - 1\]
        </div> 
        <p>This results in a sequence 1, 3, 7, 15, 31....</p> 
        <p>Here is the improvement to our naive method that dynamically calculates the intervals based on the first suggestion of Knuth:</p> 
        <div class="highlight-csharp">
         <table class="highlighttable">
          <tbody>
           <tr>
            <td class="linenos">
             <div class="linenodiv">
              <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre>
             </div></td>
            <td class="code">
             <div class="highlight">
              <pre>    
      <span class="k">static</span> <span class="kt">int</span><span class="p">[]</span> <span class="nf">GenerateIntervals</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
      <span class="p">{</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="p">&lt;</span> <span class="m">2</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// no sorting will be needed</span>
            <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="m">0</span><span class="p">];</span>
         <span class="p">}</span>
         <span class="kt">int</span> <span class="n">t</span> <span class="p">=</span> <span class="n">Math</span><span class="p">.</span><span class="n">Max</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">Math</span><span class="p">.</span><span class="n">Log</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span> <span class="p">-</span> <span class="m">1</span><span class="p">);</span>
         <span class="kt">int</span><span class="p">[]</span> <span class="n">intervals</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">t</span><span class="p">];</span>       
         <span class="n">intervals</span> <span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
         <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">=</span><span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">t</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="n">intervals</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="m">3</span> <span class="p">*</span> <span class="n">intervals</span> <span class="p">[</span><span class="n">i</span> <span class="p">-</span> <span class="m">1</span><span class="p">]</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>
         <span class="k">return</span> <span class="n">intervals</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">IntArrayShellSortBetter</span> <span class="p">(</span><span class="kt">int</span><span class="p">[]</span> <span class="n">data</span><span class="p">)</span>
      <span class="p">{</span>
         <span class="kt">int</span><span class="p">[]</span> <span class="n">intervals</span> <span class="p">=</span> <span class="n">GenerateIntervals</span> <span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span>
         <span class="n">IntArrayShellSort</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">intervals</span><span class="p">);</span>
      <span class="p">}</span>
</pre>
             </div> </td>
           </tr>
          </tbody>
         </table>
        </div> 
        <p>Shell sort is a complex sorting algorithm to make “work well”, which is why it is not seen often in practice. It is, however, making a bit of a comeback in embedded systems.</p> 
        <p>We nevertheless think it is a very cool algorithm to have heard of as a computer science student and think it has promise in a number of situations, especially in systems where there are limits on available memory (e.g. embedded systems).</p> 
       </div> 
       <div class="section" id="quicksort-a-k-a-partition-sort"> 
        <span id="index-5"></span>
        <h2>10.4.6. Quicksort a.k.a. Partition Sort<a class="headerlink" href="#quicksort-a-k-a-partition-sort" title="Permalink to this headline">¶</a></h2> 
        <p>This sort is a more advanced example that uses <em>recursion</em>. We’re going to explain it elsewhere in our notes/book.</p> 
        <p>Quicksort is a rather interesting case. It is often perceived to be one of the best sorting algorithms but, in practice, has a worst case performance also on the order <span class="math">\(O(N ^2)\)</span>. When the data are randomly sorted (as in our experiments) it does better at <span class="math">\(O(N \log N)\)</span>.</p> 
        <div class="highlight-csharp">
         <table class="highlighttable">
          <tbody>
           <tr>
            <td class="linenos">
             <div class="linenodiv">
              <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32</pre>
             </div></td>
            <td class="code">
             <div class="highlight">
              <pre>      <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">IntArrayQuickSort</span> <span class="p">(</span><span class="kt">int</span><span class="p">[]</span> <span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span>
      <span class="p">{</span>
         <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
         <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
 
         <span class="n">i</span> <span class="p">=</span> <span class="n">l</span><span class="p">;</span>
         <span class="n">j</span> <span class="p">=</span> <span class="n">r</span><span class="p">;</span>

         <span class="n">x</span> <span class="p">=</span> <span class="n">data</span> <span class="p">[(</span><span class="n">l</span> <span class="p">+</span> <span class="n">r</span><span class="p">)</span> <span class="p">/</span> <span class="m">2</span><span class="p">];</span> <span class="cm">/* find pivot item */</span>
         <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">&lt;</span> <span class="n">x</span><span class="p">)</span>
               <span class="n">i</span><span class="p">++;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="p">&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
               <span class="n">j</span><span class="p">--;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="p">&lt;=</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
               <span class="n">exchange</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
               <span class="n">i</span><span class="p">++;</span>
               <span class="n">j</span><span class="p">--;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="p">&gt;</span> <span class="n">j</span><span class="p">)</span>
               <span class="k">break</span><span class="p">;</span>
         <span class="p">}</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="p">&lt;</span> <span class="n">j</span><span class="p">)</span>
            <span class="n">IntArrayQuickSort</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="p">&lt;</span> <span class="n">r</span><span class="p">)</span>
            <span class="n">IntArrayQuickSort</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">IntArrayQuickSort</span> <span class="p">(</span><span class="kt">int</span><span class="p">[]</span> <span class="n">data</span><span class="p">)</span>
      <span class="p">{</span>
         <span class="n">IntArrayQuickSort</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">Length</span> <span class="p">-</span> <span class="m">1</span><span class="p">);</span>
      <span class="p">}</span>
</pre>
             </div> </td>
           </tr>
          </tbody>
         </table>
        </div> 
        <p>We’ll have a bit more to say about this algorithm in our discussion of recursion.</p> 
       </div> 
       <div class="section" id="random-data-generation"> 
        <span id="index-6"></span>
        <h2>10.4.7. Random Data Generation<a class="headerlink" href="#random-data-generation" title="Permalink to this headline">¶</a></h2> 
        <p>Now it is time to talk about how we are going to check the performance in a real-world situation. We’re going to start by modeling the situation here the data are in random order.</p> 
        <p>The following code generates a random array:</p> 
        <div class="highlight-csharp">
         <table class="highlighttable">
          <tbody>
           <tr>
            <td class="linenos">
             <div class="linenodiv">
              <pre>1
2
3
4
5
6</pre>
             </div></td>
            <td class="code">
             <div class="highlight">
              <pre>      <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">IntArrayGenerate</span> <span class="p">(</span><span class="kt">int</span><span class="p">[]</span> <span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">randomSeed</span><span class="p">)</span>
      <span class="p">{</span>
         <span class="n">Random</span> <span class="n">r</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Random</span> <span class="p">(</span><span class="n">randomSeed</span><span class="p">);</span>
         <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">=</span><span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">data</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="n">data</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">r</span><span class="p">.</span><span class="n">Next</span> <span class="p">();</span>
      <span class="p">}</span>
</pre>
             </div> </td>
           </tr>
          </tbody>
         </table>
        </div> 
        <p>There are a few things to note in this code:</p> 
        <ol class="arabic simple"> 
         <li>We use the random number generator option to include a <em>seed</em>. Random numbers aren’t truly random. The particular sequence is just determined by a seed. The simplest way to create a Random object uses a seed taken from the system clock.</li> 
         <li>Because the sorting algorithms <em>modify</em> the data that are passed to it, we need to have a way of regenerating the sequence. (We could also copy the data, but it is kind of a waste of memory.)</li> 
         <li>In order to regenerate a particular example, we actually need the random sequence to be consistent, so we know that each of the sorting algorithms is being tested using the same random data. Hence we specify the same seed each time.</li> 
        </ol> 
        <span class="target" id="index-7"></span>
       </div> 
       <div class="section" id="timing"> 
        <span id="index-8"></span>
        <h2>10.4.8. Timing<a class="headerlink" href="#timing" title="Permalink to this headline">¶</a></h2> 
        <p>In this code, we are actually beginning to make use of <em>classes</em> that are part of the .Net framework/library.</p> 
        <p>We need the ability to time the various sorting algorithms. Luckily, .Net gives us a way of doing so through its <tt class="docutils literal"><span class="pre">Stopwatch</span></tt> class. This class supports methods that you would expect if you’ve ever used a stopwatch (the kind found in sports):</p> 
        <ul class="simple"> 
         <li>Reset: Resets the elapsed time to zero. We need this so we can use the same Stopwatch for each sorting algorithm.</li> 
         <li>Start: Starts the stopwatch. Will keep recording time until stopped.</li> 
         <li>Stop: Stops the stopwatch.</li> 
         <li>ElapsedMilliseconds: Not really a method but a property (like a variable). We’ll use this to get the total time that has elapsed between pairs of Start/Stop events in milliseconds.</li> 
        </ul> 
        <p>So let’s take a look at how we compare the sorting algorithms by looking at the <tt class="docutils literal"><span class="pre">Main()</span></tt> method’s code. As this code is fairly lengthy, we’re going to look at parts of it. The <tt class="docutils literal"><span class="pre">Main()</span></tt> method should be thought of as an <em>experiment</em> that tests the performance of each of the sorting algorithms.</p> 
        <div class="highlight-csharp">
         <table class="highlighttable">
          <tbody>
           <tr>
            <td class="linenos">
             <div class="linenodiv">
              <pre>1
2
3
4</pre>
             </div></td>
            <td class="code">
             <div class="highlight">
              <pre>         <span class="kt">int</span> <span class="n">arraySize</span><span class="p">;</span>
         <span class="kt">int</span> <span class="n">randomSeed</span><span class="p">;</span>
         <span class="n">Stopwatch</span> <span class="n">watch</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Stopwatch</span> <span class="p">();</span>
         <span class="kt">double</span> <span class="n">elapsedTime</span><span class="p">;</span>  <span class="c1">// time in second, accurate to about millseconds</span>
</pre>
             </div> </td>
           </tr>
          </tbody>
         </table>
        </div> 
        <p>The variables declared here are to set up the apparatus:</p> 
        <ul class="simple"> 
         <li><tt class="docutils literal"><span class="pre">arraySize</span></tt>: The size of the array where we wish to test the performance. We will use this to create an array with <tt class="docutils literal"><span class="pre">arraySize</span></tt> random values.</li> 
         <li><tt class="docutils literal"><span class="pre">randomSeed</span></tt>: This allows the user to vary the seed that is used to create the random array. We often want to do this to determine whether our performance results are stable when run a large number of times with different distributions. We won’t go into too much detail here but consider it an important part of building good performance benchmarks.</li> 
         <li><tt class="docutils literal"><span class="pre">watch</span></tt>: The stopwatch object we’re using to do the timings of all experiments.</li> 
        </ul> 
        <div class="highlight-csharp">
         <table class="highlighttable">
          <tbody>
           <tr>
            <td class="linenos">
             <div class="linenodiv">
              <pre>1
2
3
4
5
6
7
8</pre>
             </div></td>
            <td class="code">
             <div class="highlight">
              <pre>         <span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">Length</span> <span class="p">&lt;</span> <span class="m">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">arraySize</span> <span class="p">=</span> <span class="n">Input</span><span class="p">.</span><span class="n">InputInt</span><span class="p">(</span><span class="s">"Please enter desired array size: "</span><span class="p">);</span>
            <span class="n">randomSeed</span> <span class="p">=</span> <span class="n">Input</span><span class="p">.</span><span class="n">InputInt</span><span class="p">(</span>
               <span class="s">"Please enter an initial random seed value: "</span><span class="p">);</span>
         <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">arraySize</span> <span class="p">=</span> <span class="kt">int</span><span class="p">.</span><span class="n">Parse</span> <span class="p">(</span><span class="n">args</span> <span class="p">[</span><span class="m">0</span><span class="p">]);</span>
            <span class="n">randomSeed</span> <span class="p">=</span> <span class="kt">int</span><span class="p">.</span><span class="n">Parse</span> <span class="p">(</span><span class="n">args</span> <span class="p">[</span><span class="m">1</span><span class="p">]);</span>
         <span class="p">}</span>
</pre>
             </div> </td>
           </tr>
          </tbody>
         </table>
        </div> 
        <p>This code is designed so we can accept the parameters <tt class="docutils literal"><span class="pre">arraySize</span></tt> and <tt class="docutils literal"><span class="pre">randomSeed</span></tt> from the command line or by prompting the user. When programmers design benchmarks, they often try to make it possible to run them with minimal user interaction. For the purposes of teaching, we wanted to make it possible to run it with or without command-line parameters.</p> 
        <div class="highlight-csharp">
         <table class="highlighttable">
          <tbody>
           <tr>
            <td class="linenos">
             <div class="linenodiv">
              <pre>1
2
3
4
5
6
7</pre>
             </div></td>
            <td class="code">
             <div class="highlight">
              <pre>         <span class="n">IntArrayGenerate</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">randomSeed</span><span class="p">);</span>
         <span class="n">watch</span><span class="p">.</span><span class="n">Reset</span> <span class="p">();</span>
         <span class="n">watch</span><span class="p">.</span><span class="n">Start</span> <span class="p">();</span>
         <span class="n">IntArrayBubbleSort</span> <span class="p">(</span><span class="n">data</span><span class="p">);</span>  <span class="c1">// the other experiments call a different method</span>
         <span class="n">watch</span><span class="p">.</span><span class="n">Stop</span> <span class="p">();</span>
         <span class="n">elapsedTime</span> <span class="p">=</span> <span class="n">watch</span><span class="p">.</span><span class="n">ElapsedMilliseconds</span><span class="p">/</span><span class="m">1000.0</span><span class="p">;</span>
         <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span> <span class="p">(</span><span class="s">"Bubble Sort: {0:F3}"</span><span class="p">,</span> <span class="n">elapsedTime</span><span class="p">);</span>
</pre>
             </div> </td>
           </tr>
          </tbody>
         </table>
        </div> 
        <p>This code fragment is actually replicated a few times in the actual <tt class="docutils literal"><span class="pre">Main()</span></tt> method (to run each of the different sorting algorithms). Essentially, we do the following for each of the sorting algorithms we want to benchmark:</p> 
        <ol class="arabic simple"> 
         <li>Create the random array of data.</li> 
         <li>Reset the Stopwatch object to zero.</li> 
         <li>Start the Stopwatch.</li> 
         <li>Run the sorting algorithm of interest (here <tt class="docutils literal"><span class="pre">IntArrayBubbleSort()</span></tt>). In the rest of the <tt class="docutils literal"><span class="pre">Main()</span></tt> code, we change this line to call the function for each of the other sorting algorithms.</li> 
         <li>Stop the Stopwatch and get the elapsed time (watch.Elapsed).</li> 
         <li>Print the performance results.</li> 
        </ol> 
        <p>When you get <tt class="docutils literal"><span class="pre">watch.ElapsedMilliseconds</span></tt>, this gives you an integer (long) number of milliseconds (thousandths of a second).</p> 
       </div> 
       <div class="section" id="getting-the-code"> 
        <h2>10.4.9. Getting the Code<a class="headerlink" href="#getting-the-code" title="Permalink to this headline">¶</a></h2> 
        <p>If you already have performed a checkout of our entire project at Bitbucket, you can find this code in the <tt class="docutils literal"><span class="pre">projects/Arrays/Sorting</span></tt> folder (and open the solution <tt class="docutils literal"><span class="pre">Sorting.sln</span></tt> in MonoDevelop or Visual Studio).</p> 
        <p>You can also view the full source code in our <a class="reference internal" href="#sortingfolder">[SortingFolder]</a>.</p> 
       </div> 
       <div class="section" id="running-the-code"> 
        <h2>10.4.10. Running the Code<a class="headerlink" href="#running-the-code" title="Permalink to this headline">¶</a></h2> 
        <p>Here’s the output of a trial run on one of our computers. The results will vary depending on your computer’s CPU, among other factors.</p> 
        <div class="highlight-text">
         <div class="highlight">
          <pre>bin/Debug$ mono Sorting.exe 1000 12
Quick Sort: 0.000
Naive Shell Sort: 0.000
Better Shell Sort: 0.000
Insertion Sort: 0.001
Selection Sort: 0.002
Bubble Sort: 0.003
bin/Debug$ mono Sorting.exe 1000 55
Quick Sort: 0.000
Naive Shell Sort: 0.000
Better Shell Sort: 0.000
Insertion Sort: 0.001
Selection Sort: 0.002
Bubble Sort: 0.003
bin/Debug$ mono Sorting.exe 10000 2
Quick Sort: 0.001
Naive Shell Sort: 0.019
Better Shell Sort: 0.002
Insertion Sort: 0.134
Selection Sort: 0.174
Bubble Sort: 0.321
bin/Debug$ mono Sorting.exe 50000 2
Quick Sort: 0.006
Naive Shell Sort: 0.441
Better Shell Sort: 0.015
Insertion Sort: 3.239
Selection Sort: 4.172
Bubble Sort: 8.028
bin/Debug$ mono Sorting.exe 100000 2
Quick Sort: 0.014
Naive Shell Sort: 1.794
Better Shell Sort: 0.034
Insertion Sort: 13.158
Selection Sort: 16.736
Bubble Sort: 31.334
</pre>
         </div> 
        </div> 
        <p>At least based on randomly-generated arrays, the performance can be summarized as follows:</p> 
        <ul class="simple"> 
         <li>Bubble Sort is rather unimpressive as expected. In fact, this algorithm is never used in practice but is of historical interest. Like the brute-force style of searching, it does way too much work to come up with the right answer!</li> 
         <li>Selection Sort and Insertion Sort are also rather unimpressive on their own. Even though Selection Sort can in theory do a lot less data movement, it must make a large number of comparisons to find the minimum value to be moved. Again it is way too much work. Insertion Sort, while unimpressive, fares a bit better and turns out to be a nice building block (if modified) for the Shell Sort. Varying the interval size drastically reduces the amount of data movement (and the distance it has to move).</li> 
         <li>Shell Sort does rather well, especially when we pick the right intervals. In practice, the intervals also need to be adjusted based on the size of the array, which is what we do as larger array sizes are considered. This is no trivial task but a great deal of work has already been done in the past to determine functions that generate good intervals.</li> 
         <li>The Quicksort is generally fastest. It is by far the most commonly used sorting algorithm. Yet there are signs that Shell sort is making a comeback in embedded systems, because it concise to code and is still quite fast. See <a class="reference internal" href="#wikipediashellsort">[WikipediaShellSort]</a>, where it is mentioned that the <a class="reference internal" href="#uclibc">[uClibc]</a> library makes use of Shell sort in its <tt class="docutils literal"><span class="pre">qsort()</span></tt> implementation, rather than implementing the library sort with the more common quicksort.</li> 
        </ul> 
        <table class="docutils citation" frame="void" id="wirthadp" rules="none"> 
         <colgroup>
          <col class="label">
          <col>
         </colgroup> 
         <tbody valign="top"> 
          <tr>
           <td class="label"><a class="fn-backref" href="#id1">[WirthADP]</a></td>
           <td>Niklaus Wirth, Algorithms + Data Structures = Programs, Prentice Hall, 1976.</td>
          </tr> 
         </tbody> 
        </table> 
        <table class="docutils citation" frame="void" id="wikipediashellsort" rules="none"> 
         <colgroup>
          <col class="label">
          <col>
         </colgroup> 
         <tbody valign="top"> 
          <tr>
           <td class="label"><a class="fn-backref" href="#id4">[WikipediaShellSort]</a></td>
           <td><a class="reference external" href="http://en.wikipedia.org/wiki/Shellsort">http://en.wikipedia.org/wiki/Shellsort</a></td>
          </tr> 
         </tbody> 
        </table> 
        <table class="docutils citation" frame="void" id="uclibc" rules="none"> 
         <colgroup>
          <col class="label">
          <col>
         </colgroup> 
         <tbody valign="top"> 
          <tr>
           <td class="label"><a class="fn-backref" href="#id5">[uClibc]</a></td>
           <td><a class="reference external" href="http://en.wikipedia.org/wiki/UClibc">http://en.wikipedia.org/wiki/UClibc</a></td>
          </tr> 
         </tbody> 
        </table> 
        <table class="docutils citation" frame="void" id="tcsortingjava" rules="none"> 
         <colgroup>
          <col class="label">
          <col>
         </colgroup> 
         <tbody valign="top"> 
          <tr>
           <td class="label"><a class="fn-backref" href="#id2">[TCSortingJava]</a></td>
           <td><a class="reference external" href="http://tools-of-computing.com/tc/CS/Sorts/SortAlgorithms.htm">http://tools-of-computing.com/tc/CS/Sorts/SortAlgorithms.htm</a></td>
          </tr> 
         </tbody> 
        </table> 
        <table class="docutils citation" frame="void" id="sortingfolder" rules="none"> 
         <colgroup>
          <col class="label">
          <col>
         </colgroup> 
         <tbody valign="top"> 
          <tr>
           <td class="label"><a class="fn-backref" href="#id3">[SortingFolder]</a></td>
           <td><a class="reference external" href="https://bitbucket.org/gkthiruvathukal/introcs-csharp/src/d82c38851f6a/projects/Arrays/Sorting/Main.cs">https://bitbucket.org/gkthiruvathukal/introcs-csharp/src/d82c38851f6a/projects/Arrays/Sorting/Main.cs</a></td>
          </tr> 
         </tbody> 
        </table> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
   <div class="sphinxsidebar"> 
    <div class="sphinxsidebarwrapper"> 
     <h3><a href="index.html">Table Of Contents</a></h3> 
     <ul> 
      <li><a class="reference internal" href="#">10.4. Sorting Algorithms</a>
       <ul> 
        <li><a class="reference internal" href="#exchanging-array-elements">10.4.1. Exchanging Array Elements</a></li> 
        <li><a class="reference internal" href="#bubble-sort">10.4.2. Bubble Sort</a></li> 
        <li><a class="reference internal" href="#selection-sort">10.4.3. Selection Sort</a></li> 
        <li><a class="reference internal" href="#insertion-sort">10.4.4. Insertion Sort</a></li> 
        <li><a class="reference internal" href="#shell-sort">10.4.5. Shell Sort</a></li> 
        <li><a class="reference internal" href="#quicksort-a-k-a-partition-sort">10.4.6. Quicksort a.k.a. Partition Sort</a></li> 
        <li><a class="reference internal" href="#random-data-generation">10.4.7. Random Data Generation</a></li> 
        <li><a class="reference internal" href="#timing">10.4.8. Timing</a></li> 
        <li><a class="reference internal" href="#getting-the-code">10.4.9. Getting the Code</a></li> 
        <li><a class="reference internal" href="#running-the-code">10.4.10. Running the Code</a></li> 
       </ul> </li> 
     </ul> 
     <h4>Previous topic</h4> 
     <p class="topless"><a href="searching.html" title="previous chapter">10.3. Linear Searching</a></p> 
     <h4>Next topic</h4> 
     <p class="topless"><a href="binarysearching.html" title="next chapter">10.5. Binary Searching</a></p> 
     <h3>This Page</h3> 
     <ul class="this-page-menu"> 
      <li><a href="_sources/sorting.txt" rel="nofollow">Show Source</a></li> 
     </ul> 
     <div id="searchbox" style="display: none"> 
      <h3>Quick search</h3> 
      <form class="search" action="search.html" method="get"> 
       <input type="text" name="q"> 
       <input type="submit" value="Go"> 
       <input type="hidden" name="check_keywords" value="yes"> 
       <input type="hidden" name="area" value="default"> 
      </form> 
      <p class="searchtip" style="font-size: 90%"> Enter search terms or a module, class or function name. </p> 
     </div> 
     <script type="text/javascript">$('#searchbox').show(0);</script> 
    </div> 
   </div> 
   <div class="clearer"></div> 
  </div> 
  <div class="related"> 
   <h3>Navigation</h3> 
   <ul> 
    <li class="right" style="margin-right: 10px"> <a href="genindex.html" title="General Index">index</a></li> 
    <li class="right"> <a href="binarysearching.html" title="10.5. Binary Searching">next</a> |</li> 
    <li class="right"> <a href="searching.html" title="10.3. Linear Searching">previous</a> |</li> 
    <li><a href="index.html">COMP 170</a> »</li> 
    <li><a href="arrays.html">10. Arrays</a> »</li> 
   </ul> 
  </div> 
  <div class="footer">
    © Copyright 2012, Andrew N. Harrington and George Thiruvathukal. Created using 
   <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2. 
  </div>  
 </body>
</html>